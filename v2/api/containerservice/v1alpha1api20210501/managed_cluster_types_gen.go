// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/containerservice/v1alpha1api20210501storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generator information:
//- Generated from: /containerservice/resource-manager/Microsoft.ContainerService/stable/2021-05-01/managedClusters.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}
type ManagedCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedClusters_SPEC  `json:"spec,omitempty"`
	Status            ManagedCluster_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedCluster{}

// GetConditions returns the conditions of the resource
func (cluster *ManagedCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *ManagedCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedCluster{}

// ConvertFrom populates our ManagedCluster from the provided hub ManagedCluster
func (cluster *ManagedCluster) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20210501storage.ManagedCluster)
	if !ok {
		return fmt.Errorf("expected storage:containerservice/v1alpha1api20210501storage/ManagedCluster but received %T instead", hub)
	}

	return cluster.AssignPropertiesFromManagedCluster(source)
}

// ConvertTo populates the provided hub ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20210501storage.ManagedCluster)
	if !ok {
		return fmt.Errorf("expected storage:containerservice/v1alpha1api20210501storage/ManagedCluster but received %T instead", hub)
	}

	return cluster.AssignPropertiesToManagedCluster(destination)
}

// +kubebuilder:webhook:path=/mutate-containerservice-azure-com-v1alpha1api20210501-managedcluster,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1alpha1api20210501,name=default.v1alpha1api20210501.managedclusters.containerservice.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &ManagedCluster{}

// Default applies defaults to the ManagedCluster resource
func (cluster *ManagedCluster) Default() {
	cluster.defaultImpl()
	var temp interface{} = cluster
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (cluster *ManagedCluster) defaultAzureName() {
	if cluster.Spec.AzureName == "" {
		cluster.Spec.AzureName = cluster.Name
	}
}

// defaultImpl applies the code generated defaults to the ManagedCluster resource
func (cluster *ManagedCluster) defaultImpl() { cluster.defaultAzureName() }

var _ genruntime.KubernetesResource = &ManagedCluster{}

// AzureName returns the Azure name of the resource
func (cluster *ManagedCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-05-01"
func (cluster ManagedCluster) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (cluster *ManagedCluster) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (cluster *ManagedCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *ManagedCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (cluster *ManagedCluster) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *ManagedCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedCluster_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (cluster *ManagedCluster) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  cluster.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (cluster *ManagedCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedCluster_Status); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedCluster_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-containerservice-azure-com-v1alpha1api20210501-managedcluster,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1alpha1api20210501,name=validate.v1alpha1api20210501.managedclusters.containerservice.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &ManagedCluster{}

// ValidateCreate validates the creation of the resource
func (cluster *ManagedCluster) ValidateCreate() error {
	validations := cluster.createValidations()
	var temp interface{} = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (cluster *ManagedCluster) ValidateDelete() error {
	validations := cluster.deleteValidations()
	var temp interface{} = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (cluster *ManagedCluster) ValidateUpdate(old runtime.Object) error {
	validations := cluster.updateValidations()
	var temp interface{} = cluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (cluster *ManagedCluster) createValidations() []func() error {
	return []func() error{cluster.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (cluster *ManagedCluster) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (cluster *ManagedCluster) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return cluster.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (cluster *ManagedCluster) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&cluster.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromManagedCluster populates our ManagedCluster from the provided source ManagedCluster
func (cluster *ManagedCluster) AssignPropertiesFromManagedCluster(source *v1alpha1api20210501storage.ManagedCluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ManagedClusters_SPEC
	err := spec.AssignPropertiesFromManagedClusters_SPEC(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromManagedClusters_SPEC() to populate field Spec")
	}
	cluster.Spec = spec

	// Status
	var status ManagedCluster_Status
	err = status.AssignPropertiesFromManagedCluster_Status(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromManagedCluster_Status() to populate field Status")
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignPropertiesToManagedCluster populates the provided destination ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) AssignPropertiesToManagedCluster(destination *v1alpha1api20210501storage.ManagedCluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20210501storage.ManagedClusters_SPEC
	err := cluster.Spec.AssignPropertiesToManagedClusters_SPEC(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToManagedClusters_SPEC() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20210501storage.ManagedCluster_Status
	err = cluster.Status.AssignPropertiesToManagedCluster_Status(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToManagedCluster_Status() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *ManagedCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion(),
		Kind:    "ManagedCluster",
	}
}

// +kubebuilder:object:root=true
//Generator information:
//- Generated from: /containerservice/resource-manager/Microsoft.ContainerService/stable/2021-05-01/managedClusters.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}
type ManagedClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedCluster `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-05-01"}
type APIVersion string

const APIVersionValue = APIVersion("2021-05-01")

type ManagedCluster_Status struct {
	//AadProfile: The Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile_Status `json:"aadProfile,omitempty"`

	//AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles *v1.JSON `json:"addonProfiles,omitempty"`

	//AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile_Status `json:"agentPoolProfiles,omitempty"`

	//ApiServerAccessProfile: The access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_Status `json:"apiServerAccessProfile,omitempty"`

	//AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when
	//enabled
	AutoScalerProfile *ManagedClusterProperties_AutoScalerProfile_Status `json:"autoScalerProfile,omitempty"`

	//AutoUpgradeProfile: The auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile_Status `json:"autoUpgradeProfile,omitempty"`

	//AzurePortalFQDN: The Azure Portal requires certain Cross-Origin Resource Sharing
	//(CORS) headers to be sent in some responses, which Kubernetes APIServer doesn't
	//handle by default. This special FQDN supports CORS, allowing the Azure Portal to
	//function properly.
	AzurePortalFQDN *string `json:"azurePortalFQDN,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DisableLocalAccounts: If set to true, getting static credentials will be
	//disabled for this cluster. This must only be used on Managed Clusters that are
	//AAD enabled. For more details see [disable local
	//accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	//DiskEncryptionSetID: This is of the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetID *string `json:"diskEncryptionSetID,omitempty"`

	//DnsPrefix: This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	//EnablePodSecurityPolicy: (DEPRECATING) Whether to enable Kubernetes pod security
	//policy (preview). This feature is set for removal on October 15th, 2020. Learn
	//more at aka.ms/aks/azpodpolicy.
	EnablePodSecurityPolicy *bool `json:"enablePodSecurityPolicy,omitempty"`

	//EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Fqdn: The FQDN of the master pool.
	Fqdn *string `json:"fqdn,omitempty"`

	//FqdnSubdomain: This cannot be updated once the Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	//HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy
	//servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig_Status `json:"httpProxyConfig,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity_Status `json:"identity,omitempty"`

	//IdentityProfile: Identities associated with the cluster.
	IdentityProfile *v1.JSON `json:"identityProfile,omitempty"`

	//KubernetesVersion: When you upgrade a supported AKS cluster, Kubernetes minor
	//versions cannot be skipped. All upgrades must be performed sequentially by major
	//version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x ->
	//1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an
	//AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more
	//details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	//LinuxProfile: The profile for Linux VMs in the Managed Cluster.
	LinuxProfile *ContainerServiceLinuxProfile_Status `json:"linuxProfile,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//MaxAgentPools: The max number of agent pools for the managed cluster.
	MaxAgentPools *int `json:"maxAgentPools,omitempty"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//NetworkProfile: The network configuration profile.
	NetworkProfile *ContainerServiceNetworkProfile_Status `json:"networkProfile,omitempty"`

	//NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	//PodIdentityProfile: See [use AAD pod
	//identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for
	//more details on AAD pod identity integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile_Status `json:"podIdentityProfile,omitempty"`

	//PowerState: The Power State of the cluster.
	PowerState *PowerState_Status `json:"powerState,omitempty"`

	//PrivateFQDN: The FQDN of private cluster.
	PrivateFQDN *string `json:"privateFQDN,omitempty"`

	//PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource_Status `json:"privateLinkResources,omitempty"`

	//ProvisioningState: The current provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ServicePrincipalProfile: Information about a service principal identity for the
	//cluster to use for manipulating Azure APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_Status `json:"servicePrincipalProfile,omitempty"`

	//Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU_Status `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//WindowsProfile: The profile for Windows VMs in the Managed Cluster.
	WindowsProfile *ManagedClusterWindowsProfile_Status `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedCluster_Status{}

// ConvertStatusFrom populates our ManagedCluster_Status from the provided source
func (cluster *ManagedCluster_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20210501storage.ManagedCluster_Status)
	if ok {
		// Populate our instance from source
		return cluster.AssignPropertiesFromManagedCluster_Status(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210501storage.ManagedCluster_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = cluster.AssignPropertiesFromManagedCluster_Status(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedCluster_Status
func (cluster *ManagedCluster_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20210501storage.ManagedCluster_Status)
	if ok {
		// Populate destination from our instance
		return cluster.AssignPropertiesToManagedCluster_Status(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210501storage.ManagedCluster_Status{}
	err := cluster.AssignPropertiesToManagedCluster_Status(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedCluster_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ManagedCluster_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedCluster_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ManagedCluster_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedCluster_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedCluster_StatusARM, got %T", armInput)
	}

	// Set property ‘AadProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile_Status
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			cluster.AadProfile = &aadProfile
		}
	}

	// Set property ‘AddonProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			addonProfiles := *(*typedInput.Properties.AddonProfiles).DeepCopy()
			cluster.AddonProfiles = &addonProfiles
		}
	}

	// Set property ‘AgentPoolProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AgentPoolProfiles = append(cluster.AgentPoolProfiles, item1)
		}
	}

	// Set property ‘ApiServerAccessProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile_Status
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			cluster.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property ‘AutoScalerProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterProperties_AutoScalerProfile_Status
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			cluster.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property ‘AutoUpgradeProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile_Status
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			cluster.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property ‘AzurePortalFQDN’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzurePortalFQDN != nil {
			azurePortalFQDN := *typedInput.Properties.AzurePortalFQDN
			cluster.AzurePortalFQDN = &azurePortalFQDN
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DisableLocalAccounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			cluster.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// Set property ‘DiskEncryptionSetID’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskEncryptionSetID != nil {
			diskEncryptionSetID := *typedInput.Properties.DiskEncryptionSetID
			cluster.DiskEncryptionSetID = &diskEncryptionSetID
		}
	}

	// Set property ‘DnsPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			cluster.DnsPrefix = &dnsPrefix
		}
	}

	// Set property ‘EnablePodSecurityPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePodSecurityPolicy != nil {
			enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
			cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
		}
	}

	// Set property ‘EnableRBAC’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			cluster.EnableRBAC = &enableRBAC
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		cluster.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Fqdn’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Fqdn != nil {
			fqdn := *typedInput.Properties.Fqdn
			cluster.Fqdn = &fqdn
		}
	}

	// Set property ‘FqdnSubdomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			cluster.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property ‘HttpProxyConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig_Status
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			cluster.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		cluster.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property ‘IdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			identityProfile := *(*typedInput.Properties.IdentityProfile).DeepCopy()
			cluster.IdentityProfile = &identityProfile
		}
	}

	// Set property ‘KubernetesVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			cluster.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property ‘LinuxProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile_Status
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			cluster.LinuxProfile = &linuxProfile
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property ‘MaxAgentPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxAgentPools != nil {
			maxAgentPools := *typedInput.Properties.MaxAgentPools
			cluster.MaxAgentPools = &maxAgentPools
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		cluster.Name = &name
	}

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile_Status
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			cluster.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘NodeResourceGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			cluster.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property ‘PodIdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile_Status
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			cluster.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property ‘PowerState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PowerState != nil {
			var powerState1 PowerState_Status
			err := powerState1.PopulateFromARM(owner, *typedInput.Properties.PowerState)
			if err != nil {
				return err
			}
			powerState := powerState1
			cluster.PowerState = &powerState
		}
	}

	// Set property ‘PrivateFQDN’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateFQDN != nil {
			privateFQDN := *typedInput.Properties.PrivateFQDN
			cluster.PrivateFQDN = &privateFQDN
		}
	}

	// Set property ‘PrivateLinkResources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateLinkResources = append(cluster.PrivateLinkResources, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			cluster.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ServicePrincipalProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile_Status
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			cluster.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		cluster.Type = &typeVar
	}

	// Set property ‘WindowsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile_Status
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			cluster.WindowsProfile = &windowsProfile
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedCluster_Status populates our ManagedCluster_Status from the provided source ManagedCluster_Status
func (cluster *ManagedCluster_Status) AssignPropertiesFromManagedCluster_Status(source *v1alpha1api20210501storage.ManagedCluster_Status) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_Status
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfile_Status(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAADProfile_Status() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfile := *source.AddonProfiles.DeepCopy()
		cluster.AddonProfiles = &addonProfile
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_Status, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile_Status
			err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfile_Status(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAgentPoolProfile_Status() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_Status
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfile_Status(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAPIServerAccessProfile_Status() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile_Status
		err := autoScalerProfile.AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Status(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Status() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_Status
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfile_Status(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAutoUpgradeProfile_Status() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	cluster.AzurePortalFQDN = genruntime.ClonePointerToString(source.AzurePortalFQDN)

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	cluster.DiskEncryptionSetID = genruntime.ClonePointerToString(source.DiskEncryptionSetID)

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		cluster.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// Fqdn
	cluster.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_Status
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfig_Status(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterHTTPProxyConfig_Status() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_Status
		err := identity.AssignPropertiesFromManagedClusterIdentity_Status(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity_Status() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfile := *source.IdentityProfile.DeepCopy()
		cluster.IdentityProfile = &identityProfile
	} else {
		cluster.IdentityProfile = nil
	}

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_Status
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfile_Status(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceLinuxProfile_Status() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MaxAgentPools
	cluster.MaxAgentPools = genruntime.ClonePointerToInt(source.MaxAgentPools)

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_Status
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfile_Status(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceNetworkProfile_Status() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_Status
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfile_Status(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProfile_Status() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_Status
		err := powerState.AssignPropertiesFromPowerState_Status(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPowerState_Status() to populate field PowerState")
		}
		cluster.PowerState = &powerState
	} else {
		cluster.PowerState = nil
	}

	// PrivateFQDN
	cluster.PrivateFQDN = genruntime.ClonePointerToString(source.PrivateFQDN)

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource_Status, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource_Status
			err := privateLinkResource.AssignPropertiesFromPrivateLinkResource_Status(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkResource_Status() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ProvisioningState
	cluster.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_Status
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfile_Status(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterServicePrincipalProfile_Status() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_Status
		err := sku.AssignPropertiesFromManagedClusterSKU_Status(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterSKU_Status() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_Status
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfile_Status(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterWindowsProfile_Status() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedCluster_Status populates the provided destination ManagedCluster_Status from our ManagedCluster_Status
func (cluster *ManagedCluster_Status) AssignPropertiesToManagedCluster_Status(destination *v1alpha1api20210501storage.ManagedCluster_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile v1alpha1api20210501storage.ManagedClusterAADProfile_Status
		err := cluster.AadProfile.AssignPropertiesToManagedClusterAADProfile_Status(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAADProfile_Status() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfile := *cluster.AddonProfiles.DeepCopy()
		destination.AddonProfiles = &addonProfile
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status
			err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfile_Status(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAgentPoolProfile_Status() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status
		err := cluster.ApiServerAccessProfile.AssignPropertiesToManagedClusterAPIServerAccessProfile_Status(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAPIServerAccessProfile_Status() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Status
		err := cluster.AutoScalerProfile.AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Status(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Status() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status
		err := cluster.AutoUpgradeProfile.AssignPropertiesToManagedClusterAutoUpgradeProfile_Status(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAutoUpgradeProfile_Status() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	destination.AzurePortalFQDN = genruntime.ClonePointerToString(cluster.AzurePortalFQDN)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	destination.DiskEncryptionSetID = genruntime.ClonePointerToString(cluster.DiskEncryptionSetID)

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnablePodSecurityPolicy
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20210501storage.ExtendedLocation_Status
		err := cluster.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(cluster.Fqdn)

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status
		err := cluster.HttpProxyConfig.AssignPropertiesToManagedClusterHTTPProxyConfig_Status(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterHTTPProxyConfig_Status() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity v1alpha1api20210501storage.ManagedClusterIdentity_Status
		err := cluster.Identity.AssignPropertiesToManagedClusterIdentity_Status(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity_Status() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfile := *cluster.IdentityProfile.DeepCopy()
		destination.IdentityProfile = &identityProfile
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status
		err := cluster.LinuxProfile.AssignPropertiesToContainerServiceLinuxProfile_Status(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceLinuxProfile_Status() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MaxAgentPools
	destination.MaxAgentPools = genruntime.ClonePointerToInt(cluster.MaxAgentPools)

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status
		err := cluster.NetworkProfile.AssignPropertiesToContainerServiceNetworkProfile_Status(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceNetworkProfile_Status() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status
		err := cluster.PodIdentityProfile.AssignPropertiesToManagedClusterPodIdentityProfile_Status(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProfile_Status() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PowerState
	if cluster.PowerState != nil {
		var powerState v1alpha1api20210501storage.PowerState_Status
		err := cluster.PowerState.AssignPropertiesToPowerState_Status(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPowerState_Status() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// PrivateFQDN
	destination.PrivateFQDN = genruntime.ClonePointerToString(cluster.PrivateFQDN)

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]v1alpha1api20210501storage.PrivateLinkResource_Status, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource v1alpha1api20210501storage.PrivateLinkResource_Status
			err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResource_Status(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkResource_Status() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(cluster.ProvisioningState)

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status
		err := cluster.ServicePrincipalProfile.AssignPropertiesToManagedClusterServicePrincipalProfile_Status(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterServicePrincipalProfile_Status() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku v1alpha1api20210501storage.ManagedClusterSKU_Status
		err := cluster.Sku.AssignPropertiesToManagedClusterSKU_Status(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterSKU_Status() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status
		err := cluster.WindowsProfile.AssignPropertiesToManagedClusterWindowsProfile_Status(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterWindowsProfile_Status() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusters_SPEC struct {
	//AadProfile: The Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile_Spec `json:"aadProfile,omitempty"`

	//AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles *v1.JSON `json:"addonProfiles,omitempty"`

	//AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile_Spec `json:"agentPoolProfiles,omitempty"`

	//ApiServerAccessProfile: The access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_Spec `json:"apiServerAccessProfile,omitempty"`

	//AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when
	//enabled
	AutoScalerProfile *ManagedClusterProperties_AutoScalerProfile_Spec `json:"autoScalerProfile,omitempty"`

	//AutoUpgradeProfile: The auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile_Spec `json:"autoUpgradeProfile,omitempty"`

	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DisableLocalAccounts: If set to true, getting static credentials will be
	//disabled for this cluster. This must only be used on Managed Clusters that are
	//AAD enabled. For more details see [disable local
	//accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	//DiskEncryptionSetIDReference: This is of the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetIDReference *genruntime.ResourceReference `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetIDReference,omitempty"`

	//DnsPrefix: This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	//EnablePodSecurityPolicy: (DEPRECATING) Whether to enable Kubernetes pod security
	//policy (preview). This feature is set for removal on October 15th, 2020. Learn
	//more at aka.ms/aks/azpodpolicy.
	EnablePodSecurityPolicy *bool `json:"enablePodSecurityPolicy,omitempty"`

	//EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//FqdnSubdomain: This cannot be updated once the Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	//HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy
	//servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig_Spec `json:"httpProxyConfig,omitempty"`

	//Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity_Spec `json:"identity,omitempty"`

	//IdentityProfile: Identities associated with the cluster.
	IdentityProfile *v1.JSON `json:"identityProfile,omitempty"`

	//KubernetesVersion: When you upgrade a supported AKS cluster, Kubernetes minor
	//versions cannot be skipped. All upgrades must be performed sequentially by major
	//version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x ->
	//1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an
	//AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more
	//details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	//LinuxProfile: The profile for Linux VMs in the Managed Cluster.
	LinuxProfile *ContainerServiceLinuxProfile_Spec `json:"linuxProfile,omitempty"`

	// +kubebuilder:validation:Required
	//Location: Resource location
	Location string `json:"location"`

	//NetworkProfile: The network configuration profile.
	NetworkProfile *ContainerServiceNetworkProfile_Spec `json:"networkProfile,omitempty"`

	//NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//PodIdentityProfile: See [use AAD pod
	//identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for
	//more details on AAD pod identity integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile_Spec `json:"podIdentityProfile,omitempty"`

	//PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource_Spec `json:"privateLinkResources,omitempty"`

	//ServicePrincipalProfile: Information about a service principal identity for the
	//cluster to use for manipulating Azure APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_Spec `json:"servicePrincipalProfile,omitempty"`

	//Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU_Spec `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//WindowsProfile: The profile for Windows VMs in the Managed Cluster.
	WindowsProfile *ManagedClusterWindowsProfile_Spec `json:"windowsProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusters_SPEC{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spec *ManagedClusters_SPEC) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spec == nil {
		return nil, nil
	}
	var result ManagedClusters_SPECARM

	// Set property ‘AzureName’:
	result.AzureName = spec.AzureName

	// Set property ‘ExtendedLocation’:
	if spec.ExtendedLocation != nil {
		extendedLocationARM, err := (*spec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if spec.Identity != nil {
		identityARM, err := (*spec.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := identityARM.(ManagedClusterIdentity_SpecARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	result.Location = spec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if spec.AadProfile != nil ||
		spec.AddonProfiles != nil ||
		spec.AgentPoolProfiles != nil ||
		spec.ApiServerAccessProfile != nil ||
		spec.AutoScalerProfile != nil ||
		spec.AutoUpgradeProfile != nil ||
		spec.DisableLocalAccounts != nil ||
		spec.DiskEncryptionSetIDReference != nil ||
		spec.DnsPrefix != nil ||
		spec.EnablePodSecurityPolicy != nil ||
		spec.EnableRBAC != nil ||
		spec.FqdnSubdomain != nil ||
		spec.HttpProxyConfig != nil ||
		spec.IdentityProfile != nil ||
		spec.KubernetesVersion != nil ||
		spec.LinuxProfile != nil ||
		spec.NetworkProfile != nil ||
		spec.NodeResourceGroup != nil ||
		spec.PodIdentityProfile != nil ||
		spec.PrivateLinkResources != nil ||
		spec.ServicePrincipalProfile != nil ||
		spec.WindowsProfile != nil {
		result.Properties = &ManagedClusterProperties_SpecARM{}
	}
	if spec.AadProfile != nil {
		aadProfileARM, err := (*spec.AadProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aadProfile := aadProfileARM.(ManagedClusterAADProfile_SpecARM)
		result.Properties.AadProfile = &aadProfile
	}
	if spec.AddonProfiles != nil {
		addonProfiles := *(*spec.AddonProfiles).DeepCopy()
		result.Properties.AddonProfiles = &addonProfiles
	}
	for _, item := range spec.AgentPoolProfiles {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AgentPoolProfiles = append(result.Properties.AgentPoolProfiles, itemARM.(ManagedClusterAgentPoolProfile_SpecARM))
	}
	if spec.ApiServerAccessProfile != nil {
		apiServerAccessProfileARM, err := (*spec.ApiServerAccessProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiServerAccessProfile := apiServerAccessProfileARM.(ManagedClusterAPIServerAccessProfile_SpecARM)
		result.Properties.ApiServerAccessProfile = &apiServerAccessProfile
	}
	if spec.AutoScalerProfile != nil {
		autoScalerProfileARM, err := (*spec.AutoScalerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScalerProfile := autoScalerProfileARM.(ManagedClusterProperties_AutoScalerProfile_SpecARM)
		result.Properties.AutoScalerProfile = &autoScalerProfile
	}
	if spec.AutoUpgradeProfile != nil {
		autoUpgradeProfileARM, err := (*spec.AutoUpgradeProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoUpgradeProfile := autoUpgradeProfileARM.(ManagedClusterAutoUpgradeProfile_SpecARM)
		result.Properties.AutoUpgradeProfile = &autoUpgradeProfile
	}
	if spec.DisableLocalAccounts != nil {
		disableLocalAccounts := *spec.DisableLocalAccounts
		result.Properties.DisableLocalAccounts = &disableLocalAccounts
	}
	if spec.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*spec.DiskEncryptionSetIDReference)
		if err != nil {
			return nil, err
		}
		diskEncryptionSetID := diskEncryptionSetIDARMID
		result.Properties.DiskEncryptionSetID = &diskEncryptionSetID
	}
	if spec.DnsPrefix != nil {
		dnsPrefix := *spec.DnsPrefix
		result.Properties.DnsPrefix = &dnsPrefix
	}
	if spec.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *spec.EnablePodSecurityPolicy
		result.Properties.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	}
	if spec.EnableRBAC != nil {
		enableRBAC := *spec.EnableRBAC
		result.Properties.EnableRBAC = &enableRBAC
	}
	if spec.FqdnSubdomain != nil {
		fqdnSubdomain := *spec.FqdnSubdomain
		result.Properties.FqdnSubdomain = &fqdnSubdomain
	}
	if spec.HttpProxyConfig != nil {
		httpProxyConfigARM, err := (*spec.HttpProxyConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpProxyConfig := httpProxyConfigARM.(ManagedClusterHTTPProxyConfig_SpecARM)
		result.Properties.HttpProxyConfig = &httpProxyConfig
	}
	if spec.IdentityProfile != nil {
		identityProfile := *(*spec.IdentityProfile).DeepCopy()
		result.Properties.IdentityProfile = &identityProfile
	}
	if spec.KubernetesVersion != nil {
		kubernetesVersion := *spec.KubernetesVersion
		result.Properties.KubernetesVersion = &kubernetesVersion
	}
	if spec.LinuxProfile != nil {
		linuxProfileARM, err := (*spec.LinuxProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxProfile := linuxProfileARM.(ContainerServiceLinuxProfile_SpecARM)
		result.Properties.LinuxProfile = &linuxProfile
	}
	if spec.NetworkProfile != nil {
		networkProfileARM, err := (*spec.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := networkProfileARM.(ContainerServiceNetworkProfile_SpecARM)
		result.Properties.NetworkProfile = &networkProfile
	}
	if spec.NodeResourceGroup != nil {
		nodeResourceGroup := *spec.NodeResourceGroup
		result.Properties.NodeResourceGroup = &nodeResourceGroup
	}
	if spec.PodIdentityProfile != nil {
		podIdentityProfileARM, err := (*spec.PodIdentityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		podIdentityProfile := podIdentityProfileARM.(ManagedClusterPodIdentityProfile_SpecARM)
		result.Properties.PodIdentityProfile = &podIdentityProfile
	}
	for _, item := range spec.PrivateLinkResources {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PrivateLinkResources = append(result.Properties.PrivateLinkResources, itemARM.(PrivateLinkResource_SpecARM))
	}
	if spec.ServicePrincipalProfile != nil {
		servicePrincipalProfileARM, err := (*spec.ServicePrincipalProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipalProfile := servicePrincipalProfileARM.(ManagedClusterServicePrincipalProfile_SpecARM)
		result.Properties.ServicePrincipalProfile = &servicePrincipalProfile
	}
	if spec.WindowsProfile != nil {
		windowsProfileARM, err := (*spec.WindowsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsProfile := windowsProfileARM.(ManagedClusterWindowsProfile_SpecARM)
		result.Properties.WindowsProfile = &windowsProfile
	}

	// Set property ‘Sku’:
	if spec.Sku != nil {
		skuARM, err := (*spec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(ManagedClusterSKU_SpecARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if spec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range spec.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spec *ManagedClusters_SPEC) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusters_SPECARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spec *ManagedClusters_SPEC) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusters_SPECARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusters_SPECARM, got %T", armInput)
	}

	// Set property ‘AadProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile_Spec
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			spec.AadProfile = &aadProfile
		}
	}

	// Set property ‘AddonProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			addonProfiles := *(*typedInput.Properties.AddonProfiles).DeepCopy()
			spec.AddonProfiles = &addonProfiles
		}
	}

	// Set property ‘AgentPoolProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.AgentPoolProfiles = append(spec.AgentPoolProfiles, item1)
		}
	}

	// Set property ‘ApiServerAccessProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile_Spec
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			spec.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property ‘AutoScalerProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterProperties_AutoScalerProfile_Spec
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			spec.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property ‘AutoUpgradeProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile_Spec
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			spec.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property ‘AzureName’:
	spec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DisableLocalAccounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			spec.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// no assignment for property ‘DiskEncryptionSetIDReference’

	// Set property ‘DnsPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			spec.DnsPrefix = &dnsPrefix
		}
	}

	// Set property ‘EnablePodSecurityPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePodSecurityPolicy != nil {
			enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
			spec.EnablePodSecurityPolicy = &enablePodSecurityPolicy
		}
	}

	// Set property ‘EnableRBAC’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			spec.EnableRBAC = &enableRBAC
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		spec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FqdnSubdomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			spec.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property ‘HttpProxyConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig_Spec
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			spec.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity_Spec
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		spec.Identity = &identity
	}

	// Set property ‘IdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			identityProfile := *(*typedInput.Properties.IdentityProfile).DeepCopy()
			spec.IdentityProfile = &identityProfile
		}
	}

	// Set property ‘KubernetesVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			spec.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property ‘LinuxProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile_Spec
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			spec.LinuxProfile = &linuxProfile
		}
	}

	// Set property ‘Location’:
	spec.Location = typedInput.Location

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile_Spec
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			spec.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘NodeResourceGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			spec.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property ‘Owner’:
	spec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘PodIdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile_Spec
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			spec.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property ‘PrivateLinkResources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.PrivateLinkResources = append(spec.PrivateLinkResources, item1)
		}
	}

	// Set property ‘ServicePrincipalProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile_Spec
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			spec.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU_Spec
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		spec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		spec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			spec.Tags[key] = value
		}
	}

	// Set property ‘WindowsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile_Spec
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			spec.WindowsProfile = &windowsProfile
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedClusters_SPEC{}

// ConvertSpecFrom populates our ManagedClusters_SPEC from the provided source
func (spec *ManagedClusters_SPEC) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20210501storage.ManagedClusters_SPEC)
	if ok {
		// Populate our instance from source
		return spec.AssignPropertiesFromManagedClusters_SPEC(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210501storage.ManagedClusters_SPEC{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = spec.AssignPropertiesFromManagedClusters_SPEC(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedClusters_SPEC
func (spec *ManagedClusters_SPEC) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20210501storage.ManagedClusters_SPEC)
	if ok {
		// Populate destination from our instance
		return spec.AssignPropertiesToManagedClusters_SPEC(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210501storage.ManagedClusters_SPEC{}
	err := spec.AssignPropertiesToManagedClusters_SPEC(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromManagedClusters_SPEC populates our ManagedClusters_SPEC from the provided source ManagedClusters_SPEC
func (spec *ManagedClusters_SPEC) AssignPropertiesFromManagedClusters_SPEC(source *v1alpha1api20210501storage.ManagedClusters_SPEC) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_Spec
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfile_Spec(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAADProfile_Spec() to populate field AadProfile")
		}
		spec.AadProfile = &aadProfile
	} else {
		spec.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfile := *source.AddonProfiles.DeepCopy()
		spec.AddonProfiles = &addonProfile
	} else {
		spec.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_Spec, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile_Spec
			err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfile_Spec(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAgentPoolProfile_Spec() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		spec.AgentPoolProfiles = agentPoolProfileList
	} else {
		spec.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_Spec
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfile_Spec(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAPIServerAccessProfile_Spec() to populate field ApiServerAccessProfile")
		}
		spec.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		spec.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile_Spec
		err := autoScalerProfile.AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Spec(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Spec() to populate field AutoScalerProfile")
		}
		spec.AutoScalerProfile = &autoScalerProfile
	} else {
		spec.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_Spec
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfile_Spec(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAutoUpgradeProfile_Spec() to populate field AutoUpgradeProfile")
		}
		spec.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		spec.AutoUpgradeProfile = nil
	}

	// AzureName
	spec.AzureName = source.AzureName

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		spec.DisableLocalAccounts = &disableLocalAccount
	} else {
		spec.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if source.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := source.DiskEncryptionSetIDReference.Copy()
		spec.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		spec.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	spec.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		spec.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		spec.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		spec.EnableRBAC = &enableRBAC
	} else {
		spec.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Spec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		spec.ExtendedLocation = &extendedLocation
	} else {
		spec.ExtendedLocation = nil
	}

	// FqdnSubdomain
	spec.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_Spec
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfig_Spec(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterHTTPProxyConfig_Spec() to populate field HttpProxyConfig")
		}
		spec.HttpProxyConfig = &httpProxyConfig
	} else {
		spec.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_Spec
		err := identity.AssignPropertiesFromManagedClusterIdentity_Spec(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity_Spec() to populate field Identity")
		}
		spec.Identity = &identity
	} else {
		spec.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfile := *source.IdentityProfile.DeepCopy()
		spec.IdentityProfile = &identityProfile
	} else {
		spec.IdentityProfile = nil
	}

	// KubernetesVersion
	spec.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_Spec
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfile_Spec(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceLinuxProfile_Spec() to populate field LinuxProfile")
		}
		spec.LinuxProfile = &linuxProfile
	} else {
		spec.LinuxProfile = nil
	}

	// Location
	spec.Location = genruntime.GetOptionalStringValue(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_Spec
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfile_Spec(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceNetworkProfile_Spec() to populate field NetworkProfile")
		}
		spec.NetworkProfile = &networkProfile
	} else {
		spec.NetworkProfile = nil
	}

	// NodeResourceGroup
	spec.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// Owner
	spec.Owner = source.Owner.Copy()

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_Spec
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfile_Spec(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProfile_Spec() to populate field PodIdentityProfile")
		}
		spec.PodIdentityProfile = &podIdentityProfile
	} else {
		spec.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource_Spec, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource_Spec
			err := privateLinkResource.AssignPropertiesFromPrivateLinkResource_Spec(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkResource_Spec() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		spec.PrivateLinkResources = privateLinkResourceList
	} else {
		spec.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_Spec
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfile_Spec(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterServicePrincipalProfile_Spec() to populate field ServicePrincipalProfile")
		}
		spec.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		spec.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_Spec
		err := sku.AssignPropertiesFromManagedClusterSKU_Spec(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterSKU_Spec() to populate field Sku")
		}
		spec.Sku = &sku
	} else {
		spec.Sku = nil
	}

	// Tags
	spec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_Spec
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfile_Spec(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterWindowsProfile_Spec() to populate field WindowsProfile")
		}
		spec.WindowsProfile = &windowsProfile
	} else {
		spec.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusters_SPEC populates the provided destination ManagedClusters_SPEC from our ManagedClusters_SPEC
func (spec *ManagedClusters_SPEC) AssignPropertiesToManagedClusters_SPEC(destination *v1alpha1api20210501storage.ManagedClusters_SPEC) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if spec.AadProfile != nil {
		var aadProfile v1alpha1api20210501storage.ManagedClusterAADProfile_Spec
		err := spec.AadProfile.AssignPropertiesToManagedClusterAADProfile_Spec(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAADProfile_Spec() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if spec.AddonProfiles != nil {
		addonProfile := *spec.AddonProfiles.DeepCopy()
		destination.AddonProfiles = &addonProfile
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if spec.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Spec, len(spec.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range spec.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Spec
			err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfile_Spec(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAgentPoolProfile_Spec() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if spec.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Spec
		err := spec.ApiServerAccessProfile.AssignPropertiesToManagedClusterAPIServerAccessProfile_Spec(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAPIServerAccessProfile_Spec() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if spec.AutoScalerProfile != nil {
		var autoScalerProfile v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Spec
		err := spec.AutoScalerProfile.AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Spec(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Spec() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if spec.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Spec
		err := spec.AutoUpgradeProfile.AssignPropertiesToManagedClusterAutoUpgradeProfile_Spec(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAutoUpgradeProfile_Spec() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureName
	destination.AzureName = spec.AzureName

	// DisableLocalAccounts
	if spec.DisableLocalAccounts != nil {
		disableLocalAccount := *spec.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if spec.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := spec.DiskEncryptionSetIDReference.Copy()
		destination.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		destination.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(spec.DnsPrefix)

	// EnablePodSecurityPolicy
	if spec.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *spec.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if spec.EnableRBAC != nil {
		enableRBAC := *spec.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if spec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20210501storage.ExtendedLocation_Spec
		err := spec.ExtendedLocation.AssignPropertiesToExtendedLocation_Spec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(spec.FqdnSubdomain)

	// HttpProxyConfig
	if spec.HttpProxyConfig != nil {
		var httpProxyConfig v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Spec
		err := spec.HttpProxyConfig.AssignPropertiesToManagedClusterHTTPProxyConfig_Spec(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterHTTPProxyConfig_Spec() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if spec.Identity != nil {
		var identity v1alpha1api20210501storage.ManagedClusterIdentity_Spec
		err := spec.Identity.AssignPropertiesToManagedClusterIdentity_Spec(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity_Spec() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if spec.IdentityProfile != nil {
		identityProfile := *spec.IdentityProfile.DeepCopy()
		destination.IdentityProfile = &identityProfile
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(spec.KubernetesVersion)

	// LinuxProfile
	if spec.LinuxProfile != nil {
		var linuxProfile v1alpha1api20210501storage.ContainerServiceLinuxProfile_Spec
		err := spec.LinuxProfile.AssignPropertiesToContainerServiceLinuxProfile_Spec(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceLinuxProfile_Spec() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	location := spec.Location
	destination.Location = &location

	// NetworkProfile
	if spec.NetworkProfile != nil {
		var networkProfile v1alpha1api20210501storage.ContainerServiceNetworkProfile_Spec
		err := spec.NetworkProfile.AssignPropertiesToContainerServiceNetworkProfile_Spec(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceNetworkProfile_Spec() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(spec.NodeResourceGroup)

	// OriginalVersion
	destination.OriginalVersion = spec.OriginalVersion()

	// Owner
	destination.Owner = spec.Owner.Copy()

	// PodIdentityProfile
	if spec.PodIdentityProfile != nil {
		var podIdentityProfile v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Spec
		err := spec.PodIdentityProfile.AssignPropertiesToManagedClusterPodIdentityProfile_Spec(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProfile_Spec() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if spec.PrivateLinkResources != nil {
		privateLinkResourceList := make([]v1alpha1api20210501storage.PrivateLinkResource_Spec, len(spec.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range spec.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource v1alpha1api20210501storage.PrivateLinkResource_Spec
			err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResource_Spec(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkResource_Spec() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if spec.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Spec
		err := spec.ServicePrincipalProfile.AssignPropertiesToManagedClusterServicePrincipalProfile_Spec(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterServicePrincipalProfile_Spec() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if spec.Sku != nil {
		var sku v1alpha1api20210501storage.ManagedClusterSKU_Spec
		err := spec.Sku.AssignPropertiesToManagedClusterSKU_Spec(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterSKU_Spec() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(spec.Tags)

	// WindowsProfile
	if spec.WindowsProfile != nil {
		var windowsProfile v1alpha1api20210501storage.ManagedClusterWindowsProfile_Spec
		err := spec.WindowsProfile.AssignPropertiesToManagedClusterWindowsProfile_Spec(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterWindowsProfile_Spec() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (spec *ManagedClusters_SPEC) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (spec *ManagedClusters_SPEC) SetAzureName(azureName string) { spec.AzureName = azureName }

type ContainerServiceLinuxProfile_Spec struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z][-A-Za-z0-9_]*$"
	//AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername string `json:"adminUsername"`

	// +kubebuilder:validation:Required
	//Ssh: The SSH configuration for Linux-based VMs running on Azure.
	Ssh ContainerServiceSshConfiguration_Spec `json:"ssh"`
}

var _ genruntime.ARMTransformer = &ContainerServiceLinuxProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceLinuxProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ContainerServiceLinuxProfile_SpecARM

	// Set property ‘AdminUsername’:
	result.AdminUsername = profile.AdminUsername

	// Set property ‘Ssh’:
	sshARM, err := profile.Ssh.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Ssh = sshARM.(ContainerServiceSshConfiguration_SpecARM)
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceLinuxProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceLinuxProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceLinuxProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	profile.AdminUsername = typedInput.AdminUsername

	// Set property ‘Ssh’:
	var ssh ContainerServiceSshConfiguration_Spec
	err := ssh.PopulateFromARM(owner, typedInput.Ssh)
	if err != nil {
		return err
	}
	profile.Ssh = ssh

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceLinuxProfile_Spec populates our ContainerServiceLinuxProfile_Spec from the provided source ContainerServiceLinuxProfile_Spec
func (profile *ContainerServiceLinuxProfile_Spec) AssignPropertiesFromContainerServiceLinuxProfile_Spec(source *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Spec) error {

	// AdminUsername
	if source.AdminUsername != nil {
		profile.AdminUsername = *source.AdminUsername
	} else {
		profile.AdminUsername = ""
	}

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_Spec
		err := ssh.AssignPropertiesFromContainerServiceSshConfiguration_Spec(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshConfiguration_Spec() to populate field Ssh")
		}
		profile.Ssh = ssh
	} else {
		profile.Ssh = ContainerServiceSshConfiguration_Spec{}
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceLinuxProfile_Spec populates the provided destination ContainerServiceLinuxProfile_Spec from our ContainerServiceLinuxProfile_Spec
func (profile *ContainerServiceLinuxProfile_Spec) AssignPropertiesToContainerServiceLinuxProfile_Spec(destination *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	adminUsername := profile.AdminUsername
	destination.AdminUsername = &adminUsername

	// Ssh
	var ssh v1alpha1api20210501storage.ContainerServiceSshConfiguration_Spec
	err := profile.Ssh.AssignPropertiesToContainerServiceSshConfiguration_Spec(&ssh)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshConfiguration_Spec() to populate field Ssh")
	}
	destination.Ssh = &ssh

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceLinuxProfile_Status struct {
	// +kubebuilder:validation:Required
	//AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername string `json:"adminUsername"`

	// +kubebuilder:validation:Required
	//Ssh: The SSH configuration for Linux-based VMs running on Azure.
	Ssh ContainerServiceSshConfiguration_Status `json:"ssh"`
}

var _ genruntime.FromARMConverter = &ContainerServiceLinuxProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceLinuxProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceLinuxProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceLinuxProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	profile.AdminUsername = typedInput.AdminUsername

	// Set property ‘Ssh’:
	var ssh ContainerServiceSshConfiguration_Status
	err := ssh.PopulateFromARM(owner, typedInput.Ssh)
	if err != nil {
		return err
	}
	profile.Ssh = ssh

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceLinuxProfile_Status populates our ContainerServiceLinuxProfile_Status from the provided source ContainerServiceLinuxProfile_Status
func (profile *ContainerServiceLinuxProfile_Status) AssignPropertiesFromContainerServiceLinuxProfile_Status(source *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status) error {

	// AdminUsername
	profile.AdminUsername = genruntime.GetOptionalStringValue(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_Status
		err := ssh.AssignPropertiesFromContainerServiceSshConfiguration_Status(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshConfiguration_Status() to populate field Ssh")
		}
		profile.Ssh = ssh
	} else {
		profile.Ssh = ContainerServiceSshConfiguration_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceLinuxProfile_Status populates the provided destination ContainerServiceLinuxProfile_Status from our ContainerServiceLinuxProfile_Status
func (profile *ContainerServiceLinuxProfile_Status) AssignPropertiesToContainerServiceLinuxProfile_Status(destination *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	adminUsername := profile.AdminUsername
	destination.AdminUsername = &adminUsername

	// Ssh
	var ssh v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status
	err := profile.Ssh.AssignPropertiesToContainerServiceSshConfiguration_Status(&ssh)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshConfiguration_Status() to populate field Ssh")
	}
	destination.Ssh = &ssh

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceNetworkProfile_Spec struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	//DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be
	//within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge
	//network. It must not overlap with any Subnet IP ranges or the Kubernetes service
	//address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	//LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_Spec `json:"loadBalancerProfile,omitempty"`

	//LoadBalancerSku: The default is 'standard'. See [Azure Load Balancer
	//SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information
	//about the differences between load balancer SKUs.
	LoadBalancerSku *ContainerServiceNetworkProfile_LoadBalancerSku_Spec `json:"loadBalancerSku,omitempty"`

	//NetworkMode: This cannot be specified if networkPlugin is anything other than
	//'azure'.
	NetworkMode *ContainerServiceNetworkProfile_NetworkMode_Spec `json:"networkMode,omitempty"`

	//NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *ContainerServiceNetworkProfile_NetworkPlugin_Spec `json:"networkPlugin,omitempty"`

	//NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *ContainerServiceNetworkProfile_NetworkPolicy_Spec `json:"networkPolicy,omitempty"`

	//OutboundType: This can only be set at cluster creation time and cannot be
	//changed later. For more information see [egress outbound
	//type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfile_OutboundType_Spec `json:"outboundType,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is
	//used.
	PodCidr *string `json:"podCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs.
	//It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceNetworkProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ContainerServiceNetworkProfile_SpecARM

	// Set property ‘DnsServiceIP’:
	if profile.DnsServiceIP != nil {
		dnsServiceIP := *profile.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if profile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *profile.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if profile.LoadBalancerProfile != nil {
		loadBalancerProfileARM, err := (*profile.LoadBalancerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerProfile := loadBalancerProfileARM.(ManagedClusterLoadBalancerProfile_SpecARM)
		result.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := *profile.LoadBalancerSku
		result.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if profile.NetworkMode != nil {
		networkMode := *profile.NetworkMode
		result.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if profile.NetworkPlugin != nil {
		networkPlugin := *profile.NetworkPlugin
		result.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if profile.NetworkPolicy != nil {
		networkPolicy := *profile.NetworkPolicy
		result.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if profile.OutboundType != nil {
		outboundType := *profile.OutboundType
		result.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		result.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceNetworkProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceNetworkProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceNetworkProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘DnsServiceIP’:
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile_Spec
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if typedInput.LoadBalancerSku != nil {
		loadBalancerSku := *typedInput.LoadBalancerSku
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if typedInput.NetworkMode != nil {
		networkMode := *typedInput.NetworkMode
		profile.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if typedInput.NetworkPlugin != nil {
		networkPlugin := *typedInput.NetworkPlugin
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if typedInput.NetworkPolicy != nil {
		networkPolicy := *typedInput.NetworkPolicy
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if typedInput.OutboundType != nil {
		outboundType := *typedInput.OutboundType
		profile.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceNetworkProfile_Spec populates our ContainerServiceNetworkProfile_Spec from the provided source ContainerServiceNetworkProfile_Spec
func (profile *ContainerServiceNetworkProfile_Spec) AssignPropertiesFromContainerServiceNetworkProfile_Spec(source *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Spec) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	} else {
		profile.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		profile.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_Spec
		err := loadBalancerProfile.AssignPropertiesFromManagedClusterLoadBalancerProfile_Spec(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_Spec() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := ContainerServiceNetworkProfile_LoadBalancerSku_Spec(*source.LoadBalancerSku)
		profile.LoadBalancerSku = &loadBalancerSku
	} else {
		profile.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := ContainerServiceNetworkProfile_NetworkMode_Spec(*source.NetworkMode)
		profile.NetworkMode = &networkMode
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := ContainerServiceNetworkProfile_NetworkPlugin_Spec(*source.NetworkPlugin)
		profile.NetworkPlugin = &networkPlugin
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := ContainerServiceNetworkProfile_NetworkPolicy_Spec(*source.NetworkPolicy)
		profile.NetworkPolicy = &networkPolicy
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := ContainerServiceNetworkProfile_OutboundType_Spec(*source.OutboundType)
		profile.OutboundType = &outboundType
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	if source.PodCidr != nil {
		podCidr := *source.PodCidr
		profile.PodCidr = &podCidr
	} else {
		profile.PodCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	} else {
		profile.ServiceCidr = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceNetworkProfile_Spec populates the provided destination ContainerServiceNetworkProfile_Spec from our ContainerServiceNetworkProfile_Spec
func (profile *ContainerServiceNetworkProfile_Spec) AssignPropertiesToContainerServiceNetworkProfile_Spec(destination *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if profile.DnsServiceIP != nil {
		dnsServiceIP := *profile.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if profile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *profile.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Spec
		err := profile.LoadBalancerProfile.AssignPropertiesToManagedClusterLoadBalancerProfile_Spec(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_Spec() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		destination.PodCidr = &podCidr
	} else {
		destination.PodCidr = nil
	}

	// ServiceCidr
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceNetworkProfile_Status struct {
	//DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be
	//within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	//DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge
	//network. It must not overlap with any Subnet IP ranges or the Kubernetes service
	//address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	//LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_Status `json:"loadBalancerProfile,omitempty"`

	//LoadBalancerSku: The default is 'standard'. See [Azure Load Balancer
	//SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information
	//about the differences between load balancer SKUs.
	LoadBalancerSku *ContainerServiceNetworkProfile_LoadBalancerSku_Status `json:"loadBalancerSku,omitempty"`

	//NetworkMode: This cannot be specified if networkPlugin is anything other than
	//'azure'.
	NetworkMode *ContainerServiceNetworkProfile_NetworkMode_Status `json:"networkMode,omitempty"`

	//NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *ContainerServiceNetworkProfile_NetworkPlugin_Status `json:"networkPlugin,omitempty"`

	//NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *ContainerServiceNetworkProfile_NetworkPolicy_Status `json:"networkPolicy,omitempty"`

	//OutboundType: This can only be set at cluster creation time and cannot be
	//changed later. For more information see [egress outbound
	//type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfile_OutboundType_Status `json:"outboundType,omitempty"`

	//PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is
	//used.
	PodCidr *string `json:"podCidr,omitempty"`

	//ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs.
	//It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceNetworkProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceNetworkProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceNetworkProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsServiceIP’:
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		profile.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile_Status
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if typedInput.LoadBalancerSku != nil {
		loadBalancerSku := *typedInput.LoadBalancerSku
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if typedInput.NetworkMode != nil {
		networkMode := *typedInput.NetworkMode
		profile.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if typedInput.NetworkPlugin != nil {
		networkPlugin := *typedInput.NetworkPlugin
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if typedInput.NetworkPolicy != nil {
		networkPolicy := *typedInput.NetworkPolicy
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if typedInput.OutboundType != nil {
		outboundType := *typedInput.OutboundType
		profile.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceNetworkProfile_Status populates our ContainerServiceNetworkProfile_Status from the provided source ContainerServiceNetworkProfile_Status
func (profile *ContainerServiceNetworkProfile_Status) AssignPropertiesFromContainerServiceNetworkProfile_Status(source *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status) error {

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	profile.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_Status
		err := loadBalancerProfile.AssignPropertiesFromManagedClusterLoadBalancerProfile_Status(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_Status() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := ContainerServiceNetworkProfile_LoadBalancerSku_Status(*source.LoadBalancerSku)
		profile.LoadBalancerSku = &loadBalancerSku
	} else {
		profile.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := ContainerServiceNetworkProfile_NetworkMode_Status(*source.NetworkMode)
		profile.NetworkMode = &networkMode
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := ContainerServiceNetworkProfile_NetworkPlugin_Status(*source.NetworkPlugin)
		profile.NetworkPlugin = &networkPlugin
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := ContainerServiceNetworkProfile_NetworkPolicy_Status(*source.NetworkPolicy)
		profile.NetworkPolicy = &networkPolicy
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := ContainerServiceNetworkProfile_OutboundType_Status(*source.OutboundType)
		profile.OutboundType = &outboundType
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// No error
	return nil
}

// AssignPropertiesToContainerServiceNetworkProfile_Status populates the provided destination ContainerServiceNetworkProfile_Status from our ContainerServiceNetworkProfile_Status
func (profile *ContainerServiceNetworkProfile_Status) AssignPropertiesToContainerServiceNetworkProfile_Status(destination *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(profile.DockerBridgeCidr)

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status
		err := profile.LoadBalancerProfile.AssignPropertiesToManagedClusterLoadBalancerProfile_Status(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_Status() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_Spec struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Spec `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	var result ExtendedLocation_SpecARM

	// Set property ‘Name’:
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if location.Type != nil {
		typeVar := *location.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_SpecARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation_Spec populates our ExtendedLocation_Spec from the provided source ExtendedLocation_Spec
func (location *ExtendedLocation_Spec) AssignPropertiesFromExtendedLocation_Spec(source *v1alpha1api20210501storage.ExtendedLocation_Spec) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Spec(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation_Spec populates the provided destination ExtendedLocation_Spec from our ExtendedLocation_Spec
func (location *ExtendedLocation_Spec) AssignPropertiesToExtendedLocation_Spec(destination *v1alpha1api20210501storage.ExtendedLocation_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_Status struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation_Status populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesFromExtendedLocation_Status(source *v1alpha1api20210501storage.ExtendedLocation_Status) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation_Status populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesToExtendedLocation_Status(destination *v1alpha1api20210501storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAADProfile_Spec struct {
	//AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role
	//of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	//ClientAppID: The client AAD application ID.
	ClientAppID *string `json:"clientAppID,omitempty"`

	//EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	//Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	//ServerAppID: The server AAD application ID.
	ServerAppID *string `json:"serverAppID,omitempty"`

	//ServerAppSecret: The server AAD application secret.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	//TenantID: The AAD tenant ID to use for authentication. If not specified, will
	//use the tenant of the deployment subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAADProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAADProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterAADProfile_SpecARM

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range profile.AdminGroupObjectIDs {
		result.AdminGroupObjectIDs = append(result.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if profile.ClientAppID != nil {
		clientAppID := *profile.ClientAppID
		result.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		result.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if profile.Managed != nil {
		managed := *profile.Managed
		result.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if profile.ServerAppID != nil {
		serverAppID := *profile.ServerAppID
		result.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if profile.ServerAppSecret != nil {
		serverAppSecret := *profile.ServerAppSecret
		result.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if profile.TenantID != nil {
		tenantID := *profile.TenantID
		result.TenantID = &tenantID
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAADProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAADProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAADProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAADProfile_Spec populates our ManagedClusterAADProfile_Spec from the provided source ManagedClusterAADProfile_Spec
func (profile *ManagedClusterAADProfile_Spec) AssignPropertiesFromManagedClusterAADProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterAADProfile_Spec) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAADProfile_Spec populates the provided destination ManagedClusterAADProfile_Spec from our ManagedClusterAADProfile_Spec
func (profile *ManagedClusterAADProfile_Spec) AssignPropertiesToManagedClusterAADProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterAADProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAADProfile_Status struct {
	//AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role
	//of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	//ClientAppID: The client AAD application ID.
	ClientAppID *string `json:"clientAppID,omitempty"`

	//EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	//Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	//ServerAppID: The server AAD application ID.
	ServerAppID *string `json:"serverAppID,omitempty"`

	//ServerAppSecret: The server AAD application secret.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	//TenantID: The AAD tenant ID to use for authentication. If not specified, will
	//use the tenant of the deployment subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAADProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAADProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAADProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAADProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAADProfile_Status populates our ManagedClusterAADProfile_Status from the provided source ManagedClusterAADProfile_Status
func (profile *ManagedClusterAADProfile_Status) AssignPropertiesFromManagedClusterAADProfile_Status(source *v1alpha1api20210501storage.ManagedClusterAADProfile_Status) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAADProfile_Status populates the provided destination ManagedClusterAADProfile_Status from our ManagedClusterAADProfile_Status
func (profile *ManagedClusterAADProfile_Status) AssignPropertiesToManagedClusterAADProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterAADProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAPIServerAccessProfile_Spec struct {
	//AuthorizedIPRanges: IP ranges are specified in CIDR format, e.g.
	//137.117.106.88/29. This feature is not compatible with clusters that use Public
	//IP Per Node, or clusters that are using a Basic Load Balancer. For more
	//information see [API server authorized IP
	//ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	//EnablePrivateCluster: For more details, see [Creating a private AKS
	//cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	//EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for
	//private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	//PrivateDNSZone: The default is System. For more details see [configure private
	//DNS
	//zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
	//Allowed values are 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAPIServerAccessProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAPIServerAccessProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterAPIServerAccessProfile_SpecARM

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range profile.AuthorizedIPRanges {
		result.AuthorizedIPRanges = append(result.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		result.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		result.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if profile.PrivateDNSZone != nil {
		privateDNSZone := *profile.PrivateDNSZone
		result.PrivateDNSZone = &privateDNSZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAPIServerAccessProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAPIServerAccessProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAPIServerAccessProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAPIServerAccessProfile_Spec populates our ManagedClusterAPIServerAccessProfile_Spec from the provided source ManagedClusterAPIServerAccessProfile_Spec
func (profile *ManagedClusterAPIServerAccessProfile_Spec) AssignPropertiesFromManagedClusterAPIServerAccessProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Spec) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAPIServerAccessProfile_Spec populates the provided destination ManagedClusterAPIServerAccessProfile_Spec from our ManagedClusterAPIServerAccessProfile_Spec
func (profile *ManagedClusterAPIServerAccessProfile_Spec) AssignPropertiesToManagedClusterAPIServerAccessProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAPIServerAccessProfile_Status struct {
	//AuthorizedIPRanges: IP ranges are specified in CIDR format, e.g.
	//137.117.106.88/29. This feature is not compatible with clusters that use Public
	//IP Per Node, or clusters that are using a Basic Load Balancer. For more
	//information see [API server authorized IP
	//ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	//EnablePrivateCluster: For more details, see [Creating a private AKS
	//cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	//EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for
	//private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	//PrivateDNSZone: The default is System. For more details see [configure private
	//DNS
	//zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
	//Allowed values are 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAPIServerAccessProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAPIServerAccessProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAPIServerAccessProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAPIServerAccessProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAPIServerAccessProfile_Status populates our ManagedClusterAPIServerAccessProfile_Status from the provided source ManagedClusterAPIServerAccessProfile_Status
func (profile *ManagedClusterAPIServerAccessProfile_Status) AssignPropertiesFromManagedClusterAPIServerAccessProfile_Status(source *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAPIServerAccessProfile_Status populates the provided destination ManagedClusterAPIServerAccessProfile_Status from our ManagedClusterAPIServerAccessProfile_Status
func (profile *ManagedClusterAPIServerAccessProfile_Status) AssignPropertiesToManagedClusterAPIServerAccessProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAgentPoolProfile_Spec struct {
	//AvailabilityZones: The list of Availability zones to use for nodes. This can
	//only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	//Count: Number of agents (VMs) to host docker containers. Allowed values must be
	//in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to
	//1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	//EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	//EnableEncryptionAtHost: This is only supported on certain VM sizes and in
	//certain Azure regions. For more information, see:
	//https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	//EnableFIPS: See [Add a FIPS-enabled node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview)
	//for more details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	//EnableNodePublicIP: Some scenarios may require nodes in a node pool to receive
	//their own dedicated public IP addresses. A common scenario is for gaming
	//workloads, where a console needs to make a direct connection to a cloud virtual
	//machine to minimize hops. For more information see [assigning a public IP per
	//node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	//The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	//EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	//GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance
	//profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile_Spec `json:"gpuInstanceProfile,omitempty"`

	//KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig   *KubeletConfig_Spec   `json:"kubeletConfig,omitempty"`
	KubeletDiskType *KubeletDiskType_Spec `json:"kubeletDiskType,omitempty"`

	//LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig_Spec `json:"linuxOSConfig,omitempty"`

	//MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	//MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	//MinCount: The minimum number of nodes for auto-scaling
	MinCount *int                `json:"minCount,omitempty"`
	Mode     *AgentPoolMode_Spec `json:"mode,omitempty"`

	// +kubebuilder:validation:Pattern="^[a-z][a-z0-9]{0,11}$"
	//Name: Windows agent pool names must be 6 characters or less.
	Name *string `json:"name,omitempty"`

	//NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty"`

	//NodePublicIPPrefixIDReference: This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixIDReference *genruntime.ResourceReference `armReference:"NodePublicIPPrefixID" json:"nodePublicIPPrefixIDReference,omitempty"`

	//NodeTaints: The taints added to new nodes during node pool create and scale. For
	//example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty"`

	//OrchestratorVersion: As a best practice, you should upgrade all node pools in an
	//AKS cluster to the same Kubernetes version. The node pool version must have the
	//same major version as the control plane. The node pool minor version must be
	//within two minor versions of the control plane version. The node pool version
	//cannot be greater than the control plane version. For more information see
	//[upgrading a node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string                      `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB        *ContainerServiceOSDisk_Spec `json:"osDiskSizeGB,omitempty"`
	OsDiskType          *OSDiskType_Spec             `json:"osDiskType,omitempty"`
	OsSKU               *OSSKU_Spec                  `json:"osSKU,omitempty"`
	OsType              *OSType_Spec                 `json:"osType,omitempty"`

	//PodSubnetIDReference: If omitted, pod IPs are statically assigned on the node
	//subnet (see vnetSubnetID for more details). This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetIDReference *genruntime.ResourceReference `armReference:"PodSubnetID" json:"podSubnetIDReference,omitempty"`

	//ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	//ScaleSetEvictionPolicy: This cannot be specified unless the scaleSetPriority is
	//'Spot'. If not specified, the default is 'Delete'.
	ScaleSetEvictionPolicy *ScaleSetEvictionPolicy_Spec `json:"scaleSetEvictionPolicy,omitempty"`

	//ScaleSetPriority: The Virtual Machine Scale Set priority. If not specified, the
	//default is 'Regular'.
	ScaleSetPriority *ScaleSetPriority_Spec `json:"scaleSetPriority,omitempty"`

	//SpotMaxPrice: Possible values are any decimal value greater than zero or -1
	//which indicates the willingness to pay any on-demand price. For more details on
	//spot pricing, see [spot VMs
	//pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	//Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string   `json:"tags,omitempty"`
	Type *AgentPoolType_Spec `json:"type,omitempty"`

	//UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings_Spec `json:"upgradeSettings,omitempty"`

	//VmSize: VM size availability varies by region. If a node contains insufficient
	//compute resources (memory, cpu, etc) pods might fail to run correctly. For more
	//details on restricted VM sizes, see:
	//https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	//VnetSubnetIDReference: If this is not specified, a VNET and subnet will be
	//generated and used. If no podSubnetID is specified, this applies to nodes and
	//pods, otherwise it applies to just nodes. This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetIDReference *genruntime.ResourceReference `armReference:"VnetSubnetID" json:"vnetSubnetIDReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAgentPoolProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAgentPoolProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterAgentPoolProfile_SpecARM

	// Set property ‘AvailabilityZones’:
	for _, item := range profile.AvailabilityZones {
		result.AvailabilityZones = append(result.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if profile.Count != nil {
		count := *profile.Count
		result.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		result.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		result.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		result.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		result.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		result.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := *profile.GpuInstanceProfile
		result.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if profile.KubeletConfig != nil {
		kubeletConfigARM, err := (*profile.KubeletConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeletConfig := kubeletConfigARM.(KubeletConfig_SpecARM)
		result.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if profile.KubeletDiskType != nil {
		kubeletDiskType := *profile.KubeletDiskType
		result.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if profile.LinuxOSConfig != nil {
		linuxOSConfigARM, err := (*profile.LinuxOSConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxOSConfig := linuxOSConfigARM.(LinuxOSConfig_SpecARM)
		result.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if profile.MaxCount != nil {
		maxCount := *profile.MaxCount
		result.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if profile.MaxPods != nil {
		maxPods := *profile.MaxPods
		result.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if profile.MinCount != nil {
		minCount := *profile.MinCount
		result.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if profile.Mode != nil {
		mode := *profile.Mode
		result.Mode = &mode
	}

	// Set property ‘Name’:
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property ‘NodeLabels’:
	if profile.NodeLabels != nil {
		result.NodeLabels = make(map[string]string)
		for key, value := range profile.NodeLabels {
			result.NodeLabels[key] = value
		}
	}

	// Set property ‘NodePublicIPPrefixID’:
	if profile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*profile.NodePublicIPPrefixIDReference)
		if err != nil {
			return nil, err
		}
		nodePublicIPPrefixIDReference := nodePublicIPPrefixIDReferenceARMID
		result.NodePublicIPPrefixID = &nodePublicIPPrefixIDReference
	}

	// Set property ‘NodeTaints’:
	for _, item := range profile.NodeTaints {
		result.NodeTaints = append(result.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if profile.OrchestratorVersion != nil {
		orchestratorVersion := *profile.OrchestratorVersion
		result.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if profile.OsDiskSizeGB != nil {
		osDiskSizeGB := *profile.OsDiskSizeGB
		result.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if profile.OsDiskType != nil {
		osDiskType := *profile.OsDiskType
		result.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if profile.OsSKU != nil {
		osSKU := *profile.OsSKU
		result.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if profile.OsType != nil {
		osType := *profile.OsType
		result.OsType = &osType
	}

	// Set property ‘PodSubnetID’:
	if profile.PodSubnetIDReference != nil {
		podSubnetIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*profile.PodSubnetIDReference)
		if err != nil {
			return nil, err
		}
		podSubnetIDReference := podSubnetIDReferenceARMID
		result.PodSubnetID = &podSubnetIDReference
	}

	// Set property ‘ProximityPlacementGroupID’:
	if profile.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *profile.ProximityPlacementGroupID
		result.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *profile.ScaleSetEvictionPolicy
		result.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := *profile.ScaleSetPriority
		result.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		result.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if profile.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range profile.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if profile.Type != nil {
		typeVar := *profile.Type
		result.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if profile.UpgradeSettings != nil {
		upgradeSettingsARM, err := (*profile.UpgradeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettings := upgradeSettingsARM.(AgentPoolUpgradeSettings_SpecARM)
		result.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}

	// Set property ‘VnetSubnetID’:
	if profile.VnetSubnetIDReference != nil {
		vnetSubnetIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*profile.VnetSubnetIDReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetIDReference := vnetSubnetIDReferenceARMID
		result.VnetSubnetID = &vnetSubnetIDReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAgentPoolProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAgentPoolProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAgentPoolProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AvailabilityZones’:
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if typedInput.GpuInstanceProfile != nil {
		gpuInstanceProfile := *typedInput.GpuInstanceProfile
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig_Spec
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if typedInput.KubeletDiskType != nil {
		kubeletDiskType := *typedInput.KubeletDiskType
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig_Spec
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		profile.Mode = &mode
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property ‘NodeLabels’:
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string)
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	}

	// no assignment for property ‘NodePublicIPPrefixIDReference’

	// Set property ‘NodeTaints’:
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if typedInput.OsDiskType != nil {
		osDiskType := *typedInput.OsDiskType
		profile.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if typedInput.OsSKU != nil {
		osSKU := *typedInput.OsSKU
		profile.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		profile.OsType = &osType
	}

	// no assignment for property ‘PodSubnetIDReference’

	// Set property ‘ProximityPlacementGroupID’:
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		profile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if typedInput.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *typedInput.ScaleSetEvictionPolicy
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if typedInput.ScaleSetPriority != nil {
		scaleSetPriority := *typedInput.ScaleSetPriority
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings_Spec
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// no assignment for property ‘VnetSubnetIDReference’

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAgentPoolProfile_Spec populates our ManagedClusterAgentPoolProfile_Spec from the provided source ManagedClusterAgentPoolProfile_Spec
func (profile *ManagedClusterAgentPoolProfile_Spec) AssignPropertiesFromManagedClusterAgentPoolProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Spec) error {

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := GPUInstanceProfile_Spec(*source.GpuInstanceProfile)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		profile.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_Spec
		err := kubeletConfig.AssignPropertiesFromKubeletConfig_Spec(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKubeletConfig_Spec() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := KubeletDiskType_Spec(*source.KubeletDiskType)
		profile.KubeletDiskType = &kubeletDiskType
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_Spec
		err := linuxOSConfig.AssignPropertiesFromLinuxOSConfig_Spec(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxOSConfig_Spec() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := AgentPoolMode_Spec(*source.Mode)
		profile.Mode = &mode
	} else {
		profile.Mode = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		profile.Name = &name
	} else {
		profile.Name = nil
	}

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixIDReference
	if source.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := source.NodePublicIPPrefixIDReference.Copy()
		profile.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		profile.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	if source.OsDiskSizeGB != nil {
		osDiskSizeGB := ContainerServiceOSDisk_Spec(*source.OsDiskSizeGB)
		profile.OsDiskSizeGB = &osDiskSizeGB
	} else {
		profile.OsDiskSizeGB = nil
	}

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := OSDiskType_Spec(*source.OsDiskType)
		profile.OsDiskType = &osDiskType
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := OSSKU_Spec(*source.OsSKU)
		profile.OsSKU = &osSKU
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := OSType_Spec(*source.OsType)
		profile.OsType = &osType
	} else {
		profile.OsType = nil
	}

	// PodSubnetIDReference
	if source.PodSubnetIDReference != nil {
		podSubnetIDReference := source.PodSubnetIDReference.Copy()
		profile.PodSubnetIDReference = &podSubnetIDReference
	} else {
		profile.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := ScaleSetEvictionPolicy_Spec(*source.ScaleSetEvictionPolicy)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := ScaleSetPriority_Spec(*source.ScaleSetPriority)
		profile.ScaleSetPriority = &scaleSetPriority
	} else {
		profile.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := AgentPoolType_Spec(*source.Type)
		profile.Type = &typeVar
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_Spec
		err := upgradeSetting.AssignPropertiesFromAgentPoolUpgradeSettings_Spec(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAgentPoolUpgradeSettings_Spec() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetIDReference
	if source.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := source.VnetSubnetIDReference.Copy()
		profile.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		profile.VnetSubnetIDReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAgentPoolProfile_Spec populates the provided destination ManagedClusterAgentPoolProfile_Spec from our ManagedClusterAgentPoolProfile_Spec
func (profile *ManagedClusterAgentPoolProfile_Spec) AssignPropertiesToManagedClusterAgentPoolProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig v1alpha1api20210501storage.KubeletConfig_Spec
		err := profile.KubeletConfig.AssignPropertiesToKubeletConfig_Spec(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKubeletConfig_Spec() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig v1alpha1api20210501storage.LinuxOSConfig_Spec
		err := profile.LinuxOSConfig.AssignPropertiesToLinuxOSConfig_Spec(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxOSConfig_Spec() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	if profile.Name != nil {
		name := *profile.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixIDReference
	if profile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := profile.NodePublicIPPrefixIDReference.Copy()
		destination.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		destination.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	if profile.OsDiskSizeGB != nil {
		osDiskSizeGB := int(*profile.OsDiskSizeGB)
		destination.OsDiskSizeGB = &osDiskSizeGB
	} else {
		destination.OsDiskSizeGB = nil
	}

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetIDReference
	if profile.PodSubnetIDReference != nil {
		podSubnetIDReference := profile.PodSubnetIDReference.Copy()
		destination.PodSubnetIDReference = &podSubnetIDReference
	} else {
		destination.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting v1alpha1api20210501storage.AgentPoolUpgradeSettings_Spec
		err := profile.UpgradeSettings.AssignPropertiesToAgentPoolUpgradeSettings_Spec(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAgentPoolUpgradeSettings_Spec() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetIDReference
	if profile.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := profile.VnetSubnetIDReference.Copy()
		destination.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		destination.VnetSubnetIDReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAgentPoolProfile_Status struct {
	//AvailabilityZones: The list of Availability zones to use for nodes. This can
	//only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	//Count: Number of agents (VMs) to host docker containers. Allowed values must be
	//in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to
	//1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	//EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	//EnableEncryptionAtHost: This is only supported on certain VM sizes and in
	//certain Azure regions. For more information, see:
	//https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	//EnableFIPS: See [Add a FIPS-enabled node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview)
	//for more details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	//EnableNodePublicIP: Some scenarios may require nodes in a node pool to receive
	//their own dedicated public IP addresses. A common scenario is for gaming
	//workloads, where a console needs to make a direct connection to a cloud virtual
	//machine to minimize hops. For more information see [assigning a public IP per
	//node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	//The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	//EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	//GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance
	//profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile_Status `json:"gpuInstanceProfile,omitempty"`

	//KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig   *KubeletConfig_Status   `json:"kubeletConfig,omitempty"`
	KubeletDiskType *KubeletDiskType_Status `json:"kubeletDiskType,omitempty"`

	//LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig_Status `json:"linuxOSConfig,omitempty"`

	//MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	//MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	//MinCount: The minimum number of nodes for auto-scaling
	MinCount *int                  `json:"minCount,omitempty"`
	Mode     *AgentPoolMode_Status `json:"mode,omitempty"`

	//Name: Windows agent pool names must be 6 characters or less.
	Name *string `json:"name,omitempty"`

	//NodeImageVersion: The version of node image
	NodeImageVersion *string `json:"nodeImageVersion,omitempty"`

	//NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty"`

	//NodePublicIPPrefixID: This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixID *string `json:"nodePublicIPPrefixID,omitempty"`

	//NodeTaints: The taints added to new nodes during node pool create and scale. For
	//example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty"`

	//OrchestratorVersion: As a best practice, you should upgrade all node pools in an
	//AKS cluster to the same Kubernetes version. The node pool version must have the
	//same major version as the control plane. The node pool minor version must be
	//within two minor versions of the control plane version. The node pool version
	//cannot be greater than the control plane version. For more information see
	//[upgrading a node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string            `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB        *int               `json:"osDiskSizeGB,omitempty"`
	OsDiskType          *OSDiskType_Status `json:"osDiskType,omitempty"`
	OsSKU               *OSSKU_Status      `json:"osSKU,omitempty"`
	OsType              *OSType_Status     `json:"osType,omitempty"`

	//PodSubnetID: If omitted, pod IPs are statically assigned on the node subnet (see
	//vnetSubnetID for more details). This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	//PowerState: Describes whether the Agent Pool is Running or Stopped
	PowerState *PowerState_Status `json:"powerState,omitempty"`

	//ProvisioningState: The current deployment or provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	//ScaleSetEvictionPolicy: This cannot be specified unless the scaleSetPriority is
	//'Spot'. If not specified, the default is 'Delete'.
	ScaleSetEvictionPolicy *ScaleSetEvictionPolicy_Status `json:"scaleSetEvictionPolicy,omitempty"`

	//ScaleSetPriority: The Virtual Machine Scale Set priority. If not specified, the
	//default is 'Regular'.
	ScaleSetPriority *ScaleSetPriority_Status `json:"scaleSetPriority,omitempty"`

	//SpotMaxPrice: Possible values are any decimal value greater than zero or -1
	//which indicates the willingness to pay any on-demand price. For more details on
	//spot pricing, see [spot VMs
	//pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	//Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string     `json:"tags,omitempty"`
	Type *AgentPoolType_Status `json:"type,omitempty"`

	//UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings_Status `json:"upgradeSettings,omitempty"`

	//VmSize: VM size availability varies by region. If a node contains insufficient
	//compute resources (memory, cpu, etc) pods might fail to run correctly. For more
	//details on restricted VM sizes, see:
	//https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	//VnetSubnetID: If this is not specified, a VNET and subnet will be generated and
	//used. If no podSubnetID is specified, this applies to nodes and pods, otherwise
	//it applies to just nodes. This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAgentPoolProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAgentPoolProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAgentPoolProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAgentPoolProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AvailabilityZones’:
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if typedInput.GpuInstanceProfile != nil {
		gpuInstanceProfile := *typedInput.GpuInstanceProfile
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig_Status
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if typedInput.KubeletDiskType != nil {
		kubeletDiskType := *typedInput.KubeletDiskType
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig_Status
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		profile.Mode = &mode
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property ‘NodeImageVersion’:
	if typedInput.NodeImageVersion != nil {
		nodeImageVersion := *typedInput.NodeImageVersion
		profile.NodeImageVersion = &nodeImageVersion
	}

	// Set property ‘NodeLabels’:
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string)
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	}

	// Set property ‘NodePublicIPPrefixID’:
	if typedInput.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *typedInput.NodePublicIPPrefixID
		profile.NodePublicIPPrefixID = &nodePublicIPPrefixID
	}

	// Set property ‘NodeTaints’:
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if typedInput.OsDiskType != nil {
		osDiskType := *typedInput.OsDiskType
		profile.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if typedInput.OsSKU != nil {
		osSKU := *typedInput.OsSKU
		profile.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		profile.OsType = &osType
	}

	// Set property ‘PodSubnetID’:
	if typedInput.PodSubnetID != nil {
		podSubnetID := *typedInput.PodSubnetID
		profile.PodSubnetID = &podSubnetID
	}

	// Set property ‘PowerState’:
	if typedInput.PowerState != nil {
		var powerState1 PowerState_Status
		err := powerState1.PopulateFromARM(owner, *typedInput.PowerState)
		if err != nil {
			return err
		}
		powerState := powerState1
		profile.PowerState = &powerState
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		profile.ProvisioningState = &provisioningState
	}

	// Set property ‘ProximityPlacementGroupID’:
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		profile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if typedInput.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *typedInput.ScaleSetEvictionPolicy
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if typedInput.ScaleSetPriority != nil {
		scaleSetPriority := *typedInput.ScaleSetPriority
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings_Status
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// Set property ‘VnetSubnetID’:
	if typedInput.VnetSubnetID != nil {
		vnetSubnetID := *typedInput.VnetSubnetID
		profile.VnetSubnetID = &vnetSubnetID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAgentPoolProfile_Status populates our ManagedClusterAgentPoolProfile_Status from the provided source ManagedClusterAgentPoolProfile_Status
func (profile *ManagedClusterAgentPoolProfile_Status) AssignPropertiesFromManagedClusterAgentPoolProfile_Status(source *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status) error {

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := GPUInstanceProfile_Status(*source.GpuInstanceProfile)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		profile.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_Status
		err := kubeletConfig.AssignPropertiesFromKubeletConfig_Status(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKubeletConfig_Status() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := KubeletDiskType_Status(*source.KubeletDiskType)
		profile.KubeletDiskType = &kubeletDiskType
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_Status
		err := linuxOSConfig.AssignPropertiesFromLinuxOSConfig_Status(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxOSConfig_Status() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := AgentPoolMode_Status(*source.Mode)
		profile.Mode = &mode
	} else {
		profile.Mode = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NodeImageVersion
	profile.NodeImageVersion = genruntime.ClonePointerToString(source.NodeImageVersion)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixID
	profile.NodePublicIPPrefixID = genruntime.ClonePointerToString(source.NodePublicIPPrefixID)

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := OSDiskType_Status(*source.OsDiskType)
		profile.OsDiskType = &osDiskType
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := OSSKU_Status(*source.OsSKU)
		profile.OsSKU = &osSKU
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := OSType_Status(*source.OsType)
		profile.OsType = &osType
	} else {
		profile.OsType = nil
	}

	// PodSubnetID
	profile.PodSubnetID = genruntime.ClonePointerToString(source.PodSubnetID)

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_Status
		err := powerState.AssignPropertiesFromPowerState_Status(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPowerState_Status() to populate field PowerState")
		}
		profile.PowerState = &powerState
	} else {
		profile.PowerState = nil
	}

	// ProvisioningState
	profile.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := ScaleSetEvictionPolicy_Status(*source.ScaleSetEvictionPolicy)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := ScaleSetPriority_Status(*source.ScaleSetPriority)
		profile.ScaleSetPriority = &scaleSetPriority
	} else {
		profile.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := AgentPoolType_Status(*source.Type)
		profile.Type = &typeVar
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_Status
		err := upgradeSetting.AssignPropertiesFromAgentPoolUpgradeSettings_Status(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAgentPoolUpgradeSettings_Status() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetID
	profile.VnetSubnetID = genruntime.ClonePointerToString(source.VnetSubnetID)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAgentPoolProfile_Status populates the provided destination ManagedClusterAgentPoolProfile_Status from our ManagedClusterAgentPoolProfile_Status
func (profile *ManagedClusterAgentPoolProfile_Status) AssignPropertiesToManagedClusterAgentPoolProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig v1alpha1api20210501storage.KubeletConfig_Status
		err := profile.KubeletConfig.AssignPropertiesToKubeletConfig_Status(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKubeletConfig_Status() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig v1alpha1api20210501storage.LinuxOSConfig_Status
		err := profile.LinuxOSConfig.AssignPropertiesToLinuxOSConfig_Status(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxOSConfig_Status() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NodeImageVersion
	destination.NodeImageVersion = genruntime.ClonePointerToString(profile.NodeImageVersion)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixID
	destination.NodePublicIPPrefixID = genruntime.ClonePointerToString(profile.NodePublicIPPrefixID)

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetID
	destination.PodSubnetID = genruntime.ClonePointerToString(profile.PodSubnetID)

	// PowerState
	if profile.PowerState != nil {
		var powerState v1alpha1api20210501storage.PowerState_Status
		err := profile.PowerState.AssignPropertiesToPowerState_Status(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPowerState_Status() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(profile.ProvisioningState)

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting v1alpha1api20210501storage.AgentPoolUpgradeSettings_Status
		err := profile.UpgradeSettings.AssignPropertiesToAgentPoolUpgradeSettings_Status(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAgentPoolUpgradeSettings_Status() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetID
	destination.VnetSubnetID = genruntime.ClonePointerToString(profile.VnetSubnetID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAutoUpgradeProfile_Spec struct {
	//UpgradeChannel: For more information see [setting the AKS cluster auto-upgrade
	//channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec `json:"upgradeChannel,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAutoUpgradeProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAutoUpgradeProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterAutoUpgradeProfile_SpecARM

	// Set property ‘UpgradeChannel’:
	if profile.UpgradeChannel != nil {
		upgradeChannel := *profile.UpgradeChannel
		result.UpgradeChannel = &upgradeChannel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAutoUpgradeProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAutoUpgradeProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAutoUpgradeProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘UpgradeChannel’:
	if typedInput.UpgradeChannel != nil {
		upgradeChannel := *typedInput.UpgradeChannel
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAutoUpgradeProfile_Spec populates our ManagedClusterAutoUpgradeProfile_Spec from the provided source ManagedClusterAutoUpgradeProfile_Spec
func (profile *ManagedClusterAutoUpgradeProfile_Spec) AssignPropertiesFromManagedClusterAutoUpgradeProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Spec) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec(*source.UpgradeChannel)
		profile.UpgradeChannel = &upgradeChannel
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAutoUpgradeProfile_Spec populates the provided destination ManagedClusterAutoUpgradeProfile_Spec from our ManagedClusterAutoUpgradeProfile_Spec
func (profile *ManagedClusterAutoUpgradeProfile_Spec) AssignPropertiesToManagedClusterAutoUpgradeProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterAutoUpgradeProfile_Status struct {
	//UpgradeChannel: For more information see [setting the AKS cluster auto-upgrade
	//channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status `json:"upgradeChannel,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAutoUpgradeProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAutoUpgradeProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAutoUpgradeProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAutoUpgradeProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘UpgradeChannel’:
	if typedInput.UpgradeChannel != nil {
		upgradeChannel := *typedInput.UpgradeChannel
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAutoUpgradeProfile_Status populates our ManagedClusterAutoUpgradeProfile_Status from the provided source ManagedClusterAutoUpgradeProfile_Status
func (profile *ManagedClusterAutoUpgradeProfile_Status) AssignPropertiesFromManagedClusterAutoUpgradeProfile_Status(source *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status(*source.UpgradeChannel)
		profile.UpgradeChannel = &upgradeChannel
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAutoUpgradeProfile_Status populates the provided destination ManagedClusterAutoUpgradeProfile_Status from our ManagedClusterAutoUpgradeProfile_Status
func (profile *ManagedClusterAutoUpgradeProfile_Status) AssignPropertiesToManagedClusterAutoUpgradeProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterHTTPProxyConfig_Spec struct {
	//HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	//HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	//NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	//TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterHTTPProxyConfig_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ManagedClusterHTTPProxyConfig_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	var result ManagedClusterHTTPProxyConfig_SpecARM

	// Set property ‘HttpProxy’:
	if config.HttpProxy != nil {
		httpProxy := *config.HttpProxy
		result.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if config.HttpsProxy != nil {
		httpsProxy := *config.HttpsProxy
		result.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range config.NoProxy {
		result.NoProxy = append(result.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if config.TrustedCa != nil {
		trustedCa := *config.TrustedCa
		result.TrustedCa = &trustedCa
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterHTTPProxyConfig_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterHTTPProxyConfig_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterHTTPProxyConfig_SpecARM, got %T", armInput)
	}

	// Set property ‘HttpProxy’:
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterHTTPProxyConfig_Spec populates our ManagedClusterHTTPProxyConfig_Spec from the provided source ManagedClusterHTTPProxyConfig_Spec
func (config *ManagedClusterHTTPProxyConfig_Spec) AssignPropertiesFromManagedClusterHTTPProxyConfig_Spec(source *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Spec) error {

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterHTTPProxyConfig_Spec populates the provided destination ManagedClusterHTTPProxyConfig_Spec from our ManagedClusterHTTPProxyConfig_Spec
func (config *ManagedClusterHTTPProxyConfig_Spec) AssignPropertiesToManagedClusterHTTPProxyConfig_Spec(destination *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterHTTPProxyConfig_Status struct {
	//HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	//HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	//NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	//TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterHTTPProxyConfig_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterHTTPProxyConfig_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterHTTPProxyConfig_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterHTTPProxyConfig_StatusARM, got %T", armInput)
	}

	// Set property ‘HttpProxy’:
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterHTTPProxyConfig_Status populates our ManagedClusterHTTPProxyConfig_Status from the provided source ManagedClusterHTTPProxyConfig_Status
func (config *ManagedClusterHTTPProxyConfig_Status) AssignPropertiesFromManagedClusterHTTPProxyConfig_Status(source *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status) error {

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterHTTPProxyConfig_Status populates the provided destination ManagedClusterHTTPProxyConfig_Status from our ManagedClusterHTTPProxyConfig_Status
func (config *ManagedClusterHTTPProxyConfig_Status) AssignPropertiesToManagedClusterHTTPProxyConfig_Status(destination *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIdentity_Spec struct {
	//Type: For more information see [use managed identities in
	//AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ManagedClusterIdentity_Type_Spec `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIdentity_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterIdentity_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	var result ManagedClusterIdentity_SpecARM

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentity_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentity_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentity_SpecARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentity_Spec populates our ManagedClusterIdentity_Spec from the provided source ManagedClusterIdentity_Spec
func (identity *ManagedClusterIdentity_Spec) AssignPropertiesFromManagedClusterIdentity_Spec(source *v1alpha1api20210501storage.ManagedClusterIdentity_Spec) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedClusterIdentity_Type_Spec(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentity_Spec populates the provided destination ManagedClusterIdentity_Spec from our ManagedClusterIdentity_Spec
func (identity *ManagedClusterIdentity_Spec) AssignPropertiesToManagedClusterIdentity_Spec(destination *v1alpha1api20210501storage.ManagedClusterIdentity_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIdentity_Status struct {
	//PrincipalId: The principal id of the system assigned identity which is used by
	//master components.
	PrincipalId *string `json:"principalId,omitempty"`

	//TenantId: The tenant id of the system assigned identity which is used by master
	//components.
	TenantId *string `json:"tenantId,omitempty"`

	//Type: For more information see [use managed identities in
	//AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ManagedClusterIdentity_Type_Status `json:"type,omitempty"`

	//UserAssignedIdentities: The keys must be ARM resource IDs in the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedClusterIdentity_UserAssignedIdentities_Status `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedClusterIdentity_UserAssignedIdentities_Status)
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedClusterIdentity_UserAssignedIdentities_Status
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentity_Status populates our ManagedClusterIdentity_Status from the provided source ManagedClusterIdentity_Status
func (identity *ManagedClusterIdentity_Status) AssignPropertiesFromManagedClusterIdentity_Status(source *v1alpha1api20210501storage.ManagedClusterIdentity_Status) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ManagedClusterIdentity_Type_Status(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedClusterIdentity_UserAssignedIdentities_Status, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ManagedClusterIdentity_UserAssignedIdentities_Status
			err := userAssignedIdentity.AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_Status(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_Status() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentity_Status populates the provided destination ManagedClusterIdentity_Status from our ManagedClusterIdentity_Status
func (identity *ManagedClusterIdentity_Status) AssignPropertiesToManagedClusterIdentity_Status(destination *v1alpha1api20210501storage.ManagedClusterIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1alpha1api20210501storage.ManagedClusterIdentity_UserAssignedIdentities_Status, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterIdentity_UserAssignedIdentities_Status
			err := userAssignedIdentityValue.AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_Status(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_Status() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProfile_Spec struct {
	//AllowNetworkPluginKubenet: Running in Kubenet is disabled by default due to the
	//security related nature of AAD Pod Identity and the risks of IP spoofing. See
	//[using Kubenet network plugin with AAD Pod
	//Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	//for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	//Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	//UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity_Spec `json:"userAssignedIdentities,omitempty"`

	//UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_Spec `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterPodIdentityProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentityProfile_SpecARM

	// Set property ‘AllowNetworkPluginKubenet’:
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		result.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range profile.UserAssignedIdentities {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentities = append(result.UserAssignedIdentities, itemARM.(ManagedClusterPodIdentity_SpecARM))
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range profile.UserAssignedIdentityExceptions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentityExceptions = append(result.UserAssignedIdentityExceptions, itemARM.(ManagedClusterPodIdentityException_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AllowNetworkPluginKubenet’:
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProfile_Spec populates our ManagedClusterPodIdentityProfile_Spec from the provided source ManagedClusterPodIdentityProfile_Spec
func (profile *ManagedClusterPodIdentityProfile_Spec) AssignPropertiesFromManagedClusterPodIdentityProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Spec) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity_Spec, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity_Spec
			err := userAssignedIdentity.AssignPropertiesFromManagedClusterPodIdentity_Spec(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentity_Spec() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_Spec, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException_Spec
			err := userAssignedIdentityException.AssignPropertiesFromManagedClusterPodIdentityException_Spec(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityException_Spec() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProfile_Spec populates the provided destination ManagedClusterPodIdentityProfile_Spec from our ManagedClusterPodIdentityProfile_Spec
func (profile *ManagedClusterPodIdentityProfile_Spec) AssignPropertiesToManagedClusterPodIdentityProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentity_Spec, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterPodIdentity_Spec
			err := userAssignedIdentityItem.AssignPropertiesToManagedClusterPodIdentity_Spec(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentity_Spec() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentityException_Spec, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException v1alpha1api20210501storage.ManagedClusterPodIdentityException_Spec
			err := userAssignedIdentityExceptionItem.AssignPropertiesToManagedClusterPodIdentityException_Spec(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityException_Spec() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProfile_Status struct {
	//AllowNetworkPluginKubenet: Running in Kubenet is disabled by default due to the
	//security related nature of AAD Pod Identity and the risks of IP spoofing. See
	//[using Kubenet network plugin with AAD Pod
	//Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	//for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	//Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	//UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity_Status `json:"userAssignedIdentities,omitempty"`

	//UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_Status `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AllowNetworkPluginKubenet’:
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProfile_Status populates our ManagedClusterPodIdentityProfile_Status from the provided source ManagedClusterPodIdentityProfile_Status
func (profile *ManagedClusterPodIdentityProfile_Status) AssignPropertiesFromManagedClusterPodIdentityProfile_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity_Status, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity_Status
			err := userAssignedIdentity.AssignPropertiesFromManagedClusterPodIdentity_Status(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentity_Status() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_Status, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException_Status
			err := userAssignedIdentityException.AssignPropertiesFromManagedClusterPodIdentityException_Status(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityException_Status() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProfile_Status populates the provided destination ManagedClusterPodIdentityProfile_Status from our ManagedClusterPodIdentityProfile_Status
func (profile *ManagedClusterPodIdentityProfile_Status) AssignPropertiesToManagedClusterPodIdentityProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentity_Status, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterPodIdentity_Status
			err := userAssignedIdentityItem.AssignPropertiesToManagedClusterPodIdentity_Status(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentity_Status() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status
			err := userAssignedIdentityExceptionItem.AssignPropertiesToManagedClusterPodIdentityException_Status(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityException_Status() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterProperties_AutoScalerProfile_Spec struct {
	//BalanceSimilarNodeGroups: Valid values are 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	//Expander: If not specified, the default is 'random'. See
	//[expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
	//for more information.
	Expander *ManagedClusterProperties_AutoScalerProfile_Expander_Spec `json:"expander,omitempty"`

	//MaxEmptyBulkDelete: The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	//MaxGracefulTerminationSec: The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	//MaxNodeProvisionTime: The default is '15m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	//MaxTotalUnreadyPercentage: The default is 45. The maximum is 100 and the minimum
	//is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	//NewPodScaleUpDelay: For scenarios like burst/batch scale where you don't want CA
	//to act before the kubernetes scheduler could schedule all the pods, you can tell
	//CA to ignore unscheduled pods before they're a certain age. The default is '0s'.
	//Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes,
	//'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	//OkTotalUnreadyCount: This must be an integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	//ScaleDownDelayAfterAdd: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	//ScaleDownDelayAfterDelete: The default is the scan-interval. Values must be an
	//integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	//ScaleDownDelayAfterFailure: The default is '3m'. Values must be an integer
	//followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	//ScaleDownUnneededTime: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	//ScaleDownUnreadyTime: The default is '20m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	//ScaleDownUtilizationThreshold: The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	//ScanInterval: The default is '10'. Values must be an integer number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	//SkipNodesWithLocalStorage: The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	//SkipNodesWithSystemPods: The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterProperties_AutoScalerProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterProperties_AutoScalerProfile_SpecARM

	// Set property ‘BalanceSimilarNodeGroups’:
	if profile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *profile.BalanceSimilarNodeGroups
		result.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if profile.Expander != nil {
		expander := *profile.Expander
		result.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if profile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *profile.MaxEmptyBulkDelete
		result.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if profile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *profile.MaxGracefulTerminationSec
		result.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if profile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *profile.MaxNodeProvisionTime
		result.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if profile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *profile.MaxTotalUnreadyPercentage
		result.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if profile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *profile.NewPodScaleUpDelay
		result.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if profile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *profile.OkTotalUnreadyCount
		result.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if profile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *profile.ScaleDownDelayAfterAdd
		result.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if profile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *profile.ScaleDownDelayAfterDelete
		result.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if profile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *profile.ScaleDownDelayAfterFailure
		result.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if profile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *profile.ScaleDownUnneededTime
		result.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if profile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *profile.ScaleDownUnreadyTime
		result.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if profile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *profile.ScaleDownUtilizationThreshold
		result.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if profile.ScanInterval != nil {
		scanInterval := *profile.ScanInterval
		result.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if profile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *profile.SkipNodesWithLocalStorage
		result.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if profile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *profile.SkipNodesWithSystemPods
		result.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterProperties_AutoScalerProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterProperties_AutoScalerProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterProperties_AutoScalerProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterProperties_AutoScalerProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘BalanceSimilarNodeGroups’:
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if typedInput.Expander != nil {
		expander := *typedInput.Expander
		profile.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Spec populates our ManagedClusterProperties_AutoScalerProfile_Spec from the provided source ManagedClusterProperties_AutoScalerProfile_Spec
func (profile *ManagedClusterProperties_AutoScalerProfile_Spec) AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Spec) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	if source.Expander != nil {
		expander := ManagedClusterProperties_AutoScalerProfile_Expander_Spec(*source.Expander)
		profile.Expander = &expander
	} else {
		profile.Expander = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Spec populates the provided destination ManagedClusterProperties_AutoScalerProfile_Spec from our ManagedClusterProperties_AutoScalerProfile_Spec
func (profile *ManagedClusterProperties_AutoScalerProfile_Spec) AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterProperties_AutoScalerProfile_Status struct {
	//BalanceSimilarNodeGroups: Valid values are 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	//Expander: If not specified, the default is 'random'. See
	//[expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
	//for more information.
	Expander *ManagedClusterProperties_AutoScalerProfile_Expander_Status `json:"expander,omitempty"`

	//MaxEmptyBulkDelete: The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	//MaxGracefulTerminationSec: The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	//MaxNodeProvisionTime: The default is '15m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	//MaxTotalUnreadyPercentage: The default is 45. The maximum is 100 and the minimum
	//is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	//NewPodScaleUpDelay: For scenarios like burst/batch scale where you don't want CA
	//to act before the kubernetes scheduler could schedule all the pods, you can tell
	//CA to ignore unscheduled pods before they're a certain age. The default is '0s'.
	//Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes,
	//'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	//OkTotalUnreadyCount: This must be an integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	//ScaleDownDelayAfterAdd: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	//ScaleDownDelayAfterDelete: The default is the scan-interval. Values must be an
	//integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	//ScaleDownDelayAfterFailure: The default is '3m'. Values must be an integer
	//followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	//ScaleDownUnneededTime: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	//ScaleDownUnreadyTime: The default is '20m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	//ScaleDownUtilizationThreshold: The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	//ScanInterval: The default is '10'. Values must be an integer number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	//SkipNodesWithLocalStorage: The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	//SkipNodesWithSystemPods: The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterProperties_AutoScalerProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterProperties_AutoScalerProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterProperties_AutoScalerProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterProperties_AutoScalerProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterProperties_AutoScalerProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterProperties_AutoScalerProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘BalanceSimilarNodeGroups’:
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if typedInput.Expander != nil {
		expander := *typedInput.Expander
		profile.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Status populates our ManagedClusterProperties_AutoScalerProfile_Status from the provided source ManagedClusterProperties_AutoScalerProfile_Status
func (profile *ManagedClusterProperties_AutoScalerProfile_Status) AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_Status(source *v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Status) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	if source.Expander != nil {
		expander := ManagedClusterProperties_AutoScalerProfile_Expander_Status(*source.Expander)
		profile.Expander = &expander
	} else {
		profile.Expander = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Status populates the provided destination ManagedClusterProperties_AutoScalerProfile_Status from our ManagedClusterProperties_AutoScalerProfile_Status
func (profile *ManagedClusterProperties_AutoScalerProfile_Status) AssignPropertiesToManagedClusterProperties_AutoScalerProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterProperties_AutoScalerProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSKU_Spec struct {
	//Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKU_Name_Spec `json:"name,omitempty"`

	//Tier: If not specified, the default is 'Free'. See [uptime
	//SLA](https://docs.microsoft.com/azure/aks/uptime-sla) for more details.
	Tier *ManagedClusterSKU_Tier_Spec `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSKU_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (clusterSKU *ManagedClusterSKU_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if clusterSKU == nil {
		return nil, nil
	}
	var result ManagedClusterSKU_SpecARM

	// Set property ‘Name’:
	if clusterSKU.Name != nil {
		name := *clusterSKU.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if clusterSKU.Tier != nil {
		tier := *clusterSKU.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterSKU_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterSKU_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterSKU_SpecARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		clusterSKU.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterSKU_Spec populates our ManagedClusterSKU_Spec from the provided source ManagedClusterSKU_Spec
func (clusterSKU *ManagedClusterSKU_Spec) AssignPropertiesFromManagedClusterSKU_Spec(source *v1alpha1api20210501storage.ManagedClusterSKU_Spec) error {

	// Name
	if source.Name != nil {
		name := ManagedClusterSKU_Name_Spec(*source.Name)
		clusterSKU.Name = &name
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := ManagedClusterSKU_Tier_Spec(*source.Tier)
		clusterSKU.Tier = &tier
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterSKU_Spec populates the provided destination ManagedClusterSKU_Spec from our ManagedClusterSKU_Spec
func (clusterSKU *ManagedClusterSKU_Spec) AssignPropertiesToManagedClusterSKU_Spec(destination *v1alpha1api20210501storage.ManagedClusterSKU_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSKU_Status struct {
	//Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKU_Name_Status `json:"name,omitempty"`

	//Tier: If not specified, the default is 'Free'. See [uptime
	//SLA](https://docs.microsoft.com/azure/aks/uptime-sla) for more details.
	Tier *ManagedClusterSKU_Tier_Status `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSKU_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterSKU_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterSKU_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterSKU_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		clusterSKU.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterSKU_Status populates our ManagedClusterSKU_Status from the provided source ManagedClusterSKU_Status
func (clusterSKU *ManagedClusterSKU_Status) AssignPropertiesFromManagedClusterSKU_Status(source *v1alpha1api20210501storage.ManagedClusterSKU_Status) error {

	// Name
	if source.Name != nil {
		name := ManagedClusterSKU_Name_Status(*source.Name)
		clusterSKU.Name = &name
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := ManagedClusterSKU_Tier_Status(*source.Tier)
		clusterSKU.Tier = &tier
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterSKU_Status populates the provided destination ManagedClusterSKU_Status from our ManagedClusterSKU_Status
func (clusterSKU *ManagedClusterSKU_Status) AssignPropertiesToManagedClusterSKU_Status(destination *v1alpha1api20210501storage.ManagedClusterSKU_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterServicePrincipalProfile_Spec struct {
	// +kubebuilder:validation:Required
	//ClientId: The ID for the service principal.
	ClientId string `json:"clientId"`

	//Secret: The secret password associated with the service principal in plain text.
	Secret *string `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterServicePrincipalProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterServicePrincipalProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterServicePrincipalProfile_SpecARM

	// Set property ‘ClientId’:
	result.ClientId = profile.ClientId

	// Set property ‘Secret’:
	if profile.Secret != nil {
		secret := *profile.Secret
		result.Secret = &secret
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterServicePrincipalProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterServicePrincipalProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterServicePrincipalProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	profile.ClientId = typedInput.ClientId

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		secret := *typedInput.Secret
		profile.Secret = &secret
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterServicePrincipalProfile_Spec populates our ManagedClusterServicePrincipalProfile_Spec from the provided source ManagedClusterServicePrincipalProfile_Spec
func (profile *ManagedClusterServicePrincipalProfile_Spec) AssignPropertiesFromManagedClusterServicePrincipalProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Spec) error {

	// ClientId
	profile.ClientId = genruntime.GetOptionalStringValue(source.ClientId)

	// Secret
	profile.Secret = genruntime.ClonePointerToString(source.Secret)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterServicePrincipalProfile_Spec populates the provided destination ManagedClusterServicePrincipalProfile_Spec from our ManagedClusterServicePrincipalProfile_Spec
func (profile *ManagedClusterServicePrincipalProfile_Spec) AssignPropertiesToManagedClusterServicePrincipalProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	clientId := profile.ClientId
	destination.ClientId = &clientId

	// Secret
	destination.Secret = genruntime.ClonePointerToString(profile.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterServicePrincipalProfile_Status struct {
	// +kubebuilder:validation:Required
	//ClientId: The ID for the service principal.
	ClientId string `json:"clientId"`

	//Secret: The secret password associated with the service principal in plain text.
	Secret *string `json:"secret,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterServicePrincipalProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterServicePrincipalProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterServicePrincipalProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterServicePrincipalProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	profile.ClientId = typedInput.ClientId

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		secret := *typedInput.Secret
		profile.Secret = &secret
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterServicePrincipalProfile_Status populates our ManagedClusterServicePrincipalProfile_Status from the provided source ManagedClusterServicePrincipalProfile_Status
func (profile *ManagedClusterServicePrincipalProfile_Status) AssignPropertiesFromManagedClusterServicePrincipalProfile_Status(source *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status) error {

	// ClientId
	profile.ClientId = genruntime.GetOptionalStringValue(source.ClientId)

	// Secret
	profile.Secret = genruntime.ClonePointerToString(source.Secret)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterServicePrincipalProfile_Status populates the provided destination ManagedClusterServicePrincipalProfile_Status from our ManagedClusterServicePrincipalProfile_Status
func (profile *ManagedClusterServicePrincipalProfile_Status) AssignPropertiesToManagedClusterServicePrincipalProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	clientId := profile.ClientId
	destination.ClientId = &clientId

	// Secret
	destination.Secret = genruntime.ClonePointerToString(profile.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterWindowsProfile_Spec struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length: 8 characters
	//Max-length: 123 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	AdminPassword *string `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	//AdminUsername: Specifies the name of the administrator account.
	//Restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length: 1 character
	//Max-length: 20 characters
	AdminUsername string `json:"adminUsername"`

	//EnableCSIProxy: For more details on CSI proxy, see the [CSI proxy GitHub
	//repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	//LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	//Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more
	//details.
	LicenseType *ManagedClusterWindowsProfile_LicenseType_Spec `json:"licenseType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWindowsProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterWindowsProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterWindowsProfile_SpecARM

	// Set property ‘AdminPassword’:
	if profile.AdminPassword != nil {
		adminPassword := *profile.AdminPassword
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	result.AdminUsername = profile.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		result.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if profile.LicenseType != nil {
		licenseType := *profile.LicenseType
		result.LicenseType = &licenseType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterWindowsProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterWindowsProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterWindowsProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		profile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	profile.AdminUsername = typedInput.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterWindowsProfile_Spec populates our ManagedClusterWindowsProfile_Spec from the provided source ManagedClusterWindowsProfile_Spec
func (profile *ManagedClusterWindowsProfile_Spec) AssignPropertiesFromManagedClusterWindowsProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Spec) error {

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.GetOptionalStringValue(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedClusterWindowsProfile_LicenseType_Spec(*source.LicenseType)
		profile.LicenseType = &licenseType
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterWindowsProfile_Spec populates the provided destination ManagedClusterWindowsProfile_Spec from our ManagedClusterWindowsProfile_Spec
func (profile *ManagedClusterWindowsProfile_Spec) AssignPropertiesToManagedClusterWindowsProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	adminUsername := profile.AdminUsername
	destination.AdminUsername = &adminUsername

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterWindowsProfile_Status struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length: 8 characters
	//Max-length: 123 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	AdminPassword *string `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	//AdminUsername: Specifies the name of the administrator account.
	//Restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length: 1 character
	//Max-length: 20 characters
	AdminUsername string `json:"adminUsername"`

	//EnableCSIProxy: For more details on CSI proxy, see the [CSI proxy GitHub
	//repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	//LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	//Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more
	//details.
	LicenseType *ManagedClusterWindowsProfile_LicenseType_Status `json:"licenseType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWindowsProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterWindowsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterWindowsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterWindowsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		profile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	profile.AdminUsername = typedInput.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterWindowsProfile_Status populates our ManagedClusterWindowsProfile_Status from the provided source ManagedClusterWindowsProfile_Status
func (profile *ManagedClusterWindowsProfile_Status) AssignPropertiesFromManagedClusterWindowsProfile_Status(source *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status) error {

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.GetOptionalStringValue(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedClusterWindowsProfile_LicenseType_Status(*source.LicenseType)
		profile.LicenseType = &licenseType
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterWindowsProfile_Status populates the provided destination ManagedClusterWindowsProfile_Status from our ManagedClusterWindowsProfile_Status
func (profile *ManagedClusterWindowsProfile_Status) AssignPropertiesToManagedClusterWindowsProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	adminUsername := profile.AdminUsername
	destination.AdminUsername = &adminUsername

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PowerState_Status struct {
	//Code: Tells whether the cluster is Running or Stopped
	Code *PowerState_Code_Status `json:"code,omitempty"`
}

var _ genruntime.FromARMConverter = &PowerState_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *PowerState_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PowerState_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *PowerState_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PowerState_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PowerState_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		state.Code = &code
	}

	// No error
	return nil
}

// AssignPropertiesFromPowerState_Status populates our PowerState_Status from the provided source PowerState_Status
func (state *PowerState_Status) AssignPropertiesFromPowerState_Status(source *v1alpha1api20210501storage.PowerState_Status) error {

	// Code
	if source.Code != nil {
		code := PowerState_Code_Status(*source.Code)
		state.Code = &code
	} else {
		state.Code = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPowerState_Status populates the provided destination PowerState_Status from our PowerState_Status
func (state *PowerState_Status) AssignPropertiesToPowerState_Status(destination *v1alpha1api20210501storage.PowerState_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if state.Code != nil {
		code := string(*state.Code)
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkResource_Spec struct {
	//GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	//Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	//Reference: The ID of the private link resource.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	//Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkResource_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *PrivateLinkResource_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	var result PrivateLinkResource_SpecARM

	// Set property ‘GroupId’:
	if resource.GroupId != nil {
		groupId := *resource.GroupId
		result.GroupId = &groupId
	}

	// Set property ‘Id’:
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if resource.Name != nil {
		name := *resource.Name
		result.Name = &name
	}

	// Set property ‘RequiredMembers’:
	for _, item := range resource.RequiredMembers {
		result.RequiredMembers = append(result.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if resource.Type != nil {
		typeVar := *resource.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkResource_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkResource_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkResource_SpecARM, got %T", armInput)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// no assignment for property ‘Reference’

	// Set property ‘RequiredMembers’:
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkResource_Spec populates our PrivateLinkResource_Spec from the provided source PrivateLinkResource_Spec
func (resource *PrivateLinkResource_Spec) AssignPropertiesFromPrivateLinkResource_Spec(source *v1alpha1api20210501storage.PrivateLinkResource_Spec) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkResource_Spec populates the provided destination PrivateLinkResource_Spec from our PrivateLinkResource_Spec
func (resource *PrivateLinkResource_Spec) AssignPropertiesToPrivateLinkResource_Spec(destination *v1alpha1api20210501storage.PrivateLinkResource_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkResource_Status struct {
	//GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	//Id: The ID of the private link resource.
	Id *string `json:"id,omitempty"`

	//Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	//PrivateLinkServiceID: The private link service ID of the resource, this field is
	//exposed only to NRP internally.
	PrivateLinkServiceID *string `json:"privateLinkServiceID,omitempty"`

	//RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	//Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkResource_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkResource_StatusARM, got %T", armInput)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property ‘PrivateLinkServiceID’:
	if typedInput.PrivateLinkServiceID != nil {
		privateLinkServiceID := *typedInput.PrivateLinkServiceID
		resource.PrivateLinkServiceID = &privateLinkServiceID
	}

	// Set property ‘RequiredMembers’:
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkResource_Status populates our PrivateLinkResource_Status from the provided source PrivateLinkResource_Status
func (resource *PrivateLinkResource_Status) AssignPropertiesFromPrivateLinkResource_Status(source *v1alpha1api20210501storage.PrivateLinkResource_Status) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkServiceID
	resource.PrivateLinkServiceID = genruntime.ClonePointerToString(source.PrivateLinkServiceID)

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkResource_Status populates the provided destination PrivateLinkResource_Status from our PrivateLinkResource_Status
func (resource *PrivateLinkResource_Status) AssignPropertiesToPrivateLinkResource_Status(destination *v1alpha1api20210501storage.PrivateLinkResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkServiceID
	destination.PrivateLinkServiceID = genruntime.ClonePointerToString(resource.PrivateLinkServiceID)

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"basic","standard"}
type ContainerServiceNetworkProfile_LoadBalancerSku_Spec string

const (
	ContainerServiceNetworkProfile_LoadBalancerSku_SpecBasic    = ContainerServiceNetworkProfile_LoadBalancerSku_Spec("basic")
	ContainerServiceNetworkProfile_LoadBalancerSku_SpecStandard = ContainerServiceNetworkProfile_LoadBalancerSku_Spec("standard")
)

type ContainerServiceNetworkProfile_LoadBalancerSku_Status string

const (
	ContainerServiceNetworkProfile_LoadBalancerSku_StatusBasic    = ContainerServiceNetworkProfile_LoadBalancerSku_Status("basic")
	ContainerServiceNetworkProfile_LoadBalancerSku_StatusStandard = ContainerServiceNetworkProfile_LoadBalancerSku_Status("standard")
)

// +kubebuilder:validation:Enum={"bridge","transparent"}
type ContainerServiceNetworkProfile_NetworkMode_Spec string

const (
	ContainerServiceNetworkProfile_NetworkMode_SpecBridge      = ContainerServiceNetworkProfile_NetworkMode_Spec("bridge")
	ContainerServiceNetworkProfile_NetworkMode_SpecTransparent = ContainerServiceNetworkProfile_NetworkMode_Spec("transparent")
)

type ContainerServiceNetworkProfile_NetworkMode_Status string

const (
	ContainerServiceNetworkProfile_NetworkMode_StatusBridge      = ContainerServiceNetworkProfile_NetworkMode_Status("bridge")
	ContainerServiceNetworkProfile_NetworkMode_StatusTransparent = ContainerServiceNetworkProfile_NetworkMode_Status("transparent")
)

// +kubebuilder:validation:Enum={"azure","kubenet"}
type ContainerServiceNetworkProfile_NetworkPlugin_Spec string

const (
	ContainerServiceNetworkProfile_NetworkPlugin_SpecAzure   = ContainerServiceNetworkProfile_NetworkPlugin_Spec("azure")
	ContainerServiceNetworkProfile_NetworkPlugin_SpecKubenet = ContainerServiceNetworkProfile_NetworkPlugin_Spec("kubenet")
)

type ContainerServiceNetworkProfile_NetworkPlugin_Status string

const (
	ContainerServiceNetworkProfile_NetworkPlugin_StatusAzure   = ContainerServiceNetworkProfile_NetworkPlugin_Status("azure")
	ContainerServiceNetworkProfile_NetworkPlugin_StatusKubenet = ContainerServiceNetworkProfile_NetworkPlugin_Status("kubenet")
)

// +kubebuilder:validation:Enum={"azure","calico"}
type ContainerServiceNetworkProfile_NetworkPolicy_Spec string

const (
	ContainerServiceNetworkProfile_NetworkPolicy_SpecAzure  = ContainerServiceNetworkProfile_NetworkPolicy_Spec("azure")
	ContainerServiceNetworkProfile_NetworkPolicy_SpecCalico = ContainerServiceNetworkProfile_NetworkPolicy_Spec("calico")
)

type ContainerServiceNetworkProfile_NetworkPolicy_Status string

const (
	ContainerServiceNetworkProfile_NetworkPolicy_StatusAzure  = ContainerServiceNetworkProfile_NetworkPolicy_Status("azure")
	ContainerServiceNetworkProfile_NetworkPolicy_StatusCalico = ContainerServiceNetworkProfile_NetworkPolicy_Status("calico")
)

// +kubebuilder:validation:Enum={"loadBalancer","userDefinedRouting"}
type ContainerServiceNetworkProfile_OutboundType_Spec string

const (
	ContainerServiceNetworkProfile_OutboundType_SpecLoadBalancer       = ContainerServiceNetworkProfile_OutboundType_Spec("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_SpecUserDefinedRouting = ContainerServiceNetworkProfile_OutboundType_Spec("userDefinedRouting")
)

type ContainerServiceNetworkProfile_OutboundType_Status string

const (
	ContainerServiceNetworkProfile_OutboundType_StatusLoadBalancer       = ContainerServiceNetworkProfile_OutboundType_Status("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_StatusUserDefinedRouting = ContainerServiceNetworkProfile_OutboundType_Status("userDefinedRouting")
)

type ContainerServiceSshConfiguration_Spec struct {
	// +kubebuilder:validation:Required
	//PublicKeys: The list of SSH public keys used to authenticate with Linux-based
	//VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey_Spec `json:"publicKeys"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ContainerServiceSshConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	var result ContainerServiceSshConfiguration_SpecARM

	// Set property ‘PublicKeys’:
	for _, item := range configuration.PublicKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, itemARM.(ContainerServiceSshPublicKey_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshConfiguration_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshConfiguration_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshConfiguration_SpecARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshConfiguration_Spec populates our ContainerServiceSshConfiguration_Spec from the provided source ContainerServiceSshConfiguration_Spec
func (configuration *ContainerServiceSshConfiguration_Spec) AssignPropertiesFromContainerServiceSshConfiguration_Spec(source *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Spec) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey_Spec, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey_Spec
			err := publicKey.AssignPropertiesFromContainerServiceSshPublicKey_Spec(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshPublicKey_Spec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshConfiguration_Spec populates the provided destination ContainerServiceSshConfiguration_Spec from our ContainerServiceSshConfiguration_Spec
func (configuration *ContainerServiceSshConfiguration_Spec) AssignPropertiesToContainerServiceSshConfiguration_Spec(destination *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v1alpha1api20210501storage.ContainerServiceSshPublicKey_Spec, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v1alpha1api20210501storage.ContainerServiceSshPublicKey_Spec
			err := publicKeyItem.AssignPropertiesToContainerServiceSshPublicKey_Spec(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshPublicKey_Spec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceSshConfiguration_Status struct {
	// +kubebuilder:validation:Required
	//PublicKeys: The list of SSH public keys used to authenticate with Linux-based
	//VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey_Status `json:"publicKeys"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshConfiguration_Status populates our ContainerServiceSshConfiguration_Status from the provided source ContainerServiceSshConfiguration_Status
func (configuration *ContainerServiceSshConfiguration_Status) AssignPropertiesFromContainerServiceSshConfiguration_Status(source *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey_Status, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey_Status
			err := publicKey.AssignPropertiesFromContainerServiceSshPublicKey_Status(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshPublicKey_Status() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshConfiguration_Status populates the provided destination ContainerServiceSshConfiguration_Status from our ContainerServiceSshConfiguration_Status
func (configuration *ContainerServiceSshConfiguration_Status) AssignPropertiesToContainerServiceSshConfiguration_Status(destination *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status
			err := publicKeyItem.AssignPropertiesToContainerServiceSshPublicKey_Status(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshPublicKey_Status() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"node-image","none","patch","rapid","stable"}
type ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec string

const (
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecNodeImage = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec("node-image")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecNone      = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec("none")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecPatch     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec("patch")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecRapid     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec("rapid")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecStable    = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Spec("stable")
)

type ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status string

const (
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_StatusNodeImage = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status("node-image")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_StatusNone      = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status("none")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_StatusPatch     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status("patch")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_StatusRapid     = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status("rapid")
	ManagedClusterAutoUpgradeProfile_UpgradeChannel_StatusStable    = ManagedClusterAutoUpgradeProfile_UpgradeChannel_Status("stable")
)

type ManagedClusterIdentity_UserAssignedIdentities_Status struct {
	//ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_UserAssignedIdentities_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ManagedClusterIdentity_UserAssignedIdentities_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentity_UserAssignedIdentities_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ManagedClusterIdentity_UserAssignedIdentities_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentity_UserAssignedIdentities_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentity_UserAssignedIdentities_StatusARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_Status populates our ManagedClusterIdentity_UserAssignedIdentities_Status from the provided source ManagedClusterIdentity_UserAssignedIdentities_Status
func (identities *ManagedClusterIdentity_UserAssignedIdentities_Status) AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_Status(source *v1alpha1api20210501storage.ManagedClusterIdentity_UserAssignedIdentities_Status) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_Status populates the provided destination ManagedClusterIdentity_UserAssignedIdentities_Status from our ManagedClusterIdentity_UserAssignedIdentities_Status
func (identities *ManagedClusterIdentity_UserAssignedIdentities_Status) AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_Status(destination *v1alpha1api20210501storage.ManagedClusterIdentity_UserAssignedIdentities_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_Spec struct {
	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	//AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM.
	//Allowed values are in the range of 0 to 64000 (inclusive). The default value is
	//0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//EffectiveOutboundIPs: The effective outbound IP resources of the cluster load
	//balancer.
	EffectiveOutboundIPs []ResourceReference_Spec `json:"effectiveOutboundIPs,omitempty"`

	// +kubebuilder:validation:Maximum=120
	// +kubebuilder:validation:Minimum=4
	//IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed
	//values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec `json:"managedOutboundIPs,omitempty"`

	//OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load
	//balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec `json:"outboundIPPrefixes,omitempty"`

	//OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec `json:"outboundIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterLoadBalancerProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfile_SpecARM

	// Set property ‘AllocatedOutboundPorts’:
	if profile.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *profile.AllocatedOutboundPorts
		result.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range profile.EffectiveOutboundIPs {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EffectiveOutboundIPs = append(result.EffectiveOutboundIPs, itemARM.(ResourceReference_SpecARM))
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *profile.IdleTimeoutInMinutes
		result.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if profile.ManagedOutboundIPs != nil {
		managedOutboundIPsARM, err := (*profile.ManagedOutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedOutboundIPs := managedOutboundIPsARM.(ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM)
		result.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if profile.OutboundIPPrefixes != nil {
		outboundIPPrefixesARM, err := (*profile.OutboundIPPrefixes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPPrefixes := outboundIPPrefixesARM.(ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM)
		result.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if profile.OutboundIPs != nil {
		outboundIPsARM, err := (*profile.OutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPs := outboundIPsARM.(ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM)
		result.OutboundIPs = &outboundIPs
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfile_OutboundIPs_Spec
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_Spec populates our ManagedClusterLoadBalancerProfile_Spec from the provided source ManagedClusterLoadBalancerProfile_Spec
func (profile *ManagedClusterLoadBalancerProfile_Spec) AssignPropertiesFromManagedClusterLoadBalancerProfile_Spec(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Spec) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		profile.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_Spec, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference_Spec
			err := effectiveOutboundIP.AssignPropertiesFromResourceReference_Spec(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Spec() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		profile.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs_Spec
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Spec(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Spec() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_Spec populates the provided destination ManagedClusterLoadBalancerProfile_Spec from our ManagedClusterLoadBalancerProfile_Spec
func (profile *ManagedClusterLoadBalancerProfile_Spec) AssignPropertiesToManagedClusterLoadBalancerProfile_Spec(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if profile.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *profile.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]v1alpha1api20210501storage.ResourceReference_Spec, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP v1alpha1api20210501storage.ResourceReference_Spec
			err := effectiveOutboundIPItem.AssignPropertiesToResourceReference_Spec(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Spec() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *profile.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec
		err := profile.ManagedOutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec
		err := profile.OutboundIPPrefixes.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Spec
		err := profile.OutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Spec(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Spec() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_Status struct {
	//AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM.
	//Allowed values are in the range of 0 to 64000 (inclusive). The default value is
	//0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//EffectiveOutboundIPs: The effective outbound IP resources of the cluster load
	//balancer.
	EffectiveOutboundIPs []ResourceReference_Status `json:"effectiveOutboundIPs,omitempty"`

	//IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed
	//values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status `json:"managedOutboundIPs,omitempty"`

	//OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load
	//balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status `json:"outboundIPPrefixes,omitempty"`

	//OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Status `json:"outboundIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfile_OutboundIPs_Status
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_Status populates our ManagedClusterLoadBalancerProfile_Status from the provided source ManagedClusterLoadBalancerProfile_Status
func (profile *ManagedClusterLoadBalancerProfile_Status) AssignPropertiesFromManagedClusterLoadBalancerProfile_Status(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status) error {

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_Status, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference_Status
			err := effectiveOutboundIP.AssignPropertiesFromResourceReference_Status(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Status() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs_Status
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Status(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Status() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_Status populates the provided destination ManagedClusterLoadBalancerProfile_Status from our ManagedClusterLoadBalancerProfile_Status
func (profile *ManagedClusterLoadBalancerProfile_Status) AssignPropertiesToManagedClusterLoadBalancerProfile_Status(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP v1alpha1api20210501storage.ResourceReference_Status
			err := effectiveOutboundIPItem.AssignPropertiesToResourceReference_Status(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Status() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status
		err := profile.ManagedOutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status
		err := profile.OutboundIPPrefixes.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Status
		err := profile.OutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Status(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Status() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityException_Spec struct {
	// +kubebuilder:validation:Required
	//Name: The name of the pod identity exception.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity exception.
	Namespace string `json:"namespace"`

	// +kubebuilder:validation:Required
	//PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityException_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exception *ManagedClusterPodIdentityException_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exception == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentityException_SpecARM

	// Set property ‘Name’:
	result.Name = exception.Name

	// Set property ‘Namespace’:
	result.Namespace = exception.Namespace

	// Set property ‘PodLabels’:
	if exception.PodLabels != nil {
		result.PodLabels = make(map[string]string)
		for key, value := range exception.PodLabels {
			result.PodLabels[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityException_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityException_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityException_SpecARM, got %T", armInput)
	}

	// Set property ‘Name’:
	exception.Name = typedInput.Name

	// Set property ‘Namespace’:
	exception.Namespace = typedInput.Namespace

	// Set property ‘PodLabels’:
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string)
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityException_Spec populates our ManagedClusterPodIdentityException_Spec from the provided source ManagedClusterPodIdentityException_Spec
func (exception *ManagedClusterPodIdentityException_Spec) AssignPropertiesFromManagedClusterPodIdentityException_Spec(source *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Spec) error {

	// Name
	exception.Name = genruntime.GetOptionalStringValue(source.Name)

	// Namespace
	exception.Namespace = genruntime.GetOptionalStringValue(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityException_Spec populates the provided destination ManagedClusterPodIdentityException_Spec from our ManagedClusterPodIdentityException_Spec
func (exception *ManagedClusterPodIdentityException_Spec) AssignPropertiesToManagedClusterPodIdentityException_Spec(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := exception.Name
	destination.Name = &name

	// Namespace
	namespace := exception.Namespace
	destination.Namespace = &namespace

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityException_Status struct {
	// +kubebuilder:validation:Required
	//Name: The name of the pod identity exception.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity exception.
	Namespace string `json:"namespace"`

	// +kubebuilder:validation:Required
	//PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityException_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityException_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityException_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityException_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	exception.Name = typedInput.Name

	// Set property ‘Namespace’:
	exception.Namespace = typedInput.Namespace

	// Set property ‘PodLabels’:
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string)
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityException_Status populates our ManagedClusterPodIdentityException_Status from the provided source ManagedClusterPodIdentityException_Status
func (exception *ManagedClusterPodIdentityException_Status) AssignPropertiesFromManagedClusterPodIdentityException_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status) error {

	// Name
	exception.Name = genruntime.GetOptionalStringValue(source.Name)

	// Namespace
	exception.Namespace = genruntime.GetOptionalStringValue(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityException_Status populates the provided destination ManagedClusterPodIdentityException_Status from our ManagedClusterPodIdentityException_Status
func (exception *ManagedClusterPodIdentityException_Status) AssignPropertiesToManagedClusterPodIdentityException_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := exception.Name
	destination.Name = &name

	// Namespace
	namespace := exception.Namespace
	destination.Namespace = &namespace

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_Spec struct {
	//BindingSelector: The binding selector to use for the AzureIdentityBinding
	//resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	//Identity: The user assigned identity details.
	Identity UserAssignedIdentity_Spec `json:"identity"`

	// +kubebuilder:validation:Required
	//Name: The name of the pod identity.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity.
	Namespace string `json:"namespace"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentity_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterPodIdentity_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentity_SpecARM

	// Set property ‘BindingSelector’:
	if identity.BindingSelector != nil {
		bindingSelector := *identity.BindingSelector
		result.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	identityARM, err := identity.Identity.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Identity = identityARM.(UserAssignedIdentity_SpecARM)

	// Set property ‘Name’:
	result.Name = identity.Name

	// Set property ‘Namespace’:
	result.Namespace = identity.Namespace
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentity_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentity_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentity_SpecARM, got %T", armInput)
	}

	// Set property ‘BindingSelector’:
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	var identity1 UserAssignedIdentity_Spec
	err := identity1.PopulateFromARM(owner, typedInput.Identity)
	if err != nil {
		return err
	}
	identity.Identity = identity1

	// Set property ‘Name’:
	identity.Name = typedInput.Name

	// Set property ‘Namespace’:
	identity.Namespace = typedInput.Namespace

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentity_Spec populates our ManagedClusterPodIdentity_Spec from the provided source ManagedClusterPodIdentity_Spec
func (identity *ManagedClusterPodIdentity_Spec) AssignPropertiesFromManagedClusterPodIdentity_Spec(source *v1alpha1api20210501storage.ManagedClusterPodIdentity_Spec) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity_Spec
		err := identityLocal.AssignPropertiesFromUserAssignedIdentity_Spec(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUserAssignedIdentity_Spec() to populate field Identity")
		}
		identity.Identity = identityLocal
	} else {
		identity.Identity = UserAssignedIdentity_Spec{}
	}

	// Name
	identity.Name = genruntime.GetOptionalStringValue(source.Name)

	// Namespace
	identity.Namespace = genruntime.GetOptionalStringValue(source.Namespace)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentity_Spec populates the provided destination ManagedClusterPodIdentity_Spec from our ManagedClusterPodIdentity_Spec
func (identity *ManagedClusterPodIdentity_Spec) AssignPropertiesToManagedClusterPodIdentity_Spec(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	var identityLocal v1alpha1api20210501storage.UserAssignedIdentity_Spec
	err := identity.Identity.AssignPropertiesToUserAssignedIdentity_Spec(&identityLocal)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToUserAssignedIdentity_Spec() to populate field Identity")
	}
	destination.Identity = &identityLocal

	// Name
	name := identity.Name
	destination.Name = &name

	// Namespace
	namespace := identity.Namespace
	destination.Namespace = &namespace

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_Status struct {
	//BindingSelector: The binding selector to use for the AzureIdentityBinding
	//resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	//Identity: The user assigned identity details.
	Identity UserAssignedIdentity_Status `json:"identity"`

	// +kubebuilder:validation:Required
	//Name: The name of the pod identity.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity.
	Namespace        string                                             `json:"namespace"`
	ProvisioningInfo *ManagedClusterPodIdentity_ProvisioningInfo_Status `json:"provisioningInfo,omitempty"`

	//ProvisioningState: The current provisioning state of the pod identity.
	ProvisioningState *ManagedClusterPodIdentity_ProvisioningState_Status `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘BindingSelector’:
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	var identity1 UserAssignedIdentity_Status
	err := identity1.PopulateFromARM(owner, typedInput.Identity)
	if err != nil {
		return err
	}
	identity.Identity = identity1

	// Set property ‘Name’:
	identity.Name = typedInput.Name

	// Set property ‘Namespace’:
	identity.Namespace = typedInput.Namespace

	// Set property ‘ProvisioningInfo’:
	if typedInput.ProvisioningInfo != nil {
		var provisioningInfo1 ManagedClusterPodIdentity_ProvisioningInfo_Status
		err = provisioningInfo1.PopulateFromARM(owner, *typedInput.ProvisioningInfo)
		if err != nil {
			return err
		}
		provisioningInfo := provisioningInfo1
		identity.ProvisioningInfo = &provisioningInfo
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		identity.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentity_Status populates our ManagedClusterPodIdentity_Status from the provided source ManagedClusterPodIdentity_Status
func (identity *ManagedClusterPodIdentity_Status) AssignPropertiesFromManagedClusterPodIdentity_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity_Status
		err := identityLocal.AssignPropertiesFromUserAssignedIdentity_Status(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUserAssignedIdentity_Status() to populate field Identity")
		}
		identity.Identity = identityLocal
	} else {
		identity.Identity = UserAssignedIdentity_Status{}
	}

	// Name
	identity.Name = genruntime.GetOptionalStringValue(source.Name)

	// Namespace
	identity.Namespace = genruntime.GetOptionalStringValue(source.Namespace)

	// ProvisioningInfo
	if source.ProvisioningInfo != nil {
		var provisioningInfo ManagedClusterPodIdentity_ProvisioningInfo_Status
		err := provisioningInfo.AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_Status(source.ProvisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_Status() to populate field ProvisioningInfo")
		}
		identity.ProvisioningInfo = &provisioningInfo
	} else {
		identity.ProvisioningInfo = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ManagedClusterPodIdentity_ProvisioningState_Status(*source.ProvisioningState)
		identity.ProvisioningState = &provisioningState
	} else {
		identity.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentity_Status populates the provided destination ManagedClusterPodIdentity_Status from our ManagedClusterPodIdentity_Status
func (identity *ManagedClusterPodIdentity_Status) AssignPropertiesToManagedClusterPodIdentity_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	var identityLocal v1alpha1api20210501storage.UserAssignedIdentity_Status
	err := identity.Identity.AssignPropertiesToUserAssignedIdentity_Status(&identityLocal)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToUserAssignedIdentity_Status() to populate field Identity")
	}
	destination.Identity = &identityLocal

	// Name
	name := identity.Name
	destination.Name = &name

	// Namespace
	namespace := identity.Namespace
	destination.Namespace = &namespace

	// ProvisioningInfo
	if identity.ProvisioningInfo != nil {
		var provisioningInfo v1alpha1api20210501storage.ManagedClusterPodIdentity_ProvisioningInfo_Status
		err = identity.ProvisioningInfo.AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_Status(&provisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_Status() to populate field ProvisioningInfo")
		}
		destination.ProvisioningInfo = &provisioningInfo
	} else {
		destination.ProvisioningInfo = nil
	}

	// ProvisioningState
	if identity.ProvisioningState != nil {
		provisioningState := string(*identity.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"least-waste","most-pods","priority","random"}
type ManagedClusterProperties_AutoScalerProfile_Expander_Spec string

const (
	ManagedClusterProperties_AutoScalerProfile_Expander_SpecLeastWaste = ManagedClusterProperties_AutoScalerProfile_Expander_Spec("least-waste")
	ManagedClusterProperties_AutoScalerProfile_Expander_SpecMostPods   = ManagedClusterProperties_AutoScalerProfile_Expander_Spec("most-pods")
	ManagedClusterProperties_AutoScalerProfile_Expander_SpecPriority   = ManagedClusterProperties_AutoScalerProfile_Expander_Spec("priority")
	ManagedClusterProperties_AutoScalerProfile_Expander_SpecRandom     = ManagedClusterProperties_AutoScalerProfile_Expander_Spec("random")
)

type ManagedClusterProperties_AutoScalerProfile_Expander_Status string

const (
	ManagedClusterProperties_AutoScalerProfile_Expander_StatusLeastWaste = ManagedClusterProperties_AutoScalerProfile_Expander_Status("least-waste")
	ManagedClusterProperties_AutoScalerProfile_Expander_StatusMostPods   = ManagedClusterProperties_AutoScalerProfile_Expander_Status("most-pods")
	ManagedClusterProperties_AutoScalerProfile_Expander_StatusPriority   = ManagedClusterProperties_AutoScalerProfile_Expander_Status("priority")
	ManagedClusterProperties_AutoScalerProfile_Expander_StatusRandom     = ManagedClusterProperties_AutoScalerProfile_Expander_Status("random")
)

// +kubebuilder:validation:Enum={"None","Windows_Server"}
type ManagedClusterWindowsProfile_LicenseType_Spec string

const (
	ManagedClusterWindowsProfile_LicenseType_SpecNone           = ManagedClusterWindowsProfile_LicenseType_Spec("None")
	ManagedClusterWindowsProfile_LicenseType_SpecWindows_Server = ManagedClusterWindowsProfile_LicenseType_Spec("Windows_Server")
)

type ManagedClusterWindowsProfile_LicenseType_Status string

const (
	ManagedClusterWindowsProfile_LicenseType_StatusNone           = ManagedClusterWindowsProfile_LicenseType_Status("None")
	ManagedClusterWindowsProfile_LicenseType_StatusWindows_Server = ManagedClusterWindowsProfile_LicenseType_Status("Windows_Server")
)

type ContainerServiceSshPublicKey_Spec struct {
	// +kubebuilder:validation:Required
	//KeyData: Certificate public key used to authenticate with VMs through SSH. The
	//certificate must be in PEM format with or without headers.
	KeyData string `json:"keyData"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshPublicKey_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (publicKey *ContainerServiceSshPublicKey_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if publicKey == nil {
		return nil, nil
	}
	var result ContainerServiceSshPublicKey_SpecARM

	// Set property ‘KeyData’:
	result.KeyData = publicKey.KeyData
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshPublicKey_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshPublicKey_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshPublicKey_SpecARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	publicKey.KeyData = typedInput.KeyData

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshPublicKey_Spec populates our ContainerServiceSshPublicKey_Spec from the provided source ContainerServiceSshPublicKey_Spec
func (publicKey *ContainerServiceSshPublicKey_Spec) AssignPropertiesFromContainerServiceSshPublicKey_Spec(source *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Spec) error {

	// KeyData
	publicKey.KeyData = genruntime.GetOptionalStringValue(source.KeyData)

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshPublicKey_Spec populates the provided destination ContainerServiceSshPublicKey_Spec from our ContainerServiceSshPublicKey_Spec
func (publicKey *ContainerServiceSshPublicKey_Spec) AssignPropertiesToContainerServiceSshPublicKey_Spec(destination *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	keyDatum := publicKey.KeyData
	destination.KeyData = &keyDatum

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerServiceSshPublicKey_Status struct {
	// +kubebuilder:validation:Required
	//KeyData: Certificate public key used to authenticate with VMs through SSH. The
	//certificate must be in PEM format with or without headers.
	KeyData string `json:"keyData"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshPublicKey_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshPublicKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshPublicKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshPublicKey_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	publicKey.KeyData = typedInput.KeyData

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshPublicKey_Status populates our ContainerServiceSshPublicKey_Status from the provided source ContainerServiceSshPublicKey_Status
func (publicKey *ContainerServiceSshPublicKey_Status) AssignPropertiesFromContainerServiceSshPublicKey_Status(source *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status) error {

	// KeyData
	publicKey.KeyData = genruntime.GetOptionalStringValue(source.KeyData)

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshPublicKey_Status populates the provided destination ContainerServiceSshPublicKey_Status from our ContainerServiceSshPublicKey_Status
func (publicKey *ContainerServiceSshPublicKey_Status) AssignPropertiesToContainerServiceSshPublicKey_Status(destination *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	keyDatum := publicKey.KeyData
	destination.KeyData = &keyDatum

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec struct {
	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	//Count: The desired number of outbound IPs created/managed by Azure for the
	//cluster load balancer. Allowed values must be in the range of 1 to 100
	//(inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM

	// Set property ‘Count’:
	if iPs.Count != nil {
		count := *iPs.Count
		result.Count = &count
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		iPs.Count = &count
	} else {
		iPs.Count = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if iPs.Count != nil {
		count := *iPs.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status struct {
	//Count: The desired number of outbound IPs created/managed by Azure for the
	//cluster load balancer. Allowed values must be in the range of 1 to 100
	//(inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_StatusARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) error {

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec struct {
	//PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference_Spec `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if prefixes == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM

	// Set property ‘PublicIPPrefixes’:
	for _, item := range prefixes.PublicIPPrefixes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPPrefixes = append(result.PublicIPPrefixes, itemARM.(ResourceReference_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM, got %T", armInput)
	}

	// Set property ‘PublicIPPrefixes’:
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_Spec, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference_Spec
			err := publicIPPrefix.AssignPropertiesFromResourceReference_Spec(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Spec() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]v1alpha1api20210501storage.ResourceReference_Spec, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix v1alpha1api20210501storage.ResourceReference_Spec
			err := publicIPPrefixItem.AssignPropertiesToResourceReference_Spec(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Spec() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status struct {
	//PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference_Status `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicIPPrefixes’:
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_Status, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference_Status
			err := publicIPPrefix.AssignPropertiesFromResourceReference_Status(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Status() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix v1alpha1api20210501storage.ResourceReference_Status
			err := publicIPPrefixItem.AssignPropertiesToResourceReference_Status(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Status() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPs_Spec struct {
	//PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference_Spec `json:"publicIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile_OutboundIPs_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM

	// Set property ‘PublicIPs’:
	for _, item := range iPs.PublicIPs {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPs = append(result.PublicIPs, itemARM.(ResourceReference_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM, got %T", armInput)
	}

	// Set property ‘PublicIPs’:
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Spec populates our ManagedClusterLoadBalancerProfile_OutboundIPs_Spec from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs_Spec
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Spec(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_Spec, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference_Spec
			err := publicIP.AssignPropertiesFromResourceReference_Spec(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Spec() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Spec populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs_Spec from our ManagedClusterLoadBalancerProfile_OutboundIPs_Spec
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Spec(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]v1alpha1api20210501storage.ResourceReference_Spec, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP v1alpha1api20210501storage.ResourceReference_Spec
			err := publicIPItem.AssignPropertiesToResourceReference_Spec(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Spec() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_OutboundIPs_Status struct {
	//PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference_Status `json:"publicIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_OutboundIPs_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_OutboundIPs_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_OutboundIPs_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_OutboundIPs_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicIPs’:
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Status populates our ManagedClusterLoadBalancerProfile_OutboundIPs_Status from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs_Status
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Status) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_Status(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Status) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_Status, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference_Status
			err := publicIP.AssignPropertiesFromResourceReference_Status(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_Status() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Status populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs_Status from our ManagedClusterLoadBalancerProfile_OutboundIPs_Status
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_Status) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_Status(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_OutboundIPs_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP v1alpha1api20210501storage.ResourceReference_Status
			err := publicIPItem.AssignPropertiesToResourceReference_Status(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_Status() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_ProvisioningInfo_Status struct {
	//Error: Pod identity assignment error (if any).
	Error *ManagedClusterPodIdentityProvisioningError_Status `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_ProvisioningInfo_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ManagedClusterPodIdentity_ProvisioningInfo_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentity_ProvisioningInfo_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ManagedClusterPodIdentity_ProvisioningInfo_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentity_ProvisioningInfo_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentity_ProvisioningInfo_StatusARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ManagedClusterPodIdentityProvisioningError_Status
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		info.Error = &error
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_Status populates our ManagedClusterPodIdentity_ProvisioningInfo_Status from the provided source ManagedClusterPodIdentity_ProvisioningInfo_Status
func (info *ManagedClusterPodIdentity_ProvisioningInfo_Status) AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentity_ProvisioningInfo_Status) error {

	// Error
	if source.Error != nil {
		var error ManagedClusterPodIdentityProvisioningError_Status
		err := error.AssignPropertiesFromManagedClusterPodIdentityProvisioningError_Status(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningError_Status() to populate field Error")
		}
		info.Error = &error
	} else {
		info.Error = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_Status populates the provided destination ManagedClusterPodIdentity_ProvisioningInfo_Status from our ManagedClusterPodIdentity_ProvisioningInfo_Status
func (info *ManagedClusterPodIdentity_ProvisioningInfo_Status) AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity_ProvisioningInfo_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if info.Error != nil {
		var error v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningError_Status
		err := info.Error.AssignPropertiesToManagedClusterPodIdentityProvisioningError_Status(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningError_Status() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentity_ProvisioningState_Status string

const (
	ManagedClusterPodIdentity_ProvisioningState_StatusAssigned = ManagedClusterPodIdentity_ProvisioningState_Status("Assigned")
	ManagedClusterPodIdentity_ProvisioningState_StatusDeleting = ManagedClusterPodIdentity_ProvisioningState_Status("Deleting")
	ManagedClusterPodIdentity_ProvisioningState_StatusFailed   = ManagedClusterPodIdentity_ProvisioningState_Status("Failed")
	ManagedClusterPodIdentity_ProvisioningState_StatusUpdating = ManagedClusterPodIdentity_ProvisioningState_Status("Updating")
)

type ResourceReference_Spec struct {
	//Reference: The fully qualified Azure resource id.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ResourceReference_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	var result ResourceReference_SpecARM

	// Set property ‘Id’:
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReference_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ResourceReference_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReference_SpecARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromResourceReference_Spec populates our ResourceReference_Spec from the provided source ResourceReference_Spec
func (reference *ResourceReference_Spec) AssignPropertiesFromResourceReference_Spec(source *v1alpha1api20210501storage.ResourceReference_Spec) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReference_Spec populates the provided destination ResourceReference_Spec from our ResourceReference_Spec
func (reference *ResourceReference_Spec) AssignPropertiesToResourceReference_Spec(destination *v1alpha1api20210501storage.ResourceReference_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceReference_Status struct {
	//Id: The fully qualified Azure resource id.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceReference_Status populates our ResourceReference_Status from the provided source ResourceReference_Status
func (reference *ResourceReference_Status) AssignPropertiesFromResourceReference_Status(source *v1alpha1api20210501storage.ResourceReference_Status) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToResourceReference_Status populates the provided destination ResourceReference_Status from our ResourceReference_Status
func (reference *ResourceReference_Status) AssignPropertiesToResourceReference_Status(destination *v1alpha1api20210501storage.ResourceReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserAssignedIdentity_Spec struct {
	//ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	//ResourceReference: The resource ID of the user assigned identity.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAssignedIdentity_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *UserAssignedIdentity_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	var result UserAssignedIdentity_SpecARM

	// Set property ‘ClientId’:
	if identity.ClientId != nil {
		clientId := *identity.ClientId
		result.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if identity.ObjectId != nil {
		objectId := *identity.ObjectId
		result.ObjectId = &objectId
	}

	// Set property ‘ResourceId’:
	if identity.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*identity.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_SpecARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignPropertiesFromUserAssignedIdentity_Spec populates our UserAssignedIdentity_Spec from the provided source UserAssignedIdentity_Spec
func (identity *UserAssignedIdentity_Spec) AssignPropertiesFromUserAssignedIdentity_Spec(source *v1alpha1api20210501storage.UserAssignedIdentity_Spec) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentity_Spec populates the provided destination UserAssignedIdentity_Spec from our UserAssignedIdentity_Spec
func (identity *UserAssignedIdentity_Spec) AssignPropertiesToUserAssignedIdentity_Spec(destination *v1alpha1api20210501storage.UserAssignedIdentity_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceReference
	if identity.ResourceReference != nil {
		resourceReference := identity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserAssignedIdentity_Status struct {
	//ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	//ResourceId: The resource ID of the user assigned identity.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// Set property ‘ResourceId’:
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		identity.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignPropertiesFromUserAssignedIdentity_Status populates our UserAssignedIdentity_Status from the provided source UserAssignedIdentity_Status
func (identity *UserAssignedIdentity_Status) AssignPropertiesFromUserAssignedIdentity_Status(source *v1alpha1api20210501storage.UserAssignedIdentity_Status) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceId
	identity.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentity_Status populates the provided destination UserAssignedIdentity_Status from our UserAssignedIdentity_Status
func (identity *UserAssignedIdentity_Status) AssignPropertiesToUserAssignedIdentity_Status(destination *v1alpha1api20210501storage.UserAssignedIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(identity.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningError_Status struct {
	//Error: Details about the error.
	Error *ManagedClusterPodIdentityProvisioningErrorBody_Status `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningError_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ManagedClusterPodIdentityProvisioningError_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProvisioningError_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ManagedClusterPodIdentityProvisioningError_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProvisioningError_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProvisioningError_StatusARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error2 ManagedClusterPodIdentityProvisioningErrorBody_Status
		err := error2.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error1 := error2
		error.Error = &error1
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProvisioningError_Status populates our ManagedClusterPodIdentityProvisioningError_Status from the provided source ManagedClusterPodIdentityProvisioningError_Status
func (error *ManagedClusterPodIdentityProvisioningError_Status) AssignPropertiesFromManagedClusterPodIdentityProvisioningError_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningError_Status) error {

	// Error
	if source.Error != nil {
		var errorLocal ManagedClusterPodIdentityProvisioningErrorBody_Status
		err := errorLocal.AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status() to populate field Error")
		}
		error.Error = &errorLocal
	} else {
		error.Error = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProvisioningError_Status populates the provided destination ManagedClusterPodIdentityProvisioningError_Status from our ManagedClusterPodIdentityProvisioningError_Status
func (error *ManagedClusterPodIdentityProvisioningError_Status) AssignPropertiesToManagedClusterPodIdentityProvisioningError_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningError_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if error.Error != nil {
		var errorLocal v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status
		err := error.Error.AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status(&errorLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status() to populate field Error")
		}
		destination.Error = &errorLocal
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningErrorBody_Status struct {
	//Code: An identifier for the error. Codes are invariant and are intended to be
	//consumed programmatically.
	Code *string `json:"code,omitempty"`

	//Details: A list of additional details about the error.
	Details []ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled `json:"details,omitempty"`

	//Message: A message describing the error, intended to be suitable for display in
	//a user interface.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error. For example, the name of the
	//property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (body *ManagedClusterPodIdentityProvisioningErrorBody_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProvisioningErrorBody_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (body *ManagedClusterPodIdentityProvisioningErrorBody_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProvisioningErrorBody_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProvisioningErrorBody_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		body.Code = &code
	}

	// Set property ‘Details’:
	for _, item := range typedInput.Details {
		var item1 ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		body.Details = append(body.Details, item1)
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		body.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		body.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status populates our ManagedClusterPodIdentityProvisioningErrorBody_Status from the provided source ManagedClusterPodIdentityProvisioningErrorBody_Status
func (body *ManagedClusterPodIdentityProvisioningErrorBody_Status) AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status) error {

	// Code
	body.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled
			err := detail.AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		body.Details = detailList
	} else {
		body.Details = nil
	}

	// Message
	body.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	body.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_Status from our ManagedClusterPodIdentityProvisioningErrorBody_Status
func (body *ManagedClusterPodIdentityProvisioningErrorBody_Status) AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(body.Code)

	// Details
	if body.Details != nil {
		detailList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled, len(body.Details))
		for detailIndex, detailItem := range body.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled
			err := detailItem.AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(body.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(body.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled struct {
	//Code: An identifier for the error. Codes are invariant and are intended to be
	//consumed programmatically.
	Code *string `json:"code,omitempty"`

	//Message: A message describing the error, intended to be suitable for display in
	//a user interface.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error. For example, the name of the
	//property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProvisioningErrorBody_Status_UnrolledARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProvisioningErrorBody_Status_UnrolledARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProvisioningErrorBody_Status_UnrolledARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled populates our ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled from the provided source ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) error {

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled from our ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProvisioningErrorBody_Status_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedCluster{}, &ManagedClusterList{})
}
