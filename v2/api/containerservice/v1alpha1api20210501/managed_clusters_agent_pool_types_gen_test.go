// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/containerservice/v1alpha1api20210501storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedClustersAgentPool_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool to hub returns original",
		prop.ForAll(RunResourceConversionTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForManagedClustersAgentPool tests if a specific instance of ManagedClustersAgentPool round trips to the hub storage version and back losslessly
func RunResourceConversionTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210501storage.ManagedClustersAgentPool
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ManagedClustersAgentPool
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool to ManagedClustersAgentPool via AssignPropertiesToManagedClustersAgentPool & AssignPropertiesFromManagedClustersAgentPool returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPool tests if a specific instance of ManagedClustersAgentPool can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.ManagedClustersAgentPool
	err := copied.AssignPropertiesToManagedClustersAgentPool(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPool
	err = actual.AssignPropertiesFromManagedClustersAgentPool(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPool runs a test to see if a specific instance of ManagedClustersAgentPool round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPool instances for property testing - lazily instantiated by
//ManagedClustersAgentPoolGenerator()
var managedClustersAgentPoolGenerator gopter.Gen

// ManagedClustersAgentPoolGenerator returns a generator of ManagedClustersAgentPool instances for property testing.
func ManagedClustersAgentPoolGenerator() gopter.Gen {
	if managedClustersAgentPoolGenerator != nil {
		return managedClustersAgentPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPool(generators)
	managedClustersAgentPoolGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPool{}), generators)

	return managedClustersAgentPoolGenerator
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPool(gens map[string]gopter.Gen) {
	gens["Spec"] = ManagedClustersAgentPools_SPECGenerator()
	gens["Status"] = AgentPool_StatusGenerator()
}

func Test_AgentPool_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPool_Status to AgentPool_Status via AssignPropertiesToAgentPool_Status & AssignPropertiesFromAgentPool_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPool_Status, AgentPool_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPool_Status tests if a specific instance of AgentPool_Status can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForAgentPool_Status(subject AgentPool_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.AgentPool_Status
	err := copied.AssignPropertiesToAgentPool_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPool_Status
	err = actual.AssignPropertiesFromAgentPool_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPool_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPool_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPool_Status, AgentPool_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPool_Status runs a test to see if a specific instance of AgentPool_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPool_Status(subject AgentPool_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPool_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPool_Status instances for property testing - lazily instantiated by AgentPool_StatusGenerator()
var agentPool_statusGenerator gopter.Gen

// AgentPool_StatusGenerator returns a generator of AgentPool_Status instances for property testing.
// We first initialize agentPool_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AgentPool_StatusGenerator() gopter.Gen {
	if agentPool_statusGenerator != nil {
		return agentPool_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPool_Status(generators)
	agentPool_statusGenerator = gen.Struct(reflect.TypeOf(AgentPool_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPool_Status(generators)
	AddRelatedPropertyGeneratorsForAgentPool_Status(generators)
	agentPool_statusGenerator = gen.Struct(reflect.TypeOf(AgentPool_Status{}), generators)

	return agentPool_statusGenerator
}

// AddIndependentPropertyGeneratorsForAgentPool_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPool_Status(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.OneConstOf(
		GPUInstanceProfile_StatusMIG1G,
		GPUInstanceProfile_StatusMIG2G,
		GPUInstanceProfile_StatusMIG3G,
		GPUInstanceProfile_StatusMIG4G,
		GPUInstanceProfile_StatusMIG7G))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["KubeletDiskType"] = gen.PtrOf(gen.OneConstOf(KubeletDiskType_StatusOS, KubeletDiskType_StatusTemporary))
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(AgentPoolMode_StatusSystem, AgentPoolMode_StatusUser))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NodeImageVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodePublicIPPrefixID"] = gen.PtrOf(gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.OneConstOf(OSDiskType_StatusEphemeral, OSDiskType_StatusManaged))
	gens["OsSKU"] = gen.PtrOf(gen.OneConstOf(OSSKU_StatusCBLMariner, OSSKU_StatusUbuntu))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSType_StatusLinux, OSType_StatusWindows))
	gens["PodSubnetID"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.OneConstOf(AgentPoolType_StatusAvailabilitySet, AgentPoolType_StatusVirtualMachineScaleSets))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.OneConstOf(ScaleSetEvictionPolicy_StatusDeallocate, ScaleSetEvictionPolicy_StatusDelete))
	gens["ScaleSetPriority"] = gen.PtrOf(gen.OneConstOf(ScaleSetPriority_StatusRegular, ScaleSetPriority_StatusSpot))
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
	gens["VnetSubnetID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAgentPool_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentPool_Status(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfig_StatusGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfig_StatusGenerator())
	gens["PowerState"] = gen.PtrOf(PowerState_StatusGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettings_StatusGenerator())
}

func Test_ManagedClustersAgentPools_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPools_SPEC to ManagedClustersAgentPools_SPEC via AssignPropertiesToManagedClustersAgentPools_SPEC & AssignPropertiesFromManagedClustersAgentPools_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPools_SPEC, ManagedClustersAgentPools_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPools_SPEC tests if a specific instance of ManagedClustersAgentPools_SPEC can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPools_SPEC(subject ManagedClustersAgentPools_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.ManagedClustersAgentPools_SPEC
	err := copied.AssignPropertiesToManagedClustersAgentPools_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPools_SPEC
	err = actual.AssignPropertiesFromManagedClustersAgentPools_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPools_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPools_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPools_SPEC, ManagedClustersAgentPools_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPools_SPEC runs a test to see if a specific instance of ManagedClustersAgentPools_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPools_SPEC(subject ManagedClustersAgentPools_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPools_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPools_SPEC instances for property testing - lazily instantiated by
//ManagedClustersAgentPools_SPECGenerator()
var managedClustersAgentPools_specGenerator gopter.Gen

// ManagedClustersAgentPools_SPECGenerator returns a generator of ManagedClustersAgentPools_SPEC instances for property testing.
// We first initialize managedClustersAgentPools_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClustersAgentPools_SPECGenerator() gopter.Gen {
	if managedClustersAgentPools_specGenerator != nil {
		return managedClustersAgentPools_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersAgentPools_SPEC(generators)
	managedClustersAgentPools_specGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPools_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersAgentPools_SPEC(generators)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPools_SPEC(generators)
	managedClustersAgentPools_specGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPools_SPEC{}), generators)

	return managedClustersAgentPools_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedClustersAgentPools_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClustersAgentPools_SPEC(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.OneConstOf(
		GPUInstanceProfile_SpecMIG1G,
		GPUInstanceProfile_SpecMIG2G,
		GPUInstanceProfile_SpecMIG3G,
		GPUInstanceProfile_SpecMIG4G,
		GPUInstanceProfile_SpecMIG7G))
	gens["KubeletDiskType"] = gen.PtrOf(gen.OneConstOf(KubeletDiskType_SpecOS, KubeletDiskType_SpecTemporary))
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(AgentPoolMode_SpecSystem, AgentPoolMode_SpecUser))
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int().Map(func(result int) ContainerServiceOSDisk_Spec {
		return ContainerServiceOSDisk_Spec(result)
	}))
	gens["OsDiskType"] = gen.PtrOf(gen.OneConstOf(OSDiskType_SpecEphemeral, OSDiskType_SpecManaged))
	gens["OsSKU"] = gen.PtrOf(gen.OneConstOf(OSSKU_SpecCBLMariner, OSSKU_SpecUbuntu))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSType_SpecLinux, OSType_SpecWindows))
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.OneConstOf(ScaleSetEvictionPolicy_SpecDeallocate, ScaleSetEvictionPolicy_SpecDelete))
	gens["ScaleSetPriority"] = gen.PtrOf(gen.OneConstOf(ScaleSetPriority_SpecRegular, ScaleSetPriority_SpecSpot))
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AgentPoolType_SpecAvailabilitySet, AgentPoolType_SpecVirtualMachineScaleSets))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPools_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPools_SPEC(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfig_SpecGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfig_SpecGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettings_SpecGenerator())
}

func Test_AgentPoolUpgradeSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolUpgradeSettings_Spec to AgentPoolUpgradeSettings_Spec via AssignPropertiesToAgentPoolUpgradeSettings_Spec & AssignPropertiesFromAgentPoolUpgradeSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Spec, AgentPoolUpgradeSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Spec tests if a specific instance of AgentPoolUpgradeSettings_Spec can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Spec(subject AgentPoolUpgradeSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.AgentPoolUpgradeSettings_Spec
	err := copied.AssignPropertiesToAgentPoolUpgradeSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolUpgradeSettings_Spec
	err = actual.AssignPropertiesFromAgentPoolUpgradeSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolUpgradeSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettings_Spec, AgentPoolUpgradeSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettings_Spec runs a test to see if a specific instance of AgentPoolUpgradeSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettings_Spec(subject AgentPoolUpgradeSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings_Spec instances for property testing - lazily instantiated by
//AgentPoolUpgradeSettings_SpecGenerator()
var agentPoolUpgradeSettings_specGenerator gopter.Gen

// AgentPoolUpgradeSettings_SpecGenerator returns a generator of AgentPoolUpgradeSettings_Spec instances for property testing.
func AgentPoolUpgradeSettings_SpecGenerator() gopter.Gen {
	if agentPoolUpgradeSettings_specGenerator != nil {
		return agentPoolUpgradeSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Spec(generators)
	agentPoolUpgradeSettings_specGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings_Spec{}), generators)

	return agentPoolUpgradeSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Spec(gens map[string]gopter.Gen) {
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentPoolUpgradeSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolUpgradeSettings_Status to AgentPoolUpgradeSettings_Status via AssignPropertiesToAgentPoolUpgradeSettings_Status & AssignPropertiesFromAgentPoolUpgradeSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Status, AgentPoolUpgradeSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Status tests if a specific instance of AgentPoolUpgradeSettings_Status can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolUpgradeSettings_Status(subject AgentPoolUpgradeSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.AgentPoolUpgradeSettings_Status
	err := copied.AssignPropertiesToAgentPoolUpgradeSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolUpgradeSettings_Status
	err = actual.AssignPropertiesFromAgentPoolUpgradeSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolUpgradeSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettings_Status, AgentPoolUpgradeSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettings_Status runs a test to see if a specific instance of AgentPoolUpgradeSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettings_Status(subject AgentPoolUpgradeSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings_Status instances for property testing - lazily instantiated by
//AgentPoolUpgradeSettings_StatusGenerator()
var agentPoolUpgradeSettings_statusGenerator gopter.Gen

// AgentPoolUpgradeSettings_StatusGenerator returns a generator of AgentPoolUpgradeSettings_Status instances for property testing.
func AgentPoolUpgradeSettings_StatusGenerator() gopter.Gen {
	if agentPoolUpgradeSettings_statusGenerator != nil {
		return agentPoolUpgradeSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Status(generators)
	agentPoolUpgradeSettings_statusGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings_Status{}), generators)

	return agentPoolUpgradeSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_Status(gens map[string]gopter.Gen) {
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubeletConfig_Spec to KubeletConfig_Spec via AssignPropertiesToKubeletConfig_Spec & AssignPropertiesFromKubeletConfig_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubeletConfig_Spec, KubeletConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubeletConfig_Spec tests if a specific instance of KubeletConfig_Spec can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForKubeletConfig_Spec(subject KubeletConfig_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.KubeletConfig_Spec
	err := copied.AssignPropertiesToKubeletConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubeletConfig_Spec
	err = actual.AssignPropertiesFromKubeletConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubeletConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfig_Spec, KubeletConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfig_Spec runs a test to see if a specific instance of KubeletConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfig_Spec(subject KubeletConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig_Spec instances for property testing - lazily instantiated by KubeletConfig_SpecGenerator()
var kubeletConfig_specGenerator gopter.Gen

// KubeletConfig_SpecGenerator returns a generator of KubeletConfig_Spec instances for property testing.
func KubeletConfig_SpecGenerator() gopter.Gen {
	if kubeletConfig_specGenerator != nil {
		return kubeletConfig_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfig_Spec(generators)
	kubeletConfig_specGenerator = gen.Struct(reflect.TypeOf(KubeletConfig_Spec{}), generators)

	return kubeletConfig_specGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfig_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfig_Spec(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubeletConfig_Status to KubeletConfig_Status via AssignPropertiesToKubeletConfig_Status & AssignPropertiesFromKubeletConfig_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubeletConfig_Status, KubeletConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubeletConfig_Status tests if a specific instance of KubeletConfig_Status can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForKubeletConfig_Status(subject KubeletConfig_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.KubeletConfig_Status
	err := copied.AssignPropertiesToKubeletConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubeletConfig_Status
	err = actual.AssignPropertiesFromKubeletConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubeletConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfig_Status, KubeletConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfig_Status runs a test to see if a specific instance of KubeletConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfig_Status(subject KubeletConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig_Status instances for property testing - lazily instantiated by
//KubeletConfig_StatusGenerator()
var kubeletConfig_statusGenerator gopter.Gen

// KubeletConfig_StatusGenerator returns a generator of KubeletConfig_Status instances for property testing.
func KubeletConfig_StatusGenerator() gopter.Gen {
	if kubeletConfig_statusGenerator != nil {
		return kubeletConfig_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfig_Status(generators)
	kubeletConfig_statusGenerator = gen.Struct(reflect.TypeOf(KubeletConfig_Status{}), generators)

	return kubeletConfig_statusGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfig_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfig_Status(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxOSConfig_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxOSConfig_Spec to LinuxOSConfig_Spec via AssignPropertiesToLinuxOSConfig_Spec & AssignPropertiesFromLinuxOSConfig_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxOSConfig_Spec, LinuxOSConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxOSConfig_Spec tests if a specific instance of LinuxOSConfig_Spec can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForLinuxOSConfig_Spec(subject LinuxOSConfig_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.LinuxOSConfig_Spec
	err := copied.AssignPropertiesToLinuxOSConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxOSConfig_Spec
	err = actual.AssignPropertiesFromLinuxOSConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxOSConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfig_Spec, LinuxOSConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfig_Spec runs a test to see if a specific instance of LinuxOSConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfig_Spec(subject LinuxOSConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig_Spec instances for property testing - lazily instantiated by LinuxOSConfig_SpecGenerator()
var linuxOSConfig_specGenerator gopter.Gen

// LinuxOSConfig_SpecGenerator returns a generator of LinuxOSConfig_Spec instances for property testing.
// We first initialize linuxOSConfig_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfig_SpecGenerator() gopter.Gen {
	if linuxOSConfig_specGenerator != nil {
		return linuxOSConfig_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_Spec(generators)
	linuxOSConfig_specGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_Spec(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfig_Spec(generators)
	linuxOSConfig_specGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Spec{}), generators)

	return linuxOSConfig_specGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfig_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfig_Spec(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfig_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfig_Spec(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfig_SpecGenerator())
}

func Test_LinuxOSConfig_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxOSConfig_Status to LinuxOSConfig_Status via AssignPropertiesToLinuxOSConfig_Status & AssignPropertiesFromLinuxOSConfig_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxOSConfig_Status, LinuxOSConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxOSConfig_Status tests if a specific instance of LinuxOSConfig_Status can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForLinuxOSConfig_Status(subject LinuxOSConfig_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.LinuxOSConfig_Status
	err := copied.AssignPropertiesToLinuxOSConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxOSConfig_Status
	err = actual.AssignPropertiesFromLinuxOSConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxOSConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfig_Status, LinuxOSConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfig_Status runs a test to see if a specific instance of LinuxOSConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfig_Status(subject LinuxOSConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig_Status instances for property testing - lazily instantiated by
//LinuxOSConfig_StatusGenerator()
var linuxOSConfig_statusGenerator gopter.Gen

// LinuxOSConfig_StatusGenerator returns a generator of LinuxOSConfig_Status instances for property testing.
// We first initialize linuxOSConfig_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfig_StatusGenerator() gopter.Gen {
	if linuxOSConfig_statusGenerator != nil {
		return linuxOSConfig_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_Status(generators)
	linuxOSConfig_statusGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_Status(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfig_Status(generators)
	linuxOSConfig_statusGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Status{}), generators)

	return linuxOSConfig_statusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfig_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfig_Status(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfig_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfig_Status(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfig_StatusGenerator())
}

func Test_SysctlConfig_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SysctlConfig_Spec to SysctlConfig_Spec via AssignPropertiesToSysctlConfig_Spec & AssignPropertiesFromSysctlConfig_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSysctlConfig_Spec, SysctlConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSysctlConfig_Spec tests if a specific instance of SysctlConfig_Spec can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForSysctlConfig_Spec(subject SysctlConfig_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.SysctlConfig_Spec
	err := copied.AssignPropertiesToSysctlConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SysctlConfig_Spec
	err = actual.AssignPropertiesFromSysctlConfig_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SysctlConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfig_Spec, SysctlConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfig_Spec runs a test to see if a specific instance of SysctlConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfig_Spec(subject SysctlConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig_Spec instances for property testing - lazily instantiated by SysctlConfig_SpecGenerator()
var sysctlConfig_specGenerator gopter.Gen

// SysctlConfig_SpecGenerator returns a generator of SysctlConfig_Spec instances for property testing.
func SysctlConfig_SpecGenerator() gopter.Gen {
	if sysctlConfig_specGenerator != nil {
		return sysctlConfig_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfig_Spec(generators)
	sysctlConfig_specGenerator = gen.Struct(reflect.TypeOf(SysctlConfig_Spec{}), generators)

	return sysctlConfig_specGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfig_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfig_Spec(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}

func Test_SysctlConfig_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SysctlConfig_Status to SysctlConfig_Status via AssignPropertiesToSysctlConfig_Status & AssignPropertiesFromSysctlConfig_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSysctlConfig_Status, SysctlConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSysctlConfig_Status tests if a specific instance of SysctlConfig_Status can be assigned to v1alpha1api20210501storage and back losslessly
func RunPropertyAssignmentTestForSysctlConfig_Status(subject SysctlConfig_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210501storage.SysctlConfig_Status
	err := copied.AssignPropertiesToSysctlConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SysctlConfig_Status
	err = actual.AssignPropertiesFromSysctlConfig_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SysctlConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfig_Status, SysctlConfig_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfig_Status runs a test to see if a specific instance of SysctlConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfig_Status(subject SysctlConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig_Status instances for property testing - lazily instantiated by
//SysctlConfig_StatusGenerator()
var sysctlConfig_statusGenerator gopter.Gen

// SysctlConfig_StatusGenerator returns a generator of SysctlConfig_Status instances for property testing.
func SysctlConfig_StatusGenerator() gopter.Gen {
	if sysctlConfig_statusGenerator != nil {
		return sysctlConfig_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfig_Status(generators)
	sysctlConfig_statusGenerator = gen.Struct(reflect.TypeOf(SysctlConfig_Status{}), generators)

	return sysctlConfig_statusGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfig_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfig_Status(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}
