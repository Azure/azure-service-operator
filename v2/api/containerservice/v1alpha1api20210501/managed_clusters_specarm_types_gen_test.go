// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedClusters_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusters_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusters_SPECARM, ManagedClusters_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusters_SPECARM runs a test to see if a specific instance of ManagedClusters_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusters_SPECARM(subject ManagedClusters_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusters_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusters_SPECARM instances for property testing - lazily instantiated by
//ManagedClusters_SPECARMGenerator()
var managedClusters_specarmGenerator gopter.Gen

// ManagedClusters_SPECARMGenerator returns a generator of ManagedClusters_SPECARM instances for property testing.
// We first initialize managedClusters_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusters_SPECARMGenerator() gopter.Gen {
	if managedClusters_specarmGenerator != nil {
		return managedClusters_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusters_SPECARM(generators)
	managedClusters_specarmGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusters_SPECARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusters_SPECARM(generators)
	managedClusters_specarmGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SPECARM{}), generators)

	return managedClusters_specarmGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusters_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusters_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusters_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusters_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedClusterIdentity_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(ManagedClusterProperties_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(ManagedClusterSKU_SpecARMGenerator())
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_SpecARM, ExtendedLocation_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_SpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_SpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocation_SpecARMGenerator()
var extendedLocation_specARMGenerator gopter.Gen

// ExtendedLocation_SpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocation_SpecARMGenerator() gopter.Gen {
	if extendedLocation_specARMGenerator != nil {
		return extendedLocation_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(generators)
	extendedLocation_specARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocation_specARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ManagedClusterIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterIdentity_SpecARM, ManagedClusterIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterIdentity_SpecARM runs a test to see if a specific instance of ManagedClusterIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterIdentity_SpecARM(subject ManagedClusterIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterIdentity_SpecARMGenerator()
var managedClusterIdentity_specARMGenerator gopter.Gen

// ManagedClusterIdentity_SpecARMGenerator returns a generator of ManagedClusterIdentity_SpecARM instances for property testing.
func ManagedClusterIdentity_SpecARMGenerator() gopter.Gen {
	if managedClusterIdentity_specARMGenerator != nil {
		return managedClusterIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterIdentity_SpecARM(generators)
	managedClusterIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterIdentity_SpecARM{}), generators)

	return managedClusterIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedClusterIdentity_Type_SpecNone, ManagedClusterIdentity_Type_SpecSystemAssigned, ManagedClusterIdentity_Type_SpecUserAssigned))
}

func Test_ManagedClusterProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterProperties_SpecARM, ManagedClusterProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterProperties_SpecARM runs a test to see if a specific instance of ManagedClusterProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterProperties_SpecARM(subject ManagedClusterProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterProperties_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterProperties_SpecARMGenerator()
var managedClusterProperties_specARMGenerator gopter.Gen

// ManagedClusterProperties_SpecARMGenerator returns a generator of ManagedClusterProperties_SpecARM instances for property testing.
// We first initialize managedClusterProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterProperties_SpecARMGenerator() gopter.Gen {
	if managedClusterProperties_specARMGenerator != nil {
		return managedClusterProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterProperties_SpecARM(generators)
	managedClusterProperties_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterProperties_SpecARM(generators)
	managedClusterProperties_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_SpecARM{}), generators)

	return managedClusterProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["DisableLocalAccounts"] = gen.PtrOf(gen.Bool())
	gens["DiskEncryptionSetID"] = gen.PtrOf(gen.AlphaString())
	gens["DnsPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["EnablePodSecurityPolicy"] = gen.PtrOf(gen.Bool())
	gens["EnableRBAC"] = gen.PtrOf(gen.Bool())
	gens["FqdnSubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["KubernetesVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AadProfile"] = gen.PtrOf(ManagedClusterAADProfile_SpecARMGenerator())
	gens["AgentPoolProfiles"] = gen.SliceOf(ManagedClusterAgentPoolProfile_SpecARMGenerator())
	gens["ApiServerAccessProfile"] = gen.PtrOf(ManagedClusterAPIServerAccessProfile_SpecARMGenerator())
	gens["AutoScalerProfile"] = gen.PtrOf(ManagedClusterProperties_AutoScalerProfile_SpecARMGenerator())
	gens["AutoUpgradeProfile"] = gen.PtrOf(ManagedClusterAutoUpgradeProfile_SpecARMGenerator())
	gens["HttpProxyConfig"] = gen.PtrOf(ManagedClusterHTTPProxyConfig_SpecARMGenerator())
	gens["LinuxProfile"] = gen.PtrOf(ContainerServiceLinuxProfile_SpecARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(ContainerServiceNetworkProfile_SpecARMGenerator())
	gens["PodIdentityProfile"] = gen.PtrOf(ManagedClusterPodIdentityProfile_SpecARMGenerator())
	gens["PrivateLinkResources"] = gen.SliceOf(PrivateLinkResource_SpecARMGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ManagedClusterServicePrincipalProfile_SpecARMGenerator())
	gens["WindowsProfile"] = gen.PtrOf(ManagedClusterWindowsProfile_SpecARMGenerator())
}

func Test_ManagedClusterSKU_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterSKU_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterSKU_SpecARM, ManagedClusterSKU_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterSKU_SpecARM runs a test to see if a specific instance of ManagedClusterSKU_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterSKU_SpecARM(subject ManagedClusterSKU_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterSKU_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterSKU_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterSKU_SpecARMGenerator()
var managedClusterSKU_specARMGenerator gopter.Gen

// ManagedClusterSKU_SpecARMGenerator returns a generator of ManagedClusterSKU_SpecARM instances for property testing.
func ManagedClusterSKU_SpecARMGenerator() gopter.Gen {
	if managedClusterSKU_specARMGenerator != nil {
		return managedClusterSKU_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterSKU_SpecARM(generators)
	managedClusterSKU_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterSKU_SpecARM{}), generators)

	return managedClusterSKU_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterSKU_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterSKU_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKU_Name_SpecBasic))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKU_Tier_SpecFree, ManagedClusterSKU_Tier_SpecPaid))
}

func Test_ContainerServiceLinuxProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceLinuxProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceLinuxProfile_SpecARM, ContainerServiceLinuxProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceLinuxProfile_SpecARM runs a test to see if a specific instance of ContainerServiceLinuxProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceLinuxProfile_SpecARM(subject ContainerServiceLinuxProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceLinuxProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceLinuxProfile_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceLinuxProfile_SpecARMGenerator()
var containerServiceLinuxProfile_specARMGenerator gopter.Gen

// ContainerServiceLinuxProfile_SpecARMGenerator returns a generator of ContainerServiceLinuxProfile_SpecARM instances for property testing.
// We first initialize containerServiceLinuxProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceLinuxProfile_SpecARMGenerator() gopter.Gen {
	if containerServiceLinuxProfile_specARMGenerator != nil {
		return containerServiceLinuxProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM(generators)
	containerServiceLinuxProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM(generators)
	containerServiceLinuxProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfile_SpecARM{}), generators)

	return containerServiceLinuxProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceLinuxProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["Ssh"] = ContainerServiceSshConfiguration_SpecARMGenerator()
}

func Test_ContainerServiceNetworkProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceNetworkProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceNetworkProfile_SpecARM, ContainerServiceNetworkProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceNetworkProfile_SpecARM runs a test to see if a specific instance of ContainerServiceNetworkProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceNetworkProfile_SpecARM(subject ContainerServiceNetworkProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceNetworkProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceNetworkProfile_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceNetworkProfile_SpecARMGenerator()
var containerServiceNetworkProfile_specARMGenerator gopter.Gen

// ContainerServiceNetworkProfile_SpecARMGenerator returns a generator of ContainerServiceNetworkProfile_SpecARM instances for property testing.
// We first initialize containerServiceNetworkProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceNetworkProfile_SpecARMGenerator() gopter.Gen {
	if containerServiceNetworkProfile_specARMGenerator != nil {
		return containerServiceNetworkProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM(generators)
	containerServiceNetworkProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM(generators)
	containerServiceNetworkProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfile_SpecARM{}), generators)

	return containerServiceNetworkProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerSku"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_LoadBalancerSku_SpecBasic, ContainerServiceNetworkProfile_LoadBalancerSku_SpecStandard))
	gens["NetworkMode"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkMode_SpecBridge, ContainerServiceNetworkProfile_NetworkMode_SpecTransparent))
	gens["NetworkPlugin"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkPlugin_SpecAzure, ContainerServiceNetworkProfile_NetworkPlugin_SpecKubenet))
	gens["NetworkPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkPolicy_SpecAzure, ContainerServiceNetworkProfile_NetworkPolicy_SpecCalico))
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_OutboundType_SpecLoadBalancer, ContainerServiceNetworkProfile_OutboundType_SpecUserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceNetworkProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(ManagedClusterLoadBalancerProfile_SpecARMGenerator())
}

func Test_ManagedClusterAADProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAADProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAADProfile_SpecARM, ManagedClusterAADProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAADProfile_SpecARM runs a test to see if a specific instance of ManagedClusterAADProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAADProfile_SpecARM(subject ManagedClusterAADProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAADProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAADProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAADProfile_SpecARMGenerator()
var managedClusterAADProfile_specARMGenerator gopter.Gen

// ManagedClusterAADProfile_SpecARMGenerator returns a generator of ManagedClusterAADProfile_SpecARM instances for property testing.
func ManagedClusterAADProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterAADProfile_specARMGenerator != nil {
		return managedClusterAADProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAADProfile_SpecARM(generators)
	managedClusterAADProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAADProfile_SpecARM{}), generators)

	return managedClusterAADProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAADProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAADProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AdminGroupObjectIDs"] = gen.SliceOf(gen.AlphaString())
	gens["ClientAppID"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAzureRBAC"] = gen.PtrOf(gen.Bool())
	gens["Managed"] = gen.PtrOf(gen.Bool())
	gens["ServerAppID"] = gen.PtrOf(gen.AlphaString())
	gens["ServerAppSecret"] = gen.PtrOf(gen.AlphaString())
	gens["TenantID"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAPIServerAccessProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAPIServerAccessProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAPIServerAccessProfile_SpecARM, ManagedClusterAPIServerAccessProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAPIServerAccessProfile_SpecARM runs a test to see if a specific instance of ManagedClusterAPIServerAccessProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAPIServerAccessProfile_SpecARM(subject ManagedClusterAPIServerAccessProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAPIServerAccessProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAPIServerAccessProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAPIServerAccessProfile_SpecARMGenerator()
var managedClusterAPIServerAccessProfile_specARMGenerator gopter.Gen

// ManagedClusterAPIServerAccessProfile_SpecARMGenerator returns a generator of ManagedClusterAPIServerAccessProfile_SpecARM instances for property testing.
func ManagedClusterAPIServerAccessProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterAPIServerAccessProfile_specARMGenerator != nil {
		return managedClusterAPIServerAccessProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfile_SpecARM(generators)
	managedClusterAPIServerAccessProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAPIServerAccessProfile_SpecARM{}), generators)

	return managedClusterAPIServerAccessProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AuthorizedIPRanges"] = gen.SliceOf(gen.AlphaString())
	gens["EnablePrivateCluster"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateClusterPublicFQDN"] = gen.PtrOf(gen.Bool())
	gens["PrivateDNSZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAgentPoolProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAgentPoolProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAgentPoolProfile_SpecARM, ManagedClusterAgentPoolProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAgentPoolProfile_SpecARM runs a test to see if a specific instance of ManagedClusterAgentPoolProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAgentPoolProfile_SpecARM(subject ManagedClusterAgentPoolProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAgentPoolProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAgentPoolProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAgentPoolProfile_SpecARMGenerator()
var managedClusterAgentPoolProfile_specARMGenerator gopter.Gen

// ManagedClusterAgentPoolProfile_SpecARMGenerator returns a generator of ManagedClusterAgentPoolProfile_SpecARM instances for property testing.
// We first initialize managedClusterAgentPoolProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterAgentPoolProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterAgentPoolProfile_specARMGenerator != nil {
		return managedClusterAgentPoolProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM(generators)
	managedClusterAgentPoolProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM(generators)
	managedClusterAgentPoolProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfile_SpecARM{}), generators)

	return managedClusterAgentPoolProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.OneConstOf(
		GPUInstanceProfile_SpecMIG1G,
		GPUInstanceProfile_SpecMIG2G,
		GPUInstanceProfile_SpecMIG3G,
		GPUInstanceProfile_SpecMIG4G,
		GPUInstanceProfile_SpecMIG7G))
	gens["KubeletDiskType"] = gen.PtrOf(gen.OneConstOf(KubeletDiskType_SpecOS, KubeletDiskType_SpecTemporary))
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(AgentPoolMode_SpecSystem, AgentPoolMode_SpecUser))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodePublicIPPrefixID"] = gen.PtrOf(gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.OneConstOf(OSDiskType_SpecEphemeral, OSDiskType_SpecManaged))
	gens["OsSKU"] = gen.PtrOf(gen.OneConstOf(OSSKU_SpecCBLMariner, OSSKU_SpecUbuntu))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSType_SpecLinux, OSType_SpecWindows))
	gens["PodSubnetID"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.OneConstOf(ScaleSetEvictionPolicy_SpecDeallocate, ScaleSetEvictionPolicy_SpecDelete))
	gens["ScaleSetPriority"] = gen.PtrOf(gen.OneConstOf(ScaleSetPriority_SpecRegular, ScaleSetPriority_SpecSpot))
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AgentPoolType_SpecAvailabilitySet, AgentPoolType_SpecVirtualMachineScaleSets))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
	gens["VnetSubnetID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfig_SpecARMGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfig_SpecARMGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettings_SpecARMGenerator())
}

func Test_ManagedClusterAutoUpgradeProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAutoUpgradeProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAutoUpgradeProfile_SpecARM, ManagedClusterAutoUpgradeProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAutoUpgradeProfile_SpecARM runs a test to see if a specific instance of ManagedClusterAutoUpgradeProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAutoUpgradeProfile_SpecARM(subject ManagedClusterAutoUpgradeProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAutoUpgradeProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAutoUpgradeProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAutoUpgradeProfile_SpecARMGenerator()
var managedClusterAutoUpgradeProfile_specARMGenerator gopter.Gen

// ManagedClusterAutoUpgradeProfile_SpecARMGenerator returns a generator of ManagedClusterAutoUpgradeProfile_SpecARM instances for property testing.
func ManagedClusterAutoUpgradeProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterAutoUpgradeProfile_specARMGenerator != nil {
		return managedClusterAutoUpgradeProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfile_SpecARM(generators)
	managedClusterAutoUpgradeProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAutoUpgradeProfile_SpecARM{}), generators)

	return managedClusterAutoUpgradeProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["UpgradeChannel"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecNodeImage,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecNone,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecPatch,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecRapid,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_SpecStable))
}

func Test_ManagedClusterHTTPProxyConfig_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterHTTPProxyConfig_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterHTTPProxyConfig_SpecARM, ManagedClusterHTTPProxyConfig_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterHTTPProxyConfig_SpecARM runs a test to see if a specific instance of ManagedClusterHTTPProxyConfig_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterHTTPProxyConfig_SpecARM(subject ManagedClusterHTTPProxyConfig_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterHTTPProxyConfig_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterHTTPProxyConfig_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterHTTPProxyConfig_SpecARMGenerator()
var managedClusterHTTPProxyConfig_specARMGenerator gopter.Gen

// ManagedClusterHTTPProxyConfig_SpecARMGenerator returns a generator of ManagedClusterHTTPProxyConfig_SpecARM instances for property testing.
func ManagedClusterHTTPProxyConfig_SpecARMGenerator() gopter.Gen {
	if managedClusterHTTPProxyConfig_specARMGenerator != nil {
		return managedClusterHTTPProxyConfig_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfig_SpecARM(generators)
	managedClusterHTTPProxyConfig_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterHTTPProxyConfig_SpecARM{}), generators)

	return managedClusterHTTPProxyConfig_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfig_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfig_SpecARM(gens map[string]gopter.Gen) {
	gens["HttpProxy"] = gen.PtrOf(gen.AlphaString())
	gens["HttpsProxy"] = gen.PtrOf(gen.AlphaString())
	gens["NoProxy"] = gen.SliceOf(gen.AlphaString())
	gens["TrustedCa"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterPodIdentityProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityProfile_SpecARM, ManagedClusterPodIdentityProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityProfile_SpecARM runs a test to see if a specific instance of ManagedClusterPodIdentityProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityProfile_SpecARM(subject ManagedClusterPodIdentityProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentityProfile_SpecARMGenerator()
var managedClusterPodIdentityProfile_specARMGenerator gopter.Gen

// ManagedClusterPodIdentityProfile_SpecARMGenerator returns a generator of ManagedClusterPodIdentityProfile_SpecARM instances for property testing.
// We first initialize managedClusterPodIdentityProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentityProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentityProfile_specARMGenerator != nil {
		return managedClusterPodIdentityProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM(generators)
	managedClusterPodIdentityProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM(generators)
	managedClusterPodIdentityProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfile_SpecARM{}), generators)

	return managedClusterPodIdentityProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AllowNetworkPluginKubenet"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(ManagedClusterPodIdentity_SpecARMGenerator())
	gens["UserAssignedIdentityExceptions"] = gen.SliceOf(ManagedClusterPodIdentityException_SpecARMGenerator())
}

func Test_ManagedClusterProperties_AutoScalerProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterProperties_AutoScalerProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterProperties_AutoScalerProfile_SpecARM, ManagedClusterProperties_AutoScalerProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterProperties_AutoScalerProfile_SpecARM runs a test to see if a specific instance of ManagedClusterProperties_AutoScalerProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterProperties_AutoScalerProfile_SpecARM(subject ManagedClusterProperties_AutoScalerProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterProperties_AutoScalerProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterProperties_AutoScalerProfile_SpecARM instances for property testing - lazily instantiated
//by ManagedClusterProperties_AutoScalerProfile_SpecARMGenerator()
var managedClusterProperties_autoScalerProfile_specARMGenerator gopter.Gen

// ManagedClusterProperties_AutoScalerProfile_SpecARMGenerator returns a generator of ManagedClusterProperties_AutoScalerProfile_SpecARM instances for property testing.
func ManagedClusterProperties_AutoScalerProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterProperties_autoScalerProfile_specARMGenerator != nil {
		return managedClusterProperties_autoScalerProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterProperties_AutoScalerProfile_SpecARM(generators)
	managedClusterProperties_autoScalerProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_AutoScalerProfile_SpecARM{}), generators)

	return managedClusterProperties_autoScalerProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterProperties_AutoScalerProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterProperties_AutoScalerProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["BalanceSimilarNodeGroups"] = gen.PtrOf(gen.AlphaString())
	gens["Expander"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterProperties_AutoScalerProfile_Expander_SpecLeastWaste,
		ManagedClusterProperties_AutoScalerProfile_Expander_SpecMostPods,
		ManagedClusterProperties_AutoScalerProfile_Expander_SpecPriority,
		ManagedClusterProperties_AutoScalerProfile_Expander_SpecRandom))
	gens["MaxEmptyBulkDelete"] = gen.PtrOf(gen.AlphaString())
	gens["MaxGracefulTerminationSec"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNodeProvisionTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaxTotalUnreadyPercentage"] = gen.PtrOf(gen.AlphaString())
	gens["NewPodScaleUpDelay"] = gen.PtrOf(gen.AlphaString())
	gens["OkTotalUnreadyCount"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterAdd"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterDelete"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterFailure"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnneededTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnreadyTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUtilizationThreshold"] = gen.PtrOf(gen.AlphaString())
	gens["ScanInterval"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithLocalStorage"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithSystemPods"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterServicePrincipalProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterServicePrincipalProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterServicePrincipalProfile_SpecARM, ManagedClusterServicePrincipalProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterServicePrincipalProfile_SpecARM runs a test to see if a specific instance of ManagedClusterServicePrincipalProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterServicePrincipalProfile_SpecARM(subject ManagedClusterServicePrincipalProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterServicePrincipalProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterServicePrincipalProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterServicePrincipalProfile_SpecARMGenerator()
var managedClusterServicePrincipalProfile_specARMGenerator gopter.Gen

// ManagedClusterServicePrincipalProfile_SpecARMGenerator returns a generator of ManagedClusterServicePrincipalProfile_SpecARM instances for property testing.
func ManagedClusterServicePrincipalProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterServicePrincipalProfile_specARMGenerator != nil {
		return managedClusterServicePrincipalProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfile_SpecARM(generators)
	managedClusterServicePrincipalProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterServicePrincipalProfile_SpecARM{}), generators)

	return managedClusterServicePrincipalProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.AlphaString()
	gens["Secret"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterWindowsProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterWindowsProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterWindowsProfile_SpecARM, ManagedClusterWindowsProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterWindowsProfile_SpecARM runs a test to see if a specific instance of ManagedClusterWindowsProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterWindowsProfile_SpecARM(subject ManagedClusterWindowsProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterWindowsProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterWindowsProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterWindowsProfile_SpecARMGenerator()
var managedClusterWindowsProfile_specARMGenerator gopter.Gen

// ManagedClusterWindowsProfile_SpecARMGenerator returns a generator of ManagedClusterWindowsProfile_SpecARM instances for property testing.
func ManagedClusterWindowsProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterWindowsProfile_specARMGenerator != nil {
		return managedClusterWindowsProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterWindowsProfile_SpecARM(generators)
	managedClusterWindowsProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterWindowsProfile_SpecARM{}), generators)

	return managedClusterWindowsProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterWindowsProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterWindowsProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.AlphaString()
	gens["EnableCSIProxy"] = gen.PtrOf(gen.Bool())
	gens["LicenseType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterWindowsProfile_LicenseType_SpecNone, ManagedClusterWindowsProfile_LicenseType_SpecWindows_Server))
}

func Test_PrivateLinkResource_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkResource_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkResource_SpecARM, PrivateLinkResource_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkResource_SpecARM runs a test to see if a specific instance of PrivateLinkResource_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkResource_SpecARM(subject PrivateLinkResource_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkResource_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkResource_SpecARM instances for property testing - lazily instantiated by
//PrivateLinkResource_SpecARMGenerator()
var privateLinkResource_specARMGenerator gopter.Gen

// PrivateLinkResource_SpecARMGenerator returns a generator of PrivateLinkResource_SpecARM instances for property testing.
func PrivateLinkResource_SpecARMGenerator() gopter.Gen {
	if privateLinkResource_specARMGenerator != nil {
		return privateLinkResource_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkResource_SpecARM(generators)
	privateLinkResource_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkResource_SpecARM{}), generators)

	return privateLinkResource_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkResource_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkResource_SpecARM(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMembers"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerServiceSshConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshConfiguration_SpecARM, ContainerServiceSshConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshConfiguration_SpecARM runs a test to see if a specific instance of ContainerServiceSshConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshConfiguration_SpecARM(subject ContainerServiceSshConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshConfiguration_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceSshConfiguration_SpecARMGenerator()
var containerServiceSshConfiguration_specARMGenerator gopter.Gen

// ContainerServiceSshConfiguration_SpecARMGenerator returns a generator of ContainerServiceSshConfiguration_SpecARM instances for property testing.
func ContainerServiceSshConfiguration_SpecARMGenerator() gopter.Gen {
	if containerServiceSshConfiguration_specARMGenerator != nil {
		return containerServiceSshConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerServiceSshConfiguration_SpecARM(generators)
	containerServiceSshConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshConfiguration_SpecARM{}), generators)

	return containerServiceSshConfiguration_specARMGenerator
}

// AddRelatedPropertyGeneratorsForContainerServiceSshConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceSshConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(ContainerServiceSshPublicKey_SpecARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfile_SpecARM, ManagedClusterLoadBalancerProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfile_SpecARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfile_SpecARM(subject ManagedClusterLoadBalancerProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterLoadBalancerProfile_SpecARMGenerator()
var managedClusterLoadBalancerProfile_specARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfile_SpecARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_SpecARM instances for property testing.
// We first initialize managedClusterLoadBalancerProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterLoadBalancerProfile_SpecARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfile_specARMGenerator != nil {
		return managedClusterLoadBalancerProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM(generators)
	managedClusterLoadBalancerProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM(generators)
	managedClusterLoadBalancerProfile_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_SpecARM{}), generators)

	return managedClusterLoadBalancerProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["EffectiveOutboundIPs"] = gen.SliceOf(ResourceReference_SpecARMGenerator())
	gens["ManagedOutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARMGenerator())
	gens["OutboundIPPrefixes"] = gen.PtrOf(ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARMGenerator())
	gens["OutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARMGenerator())
}

func Test_ManagedClusterPodIdentityException_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityException_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityException_SpecARM, ManagedClusterPodIdentityException_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityException_SpecARM runs a test to see if a specific instance of ManagedClusterPodIdentityException_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityException_SpecARM(subject ManagedClusterPodIdentityException_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityException_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityException_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentityException_SpecARMGenerator()
var managedClusterPodIdentityException_specARMGenerator gopter.Gen

// ManagedClusterPodIdentityException_SpecARMGenerator returns a generator of ManagedClusterPodIdentityException_SpecARM instances for property testing.
func ManagedClusterPodIdentityException_SpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentityException_specARMGenerator != nil {
		return managedClusterPodIdentityException_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityException_SpecARM(generators)
	managedClusterPodIdentityException_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityException_SpecARM{}), generators)

	return managedClusterPodIdentityException_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityException_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityException_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Namespace"] = gen.AlphaString()
	gens["PodLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

func Test_ManagedClusterPodIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentity_SpecARM, ManagedClusterPodIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentity_SpecARM runs a test to see if a specific instance of ManagedClusterPodIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentity_SpecARM(subject ManagedClusterPodIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentity_SpecARMGenerator()
var managedClusterPodIdentity_specARMGenerator gopter.Gen

// ManagedClusterPodIdentity_SpecARMGenerator returns a generator of ManagedClusterPodIdentity_SpecARM instances for property testing.
// We first initialize managedClusterPodIdentity_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentity_SpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentity_specARMGenerator != nil {
		return managedClusterPodIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentity_SpecARM(generators)
	managedClusterPodIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentity_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentity_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentity_SpecARM(generators)
	managedClusterPodIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentity_SpecARM{}), generators)

	return managedClusterPodIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["BindingSelector"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Namespace"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentity_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = UserAssignedIdentity_SpecARMGenerator()
}

func Test_ContainerServiceSshPublicKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshPublicKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshPublicKey_SpecARM, ContainerServiceSshPublicKey_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshPublicKey_SpecARM runs a test to see if a specific instance of ContainerServiceSshPublicKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshPublicKey_SpecARM(subject ContainerServiceSshPublicKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshPublicKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshPublicKey_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceSshPublicKey_SpecARMGenerator()
var containerServiceSshPublicKey_specARMGenerator gopter.Gen

// ContainerServiceSshPublicKey_SpecARMGenerator returns a generator of ContainerServiceSshPublicKey_SpecARM instances for property testing.
func ContainerServiceSshPublicKey_SpecARMGenerator() gopter.Gen {
	if containerServiceSshPublicKey_specARMGenerator != nil {
		return containerServiceSshPublicKey_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceSshPublicKey_SpecARM(generators)
	containerServiceSshPublicKey_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshPublicKey_SpecARM{}), generators)

	return containerServiceSshPublicKey_specARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceSshPublicKey_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceSshPublicKey_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.AlphaString()
}

func Test_ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM, ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM(subject ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARMGenerator()
var managedClusterLoadBalancerProfile_managedOutboundIPs_specARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM instances for property testing.
func ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfile_managedOutboundIPs_specARMGenerator != nil {
		return managedClusterLoadBalancerProfile_managedOutboundIPs_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM(generators)
	managedClusterLoadBalancerProfile_managedOutboundIPs_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM{}), generators)

	return managedClusterLoadBalancerProfile_managedOutboundIPs_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfile_ManagedOutboundIPs_SpecARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM, ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM(subject ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARMGenerator()
var managedClusterLoadBalancerProfile_outboundIPPrefixes_specARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM instances for property testing.
func ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfile_outboundIPPrefixes_specARMGenerator != nil {
		return managedClusterLoadBalancerProfile_outboundIPPrefixes_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM(generators)
	managedClusterLoadBalancerProfile_outboundIPPrefixes_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM{}), generators)

	return managedClusterLoadBalancerProfile_outboundIPPrefixes_specARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPPrefixes_SpecARM(gens map[string]gopter.Gen) {
	gens["PublicIPPrefixes"] = gen.SliceOf(ResourceReference_SpecARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM, ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM(subject ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARMGenerator()
var managedClusterLoadBalancerProfile_outboundIPs_specARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM instances for property testing.
func ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfile_outboundIPs_specARMGenerator != nil {
		return managedClusterLoadBalancerProfile_outboundIPs_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM(generators)
	managedClusterLoadBalancerProfile_outboundIPs_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM{}), generators)

	return managedClusterLoadBalancerProfile_outboundIPs_specARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfile_OutboundIPs_SpecARM(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.SliceOf(ResourceReference_SpecARMGenerator())
}

func Test_ResourceReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference_SpecARM, ResourceReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference_SpecARM runs a test to see if a specific instance of ResourceReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference_SpecARM(subject ResourceReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_SpecARM instances for property testing - lazily instantiated by
//ResourceReference_SpecARMGenerator()
var resourceReference_specARMGenerator gopter.Gen

// ResourceReference_SpecARMGenerator returns a generator of ResourceReference_SpecARM instances for property testing.
func ResourceReference_SpecARMGenerator() gopter.Gen {
	if resourceReference_specARMGenerator != nil {
		return resourceReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReference_SpecARM(generators)
	resourceReference_specARMGenerator = gen.Struct(reflect.TypeOf(ResourceReference_SpecARM{}), generators)

	return resourceReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_SpecARM, UserAssignedIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_SpecARM runs a test to see if a specific instance of UserAssignedIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_SpecARM(subject UserAssignedIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_SpecARM instances for property testing - lazily instantiated by
//UserAssignedIdentity_SpecARMGenerator()
var userAssignedIdentity_specARMGenerator gopter.Gen

// UserAssignedIdentity_SpecARMGenerator returns a generator of UserAssignedIdentity_SpecARM instances for property testing.
func UserAssignedIdentity_SpecARMGenerator() gopter.Gen {
	if userAssignedIdentity_specARMGenerator != nil {
		return userAssignedIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_SpecARM(generators)
	userAssignedIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_SpecARM{}), generators)

	return userAssignedIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}
