// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedClusters_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusters_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersSPECARM, ManagedClustersSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersSPECARM runs a test to see if a specific instance of ManagedClusters_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersSPECARM(subject ManagedClusters_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusters_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusters_SPECARM instances for property testing - lazily instantiated by
//ManagedClustersSPECARMGenerator()
var managedClustersSPECARMGenerator gopter.Gen

// ManagedClustersSPECARMGenerator returns a generator of ManagedClusters_SPECARM instances for property testing.
// We first initialize managedClustersSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClustersSPECARMGenerator() gopter.Gen {
	if managedClustersSPECARMGenerator != nil {
		return managedClustersSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersSPECARM(generators)
	managedClustersSPECARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersSPECARM(generators)
	AddRelatedPropertyGeneratorsForManagedClustersSPECARM(generators)
	managedClustersSPECARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SPECARM{}), generators)

	return managedClustersSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClustersSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClustersSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClustersSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersSPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedClusterIdentitySpecARMGenerator())
	gens["Properties"] = gen.PtrOf(ManagedClusterPropertiesSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(ManagedClusterSKUSpecARMGenerator())
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpecARM, ExtendedLocationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocationSpecARMGenerator()
var extendedLocationSpecARMGenerator gopter.Gen

// ExtendedLocationSpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocationSpecARMGenerator() gopter.Gen {
	if extendedLocationSpecARMGenerator != nil {
		return extendedLocationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(generators)
	extendedLocationSpecARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ManagedClusterIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterIdentitySpecARM, ManagedClusterIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterIdentitySpecARM runs a test to see if a specific instance of ManagedClusterIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterIdentitySpecARM(subject ManagedClusterIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterIdentitySpecARMGenerator()
var managedClusterIdentitySpecARMGenerator gopter.Gen

// ManagedClusterIdentitySpecARMGenerator returns a generator of ManagedClusterIdentity_SpecARM instances for property testing.
func ManagedClusterIdentitySpecARMGenerator() gopter.Gen {
	if managedClusterIdentitySpecARMGenerator != nil {
		return managedClusterIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterIdentitySpecARM(generators)
	managedClusterIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterIdentity_SpecARM{}), generators)

	return managedClusterIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedClusterIdentitySpecTypeNone, ManagedClusterIdentitySpecTypeSystemAssigned, ManagedClusterIdentitySpecTypeUserAssigned))
}

func Test_ManagedClusterProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPropertiesSpecARM, ManagedClusterPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPropertiesSpecARM runs a test to see if a specific instance of ManagedClusterProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPropertiesSpecARM(subject ManagedClusterProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterProperties_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPropertiesSpecARMGenerator()
var managedClusterPropertiesSpecARMGenerator gopter.Gen

// ManagedClusterPropertiesSpecARMGenerator returns a generator of ManagedClusterProperties_SpecARM instances for property testing.
// We first initialize managedClusterPropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPropertiesSpecARMGenerator() gopter.Gen {
	if managedClusterPropertiesSpecARMGenerator != nil {
		return managedClusterPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecARM(generators)
	managedClusterPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPropertiesSpecARM(generators)
	managedClusterPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_SpecARM{}), generators)

	return managedClusterPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["DisableLocalAccounts"] = gen.PtrOf(gen.Bool())
	gens["DiskEncryptionSetID"] = gen.PtrOf(gen.AlphaString())
	gens["DnsPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["EnablePodSecurityPolicy"] = gen.PtrOf(gen.Bool())
	gens["EnableRBAC"] = gen.PtrOf(gen.Bool())
	gens["FqdnSubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["KubernetesVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterPropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AadProfile"] = gen.PtrOf(ManagedClusterAADProfileSpecARMGenerator())
	gens["AgentPoolProfiles"] = gen.SliceOf(ManagedClusterAgentPoolProfileSpecARMGenerator())
	gens["ApiServerAccessProfile"] = gen.PtrOf(ManagedClusterAPIServerAccessProfileSpecARMGenerator())
	gens["AutoScalerProfile"] = gen.PtrOf(ManagedClusterPropertiesSpecAutoScalerProfileARMGenerator())
	gens["AutoUpgradeProfile"] = gen.PtrOf(ManagedClusterAutoUpgradeProfileSpecARMGenerator())
	gens["HttpProxyConfig"] = gen.PtrOf(ManagedClusterHTTPProxyConfigSpecARMGenerator())
	gens["LinuxProfile"] = gen.PtrOf(ContainerServiceLinuxProfileSpecARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(ContainerServiceNetworkProfileSpecARMGenerator())
	gens["PodIdentityProfile"] = gen.PtrOf(ManagedClusterPodIdentityProfileSpecARMGenerator())
	gens["PrivateLinkResources"] = gen.SliceOf(PrivateLinkResourceSpecARMGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ManagedClusterServicePrincipalProfileSpecARMGenerator())
	gens["WindowsProfile"] = gen.PtrOf(ManagedClusterWindowsProfileSpecARMGenerator())
}

func Test_ManagedClusterSKU_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterSKU_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterSKUSpecARM, ManagedClusterSKUSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterSKUSpecARM runs a test to see if a specific instance of ManagedClusterSKU_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterSKUSpecARM(subject ManagedClusterSKU_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterSKU_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterSKU_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterSKUSpecARMGenerator()
var managedClusterSKUSpecARMGenerator gopter.Gen

// ManagedClusterSKUSpecARMGenerator returns a generator of ManagedClusterSKU_SpecARM instances for property testing.
func ManagedClusterSKUSpecARMGenerator() gopter.Gen {
	if managedClusterSKUSpecARMGenerator != nil {
		return managedClusterSKUSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterSKUSpecARM(generators)
	managedClusterSKUSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterSKU_SpecARM{}), generators)

	return managedClusterSKUSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterSKUSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterSKUSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKUSpecNameBasic))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKUSpecTierFree, ManagedClusterSKUSpecTierPaid))
}

func Test_ContainerServiceLinuxProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceLinuxProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceLinuxProfileSpecARM, ContainerServiceLinuxProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceLinuxProfileSpecARM runs a test to see if a specific instance of ContainerServiceLinuxProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceLinuxProfileSpecARM(subject ContainerServiceLinuxProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceLinuxProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceLinuxProfile_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceLinuxProfileSpecARMGenerator()
var containerServiceLinuxProfileSpecARMGenerator gopter.Gen

// ContainerServiceLinuxProfileSpecARMGenerator returns a generator of ContainerServiceLinuxProfile_SpecARM instances for property testing.
// We first initialize containerServiceLinuxProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceLinuxProfileSpecARMGenerator() gopter.Gen {
	if containerServiceLinuxProfileSpecARMGenerator != nil {
		return containerServiceLinuxProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileSpecARM(generators)
	containerServiceLinuxProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileSpecARM(generators)
	containerServiceLinuxProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfile_SpecARM{}), generators)

	return containerServiceLinuxProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileSpecARM(gens map[string]gopter.Gen) {
	gens["Ssh"] = ContainerServiceSshConfigurationSpecARMGenerator()
}

func Test_ContainerServiceNetworkProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceNetworkProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceNetworkProfileSpecARM, ContainerServiceNetworkProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceNetworkProfileSpecARM runs a test to see if a specific instance of ContainerServiceNetworkProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceNetworkProfileSpecARM(subject ContainerServiceNetworkProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceNetworkProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceNetworkProfile_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceNetworkProfileSpecARMGenerator()
var containerServiceNetworkProfileSpecARMGenerator gopter.Gen

// ContainerServiceNetworkProfileSpecARMGenerator returns a generator of ContainerServiceNetworkProfile_SpecARM instances for property testing.
// We first initialize containerServiceNetworkProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceNetworkProfileSpecARMGenerator() gopter.Gen {
	if containerServiceNetworkProfileSpecARMGenerator != nil {
		return containerServiceNetworkProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileSpecARM(generators)
	containerServiceNetworkProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileSpecARM(generators)
	containerServiceNetworkProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfile_SpecARM{}), generators)

	return containerServiceNetworkProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileSpecARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerSku"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfileSpecLoadBalancerSkuBasic, ContainerServiceNetworkProfileSpecLoadBalancerSkuStandard))
	gens["NetworkMode"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfileSpecNetworkModeBridge, ContainerServiceNetworkProfileSpecNetworkModeTransparent))
	gens["NetworkPlugin"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfileSpecNetworkPluginAzure, ContainerServiceNetworkProfileSpecNetworkPluginKubenet))
	gens["NetworkPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfileSpecNetworkPolicyAzure, ContainerServiceNetworkProfileSpecNetworkPolicyCalico))
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfileSpecOutboundTypeLoadBalancer, ContainerServiceNetworkProfileSpecOutboundTypeUserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileSpecARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(ManagedClusterLoadBalancerProfileSpecARMGenerator())
}

func Test_ManagedClusterAADProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAADProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAADProfileSpecARM, ManagedClusterAADProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAADProfileSpecARM runs a test to see if a specific instance of ManagedClusterAADProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAADProfileSpecARM(subject ManagedClusterAADProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAADProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAADProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAADProfileSpecARMGenerator()
var managedClusterAADProfileSpecARMGenerator gopter.Gen

// ManagedClusterAADProfileSpecARMGenerator returns a generator of ManagedClusterAADProfile_SpecARM instances for property testing.
func ManagedClusterAADProfileSpecARMGenerator() gopter.Gen {
	if managedClusterAADProfileSpecARMGenerator != nil {
		return managedClusterAADProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAADProfileSpecARM(generators)
	managedClusterAADProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAADProfile_SpecARM{}), generators)

	return managedClusterAADProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAADProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAADProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AdminGroupObjectIDs"] = gen.SliceOf(gen.AlphaString())
	gens["ClientAppID"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAzureRBAC"] = gen.PtrOf(gen.Bool())
	gens["Managed"] = gen.PtrOf(gen.Bool())
	gens["ServerAppID"] = gen.PtrOf(gen.AlphaString())
	gens["ServerAppSecret"] = gen.PtrOf(gen.AlphaString())
	gens["TenantID"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAPIServerAccessProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAPIServerAccessProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAPIServerAccessProfileSpecARM, ManagedClusterAPIServerAccessProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAPIServerAccessProfileSpecARM runs a test to see if a specific instance of ManagedClusterAPIServerAccessProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAPIServerAccessProfileSpecARM(subject ManagedClusterAPIServerAccessProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAPIServerAccessProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAPIServerAccessProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAPIServerAccessProfileSpecARMGenerator()
var managedClusterAPIServerAccessProfileSpecARMGenerator gopter.Gen

// ManagedClusterAPIServerAccessProfileSpecARMGenerator returns a generator of ManagedClusterAPIServerAccessProfile_SpecARM instances for property testing.
func ManagedClusterAPIServerAccessProfileSpecARMGenerator() gopter.Gen {
	if managedClusterAPIServerAccessProfileSpecARMGenerator != nil {
		return managedClusterAPIServerAccessProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileSpecARM(generators)
	managedClusterAPIServerAccessProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAPIServerAccessProfile_SpecARM{}), generators)

	return managedClusterAPIServerAccessProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AuthorizedIPRanges"] = gen.SliceOf(gen.AlphaString())
	gens["EnablePrivateCluster"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateClusterPublicFQDN"] = gen.PtrOf(gen.Bool())
	gens["PrivateDNSZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAgentPoolProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAgentPoolProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAgentPoolProfileSpecARM, ManagedClusterAgentPoolProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAgentPoolProfileSpecARM runs a test to see if a specific instance of ManagedClusterAgentPoolProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAgentPoolProfileSpecARM(subject ManagedClusterAgentPoolProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAgentPoolProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAgentPoolProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAgentPoolProfileSpecARMGenerator()
var managedClusterAgentPoolProfileSpecARMGenerator gopter.Gen

// ManagedClusterAgentPoolProfileSpecARMGenerator returns a generator of ManagedClusterAgentPoolProfile_SpecARM instances for property testing.
// We first initialize managedClusterAgentPoolProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterAgentPoolProfileSpecARMGenerator() gopter.Gen {
	if managedClusterAgentPoolProfileSpecARMGenerator != nil {
		return managedClusterAgentPoolProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM(generators)
	managedClusterAgentPoolProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM(generators)
	managedClusterAgentPoolProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfile_SpecARM{}), generators)

	return managedClusterAgentPoolProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.OneConstOf(
		GPUInstanceProfile_SpecMIG1G,
		GPUInstanceProfile_SpecMIG2G,
		GPUInstanceProfile_SpecMIG3G,
		GPUInstanceProfile_SpecMIG4G,
		GPUInstanceProfile_SpecMIG7G))
	gens["KubeletDiskType"] = gen.PtrOf(gen.OneConstOf(KubeletDiskType_SpecOS, KubeletDiskType_SpecTemporary))
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(AgentPoolMode_SpecSystem, AgentPoolMode_SpecUser))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodePublicIPPrefixID"] = gen.PtrOf(gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.OneConstOf(OSDiskType_SpecEphemeral, OSDiskType_SpecManaged))
	gens["OsSKU"] = gen.PtrOf(gen.OneConstOf(OSSKU_SpecCBLMariner, OSSKU_SpecUbuntu))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSType_SpecLinux, OSType_SpecWindows))
	gens["PodSubnetID"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.OneConstOf(ScaleSetEvictionPolicy_SpecDeallocate, ScaleSetEvictionPolicy_SpecDelete))
	gens["ScaleSetPriority"] = gen.PtrOf(gen.OneConstOf(ScaleSetPriority_SpecRegular, ScaleSetPriority_SpecSpot))
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AgentPoolType_SpecAvailabilitySet, AgentPoolType_SpecVirtualMachineScaleSets))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
	gens["VnetSubnetID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileSpecARM(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfigSpecARMGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfigSpecARMGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettingsSpecARMGenerator())
}

func Test_ManagedClusterAutoUpgradeProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAutoUpgradeProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAutoUpgradeProfileSpecARM, ManagedClusterAutoUpgradeProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAutoUpgradeProfileSpecARM runs a test to see if a specific instance of ManagedClusterAutoUpgradeProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAutoUpgradeProfileSpecARM(subject ManagedClusterAutoUpgradeProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAutoUpgradeProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAutoUpgradeProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterAutoUpgradeProfileSpecARMGenerator()
var managedClusterAutoUpgradeProfileSpecARMGenerator gopter.Gen

// ManagedClusterAutoUpgradeProfileSpecARMGenerator returns a generator of ManagedClusterAutoUpgradeProfile_SpecARM instances for property testing.
func ManagedClusterAutoUpgradeProfileSpecARMGenerator() gopter.Gen {
	if managedClusterAutoUpgradeProfileSpecARMGenerator != nil {
		return managedClusterAutoUpgradeProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileSpecARM(generators)
	managedClusterAutoUpgradeProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAutoUpgradeProfile_SpecARM{}), generators)

	return managedClusterAutoUpgradeProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileSpecARM(gens map[string]gopter.Gen) {
	gens["UpgradeChannel"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterAutoUpgradeProfileSpecUpgradeChannelNodeImage,
		ManagedClusterAutoUpgradeProfileSpecUpgradeChannelNone,
		ManagedClusterAutoUpgradeProfileSpecUpgradeChannelPatch,
		ManagedClusterAutoUpgradeProfileSpecUpgradeChannelRapid,
		ManagedClusterAutoUpgradeProfileSpecUpgradeChannelStable))
}

func Test_ManagedClusterHTTPProxyConfig_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterHTTPProxyConfig_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterHTTPProxyConfigSpecARM, ManagedClusterHTTPProxyConfigSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterHTTPProxyConfigSpecARM runs a test to see if a specific instance of ManagedClusterHTTPProxyConfig_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterHTTPProxyConfigSpecARM(subject ManagedClusterHTTPProxyConfig_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterHTTPProxyConfig_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterHTTPProxyConfig_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterHTTPProxyConfigSpecARMGenerator()
var managedClusterHTTPProxyConfigSpecARMGenerator gopter.Gen

// ManagedClusterHTTPProxyConfigSpecARMGenerator returns a generator of ManagedClusterHTTPProxyConfig_SpecARM instances for property testing.
func ManagedClusterHTTPProxyConfigSpecARMGenerator() gopter.Gen {
	if managedClusterHTTPProxyConfigSpecARMGenerator != nil {
		return managedClusterHTTPProxyConfigSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigSpecARM(generators)
	managedClusterHTTPProxyConfigSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterHTTPProxyConfig_SpecARM{}), generators)

	return managedClusterHTTPProxyConfigSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigSpecARM(gens map[string]gopter.Gen) {
	gens["HttpProxy"] = gen.PtrOf(gen.AlphaString())
	gens["HttpsProxy"] = gen.PtrOf(gen.AlphaString())
	gens["NoProxy"] = gen.SliceOf(gen.AlphaString())
	gens["TrustedCa"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterPodIdentityProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityProfileSpecARM, ManagedClusterPodIdentityProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityProfileSpecARM runs a test to see if a specific instance of ManagedClusterPodIdentityProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityProfileSpecARM(subject ManagedClusterPodIdentityProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentityProfileSpecARMGenerator()
var managedClusterPodIdentityProfileSpecARMGenerator gopter.Gen

// ManagedClusterPodIdentityProfileSpecARMGenerator returns a generator of ManagedClusterPodIdentityProfile_SpecARM instances for property testing.
// We first initialize managedClusterPodIdentityProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentityProfileSpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentityProfileSpecARMGenerator != nil {
		return managedClusterPodIdentityProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM(generators)
	managedClusterPodIdentityProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM(generators)
	managedClusterPodIdentityProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfile_SpecARM{}), generators)

	return managedClusterPodIdentityProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AllowNetworkPluginKubenet"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileSpecARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(ManagedClusterPodIdentitySpecARMGenerator())
	gens["UserAssignedIdentityExceptions"] = gen.SliceOf(ManagedClusterPodIdentityExceptionSpecARMGenerator())
}

func Test_ManagedClusterProperties_Spec_AutoScalerProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterProperties_Spec_AutoScalerProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPropertiesSpecAutoScalerProfileARM, ManagedClusterPropertiesSpecAutoScalerProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPropertiesSpecAutoScalerProfileARM runs a test to see if a specific instance of ManagedClusterProperties_Spec_AutoScalerProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPropertiesSpecAutoScalerProfileARM(subject ManagedClusterProperties_Spec_AutoScalerProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterProperties_Spec_AutoScalerProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterProperties_Spec_AutoScalerProfileARM instances for property testing - lazily instantiated
//by ManagedClusterPropertiesSpecAutoScalerProfileARMGenerator()
var managedClusterPropertiesSpecAutoScalerProfileARMGenerator gopter.Gen

// ManagedClusterPropertiesSpecAutoScalerProfileARMGenerator returns a generator of ManagedClusterProperties_Spec_AutoScalerProfileARM instances for property testing.
func ManagedClusterPropertiesSpecAutoScalerProfileARMGenerator() gopter.Gen {
	if managedClusterPropertiesSpecAutoScalerProfileARMGenerator != nil {
		return managedClusterPropertiesSpecAutoScalerProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecAutoScalerProfileARM(generators)
	managedClusterPropertiesSpecAutoScalerProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterProperties_Spec_AutoScalerProfileARM{}), generators)

	return managedClusterPropertiesSpecAutoScalerProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecAutoScalerProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPropertiesSpecAutoScalerProfileARM(gens map[string]gopter.Gen) {
	gens["BalanceSimilarNodeGroups"] = gen.PtrOf(gen.AlphaString())
	gens["Expander"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterPropertiesSpecAutoScalerProfileExpanderLeastWaste,
		ManagedClusterPropertiesSpecAutoScalerProfileExpanderMostPods,
		ManagedClusterPropertiesSpecAutoScalerProfileExpanderPriority,
		ManagedClusterPropertiesSpecAutoScalerProfileExpanderRandom))
	gens["MaxEmptyBulkDelete"] = gen.PtrOf(gen.AlphaString())
	gens["MaxGracefulTerminationSec"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNodeProvisionTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaxTotalUnreadyPercentage"] = gen.PtrOf(gen.AlphaString())
	gens["NewPodScaleUpDelay"] = gen.PtrOf(gen.AlphaString())
	gens["OkTotalUnreadyCount"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterAdd"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterDelete"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterFailure"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnneededTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnreadyTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUtilizationThreshold"] = gen.PtrOf(gen.AlphaString())
	gens["ScanInterval"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithLocalStorage"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithSystemPods"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterServicePrincipalProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterServicePrincipalProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterServicePrincipalProfileSpecARM, ManagedClusterServicePrincipalProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterServicePrincipalProfileSpecARM runs a test to see if a specific instance of ManagedClusterServicePrincipalProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterServicePrincipalProfileSpecARM(subject ManagedClusterServicePrincipalProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterServicePrincipalProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterServicePrincipalProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterServicePrincipalProfileSpecARMGenerator()
var managedClusterServicePrincipalProfileSpecARMGenerator gopter.Gen

// ManagedClusterServicePrincipalProfileSpecARMGenerator returns a generator of ManagedClusterServicePrincipalProfile_SpecARM instances for property testing.
func ManagedClusterServicePrincipalProfileSpecARMGenerator() gopter.Gen {
	if managedClusterServicePrincipalProfileSpecARMGenerator != nil {
		return managedClusterServicePrincipalProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileSpecARM(generators)
	managedClusterServicePrincipalProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterServicePrincipalProfile_SpecARM{}), generators)

	return managedClusterServicePrincipalProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileSpecARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.AlphaString()
	gens["Secret"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterWindowsProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterWindowsProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterWindowsProfileSpecARM, ManagedClusterWindowsProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterWindowsProfileSpecARM runs a test to see if a specific instance of ManagedClusterWindowsProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterWindowsProfileSpecARM(subject ManagedClusterWindowsProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterWindowsProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterWindowsProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterWindowsProfileSpecARMGenerator()
var managedClusterWindowsProfileSpecARMGenerator gopter.Gen

// ManagedClusterWindowsProfileSpecARMGenerator returns a generator of ManagedClusterWindowsProfile_SpecARM instances for property testing.
func ManagedClusterWindowsProfileSpecARMGenerator() gopter.Gen {
	if managedClusterWindowsProfileSpecARMGenerator != nil {
		return managedClusterWindowsProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileSpecARM(generators)
	managedClusterWindowsProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterWindowsProfile_SpecARM{}), generators)

	return managedClusterWindowsProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.AlphaString()
	gens["EnableCSIProxy"] = gen.PtrOf(gen.Bool())
	gens["LicenseType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterWindowsProfileSpecLicenseTypeNone, ManagedClusterWindowsProfileSpecLicenseTypeWindowsServer))
}

func Test_PrivateLinkResource_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkResource_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkResourceSpecARM, PrivateLinkResourceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkResourceSpecARM runs a test to see if a specific instance of PrivateLinkResource_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkResourceSpecARM(subject PrivateLinkResource_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkResource_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkResource_SpecARM instances for property testing - lazily instantiated by
//PrivateLinkResourceSpecARMGenerator()
var privateLinkResourceSpecARMGenerator gopter.Gen

// PrivateLinkResourceSpecARMGenerator returns a generator of PrivateLinkResource_SpecARM instances for property testing.
func PrivateLinkResourceSpecARMGenerator() gopter.Gen {
	if privateLinkResourceSpecARMGenerator != nil {
		return privateLinkResourceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkResourceSpecARM(generators)
	privateLinkResourceSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkResource_SpecARM{}), generators)

	return privateLinkResourceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkResourceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkResourceSpecARM(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMembers"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerServiceSshConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshConfigurationSpecARM, ContainerServiceSshConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshConfigurationSpecARM runs a test to see if a specific instance of ContainerServiceSshConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshConfigurationSpecARM(subject ContainerServiceSshConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshConfiguration_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceSshConfigurationSpecARMGenerator()
var containerServiceSshConfigurationSpecARMGenerator gopter.Gen

// ContainerServiceSshConfigurationSpecARMGenerator returns a generator of ContainerServiceSshConfiguration_SpecARM instances for property testing.
func ContainerServiceSshConfigurationSpecARMGenerator() gopter.Gen {
	if containerServiceSshConfigurationSpecARMGenerator != nil {
		return containerServiceSshConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationSpecARM(generators)
	containerServiceSshConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshConfiguration_SpecARM{}), generators)

	return containerServiceSshConfigurationSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(ContainerServiceSshPublicKeySpecARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecARM, ManagedClusterLoadBalancerProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecARM(subject ManagedClusterLoadBalancerProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterLoadBalancerProfileSpecARMGenerator()
var managedClusterLoadBalancerProfileSpecARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileSpecARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_SpecARM instances for property testing.
// We first initialize managedClusterLoadBalancerProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterLoadBalancerProfileSpecARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileSpecARMGenerator != nil {
		return managedClusterLoadBalancerProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM(generators)
	managedClusterLoadBalancerProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM(generators)
	managedClusterLoadBalancerProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_SpecARM{}), generators)

	return managedClusterLoadBalancerProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecARM(gens map[string]gopter.Gen) {
	gens["EffectiveOutboundIPs"] = gen.SliceOf(ResourceReferenceSpecARMGenerator())
	gens["ManagedOutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator())
	gens["OutboundIPPrefixes"] = gen.PtrOf(ManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator())
	gens["OutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator())
}

func Test_ManagedClusterPodIdentityException_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityException_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityExceptionSpecARM, ManagedClusterPodIdentityExceptionSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityExceptionSpecARM runs a test to see if a specific instance of ManagedClusterPodIdentityException_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityExceptionSpecARM(subject ManagedClusterPodIdentityException_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityException_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityException_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentityExceptionSpecARMGenerator()
var managedClusterPodIdentityExceptionSpecARMGenerator gopter.Gen

// ManagedClusterPodIdentityExceptionSpecARMGenerator returns a generator of ManagedClusterPodIdentityException_SpecARM instances for property testing.
func ManagedClusterPodIdentityExceptionSpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentityExceptionSpecARMGenerator != nil {
		return managedClusterPodIdentityExceptionSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionSpecARM(generators)
	managedClusterPodIdentityExceptionSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityException_SpecARM{}), generators)

	return managedClusterPodIdentityExceptionSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Namespace"] = gen.AlphaString()
	gens["PodLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

func Test_ManagedClusterPodIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentitySpecARM, ManagedClusterPodIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentitySpecARM runs a test to see if a specific instance of ManagedClusterPodIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentitySpecARM(subject ManagedClusterPodIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedClusterPodIdentitySpecARMGenerator()
var managedClusterPodIdentitySpecARMGenerator gopter.Gen

// ManagedClusterPodIdentitySpecARMGenerator returns a generator of ManagedClusterPodIdentity_SpecARM instances for property testing.
// We first initialize managedClusterPodIdentitySpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentitySpecARMGenerator() gopter.Gen {
	if managedClusterPodIdentitySpecARMGenerator != nil {
		return managedClusterPodIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentitySpecARM(generators)
	managedClusterPodIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentity_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentitySpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentitySpecARM(generators)
	managedClusterPodIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentity_SpecARM{}), generators)

	return managedClusterPodIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["BindingSelector"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Namespace"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentitySpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = UserAssignedIdentitySpecARMGenerator()
}

func Test_ContainerServiceSshPublicKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshPublicKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshPublicKeySpecARM, ContainerServiceSshPublicKeySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshPublicKeySpecARM runs a test to see if a specific instance of ContainerServiceSshPublicKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshPublicKeySpecARM(subject ContainerServiceSshPublicKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshPublicKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshPublicKey_SpecARM instances for property testing - lazily instantiated by
//ContainerServiceSshPublicKeySpecARMGenerator()
var containerServiceSshPublicKeySpecARMGenerator gopter.Gen

// ContainerServiceSshPublicKeySpecARMGenerator returns a generator of ContainerServiceSshPublicKey_SpecARM instances for property testing.
func ContainerServiceSshPublicKeySpecARMGenerator() gopter.Gen {
	if containerServiceSshPublicKeySpecARMGenerator != nil {
		return containerServiceSshPublicKeySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeySpecARM(generators)
	containerServiceSshPublicKeySpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshPublicKey_SpecARM{}), generators)

	return containerServiceSshPublicKeySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeySpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.AlphaString()
}

func Test_ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM, ManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM(subject ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator()
var managedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM instances for property testing.
func ManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator != nil {
		return managedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM(generators)
	managedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_Spec_ManagedOutboundIPsARM{}), generators)

	return managedClusterLoadBalancerProfileSpecManagedOutboundIPsARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecManagedOutboundIPsARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM, ManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM(subject ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator()
var managedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM instances for property testing.
func ManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator != nil {
		return managedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM(generators)
	managedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_Spec_OutboundIPPrefixesARM{}), generators)

	return managedClusterLoadBalancerProfileSpecOutboundIPPrefixesARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPPrefixesARM(gens map[string]gopter.Gen) {
	gens["PublicIPPrefixes"] = gen.SliceOf(ResourceReferenceSpecARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPsARM, ManagedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPsARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileSpecOutboundIPsARM(subject ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM instances for property testing - lazily
//instantiated by ManagedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator()
var managedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator returns a generator of ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM instances for property testing.
func ManagedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator != nil {
		return managedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPsARM(generators)
	managedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfile_Spec_OutboundIPsARM{}), generators)

	return managedClusterLoadBalancerProfileSpecOutboundIPsARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileSpecOutboundIPsARM(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.SliceOf(ResourceReferenceSpecARMGenerator())
}

func Test_ResourceReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReferenceSpecARM, ResourceReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReferenceSpecARM runs a test to see if a specific instance of ResourceReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReferenceSpecARM(subject ResourceReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_SpecARM instances for property testing - lazily instantiated by
//ResourceReferenceSpecARMGenerator()
var resourceReferenceSpecARMGenerator gopter.Gen

// ResourceReferenceSpecARMGenerator returns a generator of ResourceReference_SpecARM instances for property testing.
func ResourceReferenceSpecARMGenerator() gopter.Gen {
	if resourceReferenceSpecARMGenerator != nil {
		return resourceReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReferenceSpecARM(generators)
	resourceReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(ResourceReference_SpecARM{}), generators)

	return resourceReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySpecARM, UserAssignedIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySpecARM runs a test to see if a specific instance of UserAssignedIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySpecARM(subject UserAssignedIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_SpecARM instances for property testing - lazily instantiated by
//UserAssignedIdentitySpecARMGenerator()
var userAssignedIdentitySpecARMGenerator gopter.Gen

// UserAssignedIdentitySpecARMGenerator returns a generator of UserAssignedIdentity_SpecARM instances for property testing.
func UserAssignedIdentitySpecARMGenerator() gopter.Gen {
	if userAssignedIdentitySpecARMGenerator != nil {
		return userAssignedIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySpecARM(generators)
	userAssignedIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_SpecARM{}), generators)

	return userAssignedIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}
