// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240402preview

import (
	"encoding/json"
	v20240402ps "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20240402preview/storage"
	v20240901s "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20240901/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AgentPoolArtifactStreamingProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolArtifactStreamingProfile to AgentPoolArtifactStreamingProfile via AssignProperties_To_AgentPoolArtifactStreamingProfile & AssignProperties_From_AgentPoolArtifactStreamingProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile, AgentPoolArtifactStreamingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile tests if a specific instance of AgentPoolArtifactStreamingProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile(subject AgentPoolArtifactStreamingProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolArtifactStreamingProfile
	err := copied.AssignProperties_To_AgentPoolArtifactStreamingProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolArtifactStreamingProfile
	err = actual.AssignProperties_From_AgentPoolArtifactStreamingProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolArtifactStreamingProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolArtifactStreamingProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolArtifactStreamingProfile, AgentPoolArtifactStreamingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolArtifactStreamingProfile runs a test to see if a specific instance of AgentPoolArtifactStreamingProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolArtifactStreamingProfile(subject AgentPoolArtifactStreamingProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolArtifactStreamingProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolArtifactStreamingProfile instances for property testing - lazily instantiated by
// AgentPoolArtifactStreamingProfileGenerator()
var agentPoolArtifactStreamingProfileGenerator gopter.Gen

// AgentPoolArtifactStreamingProfileGenerator returns a generator of AgentPoolArtifactStreamingProfile instances for property testing.
func AgentPoolArtifactStreamingProfileGenerator() gopter.Gen {
	if agentPoolArtifactStreamingProfileGenerator != nil {
		return agentPoolArtifactStreamingProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile(generators)
	agentPoolArtifactStreamingProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolArtifactStreamingProfile{}), generators)

	return agentPoolArtifactStreamingProfileGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AgentPoolArtifactStreamingProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolArtifactStreamingProfile_STATUS to AgentPoolArtifactStreamingProfile_STATUS via AssignProperties_To_AgentPoolArtifactStreamingProfile_STATUS & AssignProperties_From_AgentPoolArtifactStreamingProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile_STATUS, AgentPoolArtifactStreamingProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile_STATUS tests if a specific instance of AgentPoolArtifactStreamingProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolArtifactStreamingProfile_STATUS(subject AgentPoolArtifactStreamingProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolArtifactStreamingProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolArtifactStreamingProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolArtifactStreamingProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolArtifactStreamingProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolArtifactStreamingProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolArtifactStreamingProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolArtifactStreamingProfile_STATUS, AgentPoolArtifactStreamingProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolArtifactStreamingProfile_STATUS runs a test to see if a specific instance of AgentPoolArtifactStreamingProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolArtifactStreamingProfile_STATUS(subject AgentPoolArtifactStreamingProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolArtifactStreamingProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolArtifactStreamingProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolArtifactStreamingProfile_STATUSGenerator()
var agentPoolArtifactStreamingProfile_STATUSGenerator gopter.Gen

// AgentPoolArtifactStreamingProfile_STATUSGenerator returns a generator of AgentPoolArtifactStreamingProfile_STATUS instances for property testing.
func AgentPoolArtifactStreamingProfile_STATUSGenerator() gopter.Gen {
	if agentPoolArtifactStreamingProfile_STATUSGenerator != nil {
		return agentPoolArtifactStreamingProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile_STATUS(generators)
	agentPoolArtifactStreamingProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolArtifactStreamingProfile_STATUS{}), generators)

	return agentPoolArtifactStreamingProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolArtifactStreamingProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AgentPoolGPUProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolGPUProfile to AgentPoolGPUProfile via AssignProperties_To_AgentPoolGPUProfile & AssignProperties_From_AgentPoolGPUProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolGPUProfile, AgentPoolGPUProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolGPUProfile tests if a specific instance of AgentPoolGPUProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolGPUProfile(subject AgentPoolGPUProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolGPUProfile
	err := copied.AssignProperties_To_AgentPoolGPUProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolGPUProfile
	err = actual.AssignProperties_From_AgentPoolGPUProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolGPUProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolGPUProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolGPUProfile, AgentPoolGPUProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolGPUProfile runs a test to see if a specific instance of AgentPoolGPUProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolGPUProfile(subject AgentPoolGPUProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolGPUProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolGPUProfile instances for property testing - lazily instantiated by
// AgentPoolGPUProfileGenerator()
var agentPoolGPUProfileGenerator gopter.Gen

// AgentPoolGPUProfileGenerator returns a generator of AgentPoolGPUProfile instances for property testing.
func AgentPoolGPUProfileGenerator() gopter.Gen {
	if agentPoolGPUProfileGenerator != nil {
		return agentPoolGPUProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolGPUProfile(generators)
	agentPoolGPUProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolGPUProfile{}), generators)

	return agentPoolGPUProfileGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolGPUProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolGPUProfile(gens map[string]gopter.Gen) {
	gens["InstallGPUDriver"] = gen.PtrOf(gen.Bool())
}

func Test_AgentPoolGPUProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolGPUProfile_STATUS to AgentPoolGPUProfile_STATUS via AssignProperties_To_AgentPoolGPUProfile_STATUS & AssignProperties_From_AgentPoolGPUProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolGPUProfile_STATUS, AgentPoolGPUProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolGPUProfile_STATUS tests if a specific instance of AgentPoolGPUProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolGPUProfile_STATUS(subject AgentPoolGPUProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolGPUProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolGPUProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolGPUProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolGPUProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolGPUProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolGPUProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolGPUProfile_STATUS, AgentPoolGPUProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolGPUProfile_STATUS runs a test to see if a specific instance of AgentPoolGPUProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolGPUProfile_STATUS(subject AgentPoolGPUProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolGPUProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolGPUProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolGPUProfile_STATUSGenerator()
var agentPoolGPUProfile_STATUSGenerator gopter.Gen

// AgentPoolGPUProfile_STATUSGenerator returns a generator of AgentPoolGPUProfile_STATUS instances for property testing.
func AgentPoolGPUProfile_STATUSGenerator() gopter.Gen {
	if agentPoolGPUProfile_STATUSGenerator != nil {
		return agentPoolGPUProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolGPUProfile_STATUS(generators)
	agentPoolGPUProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolGPUProfile_STATUS{}), generators)

	return agentPoolGPUProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolGPUProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolGPUProfile_STATUS(gens map[string]gopter.Gen) {
	gens["InstallGPUDriver"] = gen.PtrOf(gen.Bool())
}

func Test_AgentPoolGatewayProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolGatewayProfile to AgentPoolGatewayProfile via AssignProperties_To_AgentPoolGatewayProfile & AssignProperties_From_AgentPoolGatewayProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolGatewayProfile, AgentPoolGatewayProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolGatewayProfile tests if a specific instance of AgentPoolGatewayProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolGatewayProfile(subject AgentPoolGatewayProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolGatewayProfile
	err := copied.AssignProperties_To_AgentPoolGatewayProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolGatewayProfile
	err = actual.AssignProperties_From_AgentPoolGatewayProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolGatewayProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolGatewayProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolGatewayProfile, AgentPoolGatewayProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolGatewayProfile runs a test to see if a specific instance of AgentPoolGatewayProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolGatewayProfile(subject AgentPoolGatewayProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolGatewayProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolGatewayProfile instances for property testing - lazily instantiated by
// AgentPoolGatewayProfileGenerator()
var agentPoolGatewayProfileGenerator gopter.Gen

// AgentPoolGatewayProfileGenerator returns a generator of AgentPoolGatewayProfile instances for property testing.
func AgentPoolGatewayProfileGenerator() gopter.Gen {
	if agentPoolGatewayProfileGenerator != nil {
		return agentPoolGatewayProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile(generators)
	agentPoolGatewayProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolGatewayProfile{}), generators)

	return agentPoolGatewayProfileGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile(gens map[string]gopter.Gen) {
	gens["PublicIPPrefixSize"] = gen.PtrOf(gen.Int())
}

func Test_AgentPoolGatewayProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolGatewayProfile_STATUS to AgentPoolGatewayProfile_STATUS via AssignProperties_To_AgentPoolGatewayProfile_STATUS & AssignProperties_From_AgentPoolGatewayProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolGatewayProfile_STATUS, AgentPoolGatewayProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolGatewayProfile_STATUS tests if a specific instance of AgentPoolGatewayProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolGatewayProfile_STATUS(subject AgentPoolGatewayProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolGatewayProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolGatewayProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolGatewayProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolGatewayProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolGatewayProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolGatewayProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolGatewayProfile_STATUS, AgentPoolGatewayProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolGatewayProfile_STATUS runs a test to see if a specific instance of AgentPoolGatewayProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolGatewayProfile_STATUS(subject AgentPoolGatewayProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolGatewayProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolGatewayProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolGatewayProfile_STATUSGenerator()
var agentPoolGatewayProfile_STATUSGenerator gopter.Gen

// AgentPoolGatewayProfile_STATUSGenerator returns a generator of AgentPoolGatewayProfile_STATUS instances for property testing.
func AgentPoolGatewayProfile_STATUSGenerator() gopter.Gen {
	if agentPoolGatewayProfile_STATUSGenerator != nil {
		return agentPoolGatewayProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile_STATUS(generators)
	agentPoolGatewayProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolGatewayProfile_STATUS{}), generators)

	return agentPoolGatewayProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolGatewayProfile_STATUS(gens map[string]gopter.Gen) {
	gens["PublicIPPrefixSize"] = gen.PtrOf(gen.Int())
}

func Test_AgentPoolNetworkProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolNetworkProfile to AgentPoolNetworkProfile via AssignProperties_To_AgentPoolNetworkProfile & AssignProperties_From_AgentPoolNetworkProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolNetworkProfile, AgentPoolNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolNetworkProfile tests if a specific instance of AgentPoolNetworkProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolNetworkProfile(subject AgentPoolNetworkProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolNetworkProfile
	err := copied.AssignProperties_To_AgentPoolNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolNetworkProfile
	err = actual.AssignProperties_From_AgentPoolNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolNetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolNetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolNetworkProfile, AgentPoolNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolNetworkProfile runs a test to see if a specific instance of AgentPoolNetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolNetworkProfile(subject AgentPoolNetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolNetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolNetworkProfile instances for property testing - lazily instantiated by
// AgentPoolNetworkProfileGenerator()
var agentPoolNetworkProfileGenerator gopter.Gen

// AgentPoolNetworkProfileGenerator returns a generator of AgentPoolNetworkProfile instances for property testing.
func AgentPoolNetworkProfileGenerator() gopter.Gen {
	if agentPoolNetworkProfileGenerator != nil {
		return agentPoolNetworkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile(generators)
	agentPoolNetworkProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolNetworkProfile{}), generators)

	return agentPoolNetworkProfileGenerator
}

// AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile(gens map[string]gopter.Gen) {
	gens["AllowedHostPorts"] = gen.SliceOf(PortRangeGenerator())
	gens["NodePublicIPTags"] = gen.SliceOf(IPTagGenerator())
}

func Test_AgentPoolNetworkProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolNetworkProfile_STATUS to AgentPoolNetworkProfile_STATUS via AssignProperties_To_AgentPoolNetworkProfile_STATUS & AssignProperties_From_AgentPoolNetworkProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolNetworkProfile_STATUS, AgentPoolNetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolNetworkProfile_STATUS tests if a specific instance of AgentPoolNetworkProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolNetworkProfile_STATUS(subject AgentPoolNetworkProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolNetworkProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolNetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolNetworkProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolNetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolNetworkProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolNetworkProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolNetworkProfile_STATUS, AgentPoolNetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolNetworkProfile_STATUS runs a test to see if a specific instance of AgentPoolNetworkProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolNetworkProfile_STATUS(subject AgentPoolNetworkProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolNetworkProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolNetworkProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolNetworkProfile_STATUSGenerator()
var agentPoolNetworkProfile_STATUSGenerator gopter.Gen

// AgentPoolNetworkProfile_STATUSGenerator returns a generator of AgentPoolNetworkProfile_STATUS instances for property testing.
// We first initialize agentPoolNetworkProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AgentPoolNetworkProfile_STATUSGenerator() gopter.Gen {
	if agentPoolNetworkProfile_STATUSGenerator != nil {
		return agentPoolNetworkProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolNetworkProfile_STATUS(generators)
	agentPoolNetworkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolNetworkProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolNetworkProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile_STATUS(generators)
	agentPoolNetworkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolNetworkProfile_STATUS{}), generators)

	return agentPoolNetworkProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolNetworkProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ApplicationSecurityGroups"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentPoolNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedHostPorts"] = gen.SliceOf(PortRange_STATUSGenerator())
	gens["NodePublicIPTags"] = gen.SliceOf(IPTag_STATUSGenerator())
}

func Test_AgentPoolSecurityProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolSecurityProfile to AgentPoolSecurityProfile via AssignProperties_To_AgentPoolSecurityProfile & AssignProperties_From_AgentPoolSecurityProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolSecurityProfile, AgentPoolSecurityProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolSecurityProfile tests if a specific instance of AgentPoolSecurityProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolSecurityProfile(subject AgentPoolSecurityProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolSecurityProfile
	err := copied.AssignProperties_To_AgentPoolSecurityProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolSecurityProfile
	err = actual.AssignProperties_From_AgentPoolSecurityProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolSecurityProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolSecurityProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolSecurityProfile, AgentPoolSecurityProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolSecurityProfile runs a test to see if a specific instance of AgentPoolSecurityProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolSecurityProfile(subject AgentPoolSecurityProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolSecurityProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolSecurityProfile instances for property testing - lazily instantiated by
// AgentPoolSecurityProfileGenerator()
var agentPoolSecurityProfileGenerator gopter.Gen

// AgentPoolSecurityProfileGenerator returns a generator of AgentPoolSecurityProfile instances for property testing.
func AgentPoolSecurityProfileGenerator() gopter.Gen {
	if agentPoolSecurityProfileGenerator != nil {
		return agentPoolSecurityProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile(generators)
	agentPoolSecurityProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolSecurityProfile{}), generators)

	return agentPoolSecurityProfileGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile(gens map[string]gopter.Gen) {
	gens["EnableSecureBoot"] = gen.PtrOf(gen.Bool())
	gens["EnableVTPM"] = gen.PtrOf(gen.Bool())
	gens["SshAccess"] = gen.PtrOf(gen.OneConstOf(AgentPoolSSHAccess_Disabled, AgentPoolSSHAccess_LocalUser))
}

func Test_AgentPoolSecurityProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolSecurityProfile_STATUS to AgentPoolSecurityProfile_STATUS via AssignProperties_To_AgentPoolSecurityProfile_STATUS & AssignProperties_From_AgentPoolSecurityProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolSecurityProfile_STATUS, AgentPoolSecurityProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolSecurityProfile_STATUS tests if a specific instance of AgentPoolSecurityProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolSecurityProfile_STATUS(subject AgentPoolSecurityProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolSecurityProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolSecurityProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolSecurityProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolSecurityProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolSecurityProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolSecurityProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolSecurityProfile_STATUS, AgentPoolSecurityProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolSecurityProfile_STATUS runs a test to see if a specific instance of AgentPoolSecurityProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolSecurityProfile_STATUS(subject AgentPoolSecurityProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolSecurityProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolSecurityProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolSecurityProfile_STATUSGenerator()
var agentPoolSecurityProfile_STATUSGenerator gopter.Gen

// AgentPoolSecurityProfile_STATUSGenerator returns a generator of AgentPoolSecurityProfile_STATUS instances for property testing.
func AgentPoolSecurityProfile_STATUSGenerator() gopter.Gen {
	if agentPoolSecurityProfile_STATUSGenerator != nil {
		return agentPoolSecurityProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile_STATUS(generators)
	agentPoolSecurityProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolSecurityProfile_STATUS{}), generators)

	return agentPoolSecurityProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolSecurityProfile_STATUS(gens map[string]gopter.Gen) {
	gens["EnableSecureBoot"] = gen.PtrOf(gen.Bool())
	gens["EnableVTPM"] = gen.PtrOf(gen.Bool())
	gens["SshAccess"] = gen.PtrOf(gen.OneConstOf(AgentPoolSSHAccess_STATUS_Disabled, AgentPoolSSHAccess_STATUS_LocalUser))
}

func Test_AgentPoolUpgradeSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolUpgradeSettings to AgentPoolUpgradeSettings via AssignProperties_To_AgentPoolUpgradeSettings & AssignProperties_From_AgentPoolUpgradeSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolUpgradeSettings, AgentPoolUpgradeSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolUpgradeSettings tests if a specific instance of AgentPoolUpgradeSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolUpgradeSettings(subject AgentPoolUpgradeSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolUpgradeSettings
	err := copied.AssignProperties_To_AgentPoolUpgradeSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolUpgradeSettings
	err = actual.AssignProperties_From_AgentPoolUpgradeSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolUpgradeSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettings, AgentPoolUpgradeSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettings runs a test to see if a specific instance of AgentPoolUpgradeSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettings(subject AgentPoolUpgradeSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings instances for property testing - lazily instantiated by
// AgentPoolUpgradeSettingsGenerator()
var agentPoolUpgradeSettingsGenerator gopter.Gen

// AgentPoolUpgradeSettingsGenerator returns a generator of AgentPoolUpgradeSettings instances for property testing.
func AgentPoolUpgradeSettingsGenerator() gopter.Gen {
	if agentPoolUpgradeSettingsGenerator != nil {
		return agentPoolUpgradeSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings(generators)
	agentPoolUpgradeSettingsGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings{}), generators)

	return agentPoolUpgradeSettingsGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings(gens map[string]gopter.Gen) {
	gens["DrainTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSoakDurationInMinutes"] = gen.PtrOf(gen.Int())
	gens["UndrainableNodeBehavior"] = gen.PtrOf(gen.OneConstOf(AgentPoolUpgradeSettings_UndrainableNodeBehavior_Cordon, AgentPoolUpgradeSettings_UndrainableNodeBehavior_Schedule))
}

func Test_AgentPoolUpgradeSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolUpgradeSettings_STATUS to AgentPoolUpgradeSettings_STATUS via AssignProperties_To_AgentPoolUpgradeSettings_STATUS & AssignProperties_From_AgentPoolUpgradeSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolUpgradeSettings_STATUS, AgentPoolUpgradeSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolUpgradeSettings_STATUS tests if a specific instance of AgentPoolUpgradeSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolUpgradeSettings_STATUS(subject AgentPoolUpgradeSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolUpgradeSettings_STATUS
	err := copied.AssignProperties_To_AgentPoolUpgradeSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolUpgradeSettings_STATUS
	err = actual.AssignProperties_From_AgentPoolUpgradeSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolUpgradeSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettings_STATUS, AgentPoolUpgradeSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettings_STATUS runs a test to see if a specific instance of AgentPoolUpgradeSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettings_STATUS(subject AgentPoolUpgradeSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings_STATUS instances for property testing - lazily instantiated by
// AgentPoolUpgradeSettings_STATUSGenerator()
var agentPoolUpgradeSettings_STATUSGenerator gopter.Gen

// AgentPoolUpgradeSettings_STATUSGenerator returns a generator of AgentPoolUpgradeSettings_STATUS instances for property testing.
func AgentPoolUpgradeSettings_STATUSGenerator() gopter.Gen {
	if agentPoolUpgradeSettings_STATUSGenerator != nil {
		return agentPoolUpgradeSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_STATUS(generators)
	agentPoolUpgradeSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings_STATUS{}), generators)

	return agentPoolUpgradeSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettings_STATUS(gens map[string]gopter.Gen) {
	gens["DrainTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSoakDurationInMinutes"] = gen.PtrOf(gen.Int())
	gens["UndrainableNodeBehavior"] = gen.PtrOf(gen.OneConstOf(AgentPoolUpgradeSettings_UndrainableNodeBehavior_STATUS_Cordon, AgentPoolUpgradeSettings_UndrainableNodeBehavior_STATUS_Schedule))
}

func Test_AgentPoolWindowsProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolWindowsProfile to AgentPoolWindowsProfile via AssignProperties_To_AgentPoolWindowsProfile & AssignProperties_From_AgentPoolWindowsProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolWindowsProfile, AgentPoolWindowsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolWindowsProfile tests if a specific instance of AgentPoolWindowsProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolWindowsProfile(subject AgentPoolWindowsProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolWindowsProfile
	err := copied.AssignProperties_To_AgentPoolWindowsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolWindowsProfile
	err = actual.AssignProperties_From_AgentPoolWindowsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolWindowsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolWindowsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolWindowsProfile, AgentPoolWindowsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolWindowsProfile runs a test to see if a specific instance of AgentPoolWindowsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolWindowsProfile(subject AgentPoolWindowsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolWindowsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolWindowsProfile instances for property testing - lazily instantiated by
// AgentPoolWindowsProfileGenerator()
var agentPoolWindowsProfileGenerator gopter.Gen

// AgentPoolWindowsProfileGenerator returns a generator of AgentPoolWindowsProfile instances for property testing.
func AgentPoolWindowsProfileGenerator() gopter.Gen {
	if agentPoolWindowsProfileGenerator != nil {
		return agentPoolWindowsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile(generators)
	agentPoolWindowsProfileGenerator = gen.Struct(reflect.TypeOf(AgentPoolWindowsProfile{}), generators)

	return agentPoolWindowsProfileGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile(gens map[string]gopter.Gen) {
	gens["DisableOutboundNat"] = gen.PtrOf(gen.Bool())
}

func Test_AgentPoolWindowsProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentPoolWindowsProfile_STATUS to AgentPoolWindowsProfile_STATUS via AssignProperties_To_AgentPoolWindowsProfile_STATUS & AssignProperties_From_AgentPoolWindowsProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentPoolWindowsProfile_STATUS, AgentPoolWindowsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentPoolWindowsProfile_STATUS tests if a specific instance of AgentPoolWindowsProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentPoolWindowsProfile_STATUS(subject AgentPoolWindowsProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AgentPoolWindowsProfile_STATUS
	err := copied.AssignProperties_To_AgentPoolWindowsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentPoolWindowsProfile_STATUS
	err = actual.AssignProperties_From_AgentPoolWindowsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentPoolWindowsProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolWindowsProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolWindowsProfile_STATUS, AgentPoolWindowsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolWindowsProfile_STATUS runs a test to see if a specific instance of AgentPoolWindowsProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolWindowsProfile_STATUS(subject AgentPoolWindowsProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolWindowsProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolWindowsProfile_STATUS instances for property testing - lazily instantiated by
// AgentPoolWindowsProfile_STATUSGenerator()
var agentPoolWindowsProfile_STATUSGenerator gopter.Gen

// AgentPoolWindowsProfile_STATUSGenerator returns a generator of AgentPoolWindowsProfile_STATUS instances for property testing.
func AgentPoolWindowsProfile_STATUSGenerator() gopter.Gen {
	if agentPoolWindowsProfile_STATUSGenerator != nil {
		return agentPoolWindowsProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile_STATUS(generators)
	agentPoolWindowsProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentPoolWindowsProfile_STATUS{}), generators)

	return agentPoolWindowsProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolWindowsProfile_STATUS(gens map[string]gopter.Gen) {
	gens["DisableOutboundNat"] = gen.PtrOf(gen.Bool())
}

func Test_AutoScaleProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoScaleProfile to AutoScaleProfile via AssignProperties_To_AutoScaleProfile & AssignProperties_From_AutoScaleProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoScaleProfile, AutoScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoScaleProfile tests if a specific instance of AutoScaleProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoScaleProfile(subject AutoScaleProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AutoScaleProfile
	err := copied.AssignProperties_To_AutoScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoScaleProfile
	err = actual.AssignProperties_From_AutoScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoScaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScaleProfile, AutoScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScaleProfile runs a test to see if a specific instance of AutoScaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScaleProfile(subject AutoScaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScaleProfile instances for property testing - lazily instantiated by AutoScaleProfileGenerator()
var autoScaleProfileGenerator gopter.Gen

// AutoScaleProfileGenerator returns a generator of AutoScaleProfile instances for property testing.
func AutoScaleProfileGenerator() gopter.Gen {
	if autoScaleProfileGenerator != nil {
		return autoScaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScaleProfile(generators)
	autoScaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoScaleProfile{}), generators)

	return autoScaleProfileGenerator
}

// AddIndependentPropertyGeneratorsForAutoScaleProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScaleProfile(gens map[string]gopter.Gen) {
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Sizes"] = gen.SliceOf(gen.AlphaString())
}

func Test_AutoScaleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoScaleProfile_STATUS to AutoScaleProfile_STATUS via AssignProperties_To_AutoScaleProfile_STATUS & AssignProperties_From_AutoScaleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoScaleProfile_STATUS, AutoScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoScaleProfile_STATUS tests if a specific instance of AutoScaleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoScaleProfile_STATUS(subject AutoScaleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.AutoScaleProfile_STATUS
	err := copied.AssignProperties_To_AutoScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoScaleProfile_STATUS
	err = actual.AssignProperties_From_AutoScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoScaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScaleProfile_STATUS, AutoScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScaleProfile_STATUS runs a test to see if a specific instance of AutoScaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScaleProfile_STATUS(subject AutoScaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScaleProfile_STATUS instances for property testing - lazily instantiated by
// AutoScaleProfile_STATUSGenerator()
var autoScaleProfile_STATUSGenerator gopter.Gen

// AutoScaleProfile_STATUSGenerator returns a generator of AutoScaleProfile_STATUS instances for property testing.
func AutoScaleProfile_STATUSGenerator() gopter.Gen {
	if autoScaleProfile_STATUSGenerator != nil {
		return autoScaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScaleProfile_STATUS(generators)
	autoScaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoScaleProfile_STATUS{}), generators)

	return autoScaleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoScaleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Sizes"] = gen.SliceOf(gen.AlphaString())
}

func Test_IPTag_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPTag to IPTag via AssignProperties_To_IPTag & AssignProperties_From_IPTag returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPTag, IPTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPTag tests if a specific instance of IPTag can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIPTag(subject IPTag) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.IPTag
	err := copied.AssignProperties_To_IPTag(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPTag
	err = actual.AssignProperties_From_IPTag(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPTag_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPTag via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPTag, IPTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPTag runs a test to see if a specific instance of IPTag round trips to JSON and back losslessly
func RunJSONSerializationTestForIPTag(subject IPTag) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPTag
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPTag instances for property testing - lazily instantiated by IPTagGenerator()
var ipTagGenerator gopter.Gen

// IPTagGenerator returns a generator of IPTag instances for property testing.
func IPTagGenerator() gopter.Gen {
	if ipTagGenerator != nil {
		return ipTagGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPTag(generators)
	ipTagGenerator = gen.Struct(reflect.TypeOf(IPTag{}), generators)

	return ipTagGenerator
}

// AddIndependentPropertyGeneratorsForIPTag is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPTag(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPTag_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPTag_STATUS to IPTag_STATUS via AssignProperties_To_IPTag_STATUS & AssignProperties_From_IPTag_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPTag_STATUS, IPTag_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPTag_STATUS tests if a specific instance of IPTag_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIPTag_STATUS(subject IPTag_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.IPTag_STATUS
	err := copied.AssignProperties_To_IPTag_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPTag_STATUS
	err = actual.AssignProperties_From_IPTag_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPTag_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPTag_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPTag_STATUS, IPTag_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPTag_STATUS runs a test to see if a specific instance of IPTag_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIPTag_STATUS(subject IPTag_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPTag_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPTag_STATUS instances for property testing - lazily instantiated by IPTag_STATUSGenerator()
var ipTag_STATUSGenerator gopter.Gen

// IPTag_STATUSGenerator returns a generator of IPTag_STATUS instances for property testing.
func IPTag_STATUSGenerator() gopter.Gen {
	if ipTag_STATUSGenerator != nil {
		return ipTag_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPTag_STATUS(generators)
	ipTag_STATUSGenerator = gen.Struct(reflect.TypeOf(IPTag_STATUS{}), generators)

	return ipTag_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIPTag_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPTag_STATUS(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubeletConfig to KubeletConfig via AssignProperties_To_KubeletConfig & AssignProperties_From_KubeletConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubeletConfig, KubeletConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubeletConfig tests if a specific instance of KubeletConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKubeletConfig(subject KubeletConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.KubeletConfig
	err := copied.AssignProperties_To_KubeletConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubeletConfig
	err = actual.AssignProperties_From_KubeletConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubeletConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfig, KubeletConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfig runs a test to see if a specific instance of KubeletConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfig(subject KubeletConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig instances for property testing - lazily instantiated by KubeletConfigGenerator()
var kubeletConfigGenerator gopter.Gen

// KubeletConfigGenerator returns a generator of KubeletConfig instances for property testing.
func KubeletConfigGenerator() gopter.Gen {
	if kubeletConfigGenerator != nil {
		return kubeletConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfig(generators)
	kubeletConfigGenerator = gen.Struct(reflect.TypeOf(KubeletConfig{}), generators)

	return kubeletConfigGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfig(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubeletConfig_STATUS to KubeletConfig_STATUS via AssignProperties_To_KubeletConfig_STATUS & AssignProperties_From_KubeletConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubeletConfig_STATUS, KubeletConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubeletConfig_STATUS tests if a specific instance of KubeletConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKubeletConfig_STATUS(subject KubeletConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.KubeletConfig_STATUS
	err := copied.AssignProperties_To_KubeletConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubeletConfig_STATUS
	err = actual.AssignProperties_From_KubeletConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubeletConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfig_STATUS, KubeletConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfig_STATUS runs a test to see if a specific instance of KubeletConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfig_STATUS(subject KubeletConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig_STATUS instances for property testing - lazily instantiated by
// KubeletConfig_STATUSGenerator()
var kubeletConfig_STATUSGenerator gopter.Gen

// KubeletConfig_STATUSGenerator returns a generator of KubeletConfig_STATUS instances for property testing.
func KubeletConfig_STATUSGenerator() gopter.Gen {
	if kubeletConfig_STATUSGenerator != nil {
		return kubeletConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfig_STATUS(generators)
	kubeletConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(KubeletConfig_STATUS{}), generators)

	return kubeletConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfig_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxOSConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxOSConfig to LinuxOSConfig via AssignProperties_To_LinuxOSConfig & AssignProperties_From_LinuxOSConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxOSConfig, LinuxOSConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxOSConfig tests if a specific instance of LinuxOSConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLinuxOSConfig(subject LinuxOSConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.LinuxOSConfig
	err := copied.AssignProperties_To_LinuxOSConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxOSConfig
	err = actual.AssignProperties_From_LinuxOSConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxOSConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfig, LinuxOSConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfig runs a test to see if a specific instance of LinuxOSConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfig(subject LinuxOSConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig instances for property testing - lazily instantiated by LinuxOSConfigGenerator()
var linuxOSConfigGenerator gopter.Gen

// LinuxOSConfigGenerator returns a generator of LinuxOSConfig instances for property testing.
// We first initialize linuxOSConfigGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfigGenerator() gopter.Gen {
	if linuxOSConfigGenerator != nil {
		return linuxOSConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig(generators)
	linuxOSConfigGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfig(generators)
	linuxOSConfigGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig{}), generators)

	return linuxOSConfigGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfig(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfig is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfig(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfigGenerator())
}

func Test_LinuxOSConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxOSConfig_STATUS to LinuxOSConfig_STATUS via AssignProperties_To_LinuxOSConfig_STATUS & AssignProperties_From_LinuxOSConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxOSConfig_STATUS, LinuxOSConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxOSConfig_STATUS tests if a specific instance of LinuxOSConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLinuxOSConfig_STATUS(subject LinuxOSConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.LinuxOSConfig_STATUS
	err := copied.AssignProperties_To_LinuxOSConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxOSConfig_STATUS
	err = actual.AssignProperties_From_LinuxOSConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxOSConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfig_STATUS, LinuxOSConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfig_STATUS runs a test to see if a specific instance of LinuxOSConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfig_STATUS(subject LinuxOSConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig_STATUS instances for property testing - lazily instantiated by
// LinuxOSConfig_STATUSGenerator()
var linuxOSConfig_STATUSGenerator gopter.Gen

// LinuxOSConfig_STATUSGenerator returns a generator of LinuxOSConfig_STATUS instances for property testing.
// We first initialize linuxOSConfig_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfig_STATUSGenerator() gopter.Gen {
	if linuxOSConfig_STATUSGenerator != nil {
		return linuxOSConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_STATUS(generators)
	linuxOSConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfig_STATUS(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfig_STATUS(generators)
	linuxOSConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_STATUS{}), generators)

	return linuxOSConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfig_STATUS(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfig_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfig_STATUS(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfig_STATUSGenerator())
}

func Test_ManagedClustersAgentPool_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool to hub returns original",
		prop.ForAll(RunResourceConversionTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForManagedClustersAgentPool tests if a specific instance of ManagedClustersAgentPool round trips to the hub storage version and back losslessly
func RunResourceConversionTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20240901s.ManagedClustersAgentPool
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ManagedClustersAgentPool
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool to ManagedClustersAgentPool via AssignProperties_To_ManagedClustersAgentPool & AssignProperties_From_ManagedClustersAgentPool returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPool tests if a specific instance of ManagedClustersAgentPool can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManagedClustersAgentPool
	err := copied.AssignProperties_To_ManagedClustersAgentPool(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPool
	err = actual.AssignProperties_From_ManagedClustersAgentPool(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPool runs a test to see if a specific instance of ManagedClustersAgentPool round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPool instances for property testing - lazily instantiated by
// ManagedClustersAgentPoolGenerator()
var managedClustersAgentPoolGenerator gopter.Gen

// ManagedClustersAgentPoolGenerator returns a generator of ManagedClustersAgentPool instances for property testing.
func ManagedClustersAgentPoolGenerator() gopter.Gen {
	if managedClustersAgentPoolGenerator != nil {
		return managedClustersAgentPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPool(generators)
	managedClustersAgentPoolGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPool{}), generators)

	return managedClustersAgentPoolGenerator
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPool(gens map[string]gopter.Gen) {
	gens["Spec"] = ManagedClustersAgentPool_SpecGenerator()
	gens["Status"] = ManagedClustersAgentPool_STATUSGenerator()
}

func Test_ManagedClustersAgentPoolOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPoolOperatorSpec to ManagedClustersAgentPoolOperatorSpec via AssignProperties_To_ManagedClustersAgentPoolOperatorSpec & AssignProperties_From_ManagedClustersAgentPoolOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPoolOperatorSpec, ManagedClustersAgentPoolOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPoolOperatorSpec tests if a specific instance of ManagedClustersAgentPoolOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPoolOperatorSpec(subject ManagedClustersAgentPoolOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManagedClustersAgentPoolOperatorSpec
	err := copied.AssignProperties_To_ManagedClustersAgentPoolOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPoolOperatorSpec
	err = actual.AssignProperties_From_ManagedClustersAgentPoolOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPoolOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPoolOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPoolOperatorSpec, ManagedClustersAgentPoolOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPoolOperatorSpec runs a test to see if a specific instance of ManagedClustersAgentPoolOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPoolOperatorSpec(subject ManagedClustersAgentPoolOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPoolOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPoolOperatorSpec instances for property testing - lazily instantiated by
// ManagedClustersAgentPoolOperatorSpecGenerator()
var managedClustersAgentPoolOperatorSpecGenerator gopter.Gen

// ManagedClustersAgentPoolOperatorSpecGenerator returns a generator of ManagedClustersAgentPoolOperatorSpec instances for property testing.
func ManagedClustersAgentPoolOperatorSpecGenerator() gopter.Gen {
	if managedClustersAgentPoolOperatorSpecGenerator != nil {
		return managedClustersAgentPoolOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	managedClustersAgentPoolOperatorSpecGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPoolOperatorSpec{}), generators)

	return managedClustersAgentPoolOperatorSpecGenerator
}

func Test_ManagedClustersAgentPool_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool_STATUS to ManagedClustersAgentPool_STATUS via AssignProperties_To_ManagedClustersAgentPool_STATUS & AssignProperties_From_ManagedClustersAgentPool_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPool_STATUS, ManagedClustersAgentPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPool_STATUS tests if a specific instance of ManagedClustersAgentPool_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPool_STATUS(subject ManagedClustersAgentPool_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManagedClustersAgentPool_STATUS
	err := copied.AssignProperties_To_ManagedClustersAgentPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPool_STATUS
	err = actual.AssignProperties_From_ManagedClustersAgentPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPool_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPool_STATUS, ManagedClustersAgentPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPool_STATUS runs a test to see if a specific instance of ManagedClustersAgentPool_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPool_STATUS(subject ManagedClustersAgentPool_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPool_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPool_STATUS instances for property testing - lazily instantiated by
// ManagedClustersAgentPool_STATUSGenerator()
var managedClustersAgentPool_STATUSGenerator gopter.Gen

// ManagedClustersAgentPool_STATUSGenerator returns a generator of ManagedClustersAgentPool_STATUS instances for property testing.
func ManagedClustersAgentPool_STATUSGenerator() gopter.Gen {
	if managedClustersAgentPool_STATUSGenerator != nil {
		return managedClustersAgentPool_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPool_STATUS(generators)
	managedClustersAgentPool_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPool_STATUS{}), generators)

	return managedClustersAgentPool_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPool_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPool_STATUS(gens map[string]gopter.Gen) {
	gens["ArtifactStreamingProfile"] = gen.PtrOf(AgentPoolArtifactStreamingProfile_STATUSGenerator())
	gens["CreationData"] = gen.PtrOf(CreationData_STATUSGenerator())
	gens["GatewayProfile"] = gen.PtrOf(AgentPoolGatewayProfile_STATUSGenerator())
	gens["GpuProfile"] = gen.PtrOf(AgentPoolGPUProfile_STATUSGenerator())
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfig_STATUSGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfig_STATUSGenerator())
	gens["NetworkProfile"] = gen.PtrOf(AgentPoolNetworkProfile_STATUSGenerator())
	gens["PowerState"] = gen.PtrOf(PowerState_STATUSGenerator())
	gens["SecurityProfile"] = gen.PtrOf(AgentPoolSecurityProfile_STATUSGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettings_STATUSGenerator())
	gens["VirtualMachineNodesStatus"] = gen.SliceOf(VirtualMachineNodes_STATUSGenerator())
	gens["VirtualMachinesProfile"] = gen.PtrOf(VirtualMachinesProfile_STATUSGenerator())
	gens["WindowsProfile"] = gen.PtrOf(AgentPoolWindowsProfile_STATUSGenerator())
}

func Test_ManagedClustersAgentPool_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedClustersAgentPool_Spec to ManagedClustersAgentPool_Spec via AssignProperties_To_ManagedClustersAgentPool_Spec & AssignProperties_From_ManagedClustersAgentPool_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedClustersAgentPool_Spec, ManagedClustersAgentPool_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedClustersAgentPool_Spec tests if a specific instance of ManagedClustersAgentPool_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedClustersAgentPool_Spec(subject ManagedClustersAgentPool_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManagedClustersAgentPool_Spec
	err := copied.AssignProperties_To_ManagedClustersAgentPool_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedClustersAgentPool_Spec
	err = actual.AssignProperties_From_ManagedClustersAgentPool_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedClustersAgentPool_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPool_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPool_Spec, ManagedClustersAgentPool_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPool_Spec runs a test to see if a specific instance of ManagedClustersAgentPool_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPool_Spec(subject ManagedClustersAgentPool_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPool_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPool_Spec instances for property testing - lazily instantiated by
// ManagedClustersAgentPool_SpecGenerator()
var managedClustersAgentPool_SpecGenerator gopter.Gen

// ManagedClustersAgentPool_SpecGenerator returns a generator of ManagedClustersAgentPool_Spec instances for property testing.
func ManagedClustersAgentPool_SpecGenerator() gopter.Gen {
	if managedClustersAgentPool_SpecGenerator != nil {
		return managedClustersAgentPool_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPool_Spec(generators)
	managedClustersAgentPool_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPool_Spec{}), generators)

	return managedClustersAgentPool_SpecGenerator
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPool_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPool_Spec(gens map[string]gopter.Gen) {
	gens["ArtifactStreamingProfile"] = gen.PtrOf(AgentPoolArtifactStreamingProfileGenerator())
	gens["CreationData"] = gen.PtrOf(CreationDataGenerator())
	gens["GatewayProfile"] = gen.PtrOf(AgentPoolGatewayProfileGenerator())
	gens["GpuProfile"] = gen.PtrOf(AgentPoolGPUProfileGenerator())
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfigGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfigGenerator())
	gens["NetworkProfile"] = gen.PtrOf(AgentPoolNetworkProfileGenerator())
	gens["OperatorSpec"] = gen.PtrOf(ManagedClustersAgentPoolOperatorSpecGenerator())
	gens["PowerState"] = gen.PtrOf(PowerStateGenerator())
	gens["SecurityProfile"] = gen.PtrOf(AgentPoolSecurityProfileGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettingsGenerator())
	gens["VirtualMachineNodesStatus"] = gen.SliceOf(VirtualMachineNodesGenerator())
	gens["VirtualMachinesProfile"] = gen.PtrOf(VirtualMachinesProfileGenerator())
	gens["WindowsProfile"] = gen.PtrOf(AgentPoolWindowsProfileGenerator())
}

func Test_ManualScaleProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManualScaleProfile to ManualScaleProfile via AssignProperties_To_ManualScaleProfile & AssignProperties_From_ManualScaleProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForManualScaleProfile, ManualScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManualScaleProfile tests if a specific instance of ManualScaleProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManualScaleProfile(subject ManualScaleProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManualScaleProfile
	err := copied.AssignProperties_To_ManualScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManualScaleProfile
	err = actual.AssignProperties_From_ManualScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManualScaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManualScaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManualScaleProfile, ManualScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManualScaleProfile runs a test to see if a specific instance of ManualScaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForManualScaleProfile(subject ManualScaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManualScaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManualScaleProfile instances for property testing - lazily instantiated by ManualScaleProfileGenerator()
var manualScaleProfileGenerator gopter.Gen

// ManualScaleProfileGenerator returns a generator of ManualScaleProfile instances for property testing.
func ManualScaleProfileGenerator() gopter.Gen {
	if manualScaleProfileGenerator != nil {
		return manualScaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManualScaleProfile(generators)
	manualScaleProfileGenerator = gen.Struct(reflect.TypeOf(ManualScaleProfile{}), generators)

	return manualScaleProfileGenerator
}

// AddIndependentPropertyGeneratorsForManualScaleProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManualScaleProfile(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sizes"] = gen.SliceOf(gen.AlphaString())
}

func Test_ManualScaleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManualScaleProfile_STATUS to ManualScaleProfile_STATUS via AssignProperties_To_ManualScaleProfile_STATUS & AssignProperties_From_ManualScaleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManualScaleProfile_STATUS, ManualScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManualScaleProfile_STATUS tests if a specific instance of ManualScaleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManualScaleProfile_STATUS(subject ManualScaleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ManualScaleProfile_STATUS
	err := copied.AssignProperties_To_ManualScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManualScaleProfile_STATUS
	err = actual.AssignProperties_From_ManualScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManualScaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManualScaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManualScaleProfile_STATUS, ManualScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManualScaleProfile_STATUS runs a test to see if a specific instance of ManualScaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManualScaleProfile_STATUS(subject ManualScaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManualScaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManualScaleProfile_STATUS instances for property testing - lazily instantiated by
// ManualScaleProfile_STATUSGenerator()
var manualScaleProfile_STATUSGenerator gopter.Gen

// ManualScaleProfile_STATUSGenerator returns a generator of ManualScaleProfile_STATUS instances for property testing.
func ManualScaleProfile_STATUSGenerator() gopter.Gen {
	if manualScaleProfile_STATUSGenerator != nil {
		return manualScaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManualScaleProfile_STATUS(generators)
	manualScaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ManualScaleProfile_STATUS{}), generators)

	return manualScaleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManualScaleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManualScaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sizes"] = gen.SliceOf(gen.AlphaString())
}

func Test_PortRange_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PortRange to PortRange via AssignProperties_To_PortRange & AssignProperties_From_PortRange returns original",
		prop.ForAll(RunPropertyAssignmentTestForPortRange, PortRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPortRange tests if a specific instance of PortRange can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPortRange(subject PortRange) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.PortRange
	err := copied.AssignProperties_To_PortRange(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PortRange
	err = actual.AssignProperties_From_PortRange(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PortRange_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PortRange via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortRange, PortRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortRange runs a test to see if a specific instance of PortRange round trips to JSON and back losslessly
func RunJSONSerializationTestForPortRange(subject PortRange) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PortRange
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PortRange instances for property testing - lazily instantiated by PortRangeGenerator()
var portRangeGenerator gopter.Gen

// PortRangeGenerator returns a generator of PortRange instances for property testing.
func PortRangeGenerator() gopter.Gen {
	if portRangeGenerator != nil {
		return portRangeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortRange(generators)
	portRangeGenerator = gen.Struct(reflect.TypeOf(PortRange{}), generators)

	return portRangeGenerator
}

// AddIndependentPropertyGeneratorsForPortRange is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortRange(gens map[string]gopter.Gen) {
	gens["PortEnd"] = gen.PtrOf(gen.Int())
	gens["PortStart"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortRange_Protocol_TCP, PortRange_Protocol_UDP))
}

func Test_PortRange_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PortRange_STATUS to PortRange_STATUS via AssignProperties_To_PortRange_STATUS & AssignProperties_From_PortRange_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPortRange_STATUS, PortRange_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPortRange_STATUS tests if a specific instance of PortRange_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPortRange_STATUS(subject PortRange_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.PortRange_STATUS
	err := copied.AssignProperties_To_PortRange_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PortRange_STATUS
	err = actual.AssignProperties_From_PortRange_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PortRange_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PortRange_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortRange_STATUS, PortRange_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortRange_STATUS runs a test to see if a specific instance of PortRange_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPortRange_STATUS(subject PortRange_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PortRange_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PortRange_STATUS instances for property testing - lazily instantiated by PortRange_STATUSGenerator()
var portRange_STATUSGenerator gopter.Gen

// PortRange_STATUSGenerator returns a generator of PortRange_STATUS instances for property testing.
func PortRange_STATUSGenerator() gopter.Gen {
	if portRange_STATUSGenerator != nil {
		return portRange_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortRange_STATUS(generators)
	portRange_STATUSGenerator = gen.Struct(reflect.TypeOf(PortRange_STATUS{}), generators)

	return portRange_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPortRange_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortRange_STATUS(gens map[string]gopter.Gen) {
	gens["PortEnd"] = gen.PtrOf(gen.Int())
	gens["PortStart"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortRange_Protocol_STATUS_TCP, PortRange_Protocol_STATUS_UDP))
}

func Test_PowerState_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PowerState to PowerState via AssignProperties_To_PowerState & AssignProperties_From_PowerState returns original",
		prop.ForAll(RunPropertyAssignmentTestForPowerState, PowerStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPowerState tests if a specific instance of PowerState can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPowerState(subject PowerState) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.PowerState
	err := copied.AssignProperties_To_PowerState(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PowerState
	err = actual.AssignProperties_From_PowerState(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PowerState_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PowerState via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPowerState, PowerStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPowerState runs a test to see if a specific instance of PowerState round trips to JSON and back losslessly
func RunJSONSerializationTestForPowerState(subject PowerState) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PowerState
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PowerState instances for property testing - lazily instantiated by PowerStateGenerator()
var powerStateGenerator gopter.Gen

// PowerStateGenerator returns a generator of PowerState instances for property testing.
func PowerStateGenerator() gopter.Gen {
	if powerStateGenerator != nil {
		return powerStateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPowerState(generators)
	powerStateGenerator = gen.Struct(reflect.TypeOf(PowerState{}), generators)

	return powerStateGenerator
}

// AddIndependentPropertyGeneratorsForPowerState is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPowerState(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.OneConstOf(PowerState_Code_Running, PowerState_Code_Stopped))
}

func Test_ScaleProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleProfile to ScaleProfile via AssignProperties_To_ScaleProfile & AssignProperties_From_ScaleProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleProfile, ScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleProfile tests if a specific instance of ScaleProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleProfile(subject ScaleProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ScaleProfile
	err := copied.AssignProperties_To_ScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleProfile
	err = actual.AssignProperties_From_ScaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleProfile, ScaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleProfile runs a test to see if a specific instance of ScaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleProfile(subject ScaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleProfile instances for property testing - lazily instantiated by ScaleProfileGenerator()
var scaleProfileGenerator gopter.Gen

// ScaleProfileGenerator returns a generator of ScaleProfile instances for property testing.
func ScaleProfileGenerator() gopter.Gen {
	if scaleProfileGenerator != nil {
		return scaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleProfile(generators)
	scaleProfileGenerator = gen.Struct(reflect.TypeOf(ScaleProfile{}), generators)

	return scaleProfileGenerator
}

// AddRelatedPropertyGeneratorsForScaleProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleProfile(gens map[string]gopter.Gen) {
	gens["Autoscale"] = gen.SliceOf(AutoScaleProfileGenerator())
	gens["Manual"] = gen.SliceOf(ManualScaleProfileGenerator())
}

func Test_ScaleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleProfile_STATUS to ScaleProfile_STATUS via AssignProperties_To_ScaleProfile_STATUS & AssignProperties_From_ScaleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleProfile_STATUS, ScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleProfile_STATUS tests if a specific instance of ScaleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleProfile_STATUS(subject ScaleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.ScaleProfile_STATUS
	err := copied.AssignProperties_To_ScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleProfile_STATUS
	err = actual.AssignProperties_From_ScaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleProfile_STATUS, ScaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleProfile_STATUS runs a test to see if a specific instance of ScaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleProfile_STATUS(subject ScaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleProfile_STATUS instances for property testing - lazily instantiated by
// ScaleProfile_STATUSGenerator()
var scaleProfile_STATUSGenerator gopter.Gen

// ScaleProfile_STATUSGenerator returns a generator of ScaleProfile_STATUS instances for property testing.
func ScaleProfile_STATUSGenerator() gopter.Gen {
	if scaleProfile_STATUSGenerator != nil {
		return scaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleProfile_STATUS(generators)
	scaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleProfile_STATUS{}), generators)

	return scaleProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScaleProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Autoscale"] = gen.SliceOf(AutoScaleProfile_STATUSGenerator())
	gens["Manual"] = gen.SliceOf(ManualScaleProfile_STATUSGenerator())
}

func Test_SysctlConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SysctlConfig to SysctlConfig via AssignProperties_To_SysctlConfig & AssignProperties_From_SysctlConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForSysctlConfig, SysctlConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSysctlConfig tests if a specific instance of SysctlConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSysctlConfig(subject SysctlConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.SysctlConfig
	err := copied.AssignProperties_To_SysctlConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SysctlConfig
	err = actual.AssignProperties_From_SysctlConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SysctlConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfig, SysctlConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfig runs a test to see if a specific instance of SysctlConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfig(subject SysctlConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig instances for property testing - lazily instantiated by SysctlConfigGenerator()
var sysctlConfigGenerator gopter.Gen

// SysctlConfigGenerator returns a generator of SysctlConfig instances for property testing.
func SysctlConfigGenerator() gopter.Gen {
	if sysctlConfigGenerator != nil {
		return sysctlConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfig(generators)
	sysctlConfigGenerator = gen.Struct(reflect.TypeOf(SysctlConfig{}), generators)

	return sysctlConfigGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfig(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}

func Test_SysctlConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SysctlConfig_STATUS to SysctlConfig_STATUS via AssignProperties_To_SysctlConfig_STATUS & AssignProperties_From_SysctlConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSysctlConfig_STATUS, SysctlConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSysctlConfig_STATUS tests if a specific instance of SysctlConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSysctlConfig_STATUS(subject SysctlConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.SysctlConfig_STATUS
	err := copied.AssignProperties_To_SysctlConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SysctlConfig_STATUS
	err = actual.AssignProperties_From_SysctlConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SysctlConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfig_STATUS, SysctlConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfig_STATUS runs a test to see if a specific instance of SysctlConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfig_STATUS(subject SysctlConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig_STATUS instances for property testing - lazily instantiated by
// SysctlConfig_STATUSGenerator()
var sysctlConfig_STATUSGenerator gopter.Gen

// SysctlConfig_STATUSGenerator returns a generator of SysctlConfig_STATUS instances for property testing.
func SysctlConfig_STATUSGenerator() gopter.Gen {
	if sysctlConfig_STATUSGenerator != nil {
		return sysctlConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfig_STATUS(generators)
	sysctlConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(SysctlConfig_STATUS{}), generators)

	return sysctlConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfig_STATUS(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}

func Test_VirtualMachineNodes_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineNodes to VirtualMachineNodes via AssignProperties_To_VirtualMachineNodes & AssignProperties_From_VirtualMachineNodes returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineNodes, VirtualMachineNodesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineNodes tests if a specific instance of VirtualMachineNodes can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineNodes(subject VirtualMachineNodes) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.VirtualMachineNodes
	err := copied.AssignProperties_To_VirtualMachineNodes(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineNodes
	err = actual.AssignProperties_From_VirtualMachineNodes(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineNodes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNodes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNodes, VirtualMachineNodesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNodes runs a test to see if a specific instance of VirtualMachineNodes round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNodes(subject VirtualMachineNodes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNodes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNodes instances for property testing - lazily instantiated by
// VirtualMachineNodesGenerator()
var virtualMachineNodesGenerator gopter.Gen

// VirtualMachineNodesGenerator returns a generator of VirtualMachineNodes instances for property testing.
func VirtualMachineNodesGenerator() gopter.Gen {
	if virtualMachineNodesGenerator != nil {
		return virtualMachineNodesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNodes(generators)
	virtualMachineNodesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNodes{}), generators)

	return virtualMachineNodesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNodes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNodes(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineNodes_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineNodes_STATUS to VirtualMachineNodes_STATUS via AssignProperties_To_VirtualMachineNodes_STATUS & AssignProperties_From_VirtualMachineNodes_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineNodes_STATUS, VirtualMachineNodes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineNodes_STATUS tests if a specific instance of VirtualMachineNodes_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineNodes_STATUS(subject VirtualMachineNodes_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.VirtualMachineNodes_STATUS
	err := copied.AssignProperties_To_VirtualMachineNodes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineNodes_STATUS
	err = actual.AssignProperties_From_VirtualMachineNodes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineNodes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNodes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNodes_STATUS, VirtualMachineNodes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNodes_STATUS runs a test to see if a specific instance of VirtualMachineNodes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNodes_STATUS(subject VirtualMachineNodes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNodes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNodes_STATUS instances for property testing - lazily instantiated by
// VirtualMachineNodes_STATUSGenerator()
var virtualMachineNodes_STATUSGenerator gopter.Gen

// VirtualMachineNodes_STATUSGenerator returns a generator of VirtualMachineNodes_STATUS instances for property testing.
func VirtualMachineNodes_STATUSGenerator() gopter.Gen {
	if virtualMachineNodes_STATUSGenerator != nil {
		return virtualMachineNodes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNodes_STATUS(generators)
	virtualMachineNodes_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNodes_STATUS{}), generators)

	return virtualMachineNodes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNodes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNodes_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinesProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachinesProfile to VirtualMachinesProfile via AssignProperties_To_VirtualMachinesProfile & AssignProperties_From_VirtualMachinesProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachinesProfile, VirtualMachinesProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachinesProfile tests if a specific instance of VirtualMachinesProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachinesProfile(subject VirtualMachinesProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.VirtualMachinesProfile
	err := copied.AssignProperties_To_VirtualMachinesProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachinesProfile
	err = actual.AssignProperties_From_VirtualMachinesProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachinesProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinesProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesProfile, VirtualMachinesProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesProfile runs a test to see if a specific instance of VirtualMachinesProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesProfile(subject VirtualMachinesProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinesProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinesProfile instances for property testing - lazily instantiated by
// VirtualMachinesProfileGenerator()
var virtualMachinesProfileGenerator gopter.Gen

// VirtualMachinesProfileGenerator returns a generator of VirtualMachinesProfile instances for property testing.
func VirtualMachinesProfileGenerator() gopter.Gen {
	if virtualMachinesProfileGenerator != nil {
		return virtualMachinesProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinesProfile(generators)
	virtualMachinesProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachinesProfile{}), generators)

	return virtualMachinesProfileGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinesProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesProfile(gens map[string]gopter.Gen) {
	gens["Scale"] = gen.PtrOf(ScaleProfileGenerator())
}

func Test_VirtualMachinesProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachinesProfile_STATUS to VirtualMachinesProfile_STATUS via AssignProperties_To_VirtualMachinesProfile_STATUS & AssignProperties_From_VirtualMachinesProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachinesProfile_STATUS, VirtualMachinesProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachinesProfile_STATUS tests if a specific instance of VirtualMachinesProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachinesProfile_STATUS(subject VirtualMachinesProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20240402ps.VirtualMachinesProfile_STATUS
	err := copied.AssignProperties_To_VirtualMachinesProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachinesProfile_STATUS
	err = actual.AssignProperties_From_VirtualMachinesProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachinesProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinesProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesProfile_STATUS, VirtualMachinesProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesProfile_STATUS runs a test to see if a specific instance of VirtualMachinesProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesProfile_STATUS(subject VirtualMachinesProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinesProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinesProfile_STATUS instances for property testing - lazily instantiated by
// VirtualMachinesProfile_STATUSGenerator()
var virtualMachinesProfile_STATUSGenerator gopter.Gen

// VirtualMachinesProfile_STATUSGenerator returns a generator of VirtualMachinesProfile_STATUS instances for property testing.
func VirtualMachinesProfile_STATUSGenerator() gopter.Gen {
	if virtualMachinesProfile_STATUSGenerator != nil {
		return virtualMachinesProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinesProfile_STATUS(generators)
	virtualMachinesProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualMachinesProfile_STATUS{}), generators)

	return virtualMachinesProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinesProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Scale"] = gen.PtrOf(ScaleProfile_STATUSGenerator())
}
