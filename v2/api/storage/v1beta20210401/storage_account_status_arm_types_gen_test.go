// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount_STATUSARM, StorageAccount_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount_STATUSARM runs a test to see if a specific instance of StorageAccount_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount_STATUSARM(subject StorageAccount_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_STATUSARM instances for property testing - lazily instantiated by
// StorageAccount_STATUSARMGenerator()
var storageAccount_STATUSARMGenerator gopter.Gen

// StorageAccount_STATUSARMGenerator returns a generator of StorageAccount_STATUSARM instances for property testing.
// We first initialize storageAccount_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccount_STATUSARMGenerator() gopter.Gen {
	if storageAccount_STATUSARMGenerator != nil {
		return storageAccount_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	storageAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	storageAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	return storageAccount_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccount_STATUS_Kind_BlobStorage,
		StorageAccount_STATUS_Kind_BlockBlobStorage,
		StorageAccount_STATUS_Kind_FileStorage,
		StorageAccount_STATUS_Kind_Storage,
		StorageAccount_STATUS_Kind_StorageV2))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(Identity_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountProperties_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSARMGenerator())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUSARM, ExtendedLocation_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSARMGenerator()
var extendedLocation_STATUSARMGenerator gopter.Gen

// ExtendedLocation_STATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocation_STATUSARMGenerator() gopter.Gen {
	if extendedLocation_STATUSARMGenerator != nil {
		return extendedLocation_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(generators)
	extendedLocation_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocation_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_EdgeZone))
}

func Test_Identity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUSARM, Identity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUSARM runs a test to see if a specific instance of Identity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUSARM(subject Identity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUSARM instances for property testing - lazily instantiated by Identity_STATUSARMGenerator()
var identity_STATUSARMGenerator gopter.Gen

// Identity_STATUSARMGenerator returns a generator of Identity_STATUSARM instances for property testing.
// We first initialize identity_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_STATUSARMGenerator() gopter.Gen {
	if identity_STATUSARMGenerator != nil {
		return identity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUSARM(generators)
	identity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForIdentity_STATUSARM(generators)
	identity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	return identity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_STATUS_Type_None,
		Identity_STATUS_Type_SystemAssigned,
		Identity_STATUS_Type_SystemAssignedUserAssigned,
		Identity_STATUS_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentity_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_STATUSARMGenerator())
}

func Test_StorageAccountProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountProperties_STATUSARM, StorageAccountProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountProperties_STATUSARM runs a test to see if a specific instance of StorageAccountProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountProperties_STATUSARM(subject StorageAccountProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountProperties_STATUSARMGenerator()
var storageAccountProperties_STATUSARMGenerator gopter.Gen

// StorageAccountProperties_STATUSARMGenerator returns a generator of StorageAccountProperties_STATUSARM instances for property testing.
// We first initialize storageAccountProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountProperties_STATUSARMGenerator() gopter.Gen {
	if storageAccountProperties_STATUSARMGenerator != nil {
		return storageAccountProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_STATUSARM(generators)
	storageAccountProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountProperties_STATUSARM(generators)
	storageAccountProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_STATUSARM{}), generators)

	return storageAccountProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_AccessTier_Cool, StorageAccountProperties_STATUS_AccessTier_Hot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["CreationTime"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverInProgress"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_LargeFileSharesState_Disabled, StorageAccountProperties_STATUS_LargeFileSharesState_Enabled))
	gens["LastGeoFailoverTime"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_MinimumTlsVersion_TLS1_0, StorageAccountProperties_STATUS_MinimumTlsVersion_TLS1_1, StorageAccountProperties_STATUS_MinimumTlsVersion_TLS1_2))
	gens["PrimaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_ProvisioningState_Creating, StorageAccountProperties_STATUS_ProvisioningState_ResolvingDNS, StorageAccountProperties_STATUS_ProvisioningState_Succeeded))
	gens["SecondaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["StatusOfPrimary"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_StatusOfPrimary_Available, StorageAccountProperties_STATUS_StatusOfPrimary_Unavailable))
	gens["StatusOfSecondary"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_STATUS_StatusOfSecondary_Available, StorageAccountProperties_STATUS_StatusOfSecondary_Unavailable))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_STATUSARMGenerator())
	gens["BlobRestoreStatus"] = gen.PtrOf(BlobRestoreStatus_STATUSARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_STATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_STATUSARMGenerator())
	gens["GeoReplicationStats"] = gen.PtrOf(GeoReplicationStats_STATUSARMGenerator())
	gens["KeyCreationTime"] = gen.PtrOf(KeyCreationTime_STATUSARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_STATUSARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_STATUSARMGenerator())
	gens["PrimaryEndpoints"] = gen.PtrOf(Endpoints_STATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_STATUSARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_STATUSARMGenerator())
	gens["SecondaryEndpoints"] = gen.PtrOf(Endpoints_STATUSARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM, AzureFilesIdentityBasedAuthentication_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM(subject AzureFilesIdentityBasedAuthentication_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthentication_STATUSARMGenerator()
var azureFilesIdentityBasedAuthentication_STATUSARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_STATUSARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_STATUSARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_STATUSARMGenerator != nil {
		return azureFilesIdentityBasedAuthentication_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	azureFilesIdentityBasedAuthentication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	azureFilesIdentityBasedAuthentication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	return azureFilesIdentityBasedAuthentication_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_STATUS_DefaultSharePermission_None,
		AzureFilesIdentityBasedAuthentication_STATUS_DefaultSharePermission_StorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthentication_STATUS_DefaultSharePermission_StorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthentication_STATUS_DefaultSharePermission_StorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthentication_STATUS_DefaultSharePermission_StorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.OneConstOf(AzureFilesIdentityBasedAuthentication_STATUS_DirectoryServiceOptions_AADDS, AzureFilesIdentityBasedAuthentication_STATUS_DirectoryServiceOptions_AD, AzureFilesIdentityBasedAuthentication_STATUS_DirectoryServiceOptions_None))
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_STATUSARMGenerator())
}

func Test_BlobRestoreStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreStatus_STATUSARM, BlobRestoreStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreStatus_STATUSARM runs a test to see if a specific instance of BlobRestoreStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreStatus_STATUSARM(subject BlobRestoreStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreStatus_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreStatus_STATUSARMGenerator()
var blobRestoreStatus_STATUSARMGenerator gopter.Gen

// BlobRestoreStatus_STATUSARMGenerator returns a generator of BlobRestoreStatus_STATUSARM instances for property testing.
// We first initialize blobRestoreStatus_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreStatus_STATUSARMGenerator() gopter.Gen {
	if blobRestoreStatus_STATUSARMGenerator != nil {
		return blobRestoreStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatus_STATUSARM(generators)
	blobRestoreStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatus_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreStatus_STATUSARM(generators)
	blobRestoreStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUSARM{}), generators)

	return blobRestoreStatus_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreStatus_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["FailureReason"] = gen.PtrOf(gen.AlphaString())
	gens["RestoreId"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(BlobRestoreStatus_STATUS_Status_Complete, BlobRestoreStatus_STATUS_Status_Failed, BlobRestoreStatus_STATUS_Status_InProgress))
}

// AddRelatedPropertyGeneratorsForBlobRestoreStatus_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(BlobRestoreParameters_STATUSARMGenerator())
}

func Test_CustomDomain_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_STATUSARM, CustomDomain_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_STATUSARM runs a test to see if a specific instance of CustomDomain_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_STATUSARM(subject CustomDomain_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUSARM instances for property testing - lazily instantiated by
// CustomDomain_STATUSARMGenerator()
var customDomain_STATUSARMGenerator gopter.Gen

// CustomDomain_STATUSARMGenerator returns a generator of CustomDomain_STATUSARM instances for property testing.
func CustomDomain_STATUSARMGenerator() gopter.Gen {
	if customDomain_STATUSARMGenerator != nil {
		return customDomain_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM(generators)
	customDomain_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUSARM{}), generators)

	return customDomain_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_STATUSARM, Encryption_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_STATUSARM runs a test to see if a specific instance of Encryption_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_STATUSARM(subject Encryption_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUSARM instances for property testing - lazily instantiated by
// Encryption_STATUSARMGenerator()
var encryption_STATUSARMGenerator gopter.Gen

// Encryption_STATUSARMGenerator returns a generator of Encryption_STATUSARM instances for property testing.
// We first initialize encryption_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_STATUSARMGenerator() gopter.Gen {
	if encryption_STATUSARMGenerator != nil {
		return encryption_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUSARM(generators)
	encryption_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryption_STATUSARM(generators)
	encryption_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	return encryption_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(Encryption_STATUS_KeySource_MicrosoftKeyvault, Encryption_STATUS_KeySource_MicrosoftStorage))
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_STATUSARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_STATUSARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_STATUSARMGenerator())
}

func Test_Endpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Endpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpoints_STATUSARM, Endpoints_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpoints_STATUSARM runs a test to see if a specific instance of Endpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpoints_STATUSARM(subject Endpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Endpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Endpoints_STATUSARM instances for property testing - lazily instantiated by
// Endpoints_STATUSARMGenerator()
var endpoints_STATUSARMGenerator gopter.Gen

// Endpoints_STATUSARMGenerator returns a generator of Endpoints_STATUSARM instances for property testing.
// We first initialize endpoints_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Endpoints_STATUSARMGenerator() gopter.Gen {
	if endpoints_STATUSARMGenerator != nil {
		return endpoints_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpoints_STATUSARM(generators)
	endpoints_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpoints_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEndpoints_STATUSARM(generators)
	endpoints_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUSARM{}), generators)

	return endpoints_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpoints_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpoints_STATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpoints_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpoints_STATUSARM(gens map[string]gopter.Gen) {
	gens["InternetEndpoints"] = gen.PtrOf(StorageAccountInternetEndpoints_STATUSARMGenerator())
	gens["MicrosoftEndpoints"] = gen.PtrOf(StorageAccountMicrosoftEndpoints_STATUSARMGenerator())
}

func Test_GeoReplicationStats_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoReplicationStats_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoReplicationStats_STATUSARM, GeoReplicationStats_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoReplicationStats_STATUSARM runs a test to see if a specific instance of GeoReplicationStats_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoReplicationStats_STATUSARM(subject GeoReplicationStats_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoReplicationStats_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoReplicationStats_STATUSARM instances for property testing - lazily instantiated by
// GeoReplicationStats_STATUSARMGenerator()
var geoReplicationStats_STATUSARMGenerator gopter.Gen

// GeoReplicationStats_STATUSARMGenerator returns a generator of GeoReplicationStats_STATUSARM instances for property testing.
func GeoReplicationStats_STATUSARMGenerator() gopter.Gen {
	if geoReplicationStats_STATUSARMGenerator != nil {
		return geoReplicationStats_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoReplicationStats_STATUSARM(generators)
	geoReplicationStats_STATUSARMGenerator = gen.Struct(reflect.TypeOf(GeoReplicationStats_STATUSARM{}), generators)

	return geoReplicationStats_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoReplicationStats_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoReplicationStats_STATUSARM(gens map[string]gopter.Gen) {
	gens["CanFailover"] = gen.PtrOf(gen.Bool())
	gens["LastSyncTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(GeoReplicationStats_STATUS_Status_Bootstrap, GeoReplicationStats_STATUS_Status_Live, GeoReplicationStats_STATUS_Status_Unavailable))
}

func Test_KeyCreationTime_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyCreationTime_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyCreationTime_STATUSARM, KeyCreationTime_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyCreationTime_STATUSARM runs a test to see if a specific instance of KeyCreationTime_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyCreationTime_STATUSARM(subject KeyCreationTime_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyCreationTime_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyCreationTime_STATUSARM instances for property testing - lazily instantiated by
// KeyCreationTime_STATUSARMGenerator()
var keyCreationTime_STATUSARMGenerator gopter.Gen

// KeyCreationTime_STATUSARMGenerator returns a generator of KeyCreationTime_STATUSARM instances for property testing.
func KeyCreationTime_STATUSARMGenerator() gopter.Gen {
	if keyCreationTime_STATUSARMGenerator != nil {
		return keyCreationTime_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyCreationTime_STATUSARM(generators)
	keyCreationTime_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyCreationTime_STATUSARM{}), generators)

	return keyCreationTime_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyCreationTime_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyCreationTime_STATUSARM(gens map[string]gopter.Gen) {
	gens["Key1"] = gen.PtrOf(gen.AlphaString())
	gens["Key2"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_STATUSARM, KeyPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_STATUSARM runs a test to see if a specific instance of KeyPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_STATUSARM(subject KeyPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_STATUSARM instances for property testing - lazily instantiated by
// KeyPolicy_STATUSARMGenerator()
var keyPolicy_STATUSARMGenerator gopter.Gen

// KeyPolicy_STATUSARMGenerator returns a generator of KeyPolicy_STATUSARM instances for property testing.
func KeyPolicy_STATUSARMGenerator() gopter.Gen {
	if keyPolicy_STATUSARMGenerator != nil {
		return keyPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM(generators)
	keyPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_STATUSARM{}), generators)

	return keyPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_STATUSARM, NetworkRuleSet_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_STATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_STATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSet_STATUSARMGenerator()
var networkRuleSet_STATUSARMGenerator gopter.Gen

// NetworkRuleSet_STATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSet_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_STATUSARMGenerator() gopter.Gen {
	if networkRuleSet_STATUSARMGenerator != nil {
		return networkRuleSet_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSet_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_STATUS_Bypass_AzureServices,
		NetworkRuleSet_STATUS_Bypass_Logging,
		NetworkRuleSet_STATUS_Bypass_Metrics,
		NetworkRuleSet_STATUS_Bypass_None))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_STATUS_DefaultAction_Allow, NetworkRuleSet_STATUS_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_STATUSARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_STATUSARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_STATUSARMGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM, PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()
var privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing.
func PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_STATUSARM, RoutingPreference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_STATUSARM runs a test to see if a specific instance of RoutingPreference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_STATUSARM(subject RoutingPreference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_STATUSARM instances for property testing - lazily instantiated by
// RoutingPreference_STATUSARMGenerator()
var routingPreference_STATUSARMGenerator gopter.Gen

// RoutingPreference_STATUSARMGenerator returns a generator of RoutingPreference_STATUSARM instances for property testing.
func RoutingPreference_STATUSARMGenerator() gopter.Gen {
	if routingPreference_STATUSARMGenerator != nil {
		return routingPreference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM(generators)
	routingPreference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_STATUSARM{}), generators)

	return routingPreference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_STATUS_RoutingChoice_InternetRouting, RoutingPreference_STATUS_RoutingChoice_MicrosoftRouting))
}

func Test_SasPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_STATUSARM, SasPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_STATUSARM runs a test to see if a specific instance of SasPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_STATUSARM(subject SasPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_STATUSARM instances for property testing - lazily instantiated by
// SasPolicy_STATUSARMGenerator()
var sasPolicy_STATUSARMGenerator gopter.Gen

// SasPolicy_STATUSARMGenerator returns a generator of SasPolicy_STATUSARM instances for property testing.
func SasPolicy_STATUSARMGenerator() gopter.Gen {
	if sasPolicy_STATUSARMGenerator != nil {
		return sasPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM(generators)
	sasPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_STATUSARM{}), generators)

	return sasPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.OneConstOf(SasPolicy_STATUS_ExpirationAction_Log))
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUSARM, UserAssignedIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUSARM runs a test to see if a specific instance of UserAssignedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUSARM(subject UserAssignedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSARMGenerator()
var userAssignedIdentity_STATUSARMGenerator gopter.Gen

// UserAssignedIdentity_STATUSARMGenerator returns a generator of UserAssignedIdentity_STATUSARM instances for property testing.
func UserAssignedIdentity_STATUSARMGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSARMGenerator != nil {
		return userAssignedIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(generators)
	userAssignedIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUSARM{}), generators)

	return userAssignedIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM, ActiveDirectoryProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM runs a test to see if a specific instance of ActiveDirectoryProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM(subject ActiveDirectoryProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_STATUSARM instances for property testing - lazily instantiated by
// ActiveDirectoryProperties_STATUSARMGenerator()
var activeDirectoryProperties_STATUSARMGenerator gopter.Gen

// ActiveDirectoryProperties_STATUSARMGenerator returns a generator of ActiveDirectoryProperties_STATUSARM instances for property testing.
func ActiveDirectoryProperties_STATUSARMGenerator() gopter.Gen {
	if activeDirectoryProperties_STATUSARMGenerator != nil {
		return activeDirectoryProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM(generators)
	activeDirectoryProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_STATUSARM{}), generators)

	return activeDirectoryProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobRestoreParameters_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreParameters_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreParameters_STATUSARM, BlobRestoreParameters_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreParameters_STATUSARM runs a test to see if a specific instance of BlobRestoreParameters_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreParameters_STATUSARM(subject BlobRestoreParameters_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreParameters_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreParameters_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreParameters_STATUSARMGenerator()
var blobRestoreParameters_STATUSARMGenerator gopter.Gen

// BlobRestoreParameters_STATUSARMGenerator returns a generator of BlobRestoreParameters_STATUSARM instances for property testing.
// We first initialize blobRestoreParameters_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreParameters_STATUSARMGenerator() gopter.Gen {
	if blobRestoreParameters_STATUSARMGenerator != nil {
		return blobRestoreParameters_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParameters_STATUSARM(generators)
	blobRestoreParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParameters_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreParameters_STATUSARM(generators)
	blobRestoreParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUSARM{}), generators)

	return blobRestoreParameters_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreParameters_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["TimeToRestore"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBlobRestoreParameters_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["BlobRanges"] = gen.SliceOf(BlobRestoreRange_STATUSARMGenerator())
}

func Test_EncryptionIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_STATUSARM, EncryptionIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_STATUSARM runs a test to see if a specific instance of EncryptionIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_STATUSARM(subject EncryptionIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_STATUSARM instances for property testing - lazily instantiated by
// EncryptionIdentity_STATUSARMGenerator()
var encryptionIdentity_STATUSARMGenerator gopter.Gen

// EncryptionIdentity_STATUSARMGenerator returns a generator of EncryptionIdentity_STATUSARM instances for property testing.
func EncryptionIdentity_STATUSARMGenerator() gopter.Gen {
	if encryptionIdentity_STATUSARMGenerator != nil {
		return encryptionIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM(generators)
	encryptionIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_STATUSARM{}), generators)

	return encryptionIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_STATUSARM, EncryptionServices_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_STATUSARM runs a test to see if a specific instance of EncryptionServices_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_STATUSARM(subject EncryptionServices_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_STATUSARM instances for property testing - lazily instantiated by
// EncryptionServices_STATUSARMGenerator()
var encryptionServices_STATUSARMGenerator gopter.Gen

// EncryptionServices_STATUSARMGenerator returns a generator of EncryptionServices_STATUSARM instances for property testing.
func EncryptionServices_STATUSARMGenerator() gopter.Gen {
	if encryptionServices_STATUSARMGenerator != nil {
		return encryptionServices_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM(generators)
	encryptionServices_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_STATUSARM{}), generators)

	return encryptionServices_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_STATUSARM, IPRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_STATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_STATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRule_STATUSARMGenerator()
var ipRule_STATUSARMGenerator gopter.Gen

// IPRule_STATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRule_STATUSARMGenerator() gopter.Gen {
	if ipRule_STATUSARMGenerator != nil {
		return ipRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_STATUSARM(generators)
	ipRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_STATUS_Action_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUSARM, KeyVaultProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultProperties_STATUSARMGenerator()
var keyVaultProperties_STATUSARMGenerator gopter.Gen

// KeyVaultProperties_STATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultProperties_STATUSARMGenerator() gopter.Gen {
	if keyVaultProperties_STATUSARMGenerator != nil {
		return keyVaultProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(generators)
	keyVaultProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_STATUSARM, ResourceAccessRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_STATUSARM runs a test to see if a specific instance of ResourceAccessRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_STATUSARM(subject ResourceAccessRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_STATUSARM instances for property testing - lazily instantiated by
// ResourceAccessRule_STATUSARMGenerator()
var resourceAccessRule_STATUSARMGenerator gopter.Gen

// ResourceAccessRule_STATUSARMGenerator returns a generator of ResourceAccessRule_STATUSARM instances for property testing.
func ResourceAccessRule_STATUSARMGenerator() gopter.Gen {
	if resourceAccessRule_STATUSARMGenerator != nil {
		return resourceAccessRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM(generators)
	resourceAccessRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_STATUSARM{}), generators)

	return resourceAccessRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountInternetEndpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountInternetEndpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountInternetEndpoints_STATUSARM, StorageAccountInternetEndpoints_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountInternetEndpoints_STATUSARM runs a test to see if a specific instance of StorageAccountInternetEndpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountInternetEndpoints_STATUSARM(subject StorageAccountInternetEndpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountInternetEndpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountInternetEndpoints_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountInternetEndpoints_STATUSARMGenerator()
var storageAccountInternetEndpoints_STATUSARMGenerator gopter.Gen

// StorageAccountInternetEndpoints_STATUSARMGenerator returns a generator of StorageAccountInternetEndpoints_STATUSARM instances for property testing.
func StorageAccountInternetEndpoints_STATUSARMGenerator() gopter.Gen {
	if storageAccountInternetEndpoints_STATUSARMGenerator != nil {
		return storageAccountInternetEndpoints_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountInternetEndpoints_STATUSARM(generators)
	storageAccountInternetEndpoints_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountInternetEndpoints_STATUSARM{}), generators)

	return storageAccountInternetEndpoints_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountInternetEndpoints_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountInternetEndpoints_STATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountMicrosoftEndpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountMicrosoftEndpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountMicrosoftEndpoints_STATUSARM, StorageAccountMicrosoftEndpoints_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountMicrosoftEndpoints_STATUSARM runs a test to see if a specific instance of StorageAccountMicrosoftEndpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountMicrosoftEndpoints_STATUSARM(subject StorageAccountMicrosoftEndpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountMicrosoftEndpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountMicrosoftEndpoints_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountMicrosoftEndpoints_STATUSARMGenerator()
var storageAccountMicrosoftEndpoints_STATUSARMGenerator gopter.Gen

// StorageAccountMicrosoftEndpoints_STATUSARMGenerator returns a generator of StorageAccountMicrosoftEndpoints_STATUSARM instances for property testing.
func StorageAccountMicrosoftEndpoints_STATUSARMGenerator() gopter.Gen {
	if storageAccountMicrosoftEndpoints_STATUSARMGenerator != nil {
		return storageAccountMicrosoftEndpoints_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpoints_STATUSARM(generators)
	storageAccountMicrosoftEndpoints_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountMicrosoftEndpoints_STATUSARM{}), generators)

	return storageAccountMicrosoftEndpoints_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpoints_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpoints_STATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_STATUSARM, VirtualNetworkRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_STATUSARM runs a test to see if a specific instance of VirtualNetworkRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_STATUSARM(subject VirtualNetworkRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUSARM instances for property testing - lazily instantiated by
// VirtualNetworkRule_STATUSARMGenerator()
var virtualNetworkRule_STATUSARMGenerator gopter.Gen

// VirtualNetworkRule_STATUSARMGenerator returns a generator of VirtualNetworkRule_STATUSARM instances for property testing.
func VirtualNetworkRule_STATUSARMGenerator() gopter.Gen {
	if virtualNetworkRule_STATUSARMGenerator != nil {
		return virtualNetworkRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(generators)
	virtualNetworkRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUSARM{}), generators)

	return virtualNetworkRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_STATUS_Action_Allow))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_STATUS_State_Deprovisioning,
		VirtualNetworkRule_STATUS_State_Failed,
		VirtualNetworkRule_STATUS_State_NetworkSourceDeleted,
		VirtualNetworkRule_STATUS_State_Provisioning,
		VirtualNetworkRule_STATUS_State_Succeeded))
}

func Test_BlobRestoreRange_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreRange_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreRange_STATUSARM, BlobRestoreRange_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreRange_STATUSARM runs a test to see if a specific instance of BlobRestoreRange_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreRange_STATUSARM(subject BlobRestoreRange_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreRange_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreRange_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreRange_STATUSARMGenerator()
var blobRestoreRange_STATUSARMGenerator gopter.Gen

// BlobRestoreRange_STATUSARMGenerator returns a generator of BlobRestoreRange_STATUSARM instances for property testing.
func BlobRestoreRange_STATUSARMGenerator() gopter.Gen {
	if blobRestoreRange_STATUSARMGenerator != nil {
		return blobRestoreRange_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreRange_STATUSARM(generators)
	blobRestoreRange_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreRange_STATUSARM{}), generators)

	return blobRestoreRange_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreRange_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreRange_STATUSARM(gens map[string]gopter.Gen) {
	gens["EndRange"] = gen.PtrOf(gen.AlphaString())
	gens["StartRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_STATUSARM, EncryptionService_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_STATUSARM runs a test to see if a specific instance of EncryptionService_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_STATUSARM(subject EncryptionService_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_STATUSARM instances for property testing - lazily instantiated by
// EncryptionService_STATUSARMGenerator()
var encryptionService_STATUSARMGenerator gopter.Gen

// EncryptionService_STATUSARMGenerator returns a generator of EncryptionService_STATUSARM instances for property testing.
func EncryptionService_STATUSARMGenerator() gopter.Gen {
	if encryptionService_STATUSARMGenerator != nil {
		return encryptionService_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM(generators)
	encryptionService_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_STATUSARM{}), generators)

	return encryptionService_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_STATUS_KeyType_Account, EncryptionService_STATUS_KeyType_Service))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
