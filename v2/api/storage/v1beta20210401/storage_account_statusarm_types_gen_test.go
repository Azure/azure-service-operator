// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount_STATUSARM, StorageAccount_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount_STATUSARM runs a test to see if a specific instance of StorageAccount_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount_STATUSARM(subject StorageAccount_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_STATUSARM instances for property testing - lazily instantiated by
// StorageAccount_STATUSARMGenerator()
var storageAccount_STATUSARMGenerator gopter.Gen

// StorageAccount_STATUSARMGenerator returns a generator of StorageAccount_STATUSARM instances for property testing.
// We first initialize storageAccount_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccount_STATUSARMGenerator() gopter.Gen {
	if storageAccount_STATUSARMGenerator != nil {
		return storageAccount_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	storageAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM(generators)
	storageAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	return storageAccount_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccount_Kind_BlobStorage_STATUS,
		StorageAccount_Kind_BlockBlobStorage_STATUS,
		StorageAccount_Kind_FileStorage_STATUS,
		StorageAccount_Kind_Storage_STATUS,
		StorageAccount_Kind_StorageV2_STATUS))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(Identity_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesCreateParameters_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSARMGenerator())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUSARM, ExtendedLocation_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSARMGenerator()
var extendedLocation_STATUSARMGenerator gopter.Gen

// ExtendedLocation_STATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocation_STATUSARMGenerator() gopter.Gen {
	if extendedLocation_STATUSARMGenerator != nil {
		return extendedLocation_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(generators)
	extendedLocation_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocation_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone_STATUS))
}

func Test_Identity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUSARM, Identity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUSARM runs a test to see if a specific instance of Identity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUSARM(subject Identity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUSARM instances for property testing - lazily instantiated by Identity_STATUSARMGenerator()
var identity_STATUSARMGenerator gopter.Gen

// Identity_STATUSARMGenerator returns a generator of Identity_STATUSARM instances for property testing.
// We first initialize identity_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_STATUSARMGenerator() gopter.Gen {
	if identity_STATUSARMGenerator != nil {
		return identity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUSARM(generators)
	identity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForIdentity_STATUSARM(generators)
	identity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	return identity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_None_STATUS,
		Identity_Type_SystemAssigned_STATUS,
		Identity_Type_SystemAssignedUserAssigned_STATUS,
		Identity_Type_UserAssigned_STATUS))
}

// AddRelatedPropertyGeneratorsForIdentity_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_STATUSARMGenerator())
}

func Test_Sku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUSARM, Sku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUSARM runs a test to see if a specific instance of Sku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUSARM(subject Sku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUSARM instances for property testing - lazily instantiated by Sku_STATUSARMGenerator()
var sku_STATUSARMGenerator gopter.Gen

// Sku_STATUSARMGenerator returns a generator of Sku_STATUSARM instances for property testing.
func Sku_STATUSARMGenerator() gopter.Gen {
	if sku_STATUSARMGenerator != nil {
		return sku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUSARM(generators)
	sku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Sku_STATUSARM{}), generators)

	return sku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		SkuName_Premium_LRS_STATUS,
		SkuName_Premium_ZRS_STATUS,
		SkuName_Standard_GRS_STATUS,
		SkuName_Standard_GZRS_STATUS,
		SkuName_Standard_LRS_STATUS,
		SkuName_Standard_RAGRS_STATUS,
		SkuName_Standard_RAGZRS_STATUS,
		SkuName_Standard_ZRS_STATUS))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Tier_Premium_STATUS, Tier_Standard_STATUS))
}

func Test_StorageAccountPropertiesCreateParameters_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountPropertiesCreateParameters_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesCreateParameters_STATUSARM, StorageAccountPropertiesCreateParameters_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesCreateParameters_STATUSARM runs a test to see if a specific instance of StorageAccountPropertiesCreateParameters_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesCreateParameters_STATUSARM(subject StorageAccountPropertiesCreateParameters_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountPropertiesCreateParameters_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountPropertiesCreateParameters_STATUSARM instances for property testing - lazily instantiated
// by StorageAccountPropertiesCreateParameters_STATUSARMGenerator()
var storageAccountPropertiesCreateParameters_STATUSARMGenerator gopter.Gen

// StorageAccountPropertiesCreateParameters_STATUSARMGenerator returns a generator of StorageAccountPropertiesCreateParameters_STATUSARM instances for property testing.
// We first initialize storageAccountPropertiesCreateParameters_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesCreateParameters_STATUSARMGenerator() gopter.Gen {
	if storageAccountPropertiesCreateParameters_STATUSARMGenerator != nil {
		return storageAccountPropertiesCreateParameters_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM(generators)
	storageAccountPropertiesCreateParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParameters_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM(generators)
	storageAccountPropertiesCreateParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParameters_STATUSARM{}), generators)

	return storageAccountPropertiesCreateParameters_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_AccessTier_Cool_STATUS, StorageAccountPropertiesCreateParameters_AccessTier_Hot_STATUS))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_LargeFileSharesState_Disabled_STATUS, StorageAccountPropertiesCreateParameters_LargeFileSharesState_Enabled_STATUS))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_0_STATUS, StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_1_STATUS, StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_2_STATUS))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_STATUSARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_STATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_STATUSARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_STATUSARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_STATUSARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_STATUSARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_STATUSARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM, AzureFilesIdentityBasedAuthentication_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_STATUSARM(subject AzureFilesIdentityBasedAuthentication_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthentication_STATUSARMGenerator()
var azureFilesIdentityBasedAuthentication_STATUSARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_STATUSARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_STATUSARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_STATUSARMGenerator != nil {
		return azureFilesIdentityBasedAuthentication_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	azureFilesIdentityBasedAuthentication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(generators)
	azureFilesIdentityBasedAuthentication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	return azureFilesIdentityBasedAuthentication_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_None_STATUS,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareContributor_STATUS,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareElevatedContributor_STATUS,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareOwner_STATUS,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareReader_STATUS))
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.OneConstOf(AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_AADDS_STATUS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_AD_STATUS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_None_STATUS))
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_STATUSARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_STATUSARMGenerator())
}

func Test_CustomDomain_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_STATUSARM, CustomDomain_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_STATUSARM runs a test to see if a specific instance of CustomDomain_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_STATUSARM(subject CustomDomain_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUSARM instances for property testing - lazily instantiated by
// CustomDomain_STATUSARMGenerator()
var customDomain_STATUSARMGenerator gopter.Gen

// CustomDomain_STATUSARMGenerator returns a generator of CustomDomain_STATUSARM instances for property testing.
func CustomDomain_STATUSARMGenerator() gopter.Gen {
	if customDomain_STATUSARMGenerator != nil {
		return customDomain_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM(generators)
	customDomain_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUSARM{}), generators)

	return customDomain_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_STATUSARM, Encryption_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_STATUSARM runs a test to see if a specific instance of Encryption_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_STATUSARM(subject Encryption_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUSARM instances for property testing - lazily instantiated by
// Encryption_STATUSARMGenerator()
var encryption_STATUSARMGenerator gopter.Gen

// Encryption_STATUSARMGenerator returns a generator of Encryption_STATUSARM instances for property testing.
// We first initialize encryption_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_STATUSARMGenerator() gopter.Gen {
	if encryption_STATUSARMGenerator != nil {
		return encryption_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUSARM(generators)
	encryption_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryption_STATUSARM(generators)
	encryption_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	return encryption_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(Encryption_KeySource_MicrosoftKeyvault_STATUS, Encryption_KeySource_MicrosoftStorage_STATUS))
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_STATUSARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_STATUSARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_STATUSARMGenerator())
}

func Test_KeyPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_STATUSARM, KeyPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_STATUSARM runs a test to see if a specific instance of KeyPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_STATUSARM(subject KeyPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_STATUSARM instances for property testing - lazily instantiated by
// KeyPolicy_STATUSARMGenerator()
var keyPolicy_STATUSARMGenerator gopter.Gen

// KeyPolicy_STATUSARMGenerator returns a generator of KeyPolicy_STATUSARM instances for property testing.
func KeyPolicy_STATUSARMGenerator() gopter.Gen {
	if keyPolicy_STATUSARMGenerator != nil {
		return keyPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM(generators)
	keyPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_STATUSARM{}), generators)

	return keyPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_STATUSARM, NetworkRuleSet_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_STATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_STATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSet_STATUSARMGenerator()
var networkRuleSet_STATUSARMGenerator gopter.Gen

// NetworkRuleSet_STATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSet_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_STATUSARMGenerator() gopter.Gen {
	if networkRuleSet_STATUSARMGenerator != nil {
		return networkRuleSet_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSet_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_Bypass_AzureServices_STATUS,
		NetworkRuleSet_Bypass_Logging_STATUS,
		NetworkRuleSet_Bypass_Metrics_STATUS,
		NetworkRuleSet_Bypass_None_STATUS))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_DefaultAction_Allow_STATUS, NetworkRuleSet_DefaultAction_Deny_STATUS))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_STATUSARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_STATUSARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_STATUSARMGenerator())
}

func Test_RoutingPreference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_STATUSARM, RoutingPreference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_STATUSARM runs a test to see if a specific instance of RoutingPreference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_STATUSARM(subject RoutingPreference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_STATUSARM instances for property testing - lazily instantiated by
// RoutingPreference_STATUSARMGenerator()
var routingPreference_STATUSARMGenerator gopter.Gen

// RoutingPreference_STATUSARMGenerator returns a generator of RoutingPreference_STATUSARM instances for property testing.
func RoutingPreference_STATUSARMGenerator() gopter.Gen {
	if routingPreference_STATUSARMGenerator != nil {
		return routingPreference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM(generators)
	routingPreference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_STATUSARM{}), generators)

	return routingPreference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_STATUSARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_RoutingChoice_InternetRouting_STATUS, RoutingPreference_RoutingChoice_MicrosoftRouting_STATUS))
}

func Test_SasPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_STATUSARM, SasPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_STATUSARM runs a test to see if a specific instance of SasPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_STATUSARM(subject SasPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_STATUSARM instances for property testing - lazily instantiated by
// SasPolicy_STATUSARMGenerator()
var sasPolicy_STATUSARMGenerator gopter.Gen

// SasPolicy_STATUSARMGenerator returns a generator of SasPolicy_STATUSARM instances for property testing.
func SasPolicy_STATUSARMGenerator() gopter.Gen {
	if sasPolicy_STATUSARMGenerator != nil {
		return sasPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM(generators)
	sasPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_STATUSARM{}), generators)

	return sasPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.OneConstOf(SasPolicy_ExpirationAction_Log_STATUS))
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUSARM, UserAssignedIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUSARM runs a test to see if a specific instance of UserAssignedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUSARM(subject UserAssignedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSARMGenerator()
var userAssignedIdentity_STATUSARMGenerator gopter.Gen

// UserAssignedIdentity_STATUSARMGenerator returns a generator of UserAssignedIdentity_STATUSARM instances for property testing.
func UserAssignedIdentity_STATUSARMGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSARMGenerator != nil {
		return userAssignedIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(generators)
	userAssignedIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUSARM{}), generators)

	return userAssignedIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM, ActiveDirectoryProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM runs a test to see if a specific instance of ActiveDirectoryProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_STATUSARM(subject ActiveDirectoryProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_STATUSARM instances for property testing - lazily instantiated by
// ActiveDirectoryProperties_STATUSARMGenerator()
var activeDirectoryProperties_STATUSARMGenerator gopter.Gen

// ActiveDirectoryProperties_STATUSARMGenerator returns a generator of ActiveDirectoryProperties_STATUSARM instances for property testing.
func ActiveDirectoryProperties_STATUSARMGenerator() gopter.Gen {
	if activeDirectoryProperties_STATUSARMGenerator != nil {
		return activeDirectoryProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM(generators)
	activeDirectoryProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_STATUSARM{}), generators)

	return activeDirectoryProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_STATUSARM, EncryptionIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_STATUSARM runs a test to see if a specific instance of EncryptionIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_STATUSARM(subject EncryptionIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_STATUSARM instances for property testing - lazily instantiated by
// EncryptionIdentity_STATUSARMGenerator()
var encryptionIdentity_STATUSARMGenerator gopter.Gen

// EncryptionIdentity_STATUSARMGenerator returns a generator of EncryptionIdentity_STATUSARM instances for property testing.
func EncryptionIdentity_STATUSARMGenerator() gopter.Gen {
	if encryptionIdentity_STATUSARMGenerator != nil {
		return encryptionIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM(generators)
	encryptionIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_STATUSARM{}), generators)

	return encryptionIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_STATUSARM, EncryptionServices_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_STATUSARM runs a test to see if a specific instance of EncryptionServices_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_STATUSARM(subject EncryptionServices_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_STATUSARM instances for property testing - lazily instantiated by
// EncryptionServices_STATUSARMGenerator()
var encryptionServices_STATUSARMGenerator gopter.Gen

// EncryptionServices_STATUSARMGenerator returns a generator of EncryptionServices_STATUSARM instances for property testing.
func EncryptionServices_STATUSARMGenerator() gopter.Gen {
	if encryptionServices_STATUSARMGenerator != nil {
		return encryptionServices_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM(generators)
	encryptionServices_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_STATUSARM{}), generators)

	return encryptionServices_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_STATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_STATUSARMGenerator())
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_STATUSARM, IPRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_STATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_STATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRule_STATUSARMGenerator()
var ipRule_STATUSARMGenerator gopter.Gen

// IPRule_STATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRule_STATUSARMGenerator() gopter.Gen {
	if ipRule_STATUSARMGenerator != nil {
		return ipRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_STATUSARM(generators)
	ipRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_Allow_STATUS))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUSARM, KeyVaultProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultProperties_STATUSARMGenerator()
var keyVaultProperties_STATUSARMGenerator gopter.Gen

// KeyVaultProperties_STATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultProperties_STATUSARMGenerator() gopter.Gen {
	if keyVaultProperties_STATUSARMGenerator != nil {
		return keyVaultProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(generators)
	keyVaultProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_STATUSARM, ResourceAccessRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_STATUSARM runs a test to see if a specific instance of ResourceAccessRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_STATUSARM(subject ResourceAccessRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_STATUSARM instances for property testing - lazily instantiated by
// ResourceAccessRule_STATUSARMGenerator()
var resourceAccessRule_STATUSARMGenerator gopter.Gen

// ResourceAccessRule_STATUSARMGenerator returns a generator of ResourceAccessRule_STATUSARM instances for property testing.
func ResourceAccessRule_STATUSARMGenerator() gopter.Gen {
	if resourceAccessRule_STATUSARMGenerator != nil {
		return resourceAccessRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM(generators)
	resourceAccessRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_STATUSARM{}), generators)

	return resourceAccessRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_STATUSARM, VirtualNetworkRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_STATUSARM runs a test to see if a specific instance of VirtualNetworkRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_STATUSARM(subject VirtualNetworkRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUSARM instances for property testing - lazily instantiated by
// VirtualNetworkRule_STATUSARMGenerator()
var virtualNetworkRule_STATUSARMGenerator gopter.Gen

// VirtualNetworkRule_STATUSARMGenerator returns a generator of VirtualNetworkRule_STATUSARM instances for property testing.
func VirtualNetworkRule_STATUSARMGenerator() gopter.Gen {
	if virtualNetworkRule_STATUSARMGenerator != nil {
		return virtualNetworkRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(generators)
	virtualNetworkRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUSARM{}), generators)

	return virtualNetworkRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_Action_Allow_STATUS))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_State_Deprovisioning_STATUS,
		VirtualNetworkRule_State_Failed_STATUS,
		VirtualNetworkRule_State_NetworkSourceDeleted_STATUS,
		VirtualNetworkRule_State_Provisioning_STATUS,
		VirtualNetworkRule_State_Succeeded_STATUS))
}

func Test_EncryptionService_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_STATUSARM, EncryptionService_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_STATUSARM runs a test to see if a specific instance of EncryptionService_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_STATUSARM(subject EncryptionService_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_STATUSARM instances for property testing - lazily instantiated by
// EncryptionService_STATUSARMGenerator()
var encryptionService_STATUSARMGenerator gopter.Gen

// EncryptionService_STATUSARMGenerator returns a generator of EncryptionService_STATUSARM instances for property testing.
func EncryptionService_STATUSARMGenerator() gopter.Gen {
	if encryptionService_STATUSARMGenerator != nil {
		return encryptionService_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM(generators)
	encryptionService_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_STATUSARM{}), generators)

	return encryptionService_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_STATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_KeyType_Account_STATUS, EncryptionService_KeyType_Service_STATUS))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
