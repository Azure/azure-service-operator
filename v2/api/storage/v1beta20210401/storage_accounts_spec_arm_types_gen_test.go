// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccounts_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccounts_SpecARM, StorageAccounts_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccounts_SpecARM runs a test to see if a specific instance of StorageAccounts_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccounts_SpecARM(subject StorageAccounts_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_SpecARM instances for property testing - lazily instantiated by
// StorageAccounts_SpecARMGenerator()
var storageAccounts_SpecARMGenerator gopter.Gen

// StorageAccounts_SpecARMGenerator returns a generator of StorageAccounts_SpecARM instances for property testing.
// We first initialize storageAccounts_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccounts_SpecARMGenerator() gopter.Gen {
	if storageAccounts_SpecARMGenerator != nil {
		return storageAccounts_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SpecARM(generators)
	storageAccounts_SpecARMGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SpecARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccounts_SpecARM(generators)
	storageAccounts_SpecARMGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SpecARM{}), generators)

	return storageAccounts_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccounts_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccounts_SpecARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccounts_Spec_Kind_BlobStorage,
		StorageAccounts_Spec_Kind_BlockBlobStorage,
		StorageAccounts_Spec_Kind_FileStorage,
		StorageAccounts_Spec_Kind_Storage,
		StorageAccounts_Spec_Kind_StorageV2))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccounts_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccounts_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesCreateParametersARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocation_Type_EdgeZone))
}

func Test_IdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityARM, IdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityARM runs a test to see if a specific instance of IdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityARM(subject IdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityARM instances for property testing - lazily instantiated by IdentityARMGenerator()
var identityARMGenerator gopter.Gen

// IdentityARMGenerator returns a generator of IdentityARM instances for property testing.
func IdentityARMGenerator() gopter.Gen {
	if identityARMGenerator != nil {
		return identityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityARM(generators)
	identityARMGenerator = gen.Struct(reflect.TypeOf(IdentityARM{}), generators)

	return identityARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_None,
		Identity_Type_SystemAssigned,
		Identity_Type_SystemAssignedUserAssigned,
		Identity_Type_UserAssigned))
}

func Test_SkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuARM, SkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuARM runs a test to see if a specific instance of SkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuARM(subject SkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SkuARM instances for property testing - lazily instantiated by SkuARMGenerator()
var skuARMGenerator gopter.Gen

// SkuARMGenerator returns a generator of SkuARM instances for property testing.
func SkuARMGenerator() gopter.Gen {
	if skuARMGenerator != nil {
		return skuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuARM(generators)
	skuARMGenerator = gen.Struct(reflect.TypeOf(SkuARM{}), generators)

	return skuARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		Sku_Name_Premium_LRS,
		Sku_Name_Premium_ZRS,
		Sku_Name_Standard_GRS,
		Sku_Name_Standard_GZRS,
		Sku_Name_Standard_LRS,
		Sku_Name_Standard_RAGRS,
		Sku_Name_Standard_RAGZRS,
		Sku_Name_Standard_ZRS))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Sku_Tier_Premium, Sku_Tier_Standard))
}

func Test_StorageAccountPropertiesCreateParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountPropertiesCreateParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesCreateParametersARM, StorageAccountPropertiesCreateParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesCreateParametersARM runs a test to see if a specific instance of StorageAccountPropertiesCreateParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesCreateParametersARM(subject StorageAccountPropertiesCreateParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountPropertiesCreateParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountPropertiesCreateParametersARM instances for property testing - lazily instantiated by
// StorageAccountPropertiesCreateParametersARMGenerator()
var storageAccountPropertiesCreateParametersARMGenerator gopter.Gen

// StorageAccountPropertiesCreateParametersARMGenerator returns a generator of StorageAccountPropertiesCreateParametersARM instances for property testing.
// We first initialize storageAccountPropertiesCreateParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesCreateParametersARMGenerator() gopter.Gen {
	if storageAccountPropertiesCreateParametersARMGenerator != nil {
		return storageAccountPropertiesCreateParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM(generators)
	storageAccountPropertiesCreateParametersARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM(generators)
	storageAccountPropertiesCreateParametersARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParametersARM{}), generators)

	return storageAccountPropertiesCreateParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_AccessTier_Cool, StorageAccountPropertiesCreateParameters_AccessTier_Hot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_LargeFileSharesState_Disabled, StorageAccountPropertiesCreateParameters_LargeFileSharesState_Enabled))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_0, StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_1, StorageAccountPropertiesCreateParameters_MinimumTlsVersion_TLS1_2))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthenticationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthenticationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM, AzureFilesIdentityBasedAuthenticationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthenticationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM(subject AzureFilesIdentityBasedAuthenticationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthenticationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthenticationARM instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthenticationARMGenerator()
var azureFilesIdentityBasedAuthenticationARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationARMGenerator returns a generator of AzureFilesIdentityBasedAuthenticationARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	azureFilesIdentityBasedAuthenticationARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthenticationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	azureFilesIdentityBasedAuthenticationARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthenticationARM{}), generators)

	return azureFilesIdentityBasedAuthenticationARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_None,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.OneConstOf(AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_AADDS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_AD, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_None))
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesARMGenerator())
}

func Test_CustomDomainARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainARM, CustomDomainARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainARM runs a test to see if a specific instance of CustomDomainARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainARM(subject CustomDomainARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainARM instances for property testing - lazily instantiated by CustomDomainARMGenerator()
var customDomainARMGenerator gopter.Gen

// CustomDomainARMGenerator returns a generator of CustomDomainARM instances for property testing.
func CustomDomainARMGenerator() gopter.Gen {
	if customDomainARMGenerator != nil {
		return customDomainARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainARM(generators)
	customDomainARMGenerator = gen.Struct(reflect.TypeOf(CustomDomainARM{}), generators)

	return customDomainARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_EncryptionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionARM, EncryptionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionARM runs a test to see if a specific instance of EncryptionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionARM(subject EncryptionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionARM instances for property testing - lazily instantiated by EncryptionARMGenerator()
var encryptionARMGenerator gopter.Gen

// EncryptionARMGenerator returns a generator of EncryptionARM instances for property testing.
// We first initialize encryptionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionARMGenerator() gopter.Gen {
	if encryptionARMGenerator != nil {
		return encryptionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionARM(generators)
	encryptionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionARM(generators)
	encryptionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionARM{}), generators)

	return encryptionARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(Encryption_KeySource_MicrosoftKeyvault, Encryption_KeySource_MicrosoftStorage))
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesARMGenerator())
}

func Test_KeyPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicyARM, KeyPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicyARM runs a test to see if a specific instance of KeyPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicyARM(subject KeyPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicyARM instances for property testing - lazily instantiated by KeyPolicyARMGenerator()
var keyPolicyARMGenerator gopter.Gen

// KeyPolicyARMGenerator returns a generator of KeyPolicyARM instances for property testing.
func KeyPolicyARMGenerator() gopter.Gen {
	if keyPolicyARMGenerator != nil {
		return keyPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicyARM(generators)
	keyPolicyARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicyARM{}), generators)

	return keyPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicyARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSetARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetARM, NetworkRuleSetARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetARM runs a test to see if a specific instance of NetworkRuleSetARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetARM(subject NetworkRuleSetARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetARM instances for property testing - lazily instantiated by NetworkRuleSetARMGenerator()
var networkRuleSetARMGenerator gopter.Gen

// NetworkRuleSetARMGenerator returns a generator of NetworkRuleSetARM instances for property testing.
// We first initialize networkRuleSetARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetARMGenerator() gopter.Gen {
	if networkRuleSetARMGenerator != nil {
		return networkRuleSetARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetARM(generators)
	networkRuleSetARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetARM(generators)
	networkRuleSetARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetARM{}), generators)

	return networkRuleSetARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_Bypass_AzureServices,
		NetworkRuleSet_Bypass_Logging,
		NetworkRuleSet_Bypass_Metrics,
		NetworkRuleSet_Bypass_None))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_DefaultAction_Allow, NetworkRuleSet_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleARMGenerator())
}

func Test_RoutingPreferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceARM, RoutingPreferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceARM runs a test to see if a specific instance of RoutingPreferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceARM(subject RoutingPreferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreferenceARM instances for property testing - lazily instantiated by
// RoutingPreferenceARMGenerator()
var routingPreferenceARMGenerator gopter.Gen

// RoutingPreferenceARMGenerator returns a generator of RoutingPreferenceARM instances for property testing.
func RoutingPreferenceARMGenerator() gopter.Gen {
	if routingPreferenceARMGenerator != nil {
		return routingPreferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceARM(generators)
	routingPreferenceARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreferenceARM{}), generators)

	return routingPreferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_RoutingChoice_InternetRouting, RoutingPreference_RoutingChoice_MicrosoftRouting))
}

func Test_SasPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicyARM, SasPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicyARM runs a test to see if a specific instance of SasPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicyARM(subject SasPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicyARM instances for property testing - lazily instantiated by SasPolicyARMGenerator()
var sasPolicyARMGenerator gopter.Gen

// SasPolicyARMGenerator returns a generator of SasPolicyARM instances for property testing.
func SasPolicyARMGenerator() gopter.Gen {
	if sasPolicyARMGenerator != nil {
		return sasPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicyARM(generators)
	sasPolicyARMGenerator = gen.Struct(reflect.TypeOf(SasPolicyARM{}), generators)

	return sasPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicyARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.OneConstOf(SasPolicy_ExpirationAction_Log))
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesARM, ActiveDirectoryPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesARM runs a test to see if a specific instance of ActiveDirectoryPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesARM(subject ActiveDirectoryPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryPropertiesARM instances for property testing - lazily instantiated by
// ActiveDirectoryPropertiesARMGenerator()
var activeDirectoryPropertiesARMGenerator gopter.Gen

// ActiveDirectoryPropertiesARMGenerator returns a generator of ActiveDirectoryPropertiesARM instances for property testing.
func ActiveDirectoryPropertiesARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesARMGenerator != nil {
		return activeDirectoryPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM(generators)
	activeDirectoryPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryPropertiesARM{}), generators)

	return activeDirectoryPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentityARM, EncryptionIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentityARM runs a test to see if a specific instance of EncryptionIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentityARM(subject EncryptionIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentityARM instances for property testing - lazily instantiated by
// EncryptionIdentityARMGenerator()
var encryptionIdentityARMGenerator gopter.Gen

// EncryptionIdentityARMGenerator returns a generator of EncryptionIdentityARM instances for property testing.
func EncryptionIdentityARMGenerator() gopter.Gen {
	if encryptionIdentityARMGenerator != nil {
		return encryptionIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentityARM(generators)
	encryptionIdentityARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentityARM{}), generators)

	return encryptionIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentityARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServicesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServicesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesARM, EncryptionServicesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesARM runs a test to see if a specific instance of EncryptionServicesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesARM(subject EncryptionServicesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServicesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServicesARM instances for property testing - lazily instantiated by
// EncryptionServicesARMGenerator()
var encryptionServicesARMGenerator gopter.Gen

// EncryptionServicesARMGenerator returns a generator of EncryptionServicesARM instances for property testing.
func EncryptionServicesARMGenerator() gopter.Gen {
	if encryptionServicesARMGenerator != nil {
		return encryptionServicesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesARM(generators)
	encryptionServicesARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServicesARM{}), generators)

	return encryptionServicesARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceARMGenerator())
}

func Test_IPRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleARM, IPRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleARM runs a test to see if a specific instance of IPRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleARM(subject IPRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRuleARM instances for property testing - lazily instantiated by IPRuleARMGenerator()
var ipRuleARMGenerator gopter.Gen

// IPRuleARMGenerator returns a generator of IPRuleARM instances for property testing.
func IPRuleARMGenerator() gopter.Gen {
	if ipRuleARMGenerator != nil {
		return ipRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleARM(generators)
	ipRuleARMGenerator = gen.Struct(reflect.TypeOf(IPRuleARM{}), generators)

	return ipRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesARM, KeyVaultPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesARM runs a test to see if a specific instance of KeyVaultPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesARM(subject KeyVaultPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultPropertiesARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesARMGenerator()
var keyVaultPropertiesARMGenerator gopter.Gen

// KeyVaultPropertiesARMGenerator returns a generator of KeyVaultPropertiesARM instances for property testing.
func KeyVaultPropertiesARMGenerator() gopter.Gen {
	if keyVaultPropertiesARMGenerator != nil {
		return keyVaultPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM(generators)
	keyVaultPropertiesARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultPropertiesARM{}), generators)

	return keyVaultPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleARM, ResourceAccessRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleARM runs a test to see if a specific instance of ResourceAccessRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleARM(subject ResourceAccessRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRuleARM instances for property testing - lazily instantiated by
// ResourceAccessRuleARMGenerator()
var resourceAccessRuleARMGenerator gopter.Gen

// ResourceAccessRuleARMGenerator returns a generator of ResourceAccessRuleARM instances for property testing.
func ResourceAccessRuleARMGenerator() gopter.Gen {
	if resourceAccessRuleARMGenerator != nil {
		return resourceAccessRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleARM(generators)
	resourceAccessRuleARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRuleARM{}), generators)

	return resourceAccessRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleARM, VirtualNetworkRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleARM runs a test to see if a specific instance of VirtualNetworkRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleARM(subject VirtualNetworkRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRuleARM instances for property testing - lazily instantiated by
// VirtualNetworkRuleARMGenerator()
var virtualNetworkRuleARMGenerator gopter.Gen

// VirtualNetworkRuleARMGenerator returns a generator of VirtualNetworkRuleARM instances for property testing.
func VirtualNetworkRuleARMGenerator() gopter.Gen {
	if virtualNetworkRuleARMGenerator != nil {
		return virtualNetworkRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM(generators)
	virtualNetworkRuleARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRuleARM{}), generators)

	return virtualNetworkRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_Action_Allow))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_State_Deprovisioning,
		VirtualNetworkRule_State_Failed,
		VirtualNetworkRule_State_NetworkSourceDeleted,
		VirtualNetworkRule_State_Provisioning,
		VirtualNetworkRule_State_Succeeded))
}

func Test_EncryptionServiceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServiceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceARM, EncryptionServiceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceARM runs a test to see if a specific instance of EncryptionServiceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceARM(subject EncryptionServiceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServiceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServiceARM instances for property testing - lazily instantiated by
// EncryptionServiceARMGenerator()
var encryptionServiceARMGenerator gopter.Gen

// EncryptionServiceARMGenerator returns a generator of EncryptionServiceARM instances for property testing.
func EncryptionServiceARMGenerator() gopter.Gen {
	if encryptionServiceARMGenerator != nil {
		return encryptionServiceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceARM(generators)
	encryptionServiceARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServiceARM{}), generators)

	return encryptionServiceARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_KeyType_Account, EncryptionService_KeyType_Service))
}
