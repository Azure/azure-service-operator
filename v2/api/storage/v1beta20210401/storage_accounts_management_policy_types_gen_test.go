// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401

import (
	"encoding/json"
	v20210401s "github.com/Azure/azure-service-operator/v2/api/storage/v1beta20210401storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccountsManagementPolicy_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicy to hub returns original",
		prop.ForAll(RunResourceConversionTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForStorageAccountsManagementPolicy tests if a specific instance of StorageAccountsManagementPolicy round trips to the hub storage version and back losslessly
func RunResourceConversionTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210401s.StorageAccountsManagementPolicy
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual StorageAccountsManagementPolicy
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicy to StorageAccountsManagementPolicy via AssignPropertiesToStorageAccountsManagementPolicy & AssignPropertiesFromStorageAccountsManagementPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccountsManagementPolicy tests if a specific instance of StorageAccountsManagementPolicy can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.StorageAccountsManagementPolicy
	err := copied.AssignPropertiesToStorageAccountsManagementPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccountsManagementPolicy
	err = actual.AssignPropertiesFromStorageAccountsManagementPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountsManagementPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsManagementPolicy runs a test to see if a specific instance of StorageAccountsManagementPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountsManagementPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountsManagementPolicy instances for property testing - lazily instantiated by
// StorageAccountsManagementPolicyGenerator()
var storageAccountsManagementPolicyGenerator gopter.Gen

// StorageAccountsManagementPolicyGenerator returns a generator of StorageAccountsManagementPolicy instances for property testing.
func StorageAccountsManagementPolicyGenerator() gopter.Gen {
	if storageAccountsManagementPolicyGenerator != nil {
		return storageAccountsManagementPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy(generators)
	storageAccountsManagementPolicyGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy{}), generators)

	return storageAccountsManagementPolicyGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy(gens map[string]gopter.Gen) {
<<<<<<< HEAD
	gens["Spec"] = StorageAccountsManagementPolicy_SpecGenerator()
	gens["Status"] = StorageAccountsManagementPolicy_STATUSGenerator()
}

func Test_StorageAccountsManagementPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
=======
	gens["Spec"] = StorageAccountsManagementPoliciesSpecGenerator()
	gens["Status"] = ManagementPolicySTATUSGenerator()
}

func Test_ManagementPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from StorageAccountsManagementPolicy_STATUS to StorageAccountsManagementPolicy_STATUS via AssignPropertiesToStorageAccountsManagementPolicy_STATUS & AssignPropertiesFromStorageAccountsManagementPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccountsManagementPolicy_STATUS, StorageAccountsManagementPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccountsManagementPolicy_STATUS tests if a specific instance of StorageAccountsManagementPolicy_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccountsManagementPolicy_STATUS(subject StorageAccountsManagementPolicy_STATUS) string {
=======
		"Round trip from ManagementPolicy_STATUS to ManagementPolicy_STATUS via AssignPropertiesToManagementPolicySTATUS & AssignPropertiesFromManagementPolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySTATUS, ManagementPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySTATUS tests if a specific instance of ManagementPolicy_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySTATUS(subject ManagementPolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
<<<<<<< HEAD
	var other v20210401s.StorageAccountsManagementPolicy_STATUS
	err := copied.AssignPropertiesToStorageAccountsManagementPolicy_STATUS(&other)
=======
	var other v20210401s.ManagementPolicy_STATUS
	err := copied.AssignPropertiesToManagementPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
<<<<<<< HEAD
	var actual StorageAccountsManagementPolicy_STATUS
	err = actual.AssignPropertiesFromStorageAccountsManagementPolicy_STATUS(&other)
=======
	var actual ManagementPolicy_STATUS
	err = actual.AssignPropertiesFromManagementPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
func Test_StorageAccountsManagementPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
=======
func Test_ManagementPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip of StorageAccountsManagementPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsManagementPolicy_STATUS, StorageAccountsManagementPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsManagementPolicy_STATUS runs a test to see if a specific instance of StorageAccountsManagementPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsManagementPolicy_STATUS(subject StorageAccountsManagementPolicy_STATUS) string {
=======
		"Round trip of ManagementPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySTATUS, ManagementPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySTATUS runs a test to see if a specific instance of ManagementPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySTATUS(subject ManagementPolicy_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
<<<<<<< HEAD
	var actual StorageAccountsManagementPolicy_STATUS
=======
	var actual ManagementPolicy_STATUS
>>>>>>> main
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of StorageAccountsManagementPolicy_STATUS instances for property testing - lazily instantiated by
// StorageAccountsManagementPolicy_STATUSGenerator()
var storageAccountsManagementPolicy_STATUSGenerator gopter.Gen

// StorageAccountsManagementPolicy_STATUSGenerator returns a generator of StorageAccountsManagementPolicy_STATUS instances for property testing.
// We first initialize storageAccountsManagementPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsManagementPolicy_STATUSGenerator() gopter.Gen {
	if storageAccountsManagementPolicy_STATUSGenerator != nil {
		return storageAccountsManagementPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS(generators)
	storageAccountsManagementPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS(generators)
	storageAccountsManagementPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy_STATUS{}), generators)

	return storageAccountsManagementPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of ManagementPolicy_STATUS instances for property testing - lazily instantiated by
// ManagementPolicySTATUSGenerator()
var managementPolicySTATUSGenerator gopter.Gen

// ManagementPolicySTATUSGenerator returns a generator of ManagementPolicy_STATUS instances for property testing.
// We first initialize managementPolicySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicySTATUSGenerator() gopter.Gen {
	if managementPolicySTATUSGenerator != nil {
		return managementPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicySTATUS(generators)
	managementPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicySTATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicySTATUS(generators)
	managementPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicy_STATUS{}), generators)

	return managementPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicySTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Policy"] = gen.PtrOf(ManagementPolicySchema_STATUSGenerator())
=======
// AddRelatedPropertyGeneratorsForManagementPolicySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySTATUS(gens map[string]gopter.Gen) {
	gens["Policy"] = gen.PtrOf(ManagementPolicySchemaSTATUSGenerator())
>>>>>>> main
}

func Test_StorageAccountsManagementPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicy_Spec to StorageAccountsManagementPolicy_Spec via AssignPropertiesToStorageAccountsManagementPolicy_Spec & AssignPropertiesFromStorageAccountsManagementPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccountsManagementPolicy_Spec, StorageAccountsManagementPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccountsManagementPolicy_Spec tests if a specific instance of StorageAccountsManagementPolicy_Spec can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccountsManagementPolicy_Spec(subject StorageAccountsManagementPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.StorageAccountsManagementPolicy_Spec
	err := copied.AssignPropertiesToStorageAccountsManagementPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccountsManagementPolicy_Spec
	err = actual.AssignPropertiesFromStorageAccountsManagementPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountsManagementPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsManagementPolicy_Spec, StorageAccountsManagementPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsManagementPolicy_Spec runs a test to see if a specific instance of StorageAccountsManagementPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsManagementPolicy_Spec(subject StorageAccountsManagementPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountsManagementPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountsManagementPolicy_Spec instances for property testing - lazily instantiated by
// StorageAccountsManagementPolicy_SpecGenerator()
var storageAccountsManagementPolicy_SpecGenerator gopter.Gen

// StorageAccountsManagementPolicy_SpecGenerator returns a generator of StorageAccountsManagementPolicy_Spec instances for property testing.
// We first initialize storageAccountsManagementPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsManagementPolicy_SpecGenerator() gopter.Gen {
	if storageAccountsManagementPolicy_SpecGenerator != nil {
		return storageAccountsManagementPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_Spec(generators)
	storageAccountsManagementPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_Spec(generators)
	storageAccountsManagementPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy_Spec{}), generators)

	return storageAccountsManagementPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsManagementPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Policy"] = gen.PtrOf(ManagementPolicySchemaGenerator())
}

func Test_ManagementPolicySchema_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySchema to ManagementPolicySchema via AssignPropertiesToManagementPolicySchema & AssignPropertiesFromManagementPolicySchema returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySchema, ManagementPolicySchemaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySchema tests if a specific instance of ManagementPolicySchema can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySchema(subject ManagementPolicySchema) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySchema
	err := copied.AssignPropertiesToManagementPolicySchema(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySchema
	err = actual.AssignPropertiesFromManagementPolicySchema(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySchema_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySchema via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySchema, ManagementPolicySchemaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySchema runs a test to see if a specific instance of ManagementPolicySchema round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySchema(subject ManagementPolicySchema) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySchema
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySchema instances for property testing - lazily instantiated by
// ManagementPolicySchemaGenerator()
var managementPolicySchemaGenerator gopter.Gen

// ManagementPolicySchemaGenerator returns a generator of ManagementPolicySchema instances for property testing.
func ManagementPolicySchemaGenerator() gopter.Gen {
	if managementPolicySchemaGenerator != nil {
		return managementPolicySchemaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySchema(generators)
	managementPolicySchemaGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySchema{}), generators)

	return managementPolicySchemaGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySchema is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySchema(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagementPolicyRuleGenerator())
}

func Test_ManagementPolicySchema_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicySchema_STATUS to ManagementPolicySchema_STATUS via AssignPropertiesToManagementPolicySchema_STATUS & AssignPropertiesFromManagementPolicySchema_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySchema_STATUS, ManagementPolicySchema_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySchema_STATUS tests if a specific instance of ManagementPolicySchema_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySchema_STATUS(subject ManagementPolicySchema_STATUS) string {
=======
		"Round trip from ManagementPolicySchema_STATUS to ManagementPolicySchema_STATUS via AssignPropertiesToManagementPolicySchemaSTATUS & AssignPropertiesFromManagementPolicySchemaSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySchemaSTATUS, ManagementPolicySchemaSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySchemaSTATUS tests if a specific instance of ManagementPolicySchema_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySchemaSTATUS(subject ManagementPolicySchema_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySchema_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicySchema_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicySchemaSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySchema_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicySchema_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicySchemaSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySchema_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySchema_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicySchema_STATUS, ManagementPolicySchema_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySchema_STATUS runs a test to see if a specific instance of ManagementPolicySchema_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySchema_STATUS(subject ManagementPolicySchema_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicySchemaSTATUS, ManagementPolicySchemaSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySchemaSTATUS runs a test to see if a specific instance of ManagementPolicySchema_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySchemaSTATUS(subject ManagementPolicySchema_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySchema_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySchema_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicySchema_STATUSGenerator()
var managementPolicySchema_STATUSGenerator gopter.Gen

// ManagementPolicySchema_STATUSGenerator returns a generator of ManagementPolicySchema_STATUS instances for property testing.
func ManagementPolicySchema_STATUSGenerator() gopter.Gen {
	if managementPolicySchema_STATUSGenerator != nil {
		return managementPolicySchema_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySchema_STATUS(generators)
	managementPolicySchema_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySchema_STATUS{}), generators)

	return managementPolicySchema_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySchema_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySchema_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagementPolicyRule_STATUSGenerator())
=======
// ManagementPolicySchemaSTATUSGenerator()
var managementPolicySchemaSTATUSGenerator gopter.Gen

// ManagementPolicySchemaSTATUSGenerator returns a generator of ManagementPolicySchema_STATUS instances for property testing.
func ManagementPolicySchemaSTATUSGenerator() gopter.Gen {
	if managementPolicySchemaSTATUSGenerator != nil {
		return managementPolicySchemaSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySchemaSTATUS(generators)
	managementPolicySchemaSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySchema_STATUS{}), generators)

	return managementPolicySchemaSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySchemaSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySchemaSTATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagementPolicyRuleSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyRule to ManagementPolicyRule via AssignPropertiesToManagementPolicyRule & AssignPropertiesFromManagementPolicyRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyRule, ManagementPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyRule tests if a specific instance of ManagementPolicyRule can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyRule(subject ManagementPolicyRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyRule
	err := copied.AssignPropertiesToManagementPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyRule
	err = actual.AssignPropertiesFromManagementPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyRule, ManagementPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyRule runs a test to see if a specific instance of ManagementPolicyRule round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyRule(subject ManagementPolicyRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyRule instances for property testing - lazily instantiated by
// ManagementPolicyRuleGenerator()
var managementPolicyRuleGenerator gopter.Gen

// ManagementPolicyRuleGenerator returns a generator of ManagementPolicyRule instances for property testing.
// We first initialize managementPolicyRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyRuleGenerator() gopter.Gen {
	if managementPolicyRuleGenerator != nil {
		return managementPolicyRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule(generators)
	managementPolicyRuleGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyRule(generators)
	managementPolicyRuleGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule{}), generators)

	return managementPolicyRuleGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyRule(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagementPolicyRule_Type_Lifecycle))
}

// AddRelatedPropertyGeneratorsForManagementPolicyRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyRule(gens map[string]gopter.Gen) {
	gens["Definition"] = gen.PtrOf(ManagementPolicyDefinitionGenerator())
}

func Test_ManagementPolicyRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyRule_STATUS to ManagementPolicyRule_STATUS via AssignPropertiesToManagementPolicyRule_STATUS & AssignPropertiesFromManagementPolicyRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyRule_STATUS, ManagementPolicyRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyRule_STATUS tests if a specific instance of ManagementPolicyRule_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyRule_STATUS(subject ManagementPolicyRule_STATUS) string {
=======
		"Round trip from ManagementPolicyRule_STATUS to ManagementPolicyRule_STATUS via AssignPropertiesToManagementPolicyRuleSTATUS & AssignPropertiesFromManagementPolicyRuleSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyRuleSTATUS, ManagementPolicyRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyRuleSTATUS tests if a specific instance of ManagementPolicyRule_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyRuleSTATUS(subject ManagementPolicyRule_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyRule_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyRule_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyRuleSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyRule_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyRule_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyRuleSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyRule_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyRule_STATUS, ManagementPolicyRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyRule_STATUS runs a test to see if a specific instance of ManagementPolicyRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyRule_STATUS(subject ManagementPolicyRule_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyRuleSTATUS, ManagementPolicyRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyRuleSTATUS runs a test to see if a specific instance of ManagementPolicyRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyRuleSTATUS(subject ManagementPolicyRule_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyRule_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyRule_STATUSGenerator()
var managementPolicyRule_STATUSGenerator gopter.Gen

// ManagementPolicyRule_STATUSGenerator returns a generator of ManagementPolicyRule_STATUS instances for property testing.
// We first initialize managementPolicyRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyRule_STATUSGenerator() gopter.Gen {
	if managementPolicyRule_STATUSGenerator != nil {
		return managementPolicyRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule_STATUS(generators)
	managementPolicyRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyRule_STATUS(generators)
	managementPolicyRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_STATUS{}), generators)

	return managementPolicyRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyRule_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagementPolicyRule_Type_Lifecycle_STATUS))
}

// AddRelatedPropertyGeneratorsForManagementPolicyRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyRule_STATUS(gens map[string]gopter.Gen) {
	gens["Definition"] = gen.PtrOf(ManagementPolicyDefinition_STATUSGenerator())
=======
// ManagementPolicyRuleSTATUSGenerator()
var managementPolicyRuleSTATUSGenerator gopter.Gen

// ManagementPolicyRuleSTATUSGenerator returns a generator of ManagementPolicyRule_STATUS instances for property testing.
// We first initialize managementPolicyRuleSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyRuleSTATUSGenerator() gopter.Gen {
	if managementPolicyRuleSTATUSGenerator != nil {
		return managementPolicyRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRuleSTATUS(generators)
	managementPolicyRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRuleSTATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyRuleSTATUS(generators)
	managementPolicyRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_STATUS{}), generators)

	return managementPolicyRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagementPolicyRuleSTATUSType_Lifecycle))
}

// AddRelatedPropertyGeneratorsForManagementPolicyRuleSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Definition"] = gen.PtrOf(ManagementPolicyDefinitionSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyDefinition to ManagementPolicyDefinition via AssignPropertiesToManagementPolicyDefinition & AssignPropertiesFromManagementPolicyDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyDefinition, ManagementPolicyDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyDefinition tests if a specific instance of ManagementPolicyDefinition can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyDefinition(subject ManagementPolicyDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyDefinition
	err := copied.AssignPropertiesToManagementPolicyDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyDefinition
	err = actual.AssignPropertiesFromManagementPolicyDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyDefinition, ManagementPolicyDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyDefinition runs a test to see if a specific instance of ManagementPolicyDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyDefinition(subject ManagementPolicyDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyDefinition instances for property testing - lazily instantiated by
// ManagementPolicyDefinitionGenerator()
var managementPolicyDefinitionGenerator gopter.Gen

// ManagementPolicyDefinitionGenerator returns a generator of ManagementPolicyDefinition instances for property testing.
func ManagementPolicyDefinitionGenerator() gopter.Gen {
	if managementPolicyDefinitionGenerator != nil {
		return managementPolicyDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyDefinition(generators)
	managementPolicyDefinitionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyDefinition{}), generators)

	return managementPolicyDefinitionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyDefinition(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(ManagementPolicyActionGenerator())
	gens["Filters"] = gen.PtrOf(ManagementPolicyFilterGenerator())
}

func Test_ManagementPolicyDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyDefinition_STATUS to ManagementPolicyDefinition_STATUS via AssignPropertiesToManagementPolicyDefinition_STATUS & AssignPropertiesFromManagementPolicyDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyDefinition_STATUS, ManagementPolicyDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyDefinition_STATUS tests if a specific instance of ManagementPolicyDefinition_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyDefinition_STATUS(subject ManagementPolicyDefinition_STATUS) string {
=======
		"Round trip from ManagementPolicyDefinition_STATUS to ManagementPolicyDefinition_STATUS via AssignPropertiesToManagementPolicyDefinitionSTATUS & AssignPropertiesFromManagementPolicyDefinitionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyDefinitionSTATUS, ManagementPolicyDefinitionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyDefinitionSTATUS tests if a specific instance of ManagementPolicyDefinition_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyDefinitionSTATUS(subject ManagementPolicyDefinition_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyDefinition_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyDefinition_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyDefinitionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyDefinition_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyDefinition_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyDefinitionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyDefinition_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyDefinition_STATUS, ManagementPolicyDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyDefinition_STATUS runs a test to see if a specific instance of ManagementPolicyDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyDefinition_STATUS(subject ManagementPolicyDefinition_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyDefinitionSTATUS, ManagementPolicyDefinitionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyDefinitionSTATUS runs a test to see if a specific instance of ManagementPolicyDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyDefinitionSTATUS(subject ManagementPolicyDefinition_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyDefinition_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyDefinition_STATUSGenerator()
var managementPolicyDefinition_STATUSGenerator gopter.Gen

// ManagementPolicyDefinition_STATUSGenerator returns a generator of ManagementPolicyDefinition_STATUS instances for property testing.
func ManagementPolicyDefinition_STATUSGenerator() gopter.Gen {
	if managementPolicyDefinition_STATUSGenerator != nil {
		return managementPolicyDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyDefinition_STATUS(generators)
	managementPolicyDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyDefinition_STATUS{}), generators)

	return managementPolicyDefinition_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(ManagementPolicyAction_STATUSGenerator())
	gens["Filters"] = gen.PtrOf(ManagementPolicyFilter_STATUSGenerator())
=======
// ManagementPolicyDefinitionSTATUSGenerator()
var managementPolicyDefinitionSTATUSGenerator gopter.Gen

// ManagementPolicyDefinitionSTATUSGenerator returns a generator of ManagementPolicyDefinition_STATUS instances for property testing.
func ManagementPolicyDefinitionSTATUSGenerator() gopter.Gen {
	if managementPolicyDefinitionSTATUSGenerator != nil {
		return managementPolicyDefinitionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyDefinitionSTATUS(generators)
	managementPolicyDefinitionSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyDefinition_STATUS{}), generators)

	return managementPolicyDefinitionSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyDefinitionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyDefinitionSTATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(ManagementPolicyActionSTATUSGenerator())
	gens["Filters"] = gen.PtrOf(ManagementPolicyFilterSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyAction to ManagementPolicyAction via AssignPropertiesToManagementPolicyAction & AssignPropertiesFromManagementPolicyAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyAction, ManagementPolicyActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyAction tests if a specific instance of ManagementPolicyAction can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyAction(subject ManagementPolicyAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyAction
	err := copied.AssignPropertiesToManagementPolicyAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyAction
	err = actual.AssignPropertiesFromManagementPolicyAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyAction, ManagementPolicyActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyAction runs a test to see if a specific instance of ManagementPolicyAction round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyAction(subject ManagementPolicyAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyAction instances for property testing - lazily instantiated by
// ManagementPolicyActionGenerator()
var managementPolicyActionGenerator gopter.Gen

// ManagementPolicyActionGenerator returns a generator of ManagementPolicyAction instances for property testing.
func ManagementPolicyActionGenerator() gopter.Gen {
	if managementPolicyActionGenerator != nil {
		return managementPolicyActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyAction(generators)
	managementPolicyActionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyAction{}), generators)

	return managementPolicyActionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyAction(gens map[string]gopter.Gen) {
	gens["BaseBlob"] = gen.PtrOf(ManagementPolicyBaseBlobGenerator())
	gens["Snapshot"] = gen.PtrOf(ManagementPolicySnapShotGenerator())
	gens["Version"] = gen.PtrOf(ManagementPolicyVersionGenerator())
}

func Test_ManagementPolicyAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyAction_STATUS to ManagementPolicyAction_STATUS via AssignPropertiesToManagementPolicyAction_STATUS & AssignPropertiesFromManagementPolicyAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyAction_STATUS, ManagementPolicyAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyAction_STATUS tests if a specific instance of ManagementPolicyAction_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyAction_STATUS(subject ManagementPolicyAction_STATUS) string {
=======
		"Round trip from ManagementPolicyAction_STATUS to ManagementPolicyAction_STATUS via AssignPropertiesToManagementPolicyActionSTATUS & AssignPropertiesFromManagementPolicyActionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyActionSTATUS, ManagementPolicyActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyActionSTATUS tests if a specific instance of ManagementPolicyAction_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyActionSTATUS(subject ManagementPolicyAction_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyAction_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyAction_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyActionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyAction_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyAction_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyActionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyAction_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyAction_STATUS, ManagementPolicyAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyAction_STATUS runs a test to see if a specific instance of ManagementPolicyAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyAction_STATUS(subject ManagementPolicyAction_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyActionSTATUS, ManagementPolicyActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyActionSTATUS runs a test to see if a specific instance of ManagementPolicyAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyActionSTATUS(subject ManagementPolicyAction_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyAction_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyAction_STATUSGenerator()
var managementPolicyAction_STATUSGenerator gopter.Gen

// ManagementPolicyAction_STATUSGenerator returns a generator of ManagementPolicyAction_STATUS instances for property testing.
func ManagementPolicyAction_STATUSGenerator() gopter.Gen {
	if managementPolicyAction_STATUSGenerator != nil {
		return managementPolicyAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyAction_STATUS(generators)
	managementPolicyAction_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyAction_STATUS{}), generators)

	return managementPolicyAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyAction_STATUS(gens map[string]gopter.Gen) {
	gens["BaseBlob"] = gen.PtrOf(ManagementPolicyBaseBlob_STATUSGenerator())
	gens["Snapshot"] = gen.PtrOf(ManagementPolicySnapShot_STATUSGenerator())
	gens["Version"] = gen.PtrOf(ManagementPolicyVersion_STATUSGenerator())
=======
// ManagementPolicyActionSTATUSGenerator()
var managementPolicyActionSTATUSGenerator gopter.Gen

// ManagementPolicyActionSTATUSGenerator returns a generator of ManagementPolicyAction_STATUS instances for property testing.
func ManagementPolicyActionSTATUSGenerator() gopter.Gen {
	if managementPolicyActionSTATUSGenerator != nil {
		return managementPolicyActionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyActionSTATUS(generators)
	managementPolicyActionSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyAction_STATUS{}), generators)

	return managementPolicyActionSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyActionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyActionSTATUS(gens map[string]gopter.Gen) {
	gens["BaseBlob"] = gen.PtrOf(ManagementPolicyBaseBlobSTATUSGenerator())
	gens["Snapshot"] = gen.PtrOf(ManagementPolicySnapShotSTATUSGenerator())
	gens["Version"] = gen.PtrOf(ManagementPolicyVersionSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyFilter to ManagementPolicyFilter via AssignPropertiesToManagementPolicyFilter & AssignPropertiesFromManagementPolicyFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyFilter, ManagementPolicyFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyFilter tests if a specific instance of ManagementPolicyFilter can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyFilter(subject ManagementPolicyFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyFilter
	err := copied.AssignPropertiesToManagementPolicyFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyFilter
	err = actual.AssignPropertiesFromManagementPolicyFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyFilter, ManagementPolicyFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyFilter runs a test to see if a specific instance of ManagementPolicyFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyFilter(subject ManagementPolicyFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyFilter instances for property testing - lazily instantiated by
// ManagementPolicyFilterGenerator()
var managementPolicyFilterGenerator gopter.Gen

// ManagementPolicyFilterGenerator returns a generator of ManagementPolicyFilter instances for property testing.
// We first initialize managementPolicyFilterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyFilterGenerator() gopter.Gen {
	if managementPolicyFilterGenerator != nil {
		return managementPolicyFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter(generators)
	managementPolicyFilterGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyFilter(generators)
	managementPolicyFilterGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter{}), generators)

	return managementPolicyFilterGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyFilter(gens map[string]gopter.Gen) {
	gens["BlobTypes"] = gen.SliceOf(gen.AlphaString())
	gens["PrefixMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagementPolicyFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyFilter(gens map[string]gopter.Gen) {
	gens["BlobIndexMatch"] = gen.SliceOf(TagFilterGenerator())
}

func Test_ManagementPolicyFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyFilter_STATUS to ManagementPolicyFilter_STATUS via AssignPropertiesToManagementPolicyFilter_STATUS & AssignPropertiesFromManagementPolicyFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyFilter_STATUS, ManagementPolicyFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyFilter_STATUS tests if a specific instance of ManagementPolicyFilter_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyFilter_STATUS(subject ManagementPolicyFilter_STATUS) string {
=======
		"Round trip from ManagementPolicyFilter_STATUS to ManagementPolicyFilter_STATUS via AssignPropertiesToManagementPolicyFilterSTATUS & AssignPropertiesFromManagementPolicyFilterSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyFilterSTATUS, ManagementPolicyFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyFilterSTATUS tests if a specific instance of ManagementPolicyFilter_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyFilterSTATUS(subject ManagementPolicyFilter_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyFilter_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyFilter_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyFilter_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyFilter_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyFilter_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyFilter_STATUS, ManagementPolicyFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyFilter_STATUS runs a test to see if a specific instance of ManagementPolicyFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyFilter_STATUS(subject ManagementPolicyFilter_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyFilterSTATUS, ManagementPolicyFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyFilterSTATUS runs a test to see if a specific instance of ManagementPolicyFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyFilterSTATUS(subject ManagementPolicyFilter_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyFilter_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyFilter_STATUSGenerator()
var managementPolicyFilter_STATUSGenerator gopter.Gen

// ManagementPolicyFilter_STATUSGenerator returns a generator of ManagementPolicyFilter_STATUS instances for property testing.
// We first initialize managementPolicyFilter_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyFilter_STATUSGenerator() gopter.Gen {
	if managementPolicyFilter_STATUSGenerator != nil {
		return managementPolicyFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter_STATUS(generators)
	managementPolicyFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyFilter_STATUS(generators)
	managementPolicyFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_STATUS{}), generators)

	return managementPolicyFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyFilter_STATUS(gens map[string]gopter.Gen) {
=======
// ManagementPolicyFilterSTATUSGenerator()
var managementPolicyFilterSTATUSGenerator gopter.Gen

// ManagementPolicyFilterSTATUSGenerator returns a generator of ManagementPolicyFilter_STATUS instances for property testing.
// We first initialize managementPolicyFilterSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyFilterSTATUSGenerator() gopter.Gen {
	if managementPolicyFilterSTATUSGenerator != nil {
		return managementPolicyFilterSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilterSTATUS(generators)
	managementPolicyFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilterSTATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyFilterSTATUS(generators)
	managementPolicyFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_STATUS{}), generators)

	return managementPolicyFilterSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyFilterSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyFilterSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["BlobTypes"] = gen.SliceOf(gen.AlphaString())
	gens["PrefixMatch"] = gen.SliceOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForManagementPolicyFilter_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyFilter_STATUS(gens map[string]gopter.Gen) {
	gens["BlobIndexMatch"] = gen.SliceOf(TagFilter_STATUSGenerator())
=======
// AddRelatedPropertyGeneratorsForManagementPolicyFilterSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyFilterSTATUS(gens map[string]gopter.Gen) {
	gens["BlobIndexMatch"] = gen.SliceOf(TagFilterSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyBaseBlob_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyBaseBlob to ManagementPolicyBaseBlob via AssignPropertiesToManagementPolicyBaseBlob & AssignPropertiesFromManagementPolicyBaseBlob returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyBaseBlob, ManagementPolicyBaseBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyBaseBlob tests if a specific instance of ManagementPolicyBaseBlob can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyBaseBlob(subject ManagementPolicyBaseBlob) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyBaseBlob
	err := copied.AssignPropertiesToManagementPolicyBaseBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyBaseBlob
	err = actual.AssignPropertiesFromManagementPolicyBaseBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyBaseBlob_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyBaseBlob via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyBaseBlob, ManagementPolicyBaseBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyBaseBlob runs a test to see if a specific instance of ManagementPolicyBaseBlob round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyBaseBlob(subject ManagementPolicyBaseBlob) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyBaseBlob
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyBaseBlob instances for property testing - lazily instantiated by
// ManagementPolicyBaseBlobGenerator()
var managementPolicyBaseBlobGenerator gopter.Gen

// ManagementPolicyBaseBlobGenerator returns a generator of ManagementPolicyBaseBlob instances for property testing.
// We first initialize managementPolicyBaseBlobGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyBaseBlobGenerator() gopter.Gen {
	if managementPolicyBaseBlobGenerator != nil {
		return managementPolicyBaseBlobGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	managementPolicyBaseBlobGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	managementPolicyBaseBlobGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob{}), generators)

	return managementPolicyBaseBlobGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(gens map[string]gopter.Gen) {
	gens["EnableAutoTierToHotFromCool"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterModificationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterModificationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterModificationGenerator())
}

func Test_ManagementPolicyBaseBlob_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyBaseBlob_STATUS to ManagementPolicyBaseBlob_STATUS via AssignPropertiesToManagementPolicyBaseBlob_STATUS & AssignPropertiesFromManagementPolicyBaseBlob_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyBaseBlob_STATUS, ManagementPolicyBaseBlob_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyBaseBlob_STATUS tests if a specific instance of ManagementPolicyBaseBlob_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyBaseBlob_STATUS(subject ManagementPolicyBaseBlob_STATUS) string {
=======
		"Round trip from ManagementPolicyBaseBlob_STATUS to ManagementPolicyBaseBlob_STATUS via AssignPropertiesToManagementPolicyBaseBlobSTATUS & AssignPropertiesFromManagementPolicyBaseBlobSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyBaseBlobSTATUS, ManagementPolicyBaseBlobSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyBaseBlobSTATUS tests if a specific instance of ManagementPolicyBaseBlob_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyBaseBlobSTATUS(subject ManagementPolicyBaseBlob_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyBaseBlob_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyBaseBlob_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyBaseBlobSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyBaseBlob_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyBaseBlob_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyBaseBlobSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyBaseBlob_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyBaseBlob_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyBaseBlob_STATUS, ManagementPolicyBaseBlob_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyBaseBlob_STATUS runs a test to see if a specific instance of ManagementPolicyBaseBlob_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyBaseBlob_STATUS(subject ManagementPolicyBaseBlob_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyBaseBlobSTATUS, ManagementPolicyBaseBlobSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyBaseBlobSTATUS runs a test to see if a specific instance of ManagementPolicyBaseBlob_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyBaseBlobSTATUS(subject ManagementPolicyBaseBlob_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyBaseBlob_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyBaseBlob_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyBaseBlob_STATUSGenerator()
var managementPolicyBaseBlob_STATUSGenerator gopter.Gen

// ManagementPolicyBaseBlob_STATUSGenerator returns a generator of ManagementPolicyBaseBlob_STATUS instances for property testing.
// We first initialize managementPolicyBaseBlob_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyBaseBlob_STATUSGenerator() gopter.Gen {
	if managementPolicyBaseBlob_STATUSGenerator != nil {
		return managementPolicyBaseBlob_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob_STATUS(generators)
	managementPolicyBaseBlob_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob_STATUS(generators)
	managementPolicyBaseBlob_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_STATUS{}), generators)

	return managementPolicyBaseBlob_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob_STATUS(gens map[string]gopter.Gen) {
	gens["EnableAutoTierToHotFromCool"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob_STATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterModification_STATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterModification_STATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterModification_STATUSGenerator())
=======
// ManagementPolicyBaseBlobSTATUSGenerator()
var managementPolicyBaseBlobSTATUSGenerator gopter.Gen

// ManagementPolicyBaseBlobSTATUSGenerator returns a generator of ManagementPolicyBaseBlob_STATUS instances for property testing.
// We first initialize managementPolicyBaseBlobSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyBaseBlobSTATUSGenerator() gopter.Gen {
	if managementPolicyBaseBlobSTATUSGenerator != nil {
		return managementPolicyBaseBlobSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobSTATUS(generators)
	managementPolicyBaseBlobSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobSTATUS(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobSTATUS(generators)
	managementPolicyBaseBlobSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_STATUS{}), generators)

	return managementPolicyBaseBlobSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobSTATUS(gens map[string]gopter.Gen) {
	gens["EnableAutoTierToHotFromCool"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobSTATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterModificationSTATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterModificationSTATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterModificationSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicySnapShot_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySnapShot to ManagementPolicySnapShot via AssignPropertiesToManagementPolicySnapShot & AssignPropertiesFromManagementPolicySnapShot returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySnapShot, ManagementPolicySnapShotGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySnapShot tests if a specific instance of ManagementPolicySnapShot can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySnapShot(subject ManagementPolicySnapShot) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySnapShot
	err := copied.AssignPropertiesToManagementPolicySnapShot(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySnapShot
	err = actual.AssignPropertiesFromManagementPolicySnapShot(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySnapShot_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySnapShot via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySnapShot, ManagementPolicySnapShotGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySnapShot runs a test to see if a specific instance of ManagementPolicySnapShot round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySnapShot(subject ManagementPolicySnapShot) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySnapShot
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySnapShot instances for property testing - lazily instantiated by
// ManagementPolicySnapShotGenerator()
var managementPolicySnapShotGenerator gopter.Gen

// ManagementPolicySnapShotGenerator returns a generator of ManagementPolicySnapShot instances for property testing.
func ManagementPolicySnapShotGenerator() gopter.Gen {
	if managementPolicySnapShotGenerator != nil {
		return managementPolicySnapShotGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySnapShot(generators)
	managementPolicySnapShotGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySnapShot{}), generators)

	return managementPolicySnapShotGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySnapShot is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySnapShot(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationGenerator())
}

func Test_ManagementPolicySnapShot_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicySnapShot_STATUS to ManagementPolicySnapShot_STATUS via AssignPropertiesToManagementPolicySnapShot_STATUS & AssignPropertiesFromManagementPolicySnapShot_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySnapShot_STATUS, ManagementPolicySnapShot_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySnapShot_STATUS tests if a specific instance of ManagementPolicySnapShot_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySnapShot_STATUS(subject ManagementPolicySnapShot_STATUS) string {
=======
		"Round trip from ManagementPolicySnapShot_STATUS to ManagementPolicySnapShot_STATUS via AssignPropertiesToManagementPolicySnapShotSTATUS & AssignPropertiesFromManagementPolicySnapShotSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySnapShotSTATUS, ManagementPolicySnapShotSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySnapShotSTATUS tests if a specific instance of ManagementPolicySnapShot_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySnapShotSTATUS(subject ManagementPolicySnapShot_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySnapShot_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicySnapShot_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicySnapShotSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySnapShot_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicySnapShot_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicySnapShotSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySnapShot_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySnapShot_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicySnapShot_STATUS, ManagementPolicySnapShot_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySnapShot_STATUS runs a test to see if a specific instance of ManagementPolicySnapShot_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySnapShot_STATUS(subject ManagementPolicySnapShot_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicySnapShotSTATUS, ManagementPolicySnapShotSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySnapShotSTATUS runs a test to see if a specific instance of ManagementPolicySnapShot_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySnapShotSTATUS(subject ManagementPolicySnapShot_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySnapShot_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySnapShot_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicySnapShot_STATUSGenerator()
var managementPolicySnapShot_STATUSGenerator gopter.Gen

// ManagementPolicySnapShot_STATUSGenerator returns a generator of ManagementPolicySnapShot_STATUS instances for property testing.
func ManagementPolicySnapShot_STATUSGenerator() gopter.Gen {
	if managementPolicySnapShot_STATUSGenerator != nil {
		return managementPolicySnapShot_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySnapShot_STATUS(generators)
	managementPolicySnapShot_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySnapShot_STATUS{}), generators)

	return managementPolicySnapShot_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySnapShot_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySnapShot_STATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
=======
// ManagementPolicySnapShotSTATUSGenerator()
var managementPolicySnapShotSTATUSGenerator gopter.Gen

// ManagementPolicySnapShotSTATUSGenerator returns a generator of ManagementPolicySnapShot_STATUS instances for property testing.
func ManagementPolicySnapShotSTATUSGenerator() gopter.Gen {
	if managementPolicySnapShotSTATUSGenerator != nil {
		return managementPolicySnapShotSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySnapShotSTATUS(generators)
	managementPolicySnapShotSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySnapShot_STATUS{}), generators)

	return managementPolicySnapShotSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySnapShotSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySnapShotSTATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
>>>>>>> main
}

func Test_ManagementPolicyVersion_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyVersion to ManagementPolicyVersion via AssignPropertiesToManagementPolicyVersion & AssignPropertiesFromManagementPolicyVersion returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyVersion, ManagementPolicyVersionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyVersion tests if a specific instance of ManagementPolicyVersion can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyVersion(subject ManagementPolicyVersion) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyVersion
	err := copied.AssignPropertiesToManagementPolicyVersion(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyVersion
	err = actual.AssignPropertiesFromManagementPolicyVersion(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyVersion_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyVersion via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyVersion, ManagementPolicyVersionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyVersion runs a test to see if a specific instance of ManagementPolicyVersion round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyVersion(subject ManagementPolicyVersion) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyVersion
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyVersion instances for property testing - lazily instantiated by
// ManagementPolicyVersionGenerator()
var managementPolicyVersionGenerator gopter.Gen

// ManagementPolicyVersionGenerator returns a generator of ManagementPolicyVersion instances for property testing.
func ManagementPolicyVersionGenerator() gopter.Gen {
	if managementPolicyVersionGenerator != nil {
		return managementPolicyVersionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyVersion(generators)
	managementPolicyVersionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyVersion{}), generators)

	return managementPolicyVersionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyVersion is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyVersion(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationGenerator())
}

func Test_ManagementPolicyVersion_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ManagementPolicyVersion_STATUS to ManagementPolicyVersion_STATUS via AssignPropertiesToManagementPolicyVersion_STATUS & AssignPropertiesFromManagementPolicyVersion_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyVersion_STATUS, ManagementPolicyVersion_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyVersion_STATUS tests if a specific instance of ManagementPolicyVersion_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyVersion_STATUS(subject ManagementPolicyVersion_STATUS) string {
=======
		"Round trip from ManagementPolicyVersion_STATUS to ManagementPolicyVersion_STATUS via AssignPropertiesToManagementPolicyVersionSTATUS & AssignPropertiesFromManagementPolicyVersionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyVersionSTATUS, ManagementPolicyVersionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyVersionSTATUS tests if a specific instance of ManagementPolicyVersion_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyVersionSTATUS(subject ManagementPolicyVersion_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyVersion_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToManagementPolicyVersion_STATUS(&other)
=======
	err := copied.AssignPropertiesToManagementPolicyVersionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyVersion_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromManagementPolicyVersion_STATUS(&other)
=======
	err = actual.AssignPropertiesFromManagementPolicyVersionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyVersion_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyVersion_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForManagementPolicyVersion_STATUS, ManagementPolicyVersion_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyVersion_STATUS runs a test to see if a specific instance of ManagementPolicyVersion_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyVersion_STATUS(subject ManagementPolicyVersion_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForManagementPolicyVersionSTATUS, ManagementPolicyVersionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyVersionSTATUS runs a test to see if a specific instance of ManagementPolicyVersion_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyVersionSTATUS(subject ManagementPolicyVersion_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyVersion_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyVersion_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ManagementPolicyVersion_STATUSGenerator()
var managementPolicyVersion_STATUSGenerator gopter.Gen

// ManagementPolicyVersion_STATUSGenerator returns a generator of ManagementPolicyVersion_STATUS instances for property testing.
func ManagementPolicyVersion_STATUSGenerator() gopter.Gen {
	if managementPolicyVersion_STATUSGenerator != nil {
		return managementPolicyVersion_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyVersion_STATUS(generators)
	managementPolicyVersion_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyVersion_STATUS{}), generators)

	return managementPolicyVersion_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyVersion_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyVersion_STATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreation_STATUSGenerator())
=======
// ManagementPolicyVersionSTATUSGenerator()
var managementPolicyVersionSTATUSGenerator gopter.Gen

// ManagementPolicyVersionSTATUSGenerator returns a generator of ManagementPolicyVersion_STATUS instances for property testing.
func ManagementPolicyVersionSTATUSGenerator() gopter.Gen {
	if managementPolicyVersionSTATUSGenerator != nil {
		return managementPolicyVersionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyVersionSTATUS(generators)
	managementPolicyVersionSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyVersion_STATUS{}), generators)

	return managementPolicyVersionSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyVersionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyVersionSTATUS(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationSTATUSGenerator())
>>>>>>> main
}

func Test_TagFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TagFilter to TagFilter via AssignPropertiesToTagFilter & AssignPropertiesFromTagFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForTagFilter, TagFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTagFilter tests if a specific instance of TagFilter can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForTagFilter(subject TagFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.TagFilter
	err := copied.AssignPropertiesToTagFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TagFilter
	err = actual.AssignPropertiesFromTagFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TagFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TagFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTagFilter, TagFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTagFilter runs a test to see if a specific instance of TagFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForTagFilter(subject TagFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TagFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TagFilter instances for property testing - lazily instantiated by TagFilterGenerator()
var tagFilterGenerator gopter.Gen

// TagFilterGenerator returns a generator of TagFilter instances for property testing.
func TagFilterGenerator() gopter.Gen {
	if tagFilterGenerator != nil {
		return tagFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTagFilter(generators)
	tagFilterGenerator = gen.Struct(reflect.TypeOf(TagFilter{}), generators)

	return tagFilterGenerator
}

// AddIndependentPropertyGeneratorsForTagFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTagFilter(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Op"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_TagFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from TagFilter_STATUS to TagFilter_STATUS via AssignPropertiesToTagFilter_STATUS & AssignPropertiesFromTagFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTagFilter_STATUS, TagFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTagFilter_STATUS tests if a specific instance of TagFilter_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForTagFilter_STATUS(subject TagFilter_STATUS) string {
=======
		"Round trip from TagFilter_STATUS to TagFilter_STATUS via AssignPropertiesToTagFilterSTATUS & AssignPropertiesFromTagFilterSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTagFilterSTATUS, TagFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTagFilterSTATUS tests if a specific instance of TagFilter_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForTagFilterSTATUS(subject TagFilter_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.TagFilter_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToTagFilter_STATUS(&other)
=======
	err := copied.AssignPropertiesToTagFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TagFilter_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromTagFilter_STATUS(&other)
=======
	err = actual.AssignPropertiesFromTagFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TagFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TagFilter_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForTagFilter_STATUS, TagFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTagFilter_STATUS runs a test to see if a specific instance of TagFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTagFilter_STATUS(subject TagFilter_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForTagFilterSTATUS, TagFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTagFilterSTATUS runs a test to see if a specific instance of TagFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTagFilterSTATUS(subject TagFilter_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TagFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of TagFilter_STATUS instances for property testing - lazily instantiated by TagFilter_STATUSGenerator()
var tagFilter_STATUSGenerator gopter.Gen

// TagFilter_STATUSGenerator returns a generator of TagFilter_STATUS instances for property testing.
func TagFilter_STATUSGenerator() gopter.Gen {
	if tagFilter_STATUSGenerator != nil {
		return tagFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTagFilter_STATUS(generators)
	tagFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(TagFilter_STATUS{}), generators)

	return tagFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTagFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTagFilter_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of TagFilter_STATUS instances for property testing - lazily instantiated by TagFilterSTATUSGenerator()
var tagFilterSTATUSGenerator gopter.Gen

// TagFilterSTATUSGenerator returns a generator of TagFilter_STATUS instances for property testing.
func TagFilterSTATUSGenerator() gopter.Gen {
	if tagFilterSTATUSGenerator != nil {
		return tagFilterSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTagFilterSTATUS(generators)
	tagFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(TagFilter_STATUS{}), generators)

	return tagFilterSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForTagFilterSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTagFilterSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Op"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_DateAfterCreation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterCreation to DateAfterCreation via AssignPropertiesToDateAfterCreation & AssignPropertiesFromDateAfterCreation returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterCreation, DateAfterCreationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterCreation tests if a specific instance of DateAfterCreation can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterCreation(subject DateAfterCreation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterCreation
	err := copied.AssignPropertiesToDateAfterCreation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterCreation
	err = actual.AssignPropertiesFromDateAfterCreation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterCreation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterCreation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterCreation, DateAfterCreationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterCreation runs a test to see if a specific instance of DateAfterCreation round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterCreation(subject DateAfterCreation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterCreation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterCreation instances for property testing - lazily instantiated by DateAfterCreationGenerator()
var dateAfterCreationGenerator gopter.Gen

// DateAfterCreationGenerator returns a generator of DateAfterCreation instances for property testing.
func DateAfterCreationGenerator() gopter.Gen {
	if dateAfterCreationGenerator != nil {
		return dateAfterCreationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterCreation(generators)
	dateAfterCreationGenerator = gen.Struct(reflect.TypeOf(DateAfterCreation{}), generators)

	return dateAfterCreationGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterCreation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterCreation(gens map[string]gopter.Gen) {
	gens["DaysAfterCreationGreaterThan"] = gen.PtrOf(gen.Int())
}

func Test_DateAfterCreation_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from DateAfterCreation_STATUS to DateAfterCreation_STATUS via AssignPropertiesToDateAfterCreation_STATUS & AssignPropertiesFromDateAfterCreation_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterCreation_STATUS, DateAfterCreation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterCreation_STATUS tests if a specific instance of DateAfterCreation_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterCreation_STATUS(subject DateAfterCreation_STATUS) string {
=======
		"Round trip from DateAfterCreation_STATUS to DateAfterCreation_STATUS via AssignPropertiesToDateAfterCreationSTATUS & AssignPropertiesFromDateAfterCreationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterCreationSTATUS, DateAfterCreationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterCreationSTATUS tests if a specific instance of DateAfterCreation_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterCreationSTATUS(subject DateAfterCreation_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterCreation_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToDateAfterCreation_STATUS(&other)
=======
	err := copied.AssignPropertiesToDateAfterCreationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterCreation_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromDateAfterCreation_STATUS(&other)
=======
	err = actual.AssignPropertiesFromDateAfterCreationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterCreation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterCreation_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForDateAfterCreation_STATUS, DateAfterCreation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterCreation_STATUS runs a test to see if a specific instance of DateAfterCreation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterCreation_STATUS(subject DateAfterCreation_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForDateAfterCreationSTATUS, DateAfterCreationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterCreationSTATUS runs a test to see if a specific instance of DateAfterCreation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterCreationSTATUS(subject DateAfterCreation_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterCreation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterCreation_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// DateAfterCreation_STATUSGenerator()
var dateAfterCreation_STATUSGenerator gopter.Gen

// DateAfterCreation_STATUSGenerator returns a generator of DateAfterCreation_STATUS instances for property testing.
func DateAfterCreation_STATUSGenerator() gopter.Gen {
	if dateAfterCreation_STATUSGenerator != nil {
		return dateAfterCreation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterCreation_STATUS(generators)
	dateAfterCreation_STATUSGenerator = gen.Struct(reflect.TypeOf(DateAfterCreation_STATUS{}), generators)

	return dateAfterCreation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterCreation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterCreation_STATUS(gens map[string]gopter.Gen) {
=======
// DateAfterCreationSTATUSGenerator()
var dateAfterCreationSTATUSGenerator gopter.Gen

// DateAfterCreationSTATUSGenerator returns a generator of DateAfterCreation_STATUS instances for property testing.
func DateAfterCreationSTATUSGenerator() gopter.Gen {
	if dateAfterCreationSTATUSGenerator != nil {
		return dateAfterCreationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterCreationSTATUS(generators)
	dateAfterCreationSTATUSGenerator = gen.Struct(reflect.TypeOf(DateAfterCreation_STATUS{}), generators)

	return dateAfterCreationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterCreationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterCreationSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["DaysAfterCreationGreaterThan"] = gen.PtrOf(gen.Float64())
}

func Test_DateAfterModification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterModification to DateAfterModification via AssignPropertiesToDateAfterModification & AssignPropertiesFromDateAfterModification returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterModification, DateAfterModificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterModification tests if a specific instance of DateAfterModification can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterModification(subject DateAfterModification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterModification
	err := copied.AssignPropertiesToDateAfterModification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterModification
	err = actual.AssignPropertiesFromDateAfterModification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterModification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterModification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterModification, DateAfterModificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterModification runs a test to see if a specific instance of DateAfterModification round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterModification(subject DateAfterModification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterModification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterModification instances for property testing - lazily instantiated by
// DateAfterModificationGenerator()
var dateAfterModificationGenerator gopter.Gen

// DateAfterModificationGenerator returns a generator of DateAfterModification instances for property testing.
func DateAfterModificationGenerator() gopter.Gen {
	if dateAfterModificationGenerator != nil {
		return dateAfterModificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterModification(generators)
	dateAfterModificationGenerator = gen.Struct(reflect.TypeOf(DateAfterModification{}), generators)

	return dateAfterModificationGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterModification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterModification(gens map[string]gopter.Gen) {
	gens["DaysAfterLastAccessTimeGreaterThan"] = gen.PtrOf(gen.Int())
	gens["DaysAfterModificationGreaterThan"] = gen.PtrOf(gen.Int())
}

func Test_DateAfterModification_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from DateAfterModification_STATUS to DateAfterModification_STATUS via AssignPropertiesToDateAfterModification_STATUS & AssignPropertiesFromDateAfterModification_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterModification_STATUS, DateAfterModification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterModification_STATUS tests if a specific instance of DateAfterModification_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterModification_STATUS(subject DateAfterModification_STATUS) string {
=======
		"Round trip from DateAfterModification_STATUS to DateAfterModification_STATUS via AssignPropertiesToDateAfterModificationSTATUS & AssignPropertiesFromDateAfterModificationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterModificationSTATUS, DateAfterModificationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterModificationSTATUS tests if a specific instance of DateAfterModification_STATUS can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterModificationSTATUS(subject DateAfterModification_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterModification_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToDateAfterModification_STATUS(&other)
=======
	err := copied.AssignPropertiesToDateAfterModificationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterModification_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromDateAfterModification_STATUS(&other)
=======
	err = actual.AssignPropertiesFromDateAfterModificationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterModification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterModification_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForDateAfterModification_STATUS, DateAfterModification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterModification_STATUS runs a test to see if a specific instance of DateAfterModification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterModification_STATUS(subject DateAfterModification_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForDateAfterModificationSTATUS, DateAfterModificationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterModificationSTATUS runs a test to see if a specific instance of DateAfterModification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterModificationSTATUS(subject DateAfterModification_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterModification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterModification_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// DateAfterModification_STATUSGenerator()
var dateAfterModification_STATUSGenerator gopter.Gen

// DateAfterModification_STATUSGenerator returns a generator of DateAfterModification_STATUS instances for property testing.
func DateAfterModification_STATUSGenerator() gopter.Gen {
	if dateAfterModification_STATUSGenerator != nil {
		return dateAfterModification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterModification_STATUS(generators)
	dateAfterModification_STATUSGenerator = gen.Struct(reflect.TypeOf(DateAfterModification_STATUS{}), generators)

	return dateAfterModification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterModification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterModification_STATUS(gens map[string]gopter.Gen) {
=======
// DateAfterModificationSTATUSGenerator()
var dateAfterModificationSTATUSGenerator gopter.Gen

// DateAfterModificationSTATUSGenerator returns a generator of DateAfterModification_STATUS instances for property testing.
func DateAfterModificationSTATUSGenerator() gopter.Gen {
	if dateAfterModificationSTATUSGenerator != nil {
		return dateAfterModificationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterModificationSTATUS(generators)
	dateAfterModificationSTATUSGenerator = gen.Struct(reflect.TypeOf(DateAfterModification_STATUS{}), generators)

	return dateAfterModificationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterModificationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterModificationSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["DaysAfterLastAccessTimeGreaterThan"] = gen.PtrOf(gen.Float64())
	gens["DaysAfterModificationGreaterThan"] = gen.PtrOf(gen.Float64())
}
