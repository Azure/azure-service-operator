// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401

import (
	"encoding/json"
	v20210401s "github.com/Azure/azure-service-operator/v2/api/storage/v1beta20210401storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccountsManagementPolicy_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicy to hub returns original",
		prop.ForAll(RunResourceConversionTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForStorageAccountsManagementPolicy tests if a specific instance of StorageAccountsManagementPolicy round trips to the hub storage version and back losslessly
func RunResourceConversionTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210401s.StorageAccountsManagementPolicy
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual StorageAccountsManagementPolicy
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicy to StorageAccountsManagementPolicy via AssignPropertiesToStorageAccountsManagementPolicy & AssignPropertiesFromStorageAccountsManagementPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccountsManagementPolicy tests if a specific instance of StorageAccountsManagementPolicy can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.StorageAccountsManagementPolicy
	err := copied.AssignPropertiesToStorageAccountsManagementPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccountsManagementPolicy
	err = actual.AssignPropertiesFromStorageAccountsManagementPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountsManagementPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsManagementPolicy, StorageAccountsManagementPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsManagementPolicy runs a test to see if a specific instance of StorageAccountsManagementPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsManagementPolicy(subject StorageAccountsManagementPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountsManagementPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountsManagementPolicy instances for property testing - lazily instantiated by
// StorageAccountsManagementPolicyGenerator()
var storageAccountsManagementPolicyGenerator gopter.Gen

// StorageAccountsManagementPolicyGenerator returns a generator of StorageAccountsManagementPolicy instances for property testing.
func StorageAccountsManagementPolicyGenerator() gopter.Gen {
	if storageAccountsManagementPolicyGenerator != nil {
		return storageAccountsManagementPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy(generators)
	storageAccountsManagementPolicyGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicy{}), generators)

	return storageAccountsManagementPolicyGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsManagementPolicy(gens map[string]gopter.Gen) {
	gens["Spec"] = StorageAccountsManagementPoliciesSpecGenerator()
	gens["Status"] = ManagementPolicyStatusGenerator()
}

func Test_ManagementPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicy_Status to ManagementPolicy_Status via AssignPropertiesToManagementPolicyStatus & AssignPropertiesFromManagementPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyStatus, ManagementPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyStatus tests if a specific instance of ManagementPolicy_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyStatus(subject ManagementPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicy_Status
	err := copied.AssignPropertiesToManagementPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicy_Status
	err = actual.AssignPropertiesFromManagementPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyStatus, ManagementPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyStatus runs a test to see if a specific instance of ManagementPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyStatus(subject ManagementPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicy_Status instances for property testing - lazily instantiated by
// ManagementPolicyStatusGenerator()
var managementPolicyStatusGenerator gopter.Gen

// ManagementPolicyStatusGenerator returns a generator of ManagementPolicy_Status instances for property testing.
// We first initialize managementPolicyStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyStatusGenerator() gopter.Gen {
	if managementPolicyStatusGenerator != nil {
		return managementPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyStatus(generators)
	managementPolicyStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyStatus(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyStatus(generators)
	managementPolicyStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicy_Status{}), generators)

	return managementPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagementPolicyStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyStatus(gens map[string]gopter.Gen) {
	gens["Policy"] = gen.PtrOf(ManagementPolicySchemaStatusGenerator())
}

func Test_StorageAccountsManagementPolicies_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccountsManagementPolicies_Spec to StorageAccountsManagementPolicies_Spec via AssignPropertiesToStorageAccountsManagementPoliciesSpec & AssignPropertiesFromStorageAccountsManagementPoliciesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccountsManagementPoliciesSpec, StorageAccountsManagementPoliciesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccountsManagementPoliciesSpec tests if a specific instance of StorageAccountsManagementPolicies_Spec can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccountsManagementPoliciesSpec(subject StorageAccountsManagementPolicies_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.StorageAccountsManagementPolicies_Spec
	err := copied.AssignPropertiesToStorageAccountsManagementPoliciesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccountsManagementPolicies_Spec
	err = actual.AssignPropertiesFromStorageAccountsManagementPoliciesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccountsManagementPolicies_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountsManagementPolicies_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsManagementPoliciesSpec, StorageAccountsManagementPoliciesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsManagementPoliciesSpec runs a test to see if a specific instance of StorageAccountsManagementPolicies_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsManagementPoliciesSpec(subject StorageAccountsManagementPolicies_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountsManagementPolicies_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountsManagementPolicies_Spec instances for property testing - lazily instantiated by
// StorageAccountsManagementPoliciesSpecGenerator()
var storageAccountsManagementPoliciesSpecGenerator gopter.Gen

// StorageAccountsManagementPoliciesSpecGenerator returns a generator of StorageAccountsManagementPolicies_Spec instances for property testing.
// We first initialize storageAccountsManagementPoliciesSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsManagementPoliciesSpecGenerator() gopter.Gen {
	if storageAccountsManagementPoliciesSpecGenerator != nil {
		return storageAccountsManagementPoliciesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPoliciesSpec(generators)
	storageAccountsManagementPoliciesSpecGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicies_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsManagementPoliciesSpec(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsManagementPoliciesSpec(generators)
	storageAccountsManagementPoliciesSpecGenerator = gen.Struct(reflect.TypeOf(StorageAccountsManagementPolicies_Spec{}), generators)

	return storageAccountsManagementPoliciesSpecGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsManagementPoliciesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsManagementPoliciesSpec(gens map[string]gopter.Gen) {
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountsManagementPoliciesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsManagementPoliciesSpec(gens map[string]gopter.Gen) {
	gens["Policy"] = gen.PtrOf(ManagementPolicySchemaGenerator())
}

func Test_ManagementPolicySchema_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySchema to ManagementPolicySchema via AssignPropertiesToManagementPolicySchema & AssignPropertiesFromManagementPolicySchema returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySchema, ManagementPolicySchemaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySchema tests if a specific instance of ManagementPolicySchema can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySchema(subject ManagementPolicySchema) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySchema
	err := copied.AssignPropertiesToManagementPolicySchema(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySchema
	err = actual.AssignPropertiesFromManagementPolicySchema(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySchema_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySchema via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySchema, ManagementPolicySchemaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySchema runs a test to see if a specific instance of ManagementPolicySchema round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySchema(subject ManagementPolicySchema) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySchema
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySchema instances for property testing - lazily instantiated by
// ManagementPolicySchemaGenerator()
var managementPolicySchemaGenerator gopter.Gen

// ManagementPolicySchemaGenerator returns a generator of ManagementPolicySchema instances for property testing.
func ManagementPolicySchemaGenerator() gopter.Gen {
	if managementPolicySchemaGenerator != nil {
		return managementPolicySchemaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySchema(generators)
	managementPolicySchemaGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySchema{}), generators)

	return managementPolicySchemaGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySchema is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySchema(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagementPolicyRuleGenerator())
}

func Test_ManagementPolicySchema_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySchema_Status to ManagementPolicySchema_Status via AssignPropertiesToManagementPolicySchemaStatus & AssignPropertiesFromManagementPolicySchemaStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySchemaStatus, ManagementPolicySchemaStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySchemaStatus tests if a specific instance of ManagementPolicySchema_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySchemaStatus(subject ManagementPolicySchema_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySchema_Status
	err := copied.AssignPropertiesToManagementPolicySchemaStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySchema_Status
	err = actual.AssignPropertiesFromManagementPolicySchemaStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySchema_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySchema_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySchemaStatus, ManagementPolicySchemaStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySchemaStatus runs a test to see if a specific instance of ManagementPolicySchema_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySchemaStatus(subject ManagementPolicySchema_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySchema_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySchema_Status instances for property testing - lazily instantiated by
// ManagementPolicySchemaStatusGenerator()
var managementPolicySchemaStatusGenerator gopter.Gen

// ManagementPolicySchemaStatusGenerator returns a generator of ManagementPolicySchema_Status instances for property testing.
func ManagementPolicySchemaStatusGenerator() gopter.Gen {
	if managementPolicySchemaStatusGenerator != nil {
		return managementPolicySchemaStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySchemaStatus(generators)
	managementPolicySchemaStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySchema_Status{}), generators)

	return managementPolicySchemaStatusGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySchemaStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySchemaStatus(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagementPolicyRuleStatusGenerator())
}

func Test_ManagementPolicyRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyRule to ManagementPolicyRule via AssignPropertiesToManagementPolicyRule & AssignPropertiesFromManagementPolicyRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyRule, ManagementPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyRule tests if a specific instance of ManagementPolicyRule can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyRule(subject ManagementPolicyRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyRule
	err := copied.AssignPropertiesToManagementPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyRule
	err = actual.AssignPropertiesFromManagementPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyRule, ManagementPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyRule runs a test to see if a specific instance of ManagementPolicyRule round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyRule(subject ManagementPolicyRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyRule instances for property testing - lazily instantiated by
// ManagementPolicyRuleGenerator()
var managementPolicyRuleGenerator gopter.Gen

// ManagementPolicyRuleGenerator returns a generator of ManagementPolicyRule instances for property testing.
// We first initialize managementPolicyRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyRuleGenerator() gopter.Gen {
	if managementPolicyRuleGenerator != nil {
		return managementPolicyRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule(generators)
	managementPolicyRuleGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRule(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyRule(generators)
	managementPolicyRuleGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule{}), generators)

	return managementPolicyRuleGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyRule(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagementPolicyRuleTypeLifecycle))
}

// AddRelatedPropertyGeneratorsForManagementPolicyRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyRule(gens map[string]gopter.Gen) {
	gens["Definition"] = gen.PtrOf(ManagementPolicyDefinitionGenerator())
}

func Test_ManagementPolicyRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyRule_Status to ManagementPolicyRule_Status via AssignPropertiesToManagementPolicyRuleStatus & AssignPropertiesFromManagementPolicyRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyRuleStatus, ManagementPolicyRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyRuleStatus tests if a specific instance of ManagementPolicyRule_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyRuleStatus(subject ManagementPolicyRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyRule_Status
	err := copied.AssignPropertiesToManagementPolicyRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyRule_Status
	err = actual.AssignPropertiesFromManagementPolicyRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyRuleStatus, ManagementPolicyRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyRuleStatus runs a test to see if a specific instance of ManagementPolicyRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyRuleStatus(subject ManagementPolicyRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyRule_Status instances for property testing - lazily instantiated by
// ManagementPolicyRuleStatusGenerator()
var managementPolicyRuleStatusGenerator gopter.Gen

// ManagementPolicyRuleStatusGenerator returns a generator of ManagementPolicyRule_Status instances for property testing.
// We first initialize managementPolicyRuleStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyRuleStatusGenerator() gopter.Gen {
	if managementPolicyRuleStatusGenerator != nil {
		return managementPolicyRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRuleStatus(generators)
	managementPolicyRuleStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyRuleStatus(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyRuleStatus(generators)
	managementPolicyRuleStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyRule_Status{}), generators)

	return managementPolicyRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyRuleStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagementPolicyRuleStatusTypeLifecycle))
}

// AddRelatedPropertyGeneratorsForManagementPolicyRuleStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyRuleStatus(gens map[string]gopter.Gen) {
	gens["Definition"] = gen.PtrOf(ManagementPolicyDefinitionStatusGenerator())
}

func Test_ManagementPolicyDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyDefinition to ManagementPolicyDefinition via AssignPropertiesToManagementPolicyDefinition & AssignPropertiesFromManagementPolicyDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyDefinition, ManagementPolicyDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyDefinition tests if a specific instance of ManagementPolicyDefinition can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyDefinition(subject ManagementPolicyDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyDefinition
	err := copied.AssignPropertiesToManagementPolicyDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyDefinition
	err = actual.AssignPropertiesFromManagementPolicyDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyDefinition, ManagementPolicyDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyDefinition runs a test to see if a specific instance of ManagementPolicyDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyDefinition(subject ManagementPolicyDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyDefinition instances for property testing - lazily instantiated by
// ManagementPolicyDefinitionGenerator()
var managementPolicyDefinitionGenerator gopter.Gen

// ManagementPolicyDefinitionGenerator returns a generator of ManagementPolicyDefinition instances for property testing.
func ManagementPolicyDefinitionGenerator() gopter.Gen {
	if managementPolicyDefinitionGenerator != nil {
		return managementPolicyDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyDefinition(generators)
	managementPolicyDefinitionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyDefinition{}), generators)

	return managementPolicyDefinitionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyDefinition(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(ManagementPolicyActionGenerator())
	gens["Filters"] = gen.PtrOf(ManagementPolicyFilterGenerator())
}

func Test_ManagementPolicyDefinition_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyDefinition_Status to ManagementPolicyDefinition_Status via AssignPropertiesToManagementPolicyDefinitionStatus & AssignPropertiesFromManagementPolicyDefinitionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyDefinitionStatus, ManagementPolicyDefinitionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyDefinitionStatus tests if a specific instance of ManagementPolicyDefinition_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyDefinitionStatus(subject ManagementPolicyDefinition_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyDefinition_Status
	err := copied.AssignPropertiesToManagementPolicyDefinitionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyDefinition_Status
	err = actual.AssignPropertiesFromManagementPolicyDefinitionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyDefinition_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyDefinition_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyDefinitionStatus, ManagementPolicyDefinitionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyDefinitionStatus runs a test to see if a specific instance of ManagementPolicyDefinition_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyDefinitionStatus(subject ManagementPolicyDefinition_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyDefinition_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyDefinition_Status instances for property testing - lazily instantiated by
// ManagementPolicyDefinitionStatusGenerator()
var managementPolicyDefinitionStatusGenerator gopter.Gen

// ManagementPolicyDefinitionStatusGenerator returns a generator of ManagementPolicyDefinition_Status instances for property testing.
func ManagementPolicyDefinitionStatusGenerator() gopter.Gen {
	if managementPolicyDefinitionStatusGenerator != nil {
		return managementPolicyDefinitionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyDefinitionStatus(generators)
	managementPolicyDefinitionStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyDefinition_Status{}), generators)

	return managementPolicyDefinitionStatusGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyDefinitionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyDefinitionStatus(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(ManagementPolicyActionStatusGenerator())
	gens["Filters"] = gen.PtrOf(ManagementPolicyFilterStatusGenerator())
}

func Test_ManagementPolicyAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyAction to ManagementPolicyAction via AssignPropertiesToManagementPolicyAction & AssignPropertiesFromManagementPolicyAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyAction, ManagementPolicyActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyAction tests if a specific instance of ManagementPolicyAction can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyAction(subject ManagementPolicyAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyAction
	err := copied.AssignPropertiesToManagementPolicyAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyAction
	err = actual.AssignPropertiesFromManagementPolicyAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyAction, ManagementPolicyActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyAction runs a test to see if a specific instance of ManagementPolicyAction round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyAction(subject ManagementPolicyAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyAction instances for property testing - lazily instantiated by
// ManagementPolicyActionGenerator()
var managementPolicyActionGenerator gopter.Gen

// ManagementPolicyActionGenerator returns a generator of ManagementPolicyAction instances for property testing.
func ManagementPolicyActionGenerator() gopter.Gen {
	if managementPolicyActionGenerator != nil {
		return managementPolicyActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyAction(generators)
	managementPolicyActionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyAction{}), generators)

	return managementPolicyActionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyAction(gens map[string]gopter.Gen) {
	gens["BaseBlob"] = gen.PtrOf(ManagementPolicyBaseBlobGenerator())
	gens["Snapshot"] = gen.PtrOf(ManagementPolicySnapShotGenerator())
	gens["Version"] = gen.PtrOf(ManagementPolicyVersionGenerator())
}

func Test_ManagementPolicyAction_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyAction_Status to ManagementPolicyAction_Status via AssignPropertiesToManagementPolicyActionStatus & AssignPropertiesFromManagementPolicyActionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyActionStatus, ManagementPolicyActionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyActionStatus tests if a specific instance of ManagementPolicyAction_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyActionStatus(subject ManagementPolicyAction_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyAction_Status
	err := copied.AssignPropertiesToManagementPolicyActionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyAction_Status
	err = actual.AssignPropertiesFromManagementPolicyActionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyAction_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyAction_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyActionStatus, ManagementPolicyActionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyActionStatus runs a test to see if a specific instance of ManagementPolicyAction_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyActionStatus(subject ManagementPolicyAction_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyAction_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyAction_Status instances for property testing - lazily instantiated by
// ManagementPolicyActionStatusGenerator()
var managementPolicyActionStatusGenerator gopter.Gen

// ManagementPolicyActionStatusGenerator returns a generator of ManagementPolicyAction_Status instances for property testing.
func ManagementPolicyActionStatusGenerator() gopter.Gen {
	if managementPolicyActionStatusGenerator != nil {
		return managementPolicyActionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyActionStatus(generators)
	managementPolicyActionStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyAction_Status{}), generators)

	return managementPolicyActionStatusGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyActionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyActionStatus(gens map[string]gopter.Gen) {
	gens["BaseBlob"] = gen.PtrOf(ManagementPolicyBaseBlobStatusGenerator())
	gens["Snapshot"] = gen.PtrOf(ManagementPolicySnapShotStatusGenerator())
	gens["Version"] = gen.PtrOf(ManagementPolicyVersionStatusGenerator())
}

func Test_ManagementPolicyFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyFilter to ManagementPolicyFilter via AssignPropertiesToManagementPolicyFilter & AssignPropertiesFromManagementPolicyFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyFilter, ManagementPolicyFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyFilter tests if a specific instance of ManagementPolicyFilter can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyFilter(subject ManagementPolicyFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyFilter
	err := copied.AssignPropertiesToManagementPolicyFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyFilter
	err = actual.AssignPropertiesFromManagementPolicyFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyFilter, ManagementPolicyFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyFilter runs a test to see if a specific instance of ManagementPolicyFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyFilter(subject ManagementPolicyFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyFilter instances for property testing - lazily instantiated by
// ManagementPolicyFilterGenerator()
var managementPolicyFilterGenerator gopter.Gen

// ManagementPolicyFilterGenerator returns a generator of ManagementPolicyFilter instances for property testing.
// We first initialize managementPolicyFilterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyFilterGenerator() gopter.Gen {
	if managementPolicyFilterGenerator != nil {
		return managementPolicyFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter(generators)
	managementPolicyFilterGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilter(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyFilter(generators)
	managementPolicyFilterGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter{}), generators)

	return managementPolicyFilterGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyFilter(gens map[string]gopter.Gen) {
	gens["BlobTypes"] = gen.SliceOf(gen.AlphaString())
	gens["PrefixMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagementPolicyFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyFilter(gens map[string]gopter.Gen) {
	gens["BlobIndexMatch"] = gen.SliceOf(TagFilterGenerator())
}

func Test_ManagementPolicyFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyFilter_Status to ManagementPolicyFilter_Status via AssignPropertiesToManagementPolicyFilterStatus & AssignPropertiesFromManagementPolicyFilterStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyFilterStatus, ManagementPolicyFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyFilterStatus tests if a specific instance of ManagementPolicyFilter_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyFilterStatus(subject ManagementPolicyFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyFilter_Status
	err := copied.AssignPropertiesToManagementPolicyFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyFilter_Status
	err = actual.AssignPropertiesFromManagementPolicyFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyFilterStatus, ManagementPolicyFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyFilterStatus runs a test to see if a specific instance of ManagementPolicyFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyFilterStatus(subject ManagementPolicyFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyFilter_Status instances for property testing - lazily instantiated by
// ManagementPolicyFilterStatusGenerator()
var managementPolicyFilterStatusGenerator gopter.Gen

// ManagementPolicyFilterStatusGenerator returns a generator of ManagementPolicyFilter_Status instances for property testing.
// We first initialize managementPolicyFilterStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyFilterStatusGenerator() gopter.Gen {
	if managementPolicyFilterStatusGenerator != nil {
		return managementPolicyFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilterStatus(generators)
	managementPolicyFilterStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyFilterStatus(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyFilterStatus(generators)
	managementPolicyFilterStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyFilter_Status{}), generators)

	return managementPolicyFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyFilterStatus(gens map[string]gopter.Gen) {
	gens["BlobTypes"] = gen.SliceOf(gen.AlphaString())
	gens["PrefixMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagementPolicyFilterStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyFilterStatus(gens map[string]gopter.Gen) {
	gens["BlobIndexMatch"] = gen.SliceOf(TagFilterStatusGenerator())
}

func Test_ManagementPolicyBaseBlob_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyBaseBlob to ManagementPolicyBaseBlob via AssignPropertiesToManagementPolicyBaseBlob & AssignPropertiesFromManagementPolicyBaseBlob returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyBaseBlob, ManagementPolicyBaseBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyBaseBlob tests if a specific instance of ManagementPolicyBaseBlob can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyBaseBlob(subject ManagementPolicyBaseBlob) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyBaseBlob
	err := copied.AssignPropertiesToManagementPolicyBaseBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyBaseBlob
	err = actual.AssignPropertiesFromManagementPolicyBaseBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyBaseBlob_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyBaseBlob via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyBaseBlob, ManagementPolicyBaseBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyBaseBlob runs a test to see if a specific instance of ManagementPolicyBaseBlob round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyBaseBlob(subject ManagementPolicyBaseBlob) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyBaseBlob
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyBaseBlob instances for property testing - lazily instantiated by
// ManagementPolicyBaseBlobGenerator()
var managementPolicyBaseBlobGenerator gopter.Gen

// ManagementPolicyBaseBlobGenerator returns a generator of ManagementPolicyBaseBlob instances for property testing.
// We first initialize managementPolicyBaseBlobGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyBaseBlobGenerator() gopter.Gen {
	if managementPolicyBaseBlobGenerator != nil {
		return managementPolicyBaseBlobGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	managementPolicyBaseBlobGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob(generators)
	managementPolicyBaseBlobGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob{}), generators)

	return managementPolicyBaseBlobGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyBaseBlob(gens map[string]gopter.Gen) {
	gens["EnableAutoTierToHotFromCool"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyBaseBlob(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterModificationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterModificationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterModificationGenerator())
}

func Test_ManagementPolicyBaseBlob_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyBaseBlob_Status to ManagementPolicyBaseBlob_Status via AssignPropertiesToManagementPolicyBaseBlobStatus & AssignPropertiesFromManagementPolicyBaseBlobStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyBaseBlobStatus, ManagementPolicyBaseBlobStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyBaseBlobStatus tests if a specific instance of ManagementPolicyBaseBlob_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyBaseBlobStatus(subject ManagementPolicyBaseBlob_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyBaseBlob_Status
	err := copied.AssignPropertiesToManagementPolicyBaseBlobStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyBaseBlob_Status
	err = actual.AssignPropertiesFromManagementPolicyBaseBlobStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyBaseBlob_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyBaseBlob_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyBaseBlobStatus, ManagementPolicyBaseBlobStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyBaseBlobStatus runs a test to see if a specific instance of ManagementPolicyBaseBlob_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyBaseBlobStatus(subject ManagementPolicyBaseBlob_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyBaseBlob_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyBaseBlob_Status instances for property testing - lazily instantiated by
// ManagementPolicyBaseBlobStatusGenerator()
var managementPolicyBaseBlobStatusGenerator gopter.Gen

// ManagementPolicyBaseBlobStatusGenerator returns a generator of ManagementPolicyBaseBlob_Status instances for property testing.
// We first initialize managementPolicyBaseBlobStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagementPolicyBaseBlobStatusGenerator() gopter.Gen {
	if managementPolicyBaseBlobStatusGenerator != nil {
		return managementPolicyBaseBlobStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobStatus(generators)
	managementPolicyBaseBlobStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobStatus(generators)
	AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobStatus(generators)
	managementPolicyBaseBlobStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyBaseBlob_Status{}), generators)

	return managementPolicyBaseBlobStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagementPolicyBaseBlobStatus(gens map[string]gopter.Gen) {
	gens["EnableAutoTierToHotFromCool"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyBaseBlobStatus(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterModificationStatusGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterModificationStatusGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterModificationStatusGenerator())
}

func Test_ManagementPolicySnapShot_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySnapShot to ManagementPolicySnapShot via AssignPropertiesToManagementPolicySnapShot & AssignPropertiesFromManagementPolicySnapShot returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySnapShot, ManagementPolicySnapShotGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySnapShot tests if a specific instance of ManagementPolicySnapShot can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySnapShot(subject ManagementPolicySnapShot) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySnapShot
	err := copied.AssignPropertiesToManagementPolicySnapShot(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySnapShot
	err = actual.AssignPropertiesFromManagementPolicySnapShot(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySnapShot_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySnapShot via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySnapShot, ManagementPolicySnapShotGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySnapShot runs a test to see if a specific instance of ManagementPolicySnapShot round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySnapShot(subject ManagementPolicySnapShot) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySnapShot
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySnapShot instances for property testing - lazily instantiated by
// ManagementPolicySnapShotGenerator()
var managementPolicySnapShotGenerator gopter.Gen

// ManagementPolicySnapShotGenerator returns a generator of ManagementPolicySnapShot instances for property testing.
func ManagementPolicySnapShotGenerator() gopter.Gen {
	if managementPolicySnapShotGenerator != nil {
		return managementPolicySnapShotGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySnapShot(generators)
	managementPolicySnapShotGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySnapShot{}), generators)

	return managementPolicySnapShotGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySnapShot is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySnapShot(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationGenerator())
}

func Test_ManagementPolicySnapShot_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicySnapShot_Status to ManagementPolicySnapShot_Status via AssignPropertiesToManagementPolicySnapShotStatus & AssignPropertiesFromManagementPolicySnapShotStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicySnapShotStatus, ManagementPolicySnapShotStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicySnapShotStatus tests if a specific instance of ManagementPolicySnapShot_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicySnapShotStatus(subject ManagementPolicySnapShot_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicySnapShot_Status
	err := copied.AssignPropertiesToManagementPolicySnapShotStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicySnapShot_Status
	err = actual.AssignPropertiesFromManagementPolicySnapShotStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicySnapShot_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicySnapShot_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicySnapShotStatus, ManagementPolicySnapShotStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicySnapShotStatus runs a test to see if a specific instance of ManagementPolicySnapShot_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicySnapShotStatus(subject ManagementPolicySnapShot_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicySnapShot_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicySnapShot_Status instances for property testing - lazily instantiated by
// ManagementPolicySnapShotStatusGenerator()
var managementPolicySnapShotStatusGenerator gopter.Gen

// ManagementPolicySnapShotStatusGenerator returns a generator of ManagementPolicySnapShot_Status instances for property testing.
func ManagementPolicySnapShotStatusGenerator() gopter.Gen {
	if managementPolicySnapShotStatusGenerator != nil {
		return managementPolicySnapShotStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicySnapShotStatus(generators)
	managementPolicySnapShotStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicySnapShot_Status{}), generators)

	return managementPolicySnapShotStatusGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicySnapShotStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicySnapShotStatus(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationStatusGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationStatusGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationStatusGenerator())
}

func Test_ManagementPolicyVersion_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyVersion to ManagementPolicyVersion via AssignPropertiesToManagementPolicyVersion & AssignPropertiesFromManagementPolicyVersion returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyVersion, ManagementPolicyVersionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyVersion tests if a specific instance of ManagementPolicyVersion can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyVersion(subject ManagementPolicyVersion) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyVersion
	err := copied.AssignPropertiesToManagementPolicyVersion(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyVersion
	err = actual.AssignPropertiesFromManagementPolicyVersion(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyVersion_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyVersion via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyVersion, ManagementPolicyVersionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyVersion runs a test to see if a specific instance of ManagementPolicyVersion round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyVersion(subject ManagementPolicyVersion) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyVersion
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyVersion instances for property testing - lazily instantiated by
// ManagementPolicyVersionGenerator()
var managementPolicyVersionGenerator gopter.Gen

// ManagementPolicyVersionGenerator returns a generator of ManagementPolicyVersion instances for property testing.
func ManagementPolicyVersionGenerator() gopter.Gen {
	if managementPolicyVersionGenerator != nil {
		return managementPolicyVersionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyVersion(generators)
	managementPolicyVersionGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyVersion{}), generators)

	return managementPolicyVersionGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyVersion is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyVersion(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationGenerator())
}

func Test_ManagementPolicyVersion_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagementPolicyVersion_Status to ManagementPolicyVersion_Status via AssignPropertiesToManagementPolicyVersionStatus & AssignPropertiesFromManagementPolicyVersionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagementPolicyVersionStatus, ManagementPolicyVersionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagementPolicyVersionStatus tests if a specific instance of ManagementPolicyVersion_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForManagementPolicyVersionStatus(subject ManagementPolicyVersion_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.ManagementPolicyVersion_Status
	err := copied.AssignPropertiesToManagementPolicyVersionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagementPolicyVersion_Status
	err = actual.AssignPropertiesFromManagementPolicyVersionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagementPolicyVersion_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagementPolicyVersion_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagementPolicyVersionStatus, ManagementPolicyVersionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagementPolicyVersionStatus runs a test to see if a specific instance of ManagementPolicyVersion_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagementPolicyVersionStatus(subject ManagementPolicyVersion_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagementPolicyVersion_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagementPolicyVersion_Status instances for property testing - lazily instantiated by
// ManagementPolicyVersionStatusGenerator()
var managementPolicyVersionStatusGenerator gopter.Gen

// ManagementPolicyVersionStatusGenerator returns a generator of ManagementPolicyVersion_Status instances for property testing.
func ManagementPolicyVersionStatusGenerator() gopter.Gen {
	if managementPolicyVersionStatusGenerator != nil {
		return managementPolicyVersionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagementPolicyVersionStatus(generators)
	managementPolicyVersionStatusGenerator = gen.Struct(reflect.TypeOf(ManagementPolicyVersion_Status{}), generators)

	return managementPolicyVersionStatusGenerator
}

// AddRelatedPropertyGeneratorsForManagementPolicyVersionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagementPolicyVersionStatus(gens map[string]gopter.Gen) {
	gens["Delete"] = gen.PtrOf(DateAfterCreationStatusGenerator())
	gens["TierToArchive"] = gen.PtrOf(DateAfterCreationStatusGenerator())
	gens["TierToCool"] = gen.PtrOf(DateAfterCreationStatusGenerator())
}

func Test_TagFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TagFilter to TagFilter via AssignPropertiesToTagFilter & AssignPropertiesFromTagFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForTagFilter, TagFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTagFilter tests if a specific instance of TagFilter can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForTagFilter(subject TagFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.TagFilter
	err := copied.AssignPropertiesToTagFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TagFilter
	err = actual.AssignPropertiesFromTagFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TagFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TagFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTagFilter, TagFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTagFilter runs a test to see if a specific instance of TagFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForTagFilter(subject TagFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TagFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TagFilter instances for property testing - lazily instantiated by TagFilterGenerator()
var tagFilterGenerator gopter.Gen

// TagFilterGenerator returns a generator of TagFilter instances for property testing.
func TagFilterGenerator() gopter.Gen {
	if tagFilterGenerator != nil {
		return tagFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTagFilter(generators)
	tagFilterGenerator = gen.Struct(reflect.TypeOf(TagFilter{}), generators)

	return tagFilterGenerator
}

// AddIndependentPropertyGeneratorsForTagFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTagFilter(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Op"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_TagFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TagFilter_Status to TagFilter_Status via AssignPropertiesToTagFilterStatus & AssignPropertiesFromTagFilterStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForTagFilterStatus, TagFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTagFilterStatus tests if a specific instance of TagFilter_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForTagFilterStatus(subject TagFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.TagFilter_Status
	err := copied.AssignPropertiesToTagFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TagFilter_Status
	err = actual.AssignPropertiesFromTagFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TagFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TagFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTagFilterStatus, TagFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTagFilterStatus runs a test to see if a specific instance of TagFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForTagFilterStatus(subject TagFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TagFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TagFilter_Status instances for property testing - lazily instantiated by TagFilterStatusGenerator()
var tagFilterStatusGenerator gopter.Gen

// TagFilterStatusGenerator returns a generator of TagFilter_Status instances for property testing.
func TagFilterStatusGenerator() gopter.Gen {
	if tagFilterStatusGenerator != nil {
		return tagFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTagFilterStatus(generators)
	tagFilterStatusGenerator = gen.Struct(reflect.TypeOf(TagFilter_Status{}), generators)

	return tagFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForTagFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTagFilterStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Op"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_DateAfterCreation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterCreation to DateAfterCreation via AssignPropertiesToDateAfterCreation & AssignPropertiesFromDateAfterCreation returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterCreation, DateAfterCreationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterCreation tests if a specific instance of DateAfterCreation can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterCreation(subject DateAfterCreation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterCreation
	err := copied.AssignPropertiesToDateAfterCreation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterCreation
	err = actual.AssignPropertiesFromDateAfterCreation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterCreation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterCreation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterCreation, DateAfterCreationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterCreation runs a test to see if a specific instance of DateAfterCreation round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterCreation(subject DateAfterCreation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterCreation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterCreation instances for property testing - lazily instantiated by DateAfterCreationGenerator()
var dateAfterCreationGenerator gopter.Gen

// DateAfterCreationGenerator returns a generator of DateAfterCreation instances for property testing.
func DateAfterCreationGenerator() gopter.Gen {
	if dateAfterCreationGenerator != nil {
		return dateAfterCreationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterCreation(generators)
	dateAfterCreationGenerator = gen.Struct(reflect.TypeOf(DateAfterCreation{}), generators)

	return dateAfterCreationGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterCreation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterCreation(gens map[string]gopter.Gen) {
	gens["DaysAfterCreationGreaterThan"] = gen.PtrOf(gen.Int())
}

func Test_DateAfterCreation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterCreation_Status to DateAfterCreation_Status via AssignPropertiesToDateAfterCreationStatus & AssignPropertiesFromDateAfterCreationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterCreationStatus, DateAfterCreationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterCreationStatus tests if a specific instance of DateAfterCreation_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterCreationStatus(subject DateAfterCreation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterCreation_Status
	err := copied.AssignPropertiesToDateAfterCreationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterCreation_Status
	err = actual.AssignPropertiesFromDateAfterCreationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterCreation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterCreation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterCreationStatus, DateAfterCreationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterCreationStatus runs a test to see if a specific instance of DateAfterCreation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterCreationStatus(subject DateAfterCreation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterCreation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterCreation_Status instances for property testing - lazily instantiated by
// DateAfterCreationStatusGenerator()
var dateAfterCreationStatusGenerator gopter.Gen

// DateAfterCreationStatusGenerator returns a generator of DateAfterCreation_Status instances for property testing.
func DateAfterCreationStatusGenerator() gopter.Gen {
	if dateAfterCreationStatusGenerator != nil {
		return dateAfterCreationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterCreationStatus(generators)
	dateAfterCreationStatusGenerator = gen.Struct(reflect.TypeOf(DateAfterCreation_Status{}), generators)

	return dateAfterCreationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterCreationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterCreationStatus(gens map[string]gopter.Gen) {
	gens["DaysAfterCreationGreaterThan"] = gen.PtrOf(gen.Float64())
}

func Test_DateAfterModification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterModification to DateAfterModification via AssignPropertiesToDateAfterModification & AssignPropertiesFromDateAfterModification returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterModification, DateAfterModificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterModification tests if a specific instance of DateAfterModification can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterModification(subject DateAfterModification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterModification
	err := copied.AssignPropertiesToDateAfterModification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterModification
	err = actual.AssignPropertiesFromDateAfterModification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterModification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterModification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterModification, DateAfterModificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterModification runs a test to see if a specific instance of DateAfterModification round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterModification(subject DateAfterModification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterModification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterModification instances for property testing - lazily instantiated by
// DateAfterModificationGenerator()
var dateAfterModificationGenerator gopter.Gen

// DateAfterModificationGenerator returns a generator of DateAfterModification instances for property testing.
func DateAfterModificationGenerator() gopter.Gen {
	if dateAfterModificationGenerator != nil {
		return dateAfterModificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterModification(generators)
	dateAfterModificationGenerator = gen.Struct(reflect.TypeOf(DateAfterModification{}), generators)

	return dateAfterModificationGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterModification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterModification(gens map[string]gopter.Gen) {
	gens["DaysAfterLastAccessTimeGreaterThan"] = gen.PtrOf(gen.Int())
	gens["DaysAfterModificationGreaterThan"] = gen.PtrOf(gen.Int())
}

func Test_DateAfterModification_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DateAfterModification_Status to DateAfterModification_Status via AssignPropertiesToDateAfterModificationStatus & AssignPropertiesFromDateAfterModificationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDateAfterModificationStatus, DateAfterModificationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDateAfterModificationStatus tests if a specific instance of DateAfterModification_Status can be assigned to v1beta20210401storage and back losslessly
func RunPropertyAssignmentTestForDateAfterModificationStatus(subject DateAfterModification_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401s.DateAfterModification_Status
	err := copied.AssignPropertiesToDateAfterModificationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DateAfterModification_Status
	err = actual.AssignPropertiesFromDateAfterModificationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DateAfterModification_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DateAfterModification_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDateAfterModificationStatus, DateAfterModificationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDateAfterModificationStatus runs a test to see if a specific instance of DateAfterModification_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDateAfterModificationStatus(subject DateAfterModification_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DateAfterModification_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DateAfterModification_Status instances for property testing - lazily instantiated by
// DateAfterModificationStatusGenerator()
var dateAfterModificationStatusGenerator gopter.Gen

// DateAfterModificationStatusGenerator returns a generator of DateAfterModification_Status instances for property testing.
func DateAfterModificationStatusGenerator() gopter.Gen {
	if dateAfterModificationStatusGenerator != nil {
		return dateAfterModificationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDateAfterModificationStatus(generators)
	dateAfterModificationStatusGenerator = gen.Struct(reflect.TypeOf(DateAfterModification_Status{}), generators)

	return dateAfterModificationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDateAfterModificationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDateAfterModificationStatus(gens map[string]gopter.Gen) {
	gens["DaysAfterLastAccessTimeGreaterThan"] = gen.PtrOf(gen.Float64())
	gens["DaysAfterModificationGreaterThan"] = gen.PtrOf(gen.Float64())
}
