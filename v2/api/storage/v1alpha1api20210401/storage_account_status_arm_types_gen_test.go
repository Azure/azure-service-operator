// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountSTATUSARM, StorageAccountSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountSTATUSARM runs a test to see if a specific instance of StorageAccount_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountSTATUSARM(subject StorageAccount_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountSTATUSARMGenerator()
var storageAccountSTATUSARMGenerator gopter.Gen

// StorageAccountSTATUSARMGenerator returns a generator of StorageAccount_STATUSARM instances for property testing.
// We first initialize storageAccountSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountSTATUSARMGenerator() gopter.Gen {
	if storageAccountSTATUSARMGenerator != nil {
		return storageAccountSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountSTATUSARM(generators)
	storageAccountSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountSTATUSARM(generators)
	storageAccountSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUSARM{}), generators)

	return storageAccountSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountSTATUSKind_BlobStorage,
		StorageAccountSTATUSKind_BlockBlobStorage,
		StorageAccountSTATUSKind_FileStorage,
		StorageAccountSTATUSKind_Storage,
		StorageAccountSTATUSKind_StorageV2))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentitySTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSARMGenerator())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSTATUSARM, ExtendedLocationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSTATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSTATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocationSTATUSARMGenerator()
var extendedLocationSTATUSARMGenerator gopter.Gen

// ExtendedLocationSTATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocationSTATUSARMGenerator() gopter.Gen {
	if extendedLocationSTATUSARMGenerator != nil {
		return extendedLocationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(generators)
	extendedLocationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_EdgeZone))
}

func Test_Identity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentitySTATUSARM, IdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentitySTATUSARM runs a test to see if a specific instance of Identity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentitySTATUSARM(subject Identity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUSARM instances for property testing - lazily instantiated by IdentitySTATUSARMGenerator()
var identitySTATUSARMGenerator gopter.Gen

// IdentitySTATUSARMGenerator returns a generator of Identity_STATUSARM instances for property testing.
// We first initialize identitySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentitySTATUSARMGenerator() gopter.Gen {
	if identitySTATUSARMGenerator != nil {
		return identitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUSARM(generators)
	identitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForIdentitySTATUSARM(generators)
	identitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(Identity_STATUSARM{}), generators)

	return identitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentitySTATUSType_None,
		IdentitySTATUSType_SystemAssigned,
		IdentitySTATUSType_SystemAssignedUserAssigned,
		IdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentitySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentitySTATUSARMGenerator())
}

func Test_StorageAccountProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesSTATUSARM, StorageAccountPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesSTATUSARM runs a test to see if a specific instance of StorageAccountProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesSTATUSARM(subject StorageAccountProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountPropertiesSTATUSARMGenerator()
var storageAccountPropertiesSTATUSARMGenerator gopter.Gen

// StorageAccountPropertiesSTATUSARMGenerator returns a generator of StorageAccountProperties_STATUSARM instances for property testing.
// We first initialize storageAccountPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesSTATUSARMGenerator() gopter.Gen {
	if storageAccountPropertiesSTATUSARMGenerator != nil {
		return storageAccountPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesSTATUSARM(generators)
	storageAccountPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesSTATUSARM(generators)
	storageAccountPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_STATUSARM{}), generators)

	return storageAccountPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSAccessTier_Cool, StorageAccountPropertiesSTATUSAccessTier_Hot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["CreationTime"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverInProgress"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSLargeFileSharesState_Disabled, StorageAccountPropertiesSTATUSLargeFileSharesState_Enabled))
	gens["LastGeoFailoverTime"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSMinimumTlsVersion_TLS10, StorageAccountPropertiesSTATUSMinimumTlsVersion_TLS11, StorageAccountPropertiesSTATUSMinimumTlsVersion_TLS12))
	gens["PrimaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSProvisioningState_Creating, StorageAccountPropertiesSTATUSProvisioningState_ResolvingDNS, StorageAccountPropertiesSTATUSProvisioningState_Succeeded))
	gens["SecondaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["StatusOfPrimary"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSStatusOfPrimary_Available, StorageAccountPropertiesSTATUSStatusOfPrimary_Unavailable))
	gens["StatusOfSecondary"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSTATUSStatusOfSecondary_Available, StorageAccountPropertiesSTATUSStatusOfSecondary_Unavailable))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationSTATUSARMGenerator())
	gens["BlobRestoreStatus"] = gen.PtrOf(BlobRestoreStatusSTATUSARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainSTATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionSTATUSARMGenerator())
	gens["GeoReplicationStats"] = gen.PtrOf(GeoReplicationStatsSTATUSARMGenerator())
	gens["KeyCreationTime"] = gen.PtrOf(KeyCreationTimeSTATUSARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicySTATUSARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetSTATUSARMGenerator())
	gens["PrimaryEndpoints"] = gen.PtrOf(EndpointsSTATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceSTATUSARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicySTATUSARMGenerator())
	gens["SecondaryEndpoints"] = gen.PtrOf(EndpointsSTATUSARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUSARM, AzureFilesIdentityBasedAuthenticationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUSARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUSARM(subject AzureFilesIdentityBasedAuthentication_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthenticationSTATUSARMGenerator()
var azureFilesIdentityBasedAuthenticationSTATUSARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationSTATUSARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_STATUSARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationSTATUSARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationSTATUSARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM(generators)
	azureFilesIdentityBasedAuthenticationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM(generators)
	azureFilesIdentityBasedAuthenticationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUSARM{}), generators)

	return azureFilesIdentityBasedAuthenticationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthenticationSTATUSDefaultSharePermission_None,
		AzureFilesIdentityBasedAuthenticationSTATUSDefaultSharePermission_StorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthenticationSTATUSDefaultSharePermission_StorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthenticationSTATUSDefaultSharePermission_StorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthenticationSTATUSDefaultSharePermission_StorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.OneConstOf(AzureFilesIdentityBasedAuthenticationSTATUSDirectoryServiceOptions_AADDS, AzureFilesIdentityBasedAuthenticationSTATUSDirectoryServiceOptions_AD, AzureFilesIdentityBasedAuthenticationSTATUSDirectoryServiceOptions_None))
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUSARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesSTATUSARMGenerator())
}

func Test_BlobRestoreStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreStatusSTATUSARM, BlobRestoreStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreStatusSTATUSARM runs a test to see if a specific instance of BlobRestoreStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreStatusSTATUSARM(subject BlobRestoreStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreStatus_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreStatusSTATUSARMGenerator()
var blobRestoreStatusSTATUSARMGenerator gopter.Gen

// BlobRestoreStatusSTATUSARMGenerator returns a generator of BlobRestoreStatus_STATUSARM instances for property testing.
// We first initialize blobRestoreStatusSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreStatusSTATUSARMGenerator() gopter.Gen {
	if blobRestoreStatusSTATUSARMGenerator != nil {
		return blobRestoreStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUSARM(generators)
	blobRestoreStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUSARM(generators)
	blobRestoreStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUSARM{}), generators)

	return blobRestoreStatusSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["FailureReason"] = gen.PtrOf(gen.AlphaString())
	gens["RestoreId"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(BlobRestoreStatusSTATUSStatus_Complete, BlobRestoreStatusSTATUSStatus_Failed, BlobRestoreStatusSTATUSStatus_InProgress))
}

// AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(BlobRestoreParametersSTATUSARMGenerator())
}

func Test_CustomDomain_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainSTATUSARM, CustomDomainSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainSTATUSARM runs a test to see if a specific instance of CustomDomain_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainSTATUSARM(subject CustomDomain_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUSARM instances for property testing - lazily instantiated by
// CustomDomainSTATUSARMGenerator()
var customDomainSTATUSARMGenerator gopter.Gen

// CustomDomainSTATUSARMGenerator returns a generator of CustomDomain_STATUSARM instances for property testing.
func CustomDomainSTATUSARMGenerator() gopter.Gen {
	if customDomainSTATUSARMGenerator != nil {
		return customDomainSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSTATUSARM(generators)
	customDomainSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUSARM{}), generators)

	return customDomainSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSTATUSARM, EncryptionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSTATUSARM runs a test to see if a specific instance of Encryption_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSTATUSARM(subject Encryption_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSTATUSARMGenerator()
var encryptionSTATUSARMGenerator gopter.Gen

// EncryptionSTATUSARMGenerator returns a generator of Encryption_STATUSARM instances for property testing.
// We first initialize encryptionSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSTATUSARMGenerator() gopter.Gen {
	if encryptionSTATUSARMGenerator != nil {
		return encryptionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSTATUSARM(generators)
	encryptionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSTATUSARM(generators)
	encryptionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	return encryptionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionSTATUSKeySource_MicrosoftKeyvault, EncryptionSTATUSKeySource_MicrosoftStorage))
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentitySTATUSARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesSTATUSARMGenerator())
}

func Test_Endpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Endpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointsSTATUSARM, EndpointsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointsSTATUSARM runs a test to see if a specific instance of Endpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointsSTATUSARM(subject Endpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Endpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Endpoints_STATUSARM instances for property testing - lazily instantiated by EndpointsSTATUSARMGenerator()
var endpointsSTATUSARMGenerator gopter.Gen

// EndpointsSTATUSARMGenerator returns a generator of Endpoints_STATUSARM instances for property testing.
// We first initialize endpointsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointsSTATUSARMGenerator() gopter.Gen {
	if endpointsSTATUSARMGenerator != nil {
		return endpointsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSTATUSARM(generators)
	endpointsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForEndpointsSTATUSARM(generators)
	endpointsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUSARM{}), generators)

	return endpointsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointsSTATUSARM(gens map[string]gopter.Gen) {
	gens["InternetEndpoints"] = gen.PtrOf(StorageAccountInternetEndpointsSTATUSARMGenerator())
	gens["MicrosoftEndpoints"] = gen.PtrOf(StorageAccountMicrosoftEndpointsSTATUSARMGenerator())
}

func Test_GeoReplicationStats_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoReplicationStats_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoReplicationStatsSTATUSARM, GeoReplicationStatsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoReplicationStatsSTATUSARM runs a test to see if a specific instance of GeoReplicationStats_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoReplicationStatsSTATUSARM(subject GeoReplicationStats_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoReplicationStats_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoReplicationStats_STATUSARM instances for property testing - lazily instantiated by
// GeoReplicationStatsSTATUSARMGenerator()
var geoReplicationStatsSTATUSARMGenerator gopter.Gen

// GeoReplicationStatsSTATUSARMGenerator returns a generator of GeoReplicationStats_STATUSARM instances for property testing.
func GeoReplicationStatsSTATUSARMGenerator() gopter.Gen {
	if geoReplicationStatsSTATUSARMGenerator != nil {
		return geoReplicationStatsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUSARM(generators)
	geoReplicationStatsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(GeoReplicationStats_STATUSARM{}), generators)

	return geoReplicationStatsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUSARM(gens map[string]gopter.Gen) {
	gens["CanFailover"] = gen.PtrOf(gen.Bool())
	gens["LastSyncTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(GeoReplicationStatsSTATUSStatus_Bootstrap, GeoReplicationStatsSTATUSStatus_Live, GeoReplicationStatsSTATUSStatus_Unavailable))
}

func Test_KeyCreationTime_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyCreationTime_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyCreationTimeSTATUSARM, KeyCreationTimeSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyCreationTimeSTATUSARM runs a test to see if a specific instance of KeyCreationTime_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyCreationTimeSTATUSARM(subject KeyCreationTime_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyCreationTime_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyCreationTime_STATUSARM instances for property testing - lazily instantiated by
// KeyCreationTimeSTATUSARMGenerator()
var keyCreationTimeSTATUSARMGenerator gopter.Gen

// KeyCreationTimeSTATUSARMGenerator returns a generator of KeyCreationTime_STATUSARM instances for property testing.
func KeyCreationTimeSTATUSARMGenerator() gopter.Gen {
	if keyCreationTimeSTATUSARMGenerator != nil {
		return keyCreationTimeSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUSARM(generators)
	keyCreationTimeSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyCreationTime_STATUSARM{}), generators)

	return keyCreationTimeSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUSARM(gens map[string]gopter.Gen) {
	gens["Key1"] = gen.PtrOf(gen.AlphaString())
	gens["Key2"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicySTATUSARM, KeyPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicySTATUSARM runs a test to see if a specific instance of KeyPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicySTATUSARM(subject KeyPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_STATUSARM instances for property testing - lazily instantiated by KeyPolicySTATUSARMGenerator()
var keyPolicySTATUSARMGenerator gopter.Gen

// KeyPolicySTATUSARMGenerator returns a generator of KeyPolicy_STATUSARM instances for property testing.
func KeyPolicySTATUSARMGenerator() gopter.Gen {
	if keyPolicySTATUSARMGenerator != nil {
		return keyPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicySTATUSARM(generators)
	keyPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_STATUSARM{}), generators)

	return keyPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSTATUSARM, NetworkRuleSetSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSTATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSTATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSetSTATUSARMGenerator()
var networkRuleSetSTATUSARMGenerator gopter.Gen

// NetworkRuleSetSTATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSetSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSTATUSARMGenerator() gopter.Gen {
	if networkRuleSetSTATUSARMGenerator != nil {
		return networkRuleSetSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSetSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSetSTATUSBypass_AzureServices,
		NetworkRuleSetSTATUSBypass_Logging,
		NetworkRuleSetSTATUSBypass_Metrics,
		NetworkRuleSetSTATUSBypass_None))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetSTATUSDefaultAction_Allow, NetworkRuleSetSTATUSDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSTATUSARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleSTATUSARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSTATUSARMGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM, PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing.
func PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceSTATUSARM, RoutingPreferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceSTATUSARM runs a test to see if a specific instance of RoutingPreference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceSTATUSARM(subject RoutingPreference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_STATUSARM instances for property testing - lazily instantiated by
// RoutingPreferenceSTATUSARMGenerator()
var routingPreferenceSTATUSARMGenerator gopter.Gen

// RoutingPreferenceSTATUSARMGenerator returns a generator of RoutingPreference_STATUSARM instances for property testing.
func RoutingPreferenceSTATUSARMGenerator() gopter.Gen {
	if routingPreferenceSTATUSARMGenerator != nil {
		return routingPreferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUSARM(generators)
	routingPreferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_STATUSARM{}), generators)

	return routingPreferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreferenceSTATUSRoutingChoice_InternetRouting, RoutingPreferenceSTATUSRoutingChoice_MicrosoftRouting))
}

func Test_SasPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicySTATUSARM, SasPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicySTATUSARM runs a test to see if a specific instance of SasPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicySTATUSARM(subject SasPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_STATUSARM instances for property testing - lazily instantiated by SasPolicySTATUSARMGenerator()
var sasPolicySTATUSARMGenerator gopter.Gen

// SasPolicySTATUSARMGenerator returns a generator of SasPolicy_STATUSARM instances for property testing.
func SasPolicySTATUSARMGenerator() gopter.Gen {
	if sasPolicySTATUSARMGenerator != nil {
		return sasPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicySTATUSARM(generators)
	sasPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_STATUSARM{}), generators)

	return sasPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.OneConstOf(SasPolicySTATUSExpirationAction_Log))
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySTATUSARM, UserAssignedIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySTATUSARM runs a test to see if a specific instance of UserAssignedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySTATUSARM(subject UserAssignedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentitySTATUSARMGenerator()
var userAssignedIdentitySTATUSARMGenerator gopter.Gen

// UserAssignedIdentitySTATUSARMGenerator returns a generator of UserAssignedIdentity_STATUSARM instances for property testing.
func UserAssignedIdentitySTATUSARMGenerator() gopter.Gen {
	if userAssignedIdentitySTATUSARMGenerator != nil {
		return userAssignedIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM(generators)
	userAssignedIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUSARM{}), generators)

	return userAssignedIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesSTATUSARM, ActiveDirectoryPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesSTATUSARM runs a test to see if a specific instance of ActiveDirectoryProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesSTATUSARM(subject ActiveDirectoryProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_STATUSARM instances for property testing - lazily instantiated by
// ActiveDirectoryPropertiesSTATUSARMGenerator()
var activeDirectoryPropertiesSTATUSARMGenerator gopter.Gen

// ActiveDirectoryPropertiesSTATUSARMGenerator returns a generator of ActiveDirectoryProperties_STATUSARM instances for property testing.
func ActiveDirectoryPropertiesSTATUSARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesSTATUSARMGenerator != nil {
		return activeDirectoryPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUSARM(generators)
	activeDirectoryPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_STATUSARM{}), generators)

	return activeDirectoryPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobRestoreParameters_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreParameters_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreParametersSTATUSARM, BlobRestoreParametersSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreParametersSTATUSARM runs a test to see if a specific instance of BlobRestoreParameters_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreParametersSTATUSARM(subject BlobRestoreParameters_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreParameters_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreParameters_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreParametersSTATUSARMGenerator()
var blobRestoreParametersSTATUSARMGenerator gopter.Gen

// BlobRestoreParametersSTATUSARMGenerator returns a generator of BlobRestoreParameters_STATUSARM instances for property testing.
// We first initialize blobRestoreParametersSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreParametersSTATUSARMGenerator() gopter.Gen {
	if blobRestoreParametersSTATUSARMGenerator != nil {
		return blobRestoreParametersSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUSARM(generators)
	blobRestoreParametersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUSARM(generators)
	blobRestoreParametersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUSARM{}), generators)

	return blobRestoreParametersSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUSARM(gens map[string]gopter.Gen) {
	gens["TimeToRestore"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUSARM(gens map[string]gopter.Gen) {
	gens["BlobRanges"] = gen.SliceOf(BlobRestoreRangeSTATUSARMGenerator())
}

func Test_EncryptionIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentitySTATUSARM, EncryptionIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentitySTATUSARM runs a test to see if a specific instance of EncryptionIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentitySTATUSARM(subject EncryptionIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_STATUSARM instances for property testing - lazily instantiated by
// EncryptionIdentitySTATUSARMGenerator()
var encryptionIdentitySTATUSARMGenerator gopter.Gen

// EncryptionIdentitySTATUSARMGenerator returns a generator of EncryptionIdentity_STATUSARM instances for property testing.
func EncryptionIdentitySTATUSARMGenerator() gopter.Gen {
	if encryptionIdentitySTATUSARMGenerator != nil {
		return encryptionIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUSARM(generators)
	encryptionIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_STATUSARM{}), generators)

	return encryptionIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesSTATUSARM, EncryptionServicesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesSTATUSARM runs a test to see if a specific instance of EncryptionServices_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesSTATUSARM(subject EncryptionServices_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_STATUSARM instances for property testing - lazily instantiated by
// EncryptionServicesSTATUSARMGenerator()
var encryptionServicesSTATUSARMGenerator gopter.Gen

// EncryptionServicesSTATUSARMGenerator returns a generator of EncryptionServices_STATUSARM instances for property testing.
func EncryptionServicesSTATUSARMGenerator() gopter.Gen {
	if encryptionServicesSTATUSARMGenerator != nil {
		return encryptionServicesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesSTATUSARM(generators)
	encryptionServicesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_STATUSARM{}), generators)

	return encryptionServicesSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceSTATUSARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceSTATUSARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceSTATUSARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceSTATUSARMGenerator())
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSTATUSARM, IPRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSTATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSTATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRuleSTATUSARMGenerator()
var ipRuleSTATUSARMGenerator gopter.Gen

// IPRuleSTATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRuleSTATUSARMGenerator() gopter.Gen {
	if ipRuleSTATUSARMGenerator != nil {
		return ipRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(generators)
	ipRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleSTATUSAction_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM, KeyVaultPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesSTATUSARMGenerator()
var keyVaultPropertiesSTATUSARMGenerator gopter.Gen

// KeyVaultPropertiesSTATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultPropertiesSTATUSARMGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSARMGenerator != nil {
		return keyVaultPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(generators)
	keyVaultPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleSTATUSARM, ResourceAccessRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleSTATUSARM runs a test to see if a specific instance of ResourceAccessRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleSTATUSARM(subject ResourceAccessRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_STATUSARM instances for property testing - lazily instantiated by
// ResourceAccessRuleSTATUSARMGenerator()
var resourceAccessRuleSTATUSARMGenerator gopter.Gen

// ResourceAccessRuleSTATUSARMGenerator returns a generator of ResourceAccessRule_STATUSARM instances for property testing.
func ResourceAccessRuleSTATUSARMGenerator() gopter.Gen {
	if resourceAccessRuleSTATUSARMGenerator != nil {
		return resourceAccessRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUSARM(generators)
	resourceAccessRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_STATUSARM{}), generators)

	return resourceAccessRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountInternetEndpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountInternetEndpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUSARM, StorageAccountInternetEndpointsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUSARM runs a test to see if a specific instance of StorageAccountInternetEndpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUSARM(subject StorageAccountInternetEndpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountInternetEndpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountInternetEndpoints_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountInternetEndpointsSTATUSARMGenerator()
var storageAccountInternetEndpointsSTATUSARMGenerator gopter.Gen

// StorageAccountInternetEndpointsSTATUSARMGenerator returns a generator of StorageAccountInternetEndpoints_STATUSARM instances for property testing.
func StorageAccountInternetEndpointsSTATUSARMGenerator() gopter.Gen {
	if storageAccountInternetEndpointsSTATUSARMGenerator != nil {
		return storageAccountInternetEndpointsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUSARM(generators)
	storageAccountInternetEndpointsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountInternetEndpoints_STATUSARM{}), generators)

	return storageAccountInternetEndpointsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountMicrosoftEndpoints_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountMicrosoftEndpoints_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUSARM, StorageAccountMicrosoftEndpointsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUSARM runs a test to see if a specific instance of StorageAccountMicrosoftEndpoints_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUSARM(subject StorageAccountMicrosoftEndpoints_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountMicrosoftEndpoints_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountMicrosoftEndpoints_STATUSARM instances for property testing - lazily instantiated by
// StorageAccountMicrosoftEndpointsSTATUSARMGenerator()
var storageAccountMicrosoftEndpointsSTATUSARMGenerator gopter.Gen

// StorageAccountMicrosoftEndpointsSTATUSARMGenerator returns a generator of StorageAccountMicrosoftEndpoints_STATUSARM instances for property testing.
func StorageAccountMicrosoftEndpointsSTATUSARMGenerator() gopter.Gen {
	if storageAccountMicrosoftEndpointsSTATUSARMGenerator != nil {
		return storageAccountMicrosoftEndpointsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUSARM(generators)
	storageAccountMicrosoftEndpointsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountMicrosoftEndpoints_STATUSARM{}), generators)

	return storageAccountMicrosoftEndpointsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM, VirtualNetworkRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM runs a test to see if a specific instance of VirtualNetworkRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM(subject VirtualNetworkRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUSARM instances for property testing - lazily instantiated by
// VirtualNetworkRuleSTATUSARMGenerator()
var virtualNetworkRuleSTATUSARMGenerator gopter.Gen

// VirtualNetworkRuleSTATUSARMGenerator returns a generator of VirtualNetworkRule_STATUSARM instances for property testing.
func VirtualNetworkRuleSTATUSARMGenerator() gopter.Gen {
	if virtualNetworkRuleSTATUSARMGenerator != nil {
		return virtualNetworkRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM(generators)
	virtualNetworkRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUSARM{}), generators)

	return virtualNetworkRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRuleSTATUSAction_Allow))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRuleSTATUSState_Deprovisioning,
		VirtualNetworkRuleSTATUSState_Failed,
		VirtualNetworkRuleSTATUSState_NetworkSourceDeleted,
		VirtualNetworkRuleSTATUSState_Provisioning,
		VirtualNetworkRuleSTATUSState_Succeeded))
}

func Test_BlobRestoreRange_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreRange_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreRangeSTATUSARM, BlobRestoreRangeSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreRangeSTATUSARM runs a test to see if a specific instance of BlobRestoreRange_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreRangeSTATUSARM(subject BlobRestoreRange_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreRange_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreRange_STATUSARM instances for property testing - lazily instantiated by
// BlobRestoreRangeSTATUSARMGenerator()
var blobRestoreRangeSTATUSARMGenerator gopter.Gen

// BlobRestoreRangeSTATUSARMGenerator returns a generator of BlobRestoreRange_STATUSARM instances for property testing.
func BlobRestoreRangeSTATUSARMGenerator() gopter.Gen {
	if blobRestoreRangeSTATUSARMGenerator != nil {
		return blobRestoreRangeSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUSARM(generators)
	blobRestoreRangeSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreRange_STATUSARM{}), generators)

	return blobRestoreRangeSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUSARM(gens map[string]gopter.Gen) {
	gens["EndRange"] = gen.PtrOf(gen.AlphaString())
	gens["StartRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceSTATUSARM, EncryptionServiceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceSTATUSARM runs a test to see if a specific instance of EncryptionService_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceSTATUSARM(subject EncryptionService_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_STATUSARM instances for property testing - lazily instantiated by
// EncryptionServiceSTATUSARMGenerator()
var encryptionServiceSTATUSARMGenerator gopter.Gen

// EncryptionServiceSTATUSARMGenerator returns a generator of EncryptionService_STATUSARM instances for property testing.
func EncryptionServiceSTATUSARMGenerator() gopter.Gen {
	if encryptionServiceSTATUSARMGenerator != nil {
		return encryptionServiceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceSTATUSARM(generators)
	encryptionServiceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_STATUSARM{}), generators)

	return encryptionServiceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionServiceSTATUSKeyType_Account, EncryptionServiceSTATUSKeyType_Service))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
