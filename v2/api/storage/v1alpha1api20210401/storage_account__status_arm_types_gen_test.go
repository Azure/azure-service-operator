// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountStatusARM, StorageAccountStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountStatusARM runs a test to see if a specific instance of StorageAccount_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountStatusARM(subject StorageAccount_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_StatusARM instances for property testing - lazily instantiated by
//StorageAccountStatusARMGenerator()
var storageAccountStatusARMGenerator gopter.Gen

// StorageAccountStatusARMGenerator returns a generator of StorageAccount_StatusARM instances for property testing.
// We first initialize storageAccountStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountStatusARMGenerator() gopter.Gen {
	if storageAccountStatusARMGenerator != nil {
		return storageAccountStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountStatusARM(generators)
	storageAccountStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountStatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountStatusARM(generators)
	storageAccountStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_StatusARM{}), generators)

	return storageAccountStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountStatusKindBlobStorage,
		StorageAccountStatusKindBlockBlobStorage,
		StorageAccountStatusKindFileStorage,
		StorageAccountStatusKindStorage,
		StorageAccountStatusKindStorageV2))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountStatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentityStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesStatusARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuStatusARMGenerator())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatusARM, ExtendedLocationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
//ExtendedLocationStatusARMGenerator()
var extendedLocationStatusARMGenerator gopter.Gen

// ExtendedLocationStatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocationStatusARMGenerator() gopter.Gen {
	if extendedLocationStatusARMGenerator != nil {
		return extendedLocationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(generators)
	extendedLocationStatusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_Identity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityStatusARM, IdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityStatusARM runs a test to see if a specific instance of Identity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityStatusARM(subject Identity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_StatusARM instances for property testing - lazily instantiated by IdentityStatusARMGenerator()
var identityStatusARMGenerator gopter.Gen

// IdentityStatusARMGenerator returns a generator of Identity_StatusARM instances for property testing.
// We first initialize identityStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityStatusARMGenerator() gopter.Gen {
	if identityStatusARMGenerator != nil {
		return identityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatusARM(generators)
	identityStatusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatusARM(generators)
	AddRelatedPropertyGeneratorsForIdentityStatusARM(generators)
	identityStatusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	return identityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(
		IdentityStatusTypeNone,
		IdentityStatusTypeSystemAssigned,
		IdentityStatusTypeSystemAssignedUserAssigned,
		IdentityStatusTypeUserAssigned)
}

// AddRelatedPropertyGeneratorsForIdentityStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityStatusARMGenerator())
}

func Test_StorageAccountProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesStatusARM, StorageAccountPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesStatusARM runs a test to see if a specific instance of StorageAccountProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesStatusARM(subject StorageAccountProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_StatusARM instances for property testing - lazily instantiated by
//StorageAccountPropertiesStatusARMGenerator()
var storageAccountPropertiesStatusARMGenerator gopter.Gen

// StorageAccountPropertiesStatusARMGenerator returns a generator of StorageAccountProperties_StatusARM instances for property testing.
// We first initialize storageAccountPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesStatusARMGenerator() gopter.Gen {
	if storageAccountPropertiesStatusARMGenerator != nil {
		return storageAccountPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesStatusARM(generators)
	storageAccountPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesStatusARM(generators)
	storageAccountPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_StatusARM{}), generators)

	return storageAccountPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusAccessTierCool, StorageAccountPropertiesStatusAccessTierHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["CreationTime"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverInProgress"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusLargeFileSharesStateDisabled, StorageAccountPropertiesStatusLargeFileSharesStateEnabled))
	gens["LastGeoFailoverTime"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusMinimumTlsVersionTLS10, StorageAccountPropertiesStatusMinimumTlsVersionTLS11, StorageAccountPropertiesStatusMinimumTlsVersionTLS12))
	gens["PrimaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusProvisioningStateCreating, StorageAccountPropertiesStatusProvisioningStateResolvingDNS, StorageAccountPropertiesStatusProvisioningStateSucceeded))
	gens["SecondaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["StatusOfPrimary"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusStatusOfPrimaryAvailable, StorageAccountPropertiesStatusStatusOfPrimaryUnavailable))
	gens["StatusOfSecondary"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesStatusStatusOfSecondaryAvailable, StorageAccountPropertiesStatusStatusOfSecondaryUnavailable))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationStatusARMGenerator())
	gens["BlobRestoreStatus"] = gen.PtrOf(BlobRestoreStatusStatusARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainStatusARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionStatusARMGenerator())
	gens["GeoReplicationStats"] = gen.PtrOf(GeoReplicationStatsStatusARMGenerator())
	gens["KeyCreationTime"] = gen.PtrOf(KeyCreationTimeStatusARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyStatusARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetStatusARMGenerator())
	gens["PrimaryEndpoints"] = gen.PtrOf(EndpointsStatusARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceStatusARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyStatusARMGenerator())
	gens["SecondaryEndpoints"] = gen.PtrOf(EndpointsStatusARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM, AzureFilesIdentityBasedAuthenticationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM(subject AzureFilesIdentityBasedAuthentication_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationStatusARMGenerator()
var azureFilesIdentityBasedAuthenticationStatusARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationStatusARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationStatusARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationStatusARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	azureFilesIdentityBasedAuthenticationStatusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	azureFilesIdentityBasedAuthenticationStatusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	return azureFilesIdentityBasedAuthenticationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionNone,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsAADDS, AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsAD, AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesStatusARMGenerator())
}

func Test_BlobRestoreStatus_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreStatus_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreStatusStatusARM, BlobRestoreStatusStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreStatusStatusARM runs a test to see if a specific instance of BlobRestoreStatus_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreStatusStatusARM(subject BlobRestoreStatus_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreStatus_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreStatus_StatusARM instances for property testing - lazily instantiated by
//BlobRestoreStatusStatusARMGenerator()
var blobRestoreStatusStatusARMGenerator gopter.Gen

// BlobRestoreStatusStatusARMGenerator returns a generator of BlobRestoreStatus_StatusARM instances for property testing.
// We first initialize blobRestoreStatusStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreStatusStatusARMGenerator() gopter.Gen {
	if blobRestoreStatusStatusARMGenerator != nil {
		return blobRestoreStatusStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusStatusARM(generators)
	blobRestoreStatusStatusARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusStatusARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreStatusStatusARM(generators)
	blobRestoreStatusStatusARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_StatusARM{}), generators)

	return blobRestoreStatusStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreStatusStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreStatusStatusARM(gens map[string]gopter.Gen) {
	gens["FailureReason"] = gen.PtrOf(gen.AlphaString())
	gens["RestoreId"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(BlobRestoreStatusStatusStatusComplete, BlobRestoreStatusStatusStatusFailed, BlobRestoreStatusStatusStatusInProgress))
}

// AddRelatedPropertyGeneratorsForBlobRestoreStatusStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreStatusStatusARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(BlobRestoreParametersStatusARMGenerator())
}

func Test_CustomDomain_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainStatusARM, CustomDomainStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainStatusARM runs a test to see if a specific instance of CustomDomain_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainStatusARM(subject CustomDomain_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_StatusARM instances for property testing - lazily instantiated by
//CustomDomainStatusARMGenerator()
var customDomainStatusARMGenerator gopter.Gen

// CustomDomainStatusARMGenerator returns a generator of CustomDomain_StatusARM instances for property testing.
func CustomDomainStatusARMGenerator() gopter.Gen {
	if customDomainStatusARMGenerator != nil {
		return customDomainStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainStatusARM(generators)
	customDomainStatusARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_StatusARM{}), generators)

	return customDomainStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionStatusARM, EncryptionStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionStatusARM runs a test to see if a specific instance of Encryption_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionStatusARM(subject Encryption_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_StatusARM instances for property testing - lazily instantiated by
//EncryptionStatusARMGenerator()
var encryptionStatusARMGenerator gopter.Gen

// EncryptionStatusARMGenerator returns a generator of Encryption_StatusARM instances for property testing.
// We first initialize encryptionStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionStatusARMGenerator() gopter.Gen {
	if encryptionStatusARMGenerator != nil {
		return encryptionStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatusARM(generators)
	encryptionStatusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionStatusARM(generators)
	encryptionStatusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	return encryptionStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionStatusARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(EncryptionStatusKeySourceMicrosoftKeyvault, EncryptionStatusKeySourceMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityStatusARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesStatusARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesStatusARMGenerator())
}

func Test_Endpoints_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Endpoints_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointsStatusARM, EndpointsStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointsStatusARM runs a test to see if a specific instance of Endpoints_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointsStatusARM(subject Endpoints_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Endpoints_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Endpoints_StatusARM instances for property testing - lazily instantiated by EndpointsStatusARMGenerator()
var endpointsStatusARMGenerator gopter.Gen

// EndpointsStatusARMGenerator returns a generator of Endpoints_StatusARM instances for property testing.
// We first initialize endpointsStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointsStatusARMGenerator() gopter.Gen {
	if endpointsStatusARMGenerator != nil {
		return endpointsStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsStatusARM(generators)
	endpointsStatusARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsStatusARM(generators)
	AddRelatedPropertyGeneratorsForEndpointsStatusARM(generators)
	endpointsStatusARMGenerator = gen.Struct(reflect.TypeOf(Endpoints_StatusARM{}), generators)

	return endpointsStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointsStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointsStatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointsStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointsStatusARM(gens map[string]gopter.Gen) {
	gens["InternetEndpoints"] = gen.PtrOf(StorageAccountInternetEndpointsStatusARMGenerator())
	gens["MicrosoftEndpoints"] = gen.PtrOf(StorageAccountMicrosoftEndpointsStatusARMGenerator())
}

func Test_GeoReplicationStats_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoReplicationStats_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoReplicationStatsStatusARM, GeoReplicationStatsStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoReplicationStatsStatusARM runs a test to see if a specific instance of GeoReplicationStats_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoReplicationStatsStatusARM(subject GeoReplicationStats_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoReplicationStats_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoReplicationStats_StatusARM instances for property testing - lazily instantiated by
//GeoReplicationStatsStatusARMGenerator()
var geoReplicationStatsStatusARMGenerator gopter.Gen

// GeoReplicationStatsStatusARMGenerator returns a generator of GeoReplicationStats_StatusARM instances for property testing.
func GeoReplicationStatsStatusARMGenerator() gopter.Gen {
	if geoReplicationStatsStatusARMGenerator != nil {
		return geoReplicationStatsStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoReplicationStatsStatusARM(generators)
	geoReplicationStatsStatusARMGenerator = gen.Struct(reflect.TypeOf(GeoReplicationStats_StatusARM{}), generators)

	return geoReplicationStatsStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoReplicationStatsStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoReplicationStatsStatusARM(gens map[string]gopter.Gen) {
	gens["CanFailover"] = gen.PtrOf(gen.Bool())
	gens["LastSyncTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(GeoReplicationStatsStatusStatusBootstrap, GeoReplicationStatsStatusStatusLive, GeoReplicationStatsStatusStatusUnavailable))
}

func Test_KeyCreationTime_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyCreationTime_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyCreationTimeStatusARM, KeyCreationTimeStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyCreationTimeStatusARM runs a test to see if a specific instance of KeyCreationTime_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyCreationTimeStatusARM(subject KeyCreationTime_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyCreationTime_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyCreationTime_StatusARM instances for property testing - lazily instantiated by
//KeyCreationTimeStatusARMGenerator()
var keyCreationTimeStatusARMGenerator gopter.Gen

// KeyCreationTimeStatusARMGenerator returns a generator of KeyCreationTime_StatusARM instances for property testing.
func KeyCreationTimeStatusARMGenerator() gopter.Gen {
	if keyCreationTimeStatusARMGenerator != nil {
		return keyCreationTimeStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyCreationTimeStatusARM(generators)
	keyCreationTimeStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyCreationTime_StatusARM{}), generators)

	return keyCreationTimeStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyCreationTimeStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyCreationTimeStatusARM(gens map[string]gopter.Gen) {
	gens["Key1"] = gen.PtrOf(gen.AlphaString())
	gens["Key2"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicyStatusARM, KeyPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicyStatusARM runs a test to see if a specific instance of KeyPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicyStatusARM(subject KeyPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_StatusARM instances for property testing - lazily instantiated by KeyPolicyStatusARMGenerator()
var keyPolicyStatusARMGenerator gopter.Gen

// KeyPolicyStatusARMGenerator returns a generator of KeyPolicy_StatusARM instances for property testing.
func KeyPolicyStatusARMGenerator() gopter.Gen {
	if keyPolicyStatusARMGenerator != nil {
		return keyPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicyStatusARM(generators)
	keyPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_StatusARM{}), generators)

	return keyPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetStatusARM, NetworkRuleSetStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetStatusARM runs a test to see if a specific instance of NetworkRuleSet_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetStatusARM(subject NetworkRuleSet_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_StatusARM instances for property testing - lazily instantiated by
//NetworkRuleSetStatusARMGenerator()
var networkRuleSetStatusARMGenerator gopter.Gen

// NetworkRuleSetStatusARMGenerator returns a generator of NetworkRuleSet_StatusARM instances for property testing.
// We first initialize networkRuleSetStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetStatusARMGenerator() gopter.Gen {
	if networkRuleSetStatusARMGenerator != nil {
		return networkRuleSetStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	return networkRuleSetStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSetStatusBypassAzureServices,
		NetworkRuleSetStatusBypassLogging,
		NetworkRuleSetStatusBypassMetrics,
		NetworkRuleSetStatusBypassNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSetStatusDefaultActionAllow, NetworkRuleSetStatusDefaultActionDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleStatusARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleStatusARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusARMGenerator())
}

func Test_PrivateEndpointConnection_Status_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM, PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_Status_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(subject PrivateEndpointConnection_Status_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing.
func PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(generators)
	privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceStatusARM, RoutingPreferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceStatusARM runs a test to see if a specific instance of RoutingPreference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceStatusARM(subject RoutingPreference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_StatusARM instances for property testing - lazily instantiated by
//RoutingPreferenceStatusARMGenerator()
var routingPreferenceStatusARMGenerator gopter.Gen

// RoutingPreferenceStatusARMGenerator returns a generator of RoutingPreference_StatusARM instances for property testing.
func RoutingPreferenceStatusARMGenerator() gopter.Gen {
	if routingPreferenceStatusARMGenerator != nil {
		return routingPreferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM(generators)
	routingPreferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_StatusARM{}), generators)

	return routingPreferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreferenceStatusRoutingChoiceInternetRouting, RoutingPreferenceStatusRoutingChoiceMicrosoftRouting))
}

func Test_SasPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicyStatusARM, SasPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicyStatusARM runs a test to see if a specific instance of SasPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicyStatusARM(subject SasPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_StatusARM instances for property testing - lazily instantiated by SasPolicyStatusARMGenerator()
var sasPolicyStatusARMGenerator gopter.Gen

// SasPolicyStatusARMGenerator returns a generator of SasPolicy_StatusARM instances for property testing.
func SasPolicyStatusARMGenerator() gopter.Gen {
	if sasPolicyStatusARMGenerator != nil {
		return sasPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicyStatusARM(generators)
	sasPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_StatusARM{}), generators)

	return sasPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicyStatusExpirationActionLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_UserAssignedIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityStatusARM, UserAssignedIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityStatusARM runs a test to see if a specific instance of UserAssignedIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityStatusARM(subject UserAssignedIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_StatusARM instances for property testing - lazily instantiated by
//UserAssignedIdentityStatusARMGenerator()
var userAssignedIdentityStatusARMGenerator gopter.Gen

// UserAssignedIdentityStatusARMGenerator returns a generator of UserAssignedIdentity_StatusARM instances for property testing.
func UserAssignedIdentityStatusARMGenerator() gopter.Gen {
	if userAssignedIdentityStatusARMGenerator != nil {
		return userAssignedIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM(generators)
	userAssignedIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_StatusARM{}), generators)

	return userAssignedIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM, ActiveDirectoryPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM runs a test to see if a specific instance of ActiveDirectoryProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM(subject ActiveDirectoryProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_StatusARM instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesStatusARMGenerator()
var activeDirectoryPropertiesStatusARMGenerator gopter.Gen

// ActiveDirectoryPropertiesStatusARMGenerator returns a generator of ActiveDirectoryProperties_StatusARM instances for property testing.
func ActiveDirectoryPropertiesStatusARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesStatusARMGenerator != nil {
		return activeDirectoryPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM(generators)
	activeDirectoryPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_StatusARM{}), generators)

	return activeDirectoryPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_BlobRestoreParameters_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreParameters_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreParametersStatusARM, BlobRestoreParametersStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreParametersStatusARM runs a test to see if a specific instance of BlobRestoreParameters_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreParametersStatusARM(subject BlobRestoreParameters_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreParameters_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreParameters_StatusARM instances for property testing - lazily instantiated by
//BlobRestoreParametersStatusARMGenerator()
var blobRestoreParametersStatusARMGenerator gopter.Gen

// BlobRestoreParametersStatusARMGenerator returns a generator of BlobRestoreParameters_StatusARM instances for property testing.
// We first initialize blobRestoreParametersStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreParametersStatusARMGenerator() gopter.Gen {
	if blobRestoreParametersStatusARMGenerator != nil {
		return blobRestoreParametersStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersStatusARM(generators)
	blobRestoreParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersStatusARM(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreParametersStatusARM(generators)
	blobRestoreParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_StatusARM{}), generators)

	return blobRestoreParametersStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreParametersStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreParametersStatusARM(gens map[string]gopter.Gen) {
	gens["TimeToRestore"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForBlobRestoreParametersStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreParametersStatusARM(gens map[string]gopter.Gen) {
	gens["BlobRanges"] = gen.SliceOf(BlobRestoreRangeStatusARMGenerator())
}

func Test_EncryptionIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentityStatusARM, EncryptionIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentityStatusARM runs a test to see if a specific instance of EncryptionIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentityStatusARM(subject EncryptionIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_StatusARM instances for property testing - lazily instantiated by
//EncryptionIdentityStatusARMGenerator()
var encryptionIdentityStatusARMGenerator gopter.Gen

// EncryptionIdentityStatusARMGenerator returns a generator of EncryptionIdentity_StatusARM instances for property testing.
func EncryptionIdentityStatusARMGenerator() gopter.Gen {
	if encryptionIdentityStatusARMGenerator != nil {
		return encryptionIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM(generators)
	encryptionIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_StatusARM{}), generators)

	return encryptionIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesStatusARM, EncryptionServicesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesStatusARM runs a test to see if a specific instance of EncryptionServices_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesStatusARM(subject EncryptionServices_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_StatusARM instances for property testing - lazily instantiated by
//EncryptionServicesStatusARMGenerator()
var encryptionServicesStatusARMGenerator gopter.Gen

// EncryptionServicesStatusARMGenerator returns a generator of EncryptionServices_StatusARM instances for property testing.
func EncryptionServicesStatusARMGenerator() gopter.Gen {
	if encryptionServicesStatusARMGenerator != nil {
		return encryptionServicesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM(generators)
	encryptionServicesStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_StatusARM{}), generators)

	return encryptionServicesStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
}

func Test_IPRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleStatusARM, IPRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleStatusARM runs a test to see if a specific instance of IPRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleStatusARM(subject IPRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_StatusARM instances for property testing - lazily instantiated by IPRuleStatusARMGenerator()
var ipRuleStatusARMGenerator gopter.Gen

// IPRuleStatusARMGenerator returns a generator of IPRule_StatusARM instances for property testing.
func IPRuleStatusARMGenerator() gopter.Gen {
	if ipRuleStatusARMGenerator != nil {
		return ipRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleStatusARM(generators)
	ipRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(IPRule_StatusARM{}), generators)

	return ipRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleStatusActionAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatusARM, KeyVaultPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatusARM runs a test to see if a specific instance of KeyVaultProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatusARM(subject KeyVaultProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_StatusARM instances for property testing - lazily instantiated by
//KeyVaultPropertiesStatusARMGenerator()
var keyVaultPropertiesStatusARMGenerator gopter.Gen

// KeyVaultPropertiesStatusARMGenerator returns a generator of KeyVaultProperties_StatusARM instances for property testing.
func KeyVaultPropertiesStatusARMGenerator() gopter.Gen {
	if keyVaultPropertiesStatusARMGenerator != nil {
		return keyVaultPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(generators)
	keyVaultPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_StatusARM{}), generators)

	return keyVaultPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleStatusARM, ResourceAccessRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleStatusARM runs a test to see if a specific instance of ResourceAccessRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleStatusARM(subject ResourceAccessRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_StatusARM instances for property testing - lazily instantiated by
//ResourceAccessRuleStatusARMGenerator()
var resourceAccessRuleStatusARMGenerator gopter.Gen

// ResourceAccessRuleStatusARMGenerator returns a generator of ResourceAccessRule_StatusARM instances for property testing.
func ResourceAccessRuleStatusARMGenerator() gopter.Gen {
	if resourceAccessRuleStatusARMGenerator != nil {
		return resourceAccessRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM(generators)
	resourceAccessRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_StatusARM{}), generators)

	return resourceAccessRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountInternetEndpoints_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountInternetEndpoints_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountInternetEndpointsStatusARM, StorageAccountInternetEndpointsStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountInternetEndpointsStatusARM runs a test to see if a specific instance of StorageAccountInternetEndpoints_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountInternetEndpointsStatusARM(subject StorageAccountInternetEndpoints_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountInternetEndpoints_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountInternetEndpoints_StatusARM instances for property testing - lazily instantiated by
//StorageAccountInternetEndpointsStatusARMGenerator()
var storageAccountInternetEndpointsStatusARMGenerator gopter.Gen

// StorageAccountInternetEndpointsStatusARMGenerator returns a generator of StorageAccountInternetEndpoints_StatusARM instances for property testing.
func StorageAccountInternetEndpointsStatusARMGenerator() gopter.Gen {
	if storageAccountInternetEndpointsStatusARMGenerator != nil {
		return storageAccountInternetEndpointsStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsStatusARM(generators)
	storageAccountInternetEndpointsStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountInternetEndpoints_StatusARM{}), generators)

	return storageAccountInternetEndpointsStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsStatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountMicrosoftEndpoints_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountMicrosoftEndpoints_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountMicrosoftEndpointsStatusARM, StorageAccountMicrosoftEndpointsStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountMicrosoftEndpointsStatusARM runs a test to see if a specific instance of StorageAccountMicrosoftEndpoints_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountMicrosoftEndpointsStatusARM(subject StorageAccountMicrosoftEndpoints_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountMicrosoftEndpoints_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountMicrosoftEndpoints_StatusARM instances for property testing - lazily instantiated by
//StorageAccountMicrosoftEndpointsStatusARMGenerator()
var storageAccountMicrosoftEndpointsStatusARMGenerator gopter.Gen

// StorageAccountMicrosoftEndpointsStatusARMGenerator returns a generator of StorageAccountMicrosoftEndpoints_StatusARM instances for property testing.
func StorageAccountMicrosoftEndpointsStatusARMGenerator() gopter.Gen {
	if storageAccountMicrosoftEndpointsStatusARMGenerator != nil {
		return storageAccountMicrosoftEndpointsStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsStatusARM(generators)
	storageAccountMicrosoftEndpointsStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountMicrosoftEndpoints_StatusARM{}), generators)

	return storageAccountMicrosoftEndpointsStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsStatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatusARM, VirtualNetworkRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatusARM runs a test to see if a specific instance of VirtualNetworkRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatusARM(subject VirtualNetworkRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_StatusARM instances for property testing - lazily instantiated by
//VirtualNetworkRuleStatusARMGenerator()
var virtualNetworkRuleStatusARMGenerator gopter.Gen

// VirtualNetworkRuleStatusARMGenerator returns a generator of VirtualNetworkRule_StatusARM instances for property testing.
func VirtualNetworkRuleStatusARMGenerator() gopter.Gen {
	if virtualNetworkRuleStatusARMGenerator != nil {
		return virtualNetworkRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(generators)
	virtualNetworkRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_StatusARM{}), generators)

	return virtualNetworkRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRuleStatusActionAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRuleStatusStateDeprovisioning,
		VirtualNetworkRuleStatusStateFailed,
		VirtualNetworkRuleStatusStateNetworkSourceDeleted,
		VirtualNetworkRuleStatusStateProvisioning,
		VirtualNetworkRuleStatusStateSucceeded))
}

func Test_BlobRestoreRange_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreRange_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreRangeStatusARM, BlobRestoreRangeStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreRangeStatusARM runs a test to see if a specific instance of BlobRestoreRange_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreRangeStatusARM(subject BlobRestoreRange_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreRange_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreRange_StatusARM instances for property testing - lazily instantiated by
//BlobRestoreRangeStatusARMGenerator()
var blobRestoreRangeStatusARMGenerator gopter.Gen

// BlobRestoreRangeStatusARMGenerator returns a generator of BlobRestoreRange_StatusARM instances for property testing.
func BlobRestoreRangeStatusARMGenerator() gopter.Gen {
	if blobRestoreRangeStatusARMGenerator != nil {
		return blobRestoreRangeStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreRangeStatusARM(generators)
	blobRestoreRangeStatusARMGenerator = gen.Struct(reflect.TypeOf(BlobRestoreRange_StatusARM{}), generators)

	return blobRestoreRangeStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreRangeStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreRangeStatusARM(gens map[string]gopter.Gen) {
	gens["EndRange"] = gen.AlphaString()
	gens["StartRange"] = gen.AlphaString()
}

func Test_EncryptionService_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceStatusARM, EncryptionServiceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceStatusARM runs a test to see if a specific instance of EncryptionService_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceStatusARM(subject EncryptionService_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_StatusARM instances for property testing - lazily instantiated by
//EncryptionServiceStatusARMGenerator()
var encryptionServiceStatusARMGenerator gopter.Gen

// EncryptionServiceStatusARMGenerator returns a generator of EncryptionService_StatusARM instances for property testing.
func EncryptionServiceStatusARMGenerator() gopter.Gen {
	if encryptionServiceStatusARMGenerator != nil {
		return encryptionServiceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM(generators)
	encryptionServiceStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_StatusARM{}), generators)

	return encryptionServiceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionServiceStatusKeyTypeAccount, EncryptionServiceStatusKeyTypeService))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
