// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount_StatusARM, StorageAccount_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount_StatusARM runs a test to see if a specific instance of StorageAccount_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount_StatusARM(subject StorageAccount_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_StatusARM instances for property testing - lazily instantiated by
//StorageAccount_StatusARMGenerator()
var storageAccount_statusARMGenerator gopter.Gen

// StorageAccount_StatusARMGenerator returns a generator of StorageAccount_StatusARM instances for property testing.
// We first initialize storageAccount_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccount_StatusARMGenerator() gopter.Gen {
	if storageAccount_statusARMGenerator != nil {
		return storageAccount_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_StatusARM(generators)
	storageAccount_statusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_StatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccount_StatusARM(generators)
	storageAccount_statusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_StatusARM{}), generators)

	return storageAccount_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccount_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccount_StatusARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccount_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount_StatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusARMGenerator())
	gens["Identity"] = gen.PtrOf(Identity_StatusARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountProperties_StatusARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_StatusARMGenerator())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_StatusARM, ExtendedLocation_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_StatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_StatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
//ExtendedLocation_StatusARMGenerator()
var extendedLocation_statusARMGenerator gopter.Gen

// ExtendedLocation_StatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocation_StatusARMGenerator() gopter.Gen {
	if extendedLocation_statusARMGenerator != nil {
		return extendedLocation_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(generators)
	extendedLocation_statusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocation_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_StatusARM, Identity_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_StatusARM runs a test to see if a specific instance of Identity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_StatusARM(subject Identity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_StatusARM instances for property testing - lazily instantiated by Identity_StatusARMGenerator()
var identity_statusARMGenerator gopter.Gen

// Identity_StatusARMGenerator returns a generator of Identity_StatusARM instances for property testing.
// We first initialize identity_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_StatusARMGenerator() gopter.Gen {
	if identity_statusARMGenerator != nil {
		return identity_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_StatusARM(generators)
	identity_statusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_StatusARM(generators)
	AddRelatedPropertyGeneratorsForIdentity_StatusARM(generators)
	identity_statusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	return identity_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForIdentity_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_StatusARMGenerator())
}

func Test_StorageAccountProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountProperties_StatusARM, StorageAccountProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountProperties_StatusARM runs a test to see if a specific instance of StorageAccountProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountProperties_StatusARM(subject StorageAccountProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_StatusARM instances for property testing - lazily instantiated by
//StorageAccountProperties_StatusARMGenerator()
var storageAccountProperties_statusARMGenerator gopter.Gen

// StorageAccountProperties_StatusARMGenerator returns a generator of StorageAccountProperties_StatusARM instances for property testing.
// We first initialize storageAccountProperties_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountProperties_StatusARMGenerator() gopter.Gen {
	if storageAccountProperties_statusARMGenerator != nil {
		return storageAccountProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_StatusARM(generators)
	storageAccountProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_StatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountProperties_StatusARM(generators)
	storageAccountProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_StatusARM{}), generators)

	return storageAccountProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.AlphaString())
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountProperties_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_StatusARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_StatusARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_StatusARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_StatusARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_StatusARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_StatusARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_StatusARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_StatusARM, AzureFilesIdentityBasedAuthentication_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_StatusARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_StatusARM(subject AzureFilesIdentityBasedAuthentication_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthentication_StatusARMGenerator()
var azureFilesIdentityBasedAuthentication_statusARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_StatusARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_StatusARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_statusARMGenerator != nil {
		return azureFilesIdentityBasedAuthentication_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM(generators)
	azureFilesIdentityBasedAuthentication_statusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM(generators)
	azureFilesIdentityBasedAuthentication_statusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	return azureFilesIdentityBasedAuthentication_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.AlphaString())
	gens["DirectoryServiceOptions"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_StatusARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_StatusARMGenerator())
}

func Test_CustomDomain_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_StatusARM, CustomDomain_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_StatusARM runs a test to see if a specific instance of CustomDomain_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_StatusARM(subject CustomDomain_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_StatusARM instances for property testing - lazily instantiated by
//CustomDomain_StatusARMGenerator()
var customDomain_statusARMGenerator gopter.Gen

// CustomDomain_StatusARMGenerator returns a generator of CustomDomain_StatusARM instances for property testing.
func CustomDomain_StatusARMGenerator() gopter.Gen {
	if customDomain_statusARMGenerator != nil {
		return customDomain_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_StatusARM(generators)
	customDomain_statusARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_StatusARM{}), generators)

	return customDomain_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_StatusARM, Encryption_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_StatusARM runs a test to see if a specific instance of Encryption_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_StatusARM(subject Encryption_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_StatusARM instances for property testing - lazily instantiated by
//Encryption_StatusARMGenerator()
var encryption_statusARMGenerator gopter.Gen

// Encryption_StatusARMGenerator returns a generator of Encryption_StatusARM instances for property testing.
// We first initialize encryption_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_StatusARMGenerator() gopter.Gen {
	if encryption_statusARMGenerator != nil {
		return encryption_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_StatusARM(generators)
	encryption_statusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_StatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryption_StatusARM(generators)
	encryption_statusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	return encryption_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_StatusARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.AlphaString()
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_StatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_StatusARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_StatusARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_StatusARMGenerator())
}

func Test_KeyPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_StatusARM, KeyPolicy_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_StatusARM runs a test to see if a specific instance of KeyPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_StatusARM(subject KeyPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_StatusARM instances for property testing - lazily instantiated by
//KeyPolicy_StatusARMGenerator()
var keyPolicy_statusARMGenerator gopter.Gen

// KeyPolicy_StatusARMGenerator returns a generator of KeyPolicy_StatusARM instances for property testing.
func KeyPolicy_StatusARMGenerator() gopter.Gen {
	if keyPolicy_statusARMGenerator != nil {
		return keyPolicy_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_StatusARM(generators)
	keyPolicy_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_StatusARM{}), generators)

	return keyPolicy_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_StatusARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_StatusARM, NetworkRuleSet_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_StatusARM runs a test to see if a specific instance of NetworkRuleSet_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_StatusARM(subject NetworkRuleSet_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_StatusARM instances for property testing - lazily instantiated by
//NetworkRuleSet_StatusARMGenerator()
var networkRuleSet_statusARMGenerator gopter.Gen

// NetworkRuleSet_StatusARMGenerator returns a generator of NetworkRuleSet_StatusARM instances for property testing.
// We first initialize networkRuleSet_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_StatusARMGenerator() gopter.Gen {
	if networkRuleSet_statusARMGenerator != nil {
		return networkRuleSet_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_StatusARM(generators)
	networkRuleSet_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_StatusARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_StatusARM(generators)
	networkRuleSet_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	return networkRuleSet_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_StatusARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_StatusARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_StatusARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_StatusARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusARMGenerator())
}

func Test_RoutingPreference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_StatusARM, RoutingPreference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_StatusARM runs a test to see if a specific instance of RoutingPreference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_StatusARM(subject RoutingPreference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_StatusARM instances for property testing - lazily instantiated by
//RoutingPreference_StatusARMGenerator()
var routingPreference_statusARMGenerator gopter.Gen

// RoutingPreference_StatusARMGenerator returns a generator of RoutingPreference_StatusARM instances for property testing.
func RoutingPreference_StatusARMGenerator() gopter.Gen {
	if routingPreference_statusARMGenerator != nil {
		return routingPreference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_StatusARM(generators)
	routingPreference_statusARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_StatusARM{}), generators)

	return routingPreference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_StatusARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.AlphaString())
}

func Test_SasPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_StatusARM, SasPolicy_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_StatusARM runs a test to see if a specific instance of SasPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_StatusARM(subject SasPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_StatusARM instances for property testing - lazily instantiated by
//SasPolicy_StatusARMGenerator()
var sasPolicy_statusARMGenerator gopter.Gen

// SasPolicy_StatusARMGenerator returns a generator of SasPolicy_StatusARM instances for property testing.
func SasPolicy_StatusARMGenerator() gopter.Gen {
	if sasPolicy_statusARMGenerator != nil {
		return sasPolicy_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_StatusARM(generators)
	sasPolicy_statusARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_StatusARM{}), generators)

	return sasPolicy_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_StatusARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.AlphaString()
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_UserAssignedIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_StatusARM, UserAssignedIdentity_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_StatusARM runs a test to see if a specific instance of UserAssignedIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_StatusARM(subject UserAssignedIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_StatusARM instances for property testing - lazily instantiated by
//UserAssignedIdentity_StatusARMGenerator()
var userAssignedIdentity_statusARMGenerator gopter.Gen

// UserAssignedIdentity_StatusARMGenerator returns a generator of UserAssignedIdentity_StatusARM instances for property testing.
func UserAssignedIdentity_StatusARMGenerator() gopter.Gen {
	if userAssignedIdentity_statusARMGenerator != nil {
		return userAssignedIdentity_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_StatusARM(generators)
	userAssignedIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_StatusARM{}), generators)

	return userAssignedIdentity_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_StatusARM, ActiveDirectoryProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_StatusARM runs a test to see if a specific instance of ActiveDirectoryProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_StatusARM(subject ActiveDirectoryProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_StatusARM instances for property testing - lazily instantiated by
//ActiveDirectoryProperties_StatusARMGenerator()
var activeDirectoryProperties_statusARMGenerator gopter.Gen

// ActiveDirectoryProperties_StatusARMGenerator returns a generator of ActiveDirectoryProperties_StatusARM instances for property testing.
func ActiveDirectoryProperties_StatusARMGenerator() gopter.Gen {
	if activeDirectoryProperties_statusARMGenerator != nil {
		return activeDirectoryProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_StatusARM(generators)
	activeDirectoryProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_StatusARM{}), generators)

	return activeDirectoryProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_StatusARM, EncryptionIdentity_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_StatusARM runs a test to see if a specific instance of EncryptionIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_StatusARM(subject EncryptionIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_StatusARM instances for property testing - lazily instantiated by
//EncryptionIdentity_StatusARMGenerator()
var encryptionIdentity_statusARMGenerator gopter.Gen

// EncryptionIdentity_StatusARMGenerator returns a generator of EncryptionIdentity_StatusARM instances for property testing.
func EncryptionIdentity_StatusARMGenerator() gopter.Gen {
	if encryptionIdentity_statusARMGenerator != nil {
		return encryptionIdentity_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentity_StatusARM(generators)
	encryptionIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_StatusARM{}), generators)

	return encryptionIdentity_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentity_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_StatusARM, EncryptionServices_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_StatusARM runs a test to see if a specific instance of EncryptionServices_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_StatusARM(subject EncryptionServices_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_StatusARM instances for property testing - lazily instantiated by
//EncryptionServices_StatusARMGenerator()
var encryptionServices_statusARMGenerator gopter.Gen

// EncryptionServices_StatusARMGenerator returns a generator of EncryptionServices_StatusARM instances for property testing.
func EncryptionServices_StatusARMGenerator() gopter.Gen {
	if encryptionServices_statusARMGenerator != nil {
		return encryptionServices_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_StatusARM(generators)
	encryptionServices_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_StatusARM{}), generators)

	return encryptionServices_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_StatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_StatusARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_StatusARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_StatusARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_StatusARMGenerator())
}

func Test_IPRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_StatusARM, IPRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_StatusARM runs a test to see if a specific instance of IPRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_StatusARM(subject IPRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_StatusARM instances for property testing - lazily instantiated by IPRule_StatusARMGenerator()
var ipRule_statusARMGenerator gopter.Gen

// IPRule_StatusARMGenerator returns a generator of IPRule_StatusARM instances for property testing.
func IPRule_StatusARMGenerator() gopter.Gen {
	if ipRule_statusARMGenerator != nil {
		return ipRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_StatusARM(generators)
	ipRule_statusARMGenerator = gen.Struct(reflect.TypeOf(IPRule_StatusARM{}), generators)

	return ipRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_StatusARM, KeyVaultProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_StatusARM runs a test to see if a specific instance of KeyVaultProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_StatusARM(subject KeyVaultProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_StatusARM instances for property testing - lazily instantiated by
//KeyVaultProperties_StatusARMGenerator()
var keyVaultProperties_statusARMGenerator gopter.Gen

// KeyVaultProperties_StatusARMGenerator returns a generator of KeyVaultProperties_StatusARM instances for property testing.
func KeyVaultProperties_StatusARMGenerator() gopter.Gen {
	if keyVaultProperties_statusARMGenerator != nil {
		return keyVaultProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_StatusARM(generators)
	keyVaultProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_StatusARM{}), generators)

	return keyVaultProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_StatusARM, ResourceAccessRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_StatusARM runs a test to see if a specific instance of ResourceAccessRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_StatusARM(subject ResourceAccessRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_StatusARM instances for property testing - lazily instantiated by
//ResourceAccessRule_StatusARMGenerator()
var resourceAccessRule_statusARMGenerator gopter.Gen

// ResourceAccessRule_StatusARMGenerator returns a generator of ResourceAccessRule_StatusARM instances for property testing.
func ResourceAccessRule_StatusARMGenerator() gopter.Gen {
	if resourceAccessRule_statusARMGenerator != nil {
		return resourceAccessRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_StatusARM(generators)
	resourceAccessRule_statusARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_StatusARM{}), generators)

	return resourceAccessRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_StatusARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_StatusARM, VirtualNetworkRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_StatusARM runs a test to see if a specific instance of VirtualNetworkRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_StatusARM(subject VirtualNetworkRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_StatusARM instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusARMGenerator()
var virtualNetworkRule_statusARMGenerator gopter.Gen

// VirtualNetworkRule_StatusARMGenerator returns a generator of VirtualNetworkRule_StatusARM instances for property testing.
func VirtualNetworkRule_StatusARMGenerator() gopter.Gen {
	if virtualNetworkRule_statusARMGenerator != nil {
		return virtualNetworkRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM(generators)
	virtualNetworkRule_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_StatusARM{}), generators)

	return virtualNetworkRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_StatusARM, EncryptionService_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_StatusARM runs a test to see if a specific instance of EncryptionService_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_StatusARM(subject EncryptionService_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_StatusARM instances for property testing - lazily instantiated by
//EncryptionService_StatusARMGenerator()
var encryptionService_statusARMGenerator gopter.Gen

// EncryptionService_StatusARMGenerator returns a generator of EncryptionService_StatusARM instances for property testing.
func EncryptionService_StatusARMGenerator() gopter.Gen {
	if encryptionService_statusARMGenerator != nil {
		return encryptionService_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_StatusARM(generators)
	encryptionService_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_StatusARM{}), generators)

	return encryptionService_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_StatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.AlphaString())
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
