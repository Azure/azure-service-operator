// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsSPECARM, StorageAccountsSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsSPECARM runs a test to see if a specific instance of StorageAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsSPECARM(subject StorageAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_SPECARM instances for property testing - lazily instantiated by
//StorageAccountsSPECARMGenerator()
var storageAccountsSPECARMGenerator gopter.Gen

// StorageAccountsSPECARMGenerator returns a generator of StorageAccounts_SPECARM instances for property testing.
// We first initialize storageAccountsSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsSPECARMGenerator() gopter.Gen {
	if storageAccountsSPECARMGenerator != nil {
		return storageAccountsSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSPECARM(generators)
	storageAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSPECARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsSPECARM(generators)
	storageAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPECARM{}), generators)

	return storageAccountsSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.OneConstOf(
		StorageAccountsSPECKindBlobStorage,
		StorageAccountsSPECKindBlockBlobStorage,
		StorageAccountsSPECKindFileStorage,
		StorageAccountsSPECKindStorage,
		StorageAccountsSPECKindStorageV2)
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountsSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentitySpecARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesSpecARMGenerator())
	gens["Sku"] = SkuSpecARMGenerator()
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpecARM, ExtendedLocationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocationSpecARMGenerator()
var extendedLocationSpecARMGenerator gopter.Gen

// ExtendedLocationSpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocationSpecARMGenerator() gopter.Gen {
	if extendedLocationSpecARMGenerator != nil {
		return extendedLocationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(generators)
	extendedLocationSpecARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_Identity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentitySpecARM, IdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentitySpecARM runs a test to see if a specific instance of Identity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentitySpecARM(subject Identity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_SpecARM instances for property testing - lazily instantiated by IdentitySpecARMGenerator()
var identitySpecARMGenerator gopter.Gen

// IdentitySpecARMGenerator returns a generator of Identity_SpecARM instances for property testing.
func IdentitySpecARMGenerator() gopter.Gen {
	if identitySpecARMGenerator != nil {
		return identitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySpecARM(generators)
	identitySpecARMGenerator = gen.Struct(reflect.TypeOf(Identity_SpecARM{}), generators)

	return identitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(
		IdentitySpecTypeNone,
		IdentitySpecTypeSystemAssigned,
		IdentitySpecTypeSystemAssignedUserAssigned,
		IdentitySpecTypeUserAssigned)
}

func Test_Sku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSpecARM, SkuSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSpecARM runs a test to see if a specific instance of Sku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSpecARM(subject Sku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_SpecARM instances for property testing - lazily instantiated by SkuSpecARMGenerator()
var skuSpecARMGenerator gopter.Gen

// SkuSpecARMGenerator returns a generator of Sku_SpecARM instances for property testing.
func SkuSpecARMGenerator() gopter.Gen {
	if skuSpecARMGenerator != nil {
		return skuSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSpecARM(generators)
	skuSpecARMGenerator = gen.Struct(reflect.TypeOf(Sku_SpecARM{}), generators)

	return skuSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(
		SkuName_SpecPremiumLRS,
		SkuName_SpecPremiumZRS,
		SkuName_SpecStandardGRS,
		SkuName_SpecStandardGZRS,
		SkuName_SpecStandardLRS,
		SkuName_SpecStandardRAGRS,
		SkuName_SpecStandardRAGZRS,
		SkuName_SpecStandardZRS)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Tier_SpecPremium, Tier_SpecStandard))
}

func Test_StorageAccountProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesSpecARM, StorageAccountPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesSpecARM runs a test to see if a specific instance of StorageAccountProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesSpecARM(subject StorageAccountProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_SpecARM instances for property testing - lazily instantiated by
//StorageAccountPropertiesSpecARMGenerator()
var storageAccountPropertiesSpecARMGenerator gopter.Gen

// StorageAccountPropertiesSpecARMGenerator returns a generator of StorageAccountProperties_SpecARM instances for property testing.
// We first initialize storageAccountPropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesSpecARMGenerator() gopter.Gen {
	if storageAccountPropertiesSpecARMGenerator != nil {
		return storageAccountPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesSpecARM(generators)
	storageAccountPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesSpecARM(generators)
	storageAccountPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_SpecARM{}), generators)

	return storageAccountPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSpecAccessTierCool, StorageAccountPropertiesSpecAccessTierHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSpecLargeFileSharesStateDisabled, StorageAccountPropertiesSpecLargeFileSharesStateEnabled))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesSpecMinimumTlsVersionTLS10, StorageAccountPropertiesSpecMinimumTlsVersionTLS11, StorageAccountPropertiesSpecMinimumTlsVersionTLS12))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationSpecARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainSpecARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionSpecARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicySpecARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetSpecARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceSpecARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicySpecARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpecARM, AzureFilesIdentityBasedAuthenticationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpecARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpecARM(subject AzureFilesIdentityBasedAuthentication_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_SpecARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationSpecARMGenerator()
var azureFilesIdentityBasedAuthenticationSpecARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationSpecARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_SpecARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationSpecARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationSpecARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM(generators)
	azureFilesIdentityBasedAuthenticationSpecARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM(generators)
	azureFilesIdentityBasedAuthenticationSpecARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_SpecARM{}), generators)

	return azureFilesIdentityBasedAuthenticationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthenticationSpecDefaultSharePermissionNone,
		AzureFilesIdentityBasedAuthenticationSpecDefaultSharePermissionStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthenticationSpecDefaultSharePermissionStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthenticationSpecDefaultSharePermissionStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthenticationSpecDefaultSharePermissionStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthenticationSpecDirectoryServiceOptionsAADDS, AzureFilesIdentityBasedAuthenticationSpecDirectoryServiceOptionsAD, AzureFilesIdentityBasedAuthenticationSpecDirectoryServiceOptionsNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpecARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesSpecARMGenerator())
}

func Test_CustomDomain_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainSpecARM, CustomDomainSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainSpecARM runs a test to see if a specific instance of CustomDomain_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainSpecARM(subject CustomDomain_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_SpecARM instances for property testing - lazily instantiated by
//CustomDomainSpecARMGenerator()
var customDomainSpecARMGenerator gopter.Gen

// CustomDomainSpecARMGenerator returns a generator of CustomDomain_SpecARM instances for property testing.
func CustomDomainSpecARMGenerator() gopter.Gen {
	if customDomainSpecARMGenerator != nil {
		return customDomainSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSpecARM(generators)
	customDomainSpecARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_SpecARM{}), generators)

	return customDomainSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSpecARM, EncryptionSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSpecARM runs a test to see if a specific instance of Encryption_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSpecARM(subject Encryption_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_SpecARM instances for property testing - lazily instantiated by EncryptionSpecARMGenerator()
var encryptionSpecARMGenerator gopter.Gen

// EncryptionSpecARMGenerator returns a generator of Encryption_SpecARM instances for property testing.
// We first initialize encryptionSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSpecARMGenerator() gopter.Gen {
	if encryptionSpecARMGenerator != nil {
		return encryptionSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSpecARM(generators)
	encryptionSpecARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSpecARM(generators)
	encryptionSpecARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	return encryptionSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSpecARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(EncryptionSpecKeySourceMicrosoftKeyvault, EncryptionSpecKeySourceMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentitySpecARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesSpecARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesSpecARMGenerator())
}

func Test_KeyPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicySpecARM, KeyPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicySpecARM runs a test to see if a specific instance of KeyPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicySpecARM(subject KeyPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_SpecARM instances for property testing - lazily instantiated by KeyPolicySpecARMGenerator()
var keyPolicySpecARMGenerator gopter.Gen

// KeyPolicySpecARMGenerator returns a generator of KeyPolicy_SpecARM instances for property testing.
func KeyPolicySpecARMGenerator() gopter.Gen {
	if keyPolicySpecARMGenerator != nil {
		return keyPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicySpecARM(generators)
	keyPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_SpecARM{}), generators)

	return keyPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicySpecARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSpecARM, NetworkRuleSetSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSpecARM runs a test to see if a specific instance of NetworkRuleSet_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSpecARM(subject NetworkRuleSet_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_SpecARM instances for property testing - lazily instantiated by
//NetworkRuleSetSpecARMGenerator()
var networkRuleSetSpecARMGenerator gopter.Gen

// NetworkRuleSetSpecARMGenerator returns a generator of NetworkRuleSet_SpecARM instances for property testing.
// We first initialize networkRuleSetSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSpecARMGenerator() gopter.Gen {
	if networkRuleSetSpecARMGenerator != nil {
		return networkRuleSetSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSpecARM(generators)
	networkRuleSetSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSpecARM(generators)
	networkRuleSetSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_SpecARM{}), generators)

	return networkRuleSetSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSpecARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSetSpecBypassAzureServices,
		NetworkRuleSetSpecBypassLogging,
		NetworkRuleSetSpecBypassMetrics,
		NetworkRuleSetSpecBypassNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSetSpecDefaultActionAllow, NetworkRuleSetSpecDefaultActionDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSpecARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSpecARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleSpecARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSpecARMGenerator())
}

func Test_RoutingPreference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceSpecARM, RoutingPreferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceSpecARM runs a test to see if a specific instance of RoutingPreference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceSpecARM(subject RoutingPreference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_SpecARM instances for property testing - lazily instantiated by
//RoutingPreferenceSpecARMGenerator()
var routingPreferenceSpecARMGenerator gopter.Gen

// RoutingPreferenceSpecARMGenerator returns a generator of RoutingPreference_SpecARM instances for property testing.
func RoutingPreferenceSpecARMGenerator() gopter.Gen {
	if routingPreferenceSpecARMGenerator != nil {
		return routingPreferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceSpecARM(generators)
	routingPreferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_SpecARM{}), generators)

	return routingPreferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceSpecARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreferenceSpecRoutingChoiceInternetRouting, RoutingPreferenceSpecRoutingChoiceMicrosoftRouting))
}

func Test_SasPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicySpecARM, SasPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicySpecARM runs a test to see if a specific instance of SasPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicySpecARM(subject SasPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_SpecARM instances for property testing - lazily instantiated by SasPolicySpecARMGenerator()
var sasPolicySpecARMGenerator gopter.Gen

// SasPolicySpecARMGenerator returns a generator of SasPolicy_SpecARM instances for property testing.
func SasPolicySpecARMGenerator() gopter.Gen {
	if sasPolicySpecARMGenerator != nil {
		return sasPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicySpecARM(generators)
	sasPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_SpecARM{}), generators)

	return sasPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicySpecARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicySpecExpirationActionLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_ActiveDirectoryProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesSpecARM, ActiveDirectoryPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesSpecARM runs a test to see if a specific instance of ActiveDirectoryProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesSpecARM(subject ActiveDirectoryProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_SpecARM instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesSpecARMGenerator()
var activeDirectoryPropertiesSpecARMGenerator gopter.Gen

// ActiveDirectoryPropertiesSpecARMGenerator returns a generator of ActiveDirectoryProperties_SpecARM instances for property testing.
func ActiveDirectoryPropertiesSpecARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesSpecARMGenerator != nil {
		return activeDirectoryPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpecARM(generators)
	activeDirectoryPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_SpecARM{}), generators)

	return activeDirectoryPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentitySpecARM, EncryptionIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentitySpecARM runs a test to see if a specific instance of EncryptionIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentitySpecARM(subject EncryptionIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_SpecARM instances for property testing - lazily instantiated by
//EncryptionIdentitySpecARMGenerator()
var encryptionIdentitySpecARMGenerator gopter.Gen

// EncryptionIdentitySpecARMGenerator returns a generator of EncryptionIdentity_SpecARM instances for property testing.
func EncryptionIdentitySpecARMGenerator() gopter.Gen {
	if encryptionIdentitySpecARMGenerator != nil {
		return encryptionIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentitySpecARM(generators)
	encryptionIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_SpecARM{}), generators)

	return encryptionIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesSpecARM, EncryptionServicesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesSpecARM runs a test to see if a specific instance of EncryptionServices_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesSpecARM(subject EncryptionServices_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_SpecARM instances for property testing - lazily instantiated by
//EncryptionServicesSpecARMGenerator()
var encryptionServicesSpecARMGenerator gopter.Gen

// EncryptionServicesSpecARMGenerator returns a generator of EncryptionServices_SpecARM instances for property testing.
func EncryptionServicesSpecARMGenerator() gopter.Gen {
	if encryptionServicesSpecARMGenerator != nil {
		return encryptionServicesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesSpecARM(generators)
	encryptionServicesSpecARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_SpecARM{}), generators)

	return encryptionServicesSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesSpecARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceSpecARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceSpecARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceSpecARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceSpecARMGenerator())
}

func Test_IPRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSpecARM, IPRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSpecARM runs a test to see if a specific instance of IPRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSpecARM(subject IPRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_SpecARM instances for property testing - lazily instantiated by IPRuleSpecARMGenerator()
var ipRuleSpecARMGenerator gopter.Gen

// IPRuleSpecARMGenerator returns a generator of IPRule_SpecARM instances for property testing.
func IPRuleSpecARMGenerator() gopter.Gen {
	if ipRuleSpecARMGenerator != nil {
		return ipRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSpecARM(generators)
	ipRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(IPRule_SpecARM{}), generators)

	return ipRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleSpecActionAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSpecARM, KeyVaultPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSpecARM runs a test to see if a specific instance of KeyVaultProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSpecARM(subject KeyVaultProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_SpecARM instances for property testing - lazily instantiated by
//KeyVaultPropertiesSpecARMGenerator()
var keyVaultPropertiesSpecARMGenerator gopter.Gen

// KeyVaultPropertiesSpecARMGenerator returns a generator of KeyVaultProperties_SpecARM instances for property testing.
func KeyVaultPropertiesSpecARMGenerator() gopter.Gen {
	if keyVaultPropertiesSpecARMGenerator != nil {
		return keyVaultPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM(generators)
	keyVaultPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	return keyVaultPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleSpecARM, ResourceAccessRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleSpecARM runs a test to see if a specific instance of ResourceAccessRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleSpecARM(subject ResourceAccessRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_SpecARM instances for property testing - lazily instantiated by
//ResourceAccessRuleSpecARMGenerator()
var resourceAccessRuleSpecARMGenerator gopter.Gen

// ResourceAccessRuleSpecARMGenerator returns a generator of ResourceAccessRule_SpecARM instances for property testing.
func ResourceAccessRuleSpecARMGenerator() gopter.Gen {
	if resourceAccessRuleSpecARMGenerator != nil {
		return resourceAccessRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleSpecARM(generators)
	resourceAccessRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_SpecARM{}), generators)

	return resourceAccessRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleSpecARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSpecARM, VirtualNetworkRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSpecARM runs a test to see if a specific instance of VirtualNetworkRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSpecARM(subject VirtualNetworkRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_SpecARM instances for property testing - lazily instantiated by
//VirtualNetworkRuleSpecARMGenerator()
var virtualNetworkRuleSpecARMGenerator gopter.Gen

// VirtualNetworkRuleSpecARMGenerator returns a generator of VirtualNetworkRule_SpecARM instances for property testing.
func VirtualNetworkRuleSpecARMGenerator() gopter.Gen {
	if virtualNetworkRuleSpecARMGenerator != nil {
		return virtualNetworkRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM(generators)
	virtualNetworkRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_SpecARM{}), generators)

	return virtualNetworkRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRuleSpecActionAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRuleSpecStateDeprovisioning,
		VirtualNetworkRuleSpecStateFailed,
		VirtualNetworkRuleSpecStateNetworkSourceDeleted,
		VirtualNetworkRuleSpecStateProvisioning,
		VirtualNetworkRuleSpecStateSucceeded))
}

func Test_EncryptionService_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceSpecARM, EncryptionServiceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceSpecARM runs a test to see if a specific instance of EncryptionService_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceSpecARM(subject EncryptionService_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_SpecARM instances for property testing - lazily instantiated by
//EncryptionServiceSpecARMGenerator()
var encryptionServiceSpecARMGenerator gopter.Gen

// EncryptionServiceSpecARMGenerator returns a generator of EncryptionService_SpecARM instances for property testing.
func EncryptionServiceSpecARMGenerator() gopter.Gen {
	if encryptionServiceSpecARMGenerator != nil {
		return encryptionServiceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceSpecARM(generators)
	encryptionServiceSpecARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_SpecARM{}), generators)

	return encryptionServiceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceSpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionServiceSpecKeyTypeAccount, EncryptionServiceSpecKeyTypeService))
}
