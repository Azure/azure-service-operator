// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccounts_SPECARM, StorageAccounts_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccounts_SPECARM runs a test to see if a specific instance of StorageAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccounts_SPECARM(subject StorageAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_SPECARM instances for property testing - lazily instantiated by
//StorageAccounts_SPECARMGenerator()
var storageAccounts_specarmGenerator gopter.Gen

// StorageAccounts_SPECARMGenerator returns a generator of StorageAccounts_SPECARM instances for property testing.
// We first initialize storageAccounts_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccounts_SPECARMGenerator() gopter.Gen {
	if storageAccounts_specarmGenerator != nil {
		return storageAccounts_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SPECARM(generators)
	storageAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SPECARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccounts_SPECARM(generators)
	storageAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPECARM{}), generators)

	return storageAccounts_specarmGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccounts_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.OneConstOf(
		StorageAccounts_Kind_SPECBlobStorage,
		StorageAccounts_Kind_SPECBlockBlobStorage,
		StorageAccounts_Kind_SPECFileStorage,
		StorageAccounts_Kind_SPECStorage,
		StorageAccounts_Kind_SPECStorageV2)
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccounts_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Identity"] = gen.PtrOf(Identity_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountProperties_SpecARMGenerator())
	gens["Sku"] = Sku_SpecARMGenerator()
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_SpecARM, ExtendedLocation_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_SpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_SpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocation_SpecARMGenerator()
var extendedLocation_specARMGenerator gopter.Gen

// ExtendedLocation_SpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocation_SpecARMGenerator() gopter.Gen {
	if extendedLocation_specARMGenerator != nil {
		return extendedLocation_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(generators)
	extendedLocation_specARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocation_specARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_Identity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_SpecARM, Identity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_SpecARM runs a test to see if a specific instance of Identity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_SpecARM(subject Identity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_SpecARM instances for property testing - lazily instantiated by Identity_SpecARMGenerator()
var identity_specARMGenerator gopter.Gen

// Identity_SpecARMGenerator returns a generator of Identity_SpecARM instances for property testing.
func Identity_SpecARMGenerator() gopter.Gen {
	if identity_specARMGenerator != nil {
		return identity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_SpecARM(generators)
	identity_specARMGenerator = gen.Struct(reflect.TypeOf(Identity_SpecARM{}), generators)

	return identity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(
		Identity_Type_SpecNone,
		Identity_Type_SpecSystemAssigned,
		Identity_Type_SpecSystemAssignedUserAssigned,
		Identity_Type_SpecUserAssigned)
}

func Test_Sku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_SpecARM, Sku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_SpecARM runs a test to see if a specific instance of Sku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_SpecARM(subject Sku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_SpecARM instances for property testing - lazily instantiated by Sku_SpecARMGenerator()
var sku_specARMGenerator gopter.Gen

// Sku_SpecARMGenerator returns a generator of Sku_SpecARM instances for property testing.
func Sku_SpecARMGenerator() gopter.Gen {
	if sku_specARMGenerator != nil {
		return sku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_SpecARM(generators)
	sku_specARMGenerator = gen.Struct(reflect.TypeOf(Sku_SpecARM{}), generators)

	return sku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(
		SkuName_SpecPremium_LRS,
		SkuName_SpecPremium_ZRS,
		SkuName_SpecStandard_GRS,
		SkuName_SpecStandard_GZRS,
		SkuName_SpecStandard_LRS,
		SkuName_SpecStandard_RAGRS,
		SkuName_SpecStandard_RAGZRS,
		SkuName_SpecStandard_ZRS)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Tier_SpecPremium, Tier_SpecStandard))
}

func Test_StorageAccountProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountProperties_SpecARM, StorageAccountProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountProperties_SpecARM runs a test to see if a specific instance of StorageAccountProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountProperties_SpecARM(subject StorageAccountProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountProperties_SpecARM instances for property testing - lazily instantiated by
//StorageAccountProperties_SpecARMGenerator()
var storageAccountProperties_specARMGenerator gopter.Gen

// StorageAccountProperties_SpecARMGenerator returns a generator of StorageAccountProperties_SpecARM instances for property testing.
// We first initialize storageAccountProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountProperties_SpecARMGenerator() gopter.Gen {
	if storageAccountProperties_specARMGenerator != nil {
		return storageAccountProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_SpecARM(generators)
	storageAccountProperties_specARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountProperties_SpecARM(generators)
	storageAccountProperties_specARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountProperties_SpecARM{}), generators)

	return storageAccountProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_AccessTier_SpecCool, StorageAccountProperties_AccessTier_SpecHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_LargeFileSharesState_SpecDisabled, StorageAccountProperties_LargeFileSharesState_SpecEnabled))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_MinimumTlsVersion_SpecTLS1_0, StorageAccountProperties_MinimumTlsVersion_SpecTLS1_1, StorageAccountProperties_MinimumTlsVersion_SpecTLS1_2))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_SpecARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_SpecARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_SpecARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_SpecARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_SpecARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_SpecARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_SpecARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_SpecARM, AzureFilesIdentityBasedAuthentication_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_SpecARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_SpecARM(subject AzureFilesIdentityBasedAuthentication_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_SpecARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthentication_SpecARMGenerator()
var azureFilesIdentityBasedAuthentication_specARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_SpecARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_SpecARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_SpecARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_specARMGenerator != nil {
		return azureFilesIdentityBasedAuthentication_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM(generators)
	azureFilesIdentityBasedAuthentication_specARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM(generators)
	azureFilesIdentityBasedAuthentication_specARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_SpecARM{}), generators)

	return azureFilesIdentityBasedAuthentication_specARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecNone,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecAADDS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecAD, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_SpecARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_SpecARMGenerator())
}

func Test_CustomDomain_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_SpecARM, CustomDomain_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_SpecARM runs a test to see if a specific instance of CustomDomain_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_SpecARM(subject CustomDomain_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_SpecARM instances for property testing - lazily instantiated by
//CustomDomain_SpecARMGenerator()
var customDomain_specARMGenerator gopter.Gen

// CustomDomain_SpecARMGenerator returns a generator of CustomDomain_SpecARM instances for property testing.
func CustomDomain_SpecARMGenerator() gopter.Gen {
	if customDomain_specARMGenerator != nil {
		return customDomain_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_SpecARM(generators)
	customDomain_specARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_SpecARM{}), generators)

	return customDomain_specARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_SpecARM, Encryption_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_SpecARM runs a test to see if a specific instance of Encryption_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_SpecARM(subject Encryption_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_SpecARM instances for property testing - lazily instantiated by Encryption_SpecARMGenerator()
var encryption_specARMGenerator gopter.Gen

// Encryption_SpecARMGenerator returns a generator of Encryption_SpecARM instances for property testing.
// We first initialize encryption_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_SpecARMGenerator() gopter.Gen {
	if encryption_specARMGenerator != nil {
		return encryption_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_SpecARM(generators)
	encryption_specARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryption_SpecARM(generators)
	encryption_specARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	return encryption_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_SpecARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(Encryption_KeySource_SpecMicrosoftKeyvault, Encryption_KeySource_SpecMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_SpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_SpecARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_SpecARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_SpecARMGenerator())
}

func Test_KeyPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_SpecARM, KeyPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_SpecARM runs a test to see if a specific instance of KeyPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_SpecARM(subject KeyPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_SpecARM instances for property testing - lazily instantiated by KeyPolicy_SpecARMGenerator()
var keyPolicy_specARMGenerator gopter.Gen

// KeyPolicy_SpecARMGenerator returns a generator of KeyPolicy_SpecARM instances for property testing.
func KeyPolicy_SpecARMGenerator() gopter.Gen {
	if keyPolicy_specARMGenerator != nil {
		return keyPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_SpecARM(generators)
	keyPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_SpecARM{}), generators)

	return keyPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_SpecARM, NetworkRuleSet_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_SpecARM runs a test to see if a specific instance of NetworkRuleSet_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_SpecARM(subject NetworkRuleSet_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_SpecARM instances for property testing - lazily instantiated by
//NetworkRuleSet_SpecARMGenerator()
var networkRuleSet_specARMGenerator gopter.Gen

// NetworkRuleSet_SpecARMGenerator returns a generator of NetworkRuleSet_SpecARM instances for property testing.
// We first initialize networkRuleSet_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_SpecARMGenerator() gopter.Gen {
	if networkRuleSet_specARMGenerator != nil {
		return networkRuleSet_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_SpecARM(generators)
	networkRuleSet_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_SpecARM(generators)
	networkRuleSet_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_SpecARM{}), generators)

	return networkRuleSet_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_SpecARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_Bypass_SpecAzureServices,
		NetworkRuleSet_Bypass_SpecLogging,
		NetworkRuleSet_Bypass_SpecMetrics,
		NetworkRuleSet_Bypass_SpecNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSet_DefaultAction_SpecAllow, NetworkRuleSet_DefaultAction_SpecDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_SpecARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_SpecARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_SpecARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_SpecARMGenerator())
}

func Test_RoutingPreference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_SpecARM, RoutingPreference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_SpecARM runs a test to see if a specific instance of RoutingPreference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_SpecARM(subject RoutingPreference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_SpecARM instances for property testing - lazily instantiated by
//RoutingPreference_SpecARMGenerator()
var routingPreference_specARMGenerator gopter.Gen

// RoutingPreference_SpecARMGenerator returns a generator of RoutingPreference_SpecARM instances for property testing.
func RoutingPreference_SpecARMGenerator() gopter.Gen {
	if routingPreference_specARMGenerator != nil {
		return routingPreference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_SpecARM(generators)
	routingPreference_specARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_SpecARM{}), generators)

	return routingPreference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_SpecARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_RoutingChoice_SpecInternetRouting, RoutingPreference_RoutingChoice_SpecMicrosoftRouting))
}

func Test_SasPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_SpecARM, SasPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_SpecARM runs a test to see if a specific instance of SasPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_SpecARM(subject SasPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_SpecARM instances for property testing - lazily instantiated by SasPolicy_SpecARMGenerator()
var sasPolicy_specARMGenerator gopter.Gen

// SasPolicy_SpecARMGenerator returns a generator of SasPolicy_SpecARM instances for property testing.
func SasPolicy_SpecARMGenerator() gopter.Gen {
	if sasPolicy_specARMGenerator != nil {
		return sasPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_SpecARM(generators)
	sasPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_SpecARM{}), generators)

	return sasPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicy_ExpirationAction_SpecLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_ActiveDirectoryProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_SpecARM, ActiveDirectoryProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_SpecARM runs a test to see if a specific instance of ActiveDirectoryProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_SpecARM(subject ActiveDirectoryProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_SpecARM instances for property testing - lazily instantiated by
//ActiveDirectoryProperties_SpecARMGenerator()
var activeDirectoryProperties_specARMGenerator gopter.Gen

// ActiveDirectoryProperties_SpecARMGenerator returns a generator of ActiveDirectoryProperties_SpecARM instances for property testing.
func ActiveDirectoryProperties_SpecARMGenerator() gopter.Gen {
	if activeDirectoryProperties_specARMGenerator != nil {
		return activeDirectoryProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_SpecARM(generators)
	activeDirectoryProperties_specARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_SpecARM{}), generators)

	return activeDirectoryProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_SpecARM, EncryptionIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_SpecARM runs a test to see if a specific instance of EncryptionIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_SpecARM(subject EncryptionIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_SpecARM instances for property testing - lazily instantiated by
//EncryptionIdentity_SpecARMGenerator()
var encryptionIdentity_specARMGenerator gopter.Gen

// EncryptionIdentity_SpecARMGenerator returns a generator of EncryptionIdentity_SpecARM instances for property testing.
func EncryptionIdentity_SpecARMGenerator() gopter.Gen {
	if encryptionIdentity_specARMGenerator != nil {
		return encryptionIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentity_SpecARM(generators)
	encryptionIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_SpecARM{}), generators)

	return encryptionIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_SpecARM, EncryptionServices_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_SpecARM runs a test to see if a specific instance of EncryptionServices_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_SpecARM(subject EncryptionServices_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_SpecARM instances for property testing - lazily instantiated by
//EncryptionServices_SpecARMGenerator()
var encryptionServices_specARMGenerator gopter.Gen

// EncryptionServices_SpecARMGenerator returns a generator of EncryptionServices_SpecARM instances for property testing.
func EncryptionServices_SpecARMGenerator() gopter.Gen {
	if encryptionServices_specARMGenerator != nil {
		return encryptionServices_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_SpecARM(generators)
	encryptionServices_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_SpecARM{}), generators)

	return encryptionServices_specARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_SpecARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_SpecARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_SpecARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_SpecARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_SpecARMGenerator())
}

func Test_IPRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_SpecARM, IPRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_SpecARM runs a test to see if a specific instance of IPRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_SpecARM(subject IPRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_SpecARM instances for property testing - lazily instantiated by IPRule_SpecARMGenerator()
var ipRule_specARMGenerator gopter.Gen

// IPRule_SpecARMGenerator returns a generator of IPRule_SpecARM instances for property testing.
func IPRule_SpecARMGenerator() gopter.Gen {
	if ipRule_specARMGenerator != nil {
		return ipRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_SpecARM(generators)
	ipRule_specARMGenerator = gen.Struct(reflect.TypeOf(IPRule_SpecARM{}), generators)

	return ipRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_SpecAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_SpecARM, KeyVaultProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_SpecARM runs a test to see if a specific instance of KeyVaultProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_SpecARM(subject KeyVaultProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_SpecARM instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecARMGenerator()
var keyVaultProperties_specARMGenerator gopter.Gen

// KeyVaultProperties_SpecARMGenerator returns a generator of KeyVaultProperties_SpecARM instances for property testing.
func KeyVaultProperties_SpecARMGenerator() gopter.Gen {
	if keyVaultProperties_specARMGenerator != nil {
		return keyVaultProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(generators)
	keyVaultProperties_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	return keyVaultProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_SpecARM, ResourceAccessRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_SpecARM runs a test to see if a specific instance of ResourceAccessRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_SpecARM(subject ResourceAccessRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_SpecARM instances for property testing - lazily instantiated by
//ResourceAccessRule_SpecARMGenerator()
var resourceAccessRule_specARMGenerator gopter.Gen

// ResourceAccessRule_SpecARMGenerator returns a generator of ResourceAccessRule_SpecARM instances for property testing.
func ResourceAccessRule_SpecARMGenerator() gopter.Gen {
	if resourceAccessRule_specARMGenerator != nil {
		return resourceAccessRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_SpecARM(generators)
	resourceAccessRule_specARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_SpecARM{}), generators)

	return resourceAccessRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_SpecARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_SpecARM, VirtualNetworkRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_SpecARM runs a test to see if a specific instance of VirtualNetworkRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_SpecARM(subject VirtualNetworkRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_SpecARM instances for property testing - lazily instantiated by
//VirtualNetworkRule_SpecARMGenerator()
var virtualNetworkRule_specARMGenerator gopter.Gen

// VirtualNetworkRule_SpecARMGenerator returns a generator of VirtualNetworkRule_SpecARM instances for property testing.
func VirtualNetworkRule_SpecARMGenerator() gopter.Gen {
	if virtualNetworkRule_specARMGenerator != nil {
		return virtualNetworkRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM(generators)
	virtualNetworkRule_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_SpecARM{}), generators)

	return virtualNetworkRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_Action_SpecAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_State_SpecDeprovisioning,
		VirtualNetworkRule_State_SpecFailed,
		VirtualNetworkRule_State_SpecNetworkSourceDeleted,
		VirtualNetworkRule_State_SpecProvisioning,
		VirtualNetworkRule_State_SpecSucceeded))
}

func Test_EncryptionService_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_SpecARM, EncryptionService_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_SpecARM runs a test to see if a specific instance of EncryptionService_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_SpecARM(subject EncryptionService_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_SpecARM instances for property testing - lazily instantiated by
//EncryptionService_SpecARMGenerator()
var encryptionService_specARMGenerator gopter.Gen

// EncryptionService_SpecARMGenerator returns a generator of EncryptionService_SpecARM instances for property testing.
func EncryptionService_SpecARMGenerator() gopter.Gen {
	if encryptionService_specARMGenerator != nil {
		return encryptionService_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_SpecARM(generators)
	encryptionService_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_SpecARM{}), generators)

	return encryptionService_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_SpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_KeyType_SpecAccount, EncryptionService_KeyType_SpecService))
}
