// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount_SpecARM, StorageAccount_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount_SpecARM runs a test to see if a specific instance of StorageAccount_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount_SpecARM(subject StorageAccount_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_SpecARM instances for property testing - lazily instantiated by
//StorageAccount_SpecARMGenerator()
var storageAccount_specARMGenerator gopter.Gen

// StorageAccount_SpecARMGenerator returns a generator of StorageAccount_SpecARM instances for property testing.
// We first initialize storageAccount_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccount_SpecARMGenerator() gopter.Gen {
	if storageAccount_specARMGenerator != nil {
		return storageAccount_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_SpecARM(generators)
	storageAccount_specARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_SpecARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccount_SpecARM(generators)
	storageAccount_specARMGenerator = gen.Struct(reflect.TypeOf(StorageAccount_SpecARM{}), generators)

	return storageAccount_specARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccount_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccount_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.OneConstOf(
		StorageAccount_SpecKindBlobStorage,
		StorageAccount_SpecKindBlockBlobStorage,
		StorageAccount_SpecKindFileStorage,
		StorageAccount_SpecKindStorage,
		StorageAccount_SpecKindStorageV2)
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccount_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesARMGenerator())
	gens["Sku"] = SkuARMGenerator()
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
//ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationTypeEdgeZone))
}

func Test_IdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityARM, IdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityARM runs a test to see if a specific instance of IdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityARM(subject IdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityARM instances for property testing - lazily instantiated by IdentityARMGenerator()
var identityARMGenerator gopter.Gen

// IdentityARMGenerator returns a generator of IdentityARM instances for property testing.
func IdentityARMGenerator() gopter.Gen {
	if identityARMGenerator != nil {
		return identityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityARM(generators)
	identityARMGenerator = gen.Struct(reflect.TypeOf(IdentityARM{}), generators)

	return identityARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(
		IdentityTypeNone,
		IdentityTypeSystemAssigned,
		IdentityTypeSystemAssignedUserAssigned,
		IdentityTypeUserAssigned)
}

func Test_SkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuARM, SkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuARM runs a test to see if a specific instance of SkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuARM(subject SkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SkuARM instances for property testing - lazily instantiated by SkuARMGenerator()
var skuARMGenerator gopter.Gen

// SkuARMGenerator returns a generator of SkuARM instances for property testing.
func SkuARMGenerator() gopter.Gen {
	if skuARMGenerator != nil {
		return skuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuARM(generators)
	skuARMGenerator = gen.Struct(reflect.TypeOf(SkuARM{}), generators)

	return skuARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(
		SkuNamePremium_LRS,
		SkuNamePremium_ZRS,
		SkuNameStandard_GRS,
		SkuNameStandard_GZRS,
		SkuNameStandard_LRS,
		SkuNameStandard_RAGRS,
		SkuNameStandard_RAGZRS,
		SkuNameStandard_ZRS)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(TierPremium, TierStandard))
}

func Test_StorageAccountPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesARM, StorageAccountPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesARM runs a test to see if a specific instance of StorageAccountPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesARM(subject StorageAccountPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountPropertiesARM instances for property testing - lazily instantiated by
//StorageAccountPropertiesARMGenerator()
var storageAccountPropertiesARMGenerator gopter.Gen

// StorageAccountPropertiesARMGenerator returns a generator of StorageAccountPropertiesARM instances for property testing.
// We first initialize storageAccountPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesARMGenerator() gopter.Gen {
	if storageAccountPropertiesARMGenerator != nil {
		return storageAccountPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesARM(generators)
	storageAccountPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesARM(generators)
	storageAccountPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesARM{}), generators)

	return storageAccountPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesAccessTierCool, StorageAccountPropertiesAccessTierHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesLargeFileSharesStateDisabled, StorageAccountPropertiesLargeFileSharesStateEnabled))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesMinimumTlsVersionTLS1_0, StorageAccountPropertiesMinimumTlsVersionTLS1_1, StorageAccountPropertiesMinimumTlsVersionTLS1_2))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthenticationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthenticationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM, AzureFilesIdentityBasedAuthenticationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthenticationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationARM(subject AzureFilesIdentityBasedAuthenticationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthenticationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthenticationARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationARMGenerator()
var azureFilesIdentityBasedAuthenticationARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationARMGenerator returns a generator of AzureFilesIdentityBasedAuthenticationARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	azureFilesIdentityBasedAuthenticationARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthenticationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(generators)
	azureFilesIdentityBasedAuthenticationARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthenticationARM{}), generators)

	return azureFilesIdentityBasedAuthenticationARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthenticationDefaultSharePermissionNone,
		AzureFilesIdentityBasedAuthenticationDefaultSharePermissionStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthenticationDefaultSharePermissionStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthenticationDefaultSharePermissionStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthenticationDefaultSharePermissionStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthenticationDirectoryServiceOptionsAADDS, AzureFilesIdentityBasedAuthenticationDirectoryServiceOptionsAD, AzureFilesIdentityBasedAuthenticationDirectoryServiceOptionsNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesARMGenerator())
}

func Test_CustomDomainARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainARM, CustomDomainARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainARM runs a test to see if a specific instance of CustomDomainARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainARM(subject CustomDomainARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainARM instances for property testing - lazily instantiated by CustomDomainARMGenerator()
var customDomainARMGenerator gopter.Gen

// CustomDomainARMGenerator returns a generator of CustomDomainARM instances for property testing.
func CustomDomainARMGenerator() gopter.Gen {
	if customDomainARMGenerator != nil {
		return customDomainARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainARM(generators)
	customDomainARMGenerator = gen.Struct(reflect.TypeOf(CustomDomainARM{}), generators)

	return customDomainARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_EncryptionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionARM, EncryptionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionARM runs a test to see if a specific instance of EncryptionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionARM(subject EncryptionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionARM instances for property testing - lazily instantiated by EncryptionARMGenerator()
var encryptionARMGenerator gopter.Gen

// EncryptionARMGenerator returns a generator of EncryptionARM instances for property testing.
// We first initialize encryptionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionARMGenerator() gopter.Gen {
	if encryptionARMGenerator != nil {
		return encryptionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionARM(generators)
	encryptionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionARM(generators)
	encryptionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionARM{}), generators)

	return encryptionARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(EncryptionKeySourceMicrosoftKeyvault, EncryptionKeySourceMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesARMGenerator())
}

func Test_KeyPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicyARM, KeyPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicyARM runs a test to see if a specific instance of KeyPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicyARM(subject KeyPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicyARM instances for property testing - lazily instantiated by KeyPolicyARMGenerator()
var keyPolicyARMGenerator gopter.Gen

// KeyPolicyARMGenerator returns a generator of KeyPolicyARM instances for property testing.
func KeyPolicyARMGenerator() gopter.Gen {
	if keyPolicyARMGenerator != nil {
		return keyPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicyARM(generators)
	keyPolicyARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicyARM{}), generators)

	return keyPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicyARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSetARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetARM, NetworkRuleSetARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetARM runs a test to see if a specific instance of NetworkRuleSetARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetARM(subject NetworkRuleSetARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetARM instances for property testing - lazily instantiated by NetworkRuleSetARMGenerator()
var networkRuleSetARMGenerator gopter.Gen

// NetworkRuleSetARMGenerator returns a generator of NetworkRuleSetARM instances for property testing.
// We first initialize networkRuleSetARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetARMGenerator() gopter.Gen {
	if networkRuleSetARMGenerator != nil {
		return networkRuleSetARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetARM(generators)
	networkRuleSetARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetARM(generators)
	networkRuleSetARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetARM{}), generators)

	return networkRuleSetARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSetBypassAzureServices,
		NetworkRuleSetBypassLogging,
		NetworkRuleSetBypassMetrics,
		NetworkRuleSetBypassNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSetDefaultActionAllow, NetworkRuleSetDefaultActionDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleARMGenerator())
}

func Test_RoutingPreferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceARM, RoutingPreferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceARM runs a test to see if a specific instance of RoutingPreferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceARM(subject RoutingPreferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreferenceARM instances for property testing - lazily instantiated by
//RoutingPreferenceARMGenerator()
var routingPreferenceARMGenerator gopter.Gen

// RoutingPreferenceARMGenerator returns a generator of RoutingPreferenceARM instances for property testing.
func RoutingPreferenceARMGenerator() gopter.Gen {
	if routingPreferenceARMGenerator != nil {
		return routingPreferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceARM(generators)
	routingPreferenceARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreferenceARM{}), generators)

	return routingPreferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreferenceRoutingChoiceInternetRouting, RoutingPreferenceRoutingChoiceMicrosoftRouting))
}

func Test_SasPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicyARM, SasPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicyARM runs a test to see if a specific instance of SasPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicyARM(subject SasPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicyARM instances for property testing - lazily instantiated by SasPolicyARMGenerator()
var sasPolicyARMGenerator gopter.Gen

// SasPolicyARMGenerator returns a generator of SasPolicyARM instances for property testing.
func SasPolicyARMGenerator() gopter.Gen {
	if sasPolicyARMGenerator != nil {
		return sasPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicyARM(generators)
	sasPolicyARMGenerator = gen.Struct(reflect.TypeOf(SasPolicyARM{}), generators)

	return sasPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicyARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicyExpirationActionLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_ActiveDirectoryPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesARM, ActiveDirectoryPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesARM runs a test to see if a specific instance of ActiveDirectoryPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesARM(subject ActiveDirectoryPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryPropertiesARM instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesARMGenerator()
var activeDirectoryPropertiesARMGenerator gopter.Gen

// ActiveDirectoryPropertiesARMGenerator returns a generator of ActiveDirectoryPropertiesARM instances for property testing.
func ActiveDirectoryPropertiesARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesARMGenerator != nil {
		return activeDirectoryPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM(generators)
	activeDirectoryPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryPropertiesARM{}), generators)

	return activeDirectoryPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentityARM, EncryptionIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentityARM runs a test to see if a specific instance of EncryptionIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentityARM(subject EncryptionIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentityARM instances for property testing - lazily instantiated by
//EncryptionIdentityARMGenerator()
var encryptionIdentityARMGenerator gopter.Gen

// EncryptionIdentityARMGenerator returns a generator of EncryptionIdentityARM instances for property testing.
func EncryptionIdentityARMGenerator() gopter.Gen {
	if encryptionIdentityARMGenerator != nil {
		return encryptionIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentityARM(generators)
	encryptionIdentityARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentityARM{}), generators)

	return encryptionIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentityARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServicesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServicesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesARM, EncryptionServicesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesARM runs a test to see if a specific instance of EncryptionServicesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesARM(subject EncryptionServicesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServicesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServicesARM instances for property testing - lazily instantiated by
//EncryptionServicesARMGenerator()
var encryptionServicesARMGenerator gopter.Gen

// EncryptionServicesARMGenerator returns a generator of EncryptionServicesARM instances for property testing.
func EncryptionServicesARMGenerator() gopter.Gen {
	if encryptionServicesARMGenerator != nil {
		return encryptionServicesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesARM(generators)
	encryptionServicesARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServicesARM{}), generators)

	return encryptionServicesARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceARMGenerator())
}

func Test_IPRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleARM, IPRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleARM runs a test to see if a specific instance of IPRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleARM(subject IPRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRuleARM instances for property testing - lazily instantiated by IPRuleARMGenerator()
var ipRuleARMGenerator gopter.Gen

// IPRuleARMGenerator returns a generator of IPRuleARM instances for property testing.
func IPRuleARMGenerator() gopter.Gen {
	if ipRuleARMGenerator != nil {
		return ipRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleARM(generators)
	ipRuleARMGenerator = gen.Struct(reflect.TypeOf(IPRuleARM{}), generators)

	return ipRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleActionAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesARM, KeyVaultPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesARM runs a test to see if a specific instance of KeyVaultPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesARM(subject KeyVaultPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultPropertiesARM instances for property testing - lazily instantiated by
//KeyVaultPropertiesARMGenerator()
var keyVaultPropertiesARMGenerator gopter.Gen

// KeyVaultPropertiesARMGenerator returns a generator of KeyVaultPropertiesARM instances for property testing.
func KeyVaultPropertiesARMGenerator() gopter.Gen {
	if keyVaultPropertiesARMGenerator != nil {
		return keyVaultPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM(generators)
	keyVaultPropertiesARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultPropertiesARM{}), generators)

	return keyVaultPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesARM(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleARM, ResourceAccessRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleARM runs a test to see if a specific instance of ResourceAccessRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleARM(subject ResourceAccessRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRuleARM instances for property testing - lazily instantiated by
//ResourceAccessRuleARMGenerator()
var resourceAccessRuleARMGenerator gopter.Gen

// ResourceAccessRuleARMGenerator returns a generator of ResourceAccessRuleARM instances for property testing.
func ResourceAccessRuleARMGenerator() gopter.Gen {
	if resourceAccessRuleARMGenerator != nil {
		return resourceAccessRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleARM(generators)
	resourceAccessRuleARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRuleARM{}), generators)

	return resourceAccessRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleARM, VirtualNetworkRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleARM runs a test to see if a specific instance of VirtualNetworkRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleARM(subject VirtualNetworkRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRuleARM instances for property testing - lazily instantiated by
//VirtualNetworkRuleARMGenerator()
var virtualNetworkRuleARMGenerator gopter.Gen

// VirtualNetworkRuleARMGenerator returns a generator of VirtualNetworkRuleARM instances for property testing.
func VirtualNetworkRuleARMGenerator() gopter.Gen {
	if virtualNetworkRuleARMGenerator != nil {
		return virtualNetworkRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM(generators)
	virtualNetworkRuleARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRuleARM{}), generators)

	return virtualNetworkRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRuleActionAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRuleStateDeprovisioning,
		VirtualNetworkRuleStateFailed,
		VirtualNetworkRuleStateNetworkSourceDeleted,
		VirtualNetworkRuleStateProvisioning,
		VirtualNetworkRuleStateSucceeded))
}

func Test_EncryptionServiceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServiceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceARM, EncryptionServiceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceARM runs a test to see if a specific instance of EncryptionServiceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceARM(subject EncryptionServiceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServiceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServiceARM instances for property testing - lazily instantiated by
//EncryptionServiceARMGenerator()
var encryptionServiceARMGenerator gopter.Gen

// EncryptionServiceARMGenerator returns a generator of EncryptionServiceARM instances for property testing.
func EncryptionServiceARMGenerator() gopter.Gen {
	if encryptionServiceARMGenerator != nil {
		return encryptionServiceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceARM(generators)
	encryptionServiceARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServiceARM{}), generators)

	return encryptionServiceARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionServiceKeyTypeAccount, EncryptionServiceKeyTypeService))
}
