// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccountCreateParameters_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountCreateParameters_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountCreateParametersStatusARM, StorageAccountCreateParametersStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountCreateParametersStatusARM runs a test to see if a specific instance of StorageAccountCreateParameters_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountCreateParametersStatusARM(subject StorageAccountCreateParameters_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountCreateParameters_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountCreateParameters_StatusARM instances for property testing - lazily instantiated by
//StorageAccountCreateParametersStatusARMGenerator()
var storageAccountCreateParametersStatusARMGenerator gopter.Gen

// StorageAccountCreateParametersStatusARMGenerator returns a generator of StorageAccountCreateParameters_StatusARM instances for property testing.
// We first initialize storageAccountCreateParametersStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountCreateParametersStatusARMGenerator() gopter.Gen {
	if storageAccountCreateParametersStatusARMGenerator != nil {
		return storageAccountCreateParametersStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatusARM(generators)
	storageAccountCreateParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountCreateParameters_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatusARM(generators)
	storageAccountCreateParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountCreateParameters_StatusARM{}), generators)

	return storageAccountCreateParametersStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatusARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountCreateParametersStatusKindBlobStorage,
		StorageAccountCreateParametersStatusKindBlockBlobStorage,
		StorageAccountCreateParametersStatusKindFileStorage,
		StorageAccountCreateParametersStatusKindStorage,
		StorageAccountCreateParametersStatusKindStorageV2))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusARMGenerator())
	gens["Identity"] = gen.PtrOf(IdentityStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(StorageAccountPropertiesCreateParametersStatusARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuStatusARMGenerator())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatusARM, ExtendedLocationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
//ExtendedLocationStatusARMGenerator()
var extendedLocationStatusARMGenerator gopter.Gen

// ExtendedLocationStatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocationStatusARMGenerator() gopter.Gen {
	if extendedLocationStatusARMGenerator != nil {
		return extendedLocationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(generators)
	extendedLocationStatusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_Identity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityStatusARM, IdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityStatusARM runs a test to see if a specific instance of Identity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityStatusARM(subject Identity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_StatusARM instances for property testing - lazily instantiated by IdentityStatusARMGenerator()
var identityStatusARMGenerator gopter.Gen

// IdentityStatusARMGenerator returns a generator of Identity_StatusARM instances for property testing.
// We first initialize identityStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityStatusARMGenerator() gopter.Gen {
	if identityStatusARMGenerator != nil {
		return identityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatusARM(generators)
	identityStatusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatusARM(generators)
	AddRelatedPropertyGeneratorsForIdentityStatusARM(generators)
	identityStatusARMGenerator = gen.Struct(reflect.TypeOf(Identity_StatusARM{}), generators)

	return identityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(
		IdentityStatusTypeNone,
		IdentityStatusTypeSystemAssigned,
		IdentityStatusTypeSystemAssignedUserAssigned,
		IdentityStatusTypeUserAssigned)
}

// AddRelatedPropertyGeneratorsForIdentityStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityStatusARMGenerator())
}

func Test_StorageAccountPropertiesCreateParameters_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountPropertiesCreateParameters_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountPropertiesCreateParametersStatusARM, StorageAccountPropertiesCreateParametersStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountPropertiesCreateParametersStatusARM runs a test to see if a specific instance of StorageAccountPropertiesCreateParameters_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountPropertiesCreateParametersStatusARM(subject StorageAccountPropertiesCreateParameters_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountPropertiesCreateParameters_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountPropertiesCreateParameters_StatusARM instances for property testing - lazily instantiated
//by StorageAccountPropertiesCreateParametersStatusARMGenerator()
var storageAccountPropertiesCreateParametersStatusARMGenerator gopter.Gen

// StorageAccountPropertiesCreateParametersStatusARMGenerator returns a generator of StorageAccountPropertiesCreateParameters_StatusARM instances for property testing.
// We first initialize storageAccountPropertiesCreateParametersStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountPropertiesCreateParametersStatusARMGenerator() gopter.Gen {
	if storageAccountPropertiesCreateParametersStatusARMGenerator != nil {
		return storageAccountPropertiesCreateParametersStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM(generators)
	storageAccountPropertiesCreateParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParameters_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM(generators)
	AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM(generators)
	storageAccountPropertiesCreateParametersStatusARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountPropertiesCreateParameters_StatusARM{}), generators)

	return storageAccountPropertiesCreateParametersStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParametersStatusAccessTierCool, StorageAccountPropertiesCreateParametersStatusAccessTierHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParametersStatusLargeFileSharesStateDisabled, StorageAccountPropertiesCreateParametersStatusLargeFileSharesStateEnabled))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountPropertiesCreateParametersStatusMinimumTlsVersionTLS10, StorageAccountPropertiesCreateParametersStatusMinimumTlsVersionTLS11, StorageAccountPropertiesCreateParametersStatusMinimumTlsVersionTLS12))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountPropertiesCreateParametersStatusARM(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationStatusARMGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainStatusARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionStatusARMGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyStatusARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetStatusARMGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceStatusARMGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyStatusARMGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM, AzureFilesIdentityBasedAuthenticationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatusARM(subject AzureFilesIdentityBasedAuthentication_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationStatusARMGenerator()
var azureFilesIdentityBasedAuthenticationStatusARMGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationStatusARMGenerator returns a generator of AzureFilesIdentityBasedAuthentication_StatusARM instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationStatusARMGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationStatusARMGenerator != nil {
		return azureFilesIdentityBasedAuthenticationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	azureFilesIdentityBasedAuthenticationStatusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(generators)
	azureFilesIdentityBasedAuthenticationStatusARMGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_StatusARM{}), generators)

	return azureFilesIdentityBasedAuthenticationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionNone,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthenticationStatusDefaultSharePermissionStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsAADDS, AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsAD, AzureFilesIdentityBasedAuthenticationStatusDirectoryServiceOptionsNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatusARM(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesStatusARMGenerator())
}

func Test_CustomDomain_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainStatusARM, CustomDomainStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainStatusARM runs a test to see if a specific instance of CustomDomain_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainStatusARM(subject CustomDomain_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_StatusARM instances for property testing - lazily instantiated by
//CustomDomainStatusARMGenerator()
var customDomainStatusARMGenerator gopter.Gen

// CustomDomainStatusARMGenerator returns a generator of CustomDomain_StatusARM instances for property testing.
func CustomDomainStatusARMGenerator() gopter.Gen {
	if customDomainStatusARMGenerator != nil {
		return customDomainStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainStatusARM(generators)
	customDomainStatusARMGenerator = gen.Struct(reflect.TypeOf(CustomDomain_StatusARM{}), generators)

	return customDomainStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionStatusARM, EncryptionStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionStatusARM runs a test to see if a specific instance of Encryption_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionStatusARM(subject Encryption_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_StatusARM instances for property testing - lazily instantiated by
//EncryptionStatusARMGenerator()
var encryptionStatusARMGenerator gopter.Gen

// EncryptionStatusARMGenerator returns a generator of Encryption_StatusARM instances for property testing.
// We first initialize encryptionStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionStatusARMGenerator() gopter.Gen {
	if encryptionStatusARMGenerator != nil {
		return encryptionStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatusARM(generators)
	encryptionStatusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionStatusARM(generators)
	encryptionStatusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	return encryptionStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionStatusARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(EncryptionStatusKeySourceMicrosoftKeyvault, EncryptionStatusKeySourceMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityStatusARMGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesStatusARMGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesStatusARMGenerator())
}

func Test_KeyPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicyStatusARM, KeyPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicyStatusARM runs a test to see if a specific instance of KeyPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicyStatusARM(subject KeyPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_StatusARM instances for property testing - lazily instantiated by KeyPolicyStatusARMGenerator()
var keyPolicyStatusARMGenerator gopter.Gen

// KeyPolicyStatusARMGenerator returns a generator of KeyPolicy_StatusARM instances for property testing.
func KeyPolicyStatusARMGenerator() gopter.Gen {
	if keyPolicyStatusARMGenerator != nil {
		return keyPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicyStatusARM(generators)
	keyPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_StatusARM{}), generators)

	return keyPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetStatusARM, NetworkRuleSetStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetStatusARM runs a test to see if a specific instance of NetworkRuleSet_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetStatusARM(subject NetworkRuleSet_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_StatusARM instances for property testing - lazily instantiated by
//NetworkRuleSetStatusARMGenerator()
var networkRuleSetStatusARMGenerator gopter.Gen

// NetworkRuleSetStatusARMGenerator returns a generator of NetworkRuleSet_StatusARM instances for property testing.
// We first initialize networkRuleSetStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetStatusARMGenerator() gopter.Gen {
	if networkRuleSetStatusARMGenerator != nil {
		return networkRuleSetStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	return networkRuleSetStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSetStatusBypassAzureServices,
		NetworkRuleSetStatusBypassLogging,
		NetworkRuleSetStatusBypassMetrics,
		NetworkRuleSetStatusBypassNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSetStatusDefaultActionAllow, NetworkRuleSetStatusDefaultActionDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleStatusARMGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleStatusARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusARMGenerator())
}

func Test_RoutingPreference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceStatusARM, RoutingPreferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceStatusARM runs a test to see if a specific instance of RoutingPreference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceStatusARM(subject RoutingPreference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_StatusARM instances for property testing - lazily instantiated by
//RoutingPreferenceStatusARMGenerator()
var routingPreferenceStatusARMGenerator gopter.Gen

// RoutingPreferenceStatusARMGenerator returns a generator of RoutingPreference_StatusARM instances for property testing.
func RoutingPreferenceStatusARMGenerator() gopter.Gen {
	if routingPreferenceStatusARMGenerator != nil {
		return routingPreferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM(generators)
	routingPreferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_StatusARM{}), generators)

	return routingPreferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceStatusARM(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreferenceStatusRoutingChoiceInternetRouting, RoutingPreferenceStatusRoutingChoiceMicrosoftRouting))
}

func Test_SasPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicyStatusARM, SasPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicyStatusARM runs a test to see if a specific instance of SasPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicyStatusARM(subject SasPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_StatusARM instances for property testing - lazily instantiated by SasPolicyStatusARMGenerator()
var sasPolicyStatusARMGenerator gopter.Gen

// SasPolicyStatusARMGenerator returns a generator of SasPolicy_StatusARM instances for property testing.
func SasPolicyStatusARMGenerator() gopter.Gen {
	if sasPolicyStatusARMGenerator != nil {
		return sasPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicyStatusARM(generators)
	sasPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(SasPolicy_StatusARM{}), generators)

	return sasPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicyStatusExpirationActionLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_UserAssignedIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityStatusARM, UserAssignedIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityStatusARM runs a test to see if a specific instance of UserAssignedIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityStatusARM(subject UserAssignedIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_StatusARM instances for property testing - lazily instantiated by
//UserAssignedIdentityStatusARMGenerator()
var userAssignedIdentityStatusARMGenerator gopter.Gen

// UserAssignedIdentityStatusARMGenerator returns a generator of UserAssignedIdentity_StatusARM instances for property testing.
func UserAssignedIdentityStatusARMGenerator() gopter.Gen {
	if userAssignedIdentityStatusARMGenerator != nil {
		return userAssignedIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM(generators)
	userAssignedIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_StatusARM{}), generators)

	return userAssignedIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM, ActiveDirectoryPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM runs a test to see if a specific instance of ActiveDirectoryProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesStatusARM(subject ActiveDirectoryProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_StatusARM instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesStatusARMGenerator()
var activeDirectoryPropertiesStatusARMGenerator gopter.Gen

// ActiveDirectoryPropertiesStatusARMGenerator returns a generator of ActiveDirectoryProperties_StatusARM instances for property testing.
func ActiveDirectoryPropertiesStatusARMGenerator() gopter.Gen {
	if activeDirectoryPropertiesStatusARMGenerator != nil {
		return activeDirectoryPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM(generators)
	activeDirectoryPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_StatusARM{}), generators)

	return activeDirectoryPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentityStatusARM, EncryptionIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentityStatusARM runs a test to see if a specific instance of EncryptionIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentityStatusARM(subject EncryptionIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_StatusARM instances for property testing - lazily instantiated by
//EncryptionIdentityStatusARMGenerator()
var encryptionIdentityStatusARMGenerator gopter.Gen

// EncryptionIdentityStatusARMGenerator returns a generator of EncryptionIdentity_StatusARM instances for property testing.
func EncryptionIdentityStatusARMGenerator() gopter.Gen {
	if encryptionIdentityStatusARMGenerator != nil {
		return encryptionIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM(generators)
	encryptionIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_StatusARM{}), generators)

	return encryptionIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesStatusARM, EncryptionServicesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesStatusARM runs a test to see if a specific instance of EncryptionServices_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesStatusARM(subject EncryptionServices_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_StatusARM instances for property testing - lazily instantiated by
//EncryptionServicesStatusARMGenerator()
var encryptionServicesStatusARMGenerator gopter.Gen

// EncryptionServicesStatusARMGenerator returns a generator of EncryptionServices_StatusARM instances for property testing.
func EncryptionServicesStatusARMGenerator() gopter.Gen {
	if encryptionServicesStatusARMGenerator != nil {
		return encryptionServicesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM(generators)
	encryptionServicesStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_StatusARM{}), generators)

	return encryptionServicesStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesStatusARM(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceStatusARMGenerator())
}

func Test_IPRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleStatusARM, IPRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleStatusARM runs a test to see if a specific instance of IPRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleStatusARM(subject IPRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_StatusARM instances for property testing - lazily instantiated by IPRuleStatusARMGenerator()
var ipRuleStatusARMGenerator gopter.Gen

// IPRuleStatusARMGenerator returns a generator of IPRule_StatusARM instances for property testing.
func IPRuleStatusARMGenerator() gopter.Gen {
	if ipRuleStatusARMGenerator != nil {
		return ipRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleStatusARM(generators)
	ipRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(IPRule_StatusARM{}), generators)

	return ipRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleStatusActionAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatusARM, KeyVaultPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatusARM runs a test to see if a specific instance of KeyVaultProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatusARM(subject KeyVaultProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_StatusARM instances for property testing - lazily instantiated by
//KeyVaultPropertiesStatusARMGenerator()
var keyVaultPropertiesStatusARMGenerator gopter.Gen

// KeyVaultPropertiesStatusARMGenerator returns a generator of KeyVaultProperties_StatusARM instances for property testing.
func KeyVaultPropertiesStatusARMGenerator() gopter.Gen {
	if keyVaultPropertiesStatusARMGenerator != nil {
		return keyVaultPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(generators)
	keyVaultPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_StatusARM{}), generators)

	return keyVaultPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleStatusARM, ResourceAccessRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleStatusARM runs a test to see if a specific instance of ResourceAccessRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleStatusARM(subject ResourceAccessRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_StatusARM instances for property testing - lazily instantiated by
//ResourceAccessRuleStatusARMGenerator()
var resourceAccessRuleStatusARMGenerator gopter.Gen

// ResourceAccessRuleStatusARMGenerator returns a generator of ResourceAccessRule_StatusARM instances for property testing.
func ResourceAccessRuleStatusARMGenerator() gopter.Gen {
	if resourceAccessRuleStatusARMGenerator != nil {
		return resourceAccessRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM(generators)
	resourceAccessRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_StatusARM{}), generators)

	return resourceAccessRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleStatusARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatusARM, VirtualNetworkRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatusARM runs a test to see if a specific instance of VirtualNetworkRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatusARM(subject VirtualNetworkRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_StatusARM instances for property testing - lazily instantiated by
//VirtualNetworkRuleStatusARMGenerator()
var virtualNetworkRuleStatusARMGenerator gopter.Gen

// VirtualNetworkRuleStatusARMGenerator returns a generator of VirtualNetworkRule_StatusARM instances for property testing.
func VirtualNetworkRuleStatusARMGenerator() gopter.Gen {
	if virtualNetworkRuleStatusARMGenerator != nil {
		return virtualNetworkRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(generators)
	virtualNetworkRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_StatusARM{}), generators)

	return virtualNetworkRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRuleStatusActionAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRuleStatusStateDeprovisioning,
		VirtualNetworkRuleStatusStateFailed,
		VirtualNetworkRuleStatusStateNetworkSourceDeleted,
		VirtualNetworkRuleStatusStateProvisioning,
		VirtualNetworkRuleStatusStateSucceeded))
}

func Test_EncryptionService_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceStatusARM, EncryptionServiceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceStatusARM runs a test to see if a specific instance of EncryptionService_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceStatusARM(subject EncryptionService_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_StatusARM instances for property testing - lazily instantiated by
//EncryptionServiceStatusARMGenerator()
var encryptionServiceStatusARMGenerator gopter.Gen

// EncryptionServiceStatusARMGenerator returns a generator of EncryptionService_StatusARM instances for property testing.
func EncryptionServiceStatusARMGenerator() gopter.Gen {
	if encryptionServiceStatusARMGenerator != nil {
		return encryptionServiceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM(generators)
	encryptionServiceStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionService_StatusARM{}), generators)

	return encryptionServiceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceStatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionServiceStatusKeyTypeAccount, EncryptionServiceStatusKeyTypeService))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
