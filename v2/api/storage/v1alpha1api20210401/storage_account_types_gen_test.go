// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/storage/v1alpha1api20210401storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForStorageAccount, StorageAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForStorageAccount tests if a specific instance of StorageAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForStorageAccount(subject StorageAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210401storage.StorageAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual StorageAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccount to StorageAccount via AssignPropertiesToStorageAccount & AssignPropertiesFromStorageAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccount, StorageAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccount tests if a specific instance of StorageAccount can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccount(subject StorageAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.StorageAccount
	err := copied.AssignPropertiesToStorageAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccount
	err = actual.AssignPropertiesFromStorageAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount, StorageAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount runs a test to see if a specific instance of StorageAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount(subject StorageAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount instances for property testing - lazily instantiated by StorageAccountGenerator()
var storageAccountGenerator gopter.Gen

// StorageAccountGenerator returns a generator of StorageAccount instances for property testing.
func StorageAccountGenerator() gopter.Gen {
	if storageAccountGenerator != nil {
		return storageAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccount(generators)
	storageAccountGenerator = gen.Struct(reflect.TypeOf(StorageAccount{}), generators)

	return storageAccountGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = StorageAccounts_SPECGenerator()
	gens["Status"] = StorageAccount_StatusGenerator()
}

func Test_StorageAccount_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccount_Status to StorageAccount_Status via AssignPropertiesToStorageAccount_Status & AssignPropertiesFromStorageAccount_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccount_Status, StorageAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccount_Status tests if a specific instance of StorageAccount_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccount_Status(subject StorageAccount_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.StorageAccount_Status
	err := copied.AssignPropertiesToStorageAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccount_Status
	err = actual.AssignPropertiesFromStorageAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount_Status, StorageAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount_Status runs a test to see if a specific instance of StorageAccount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount_Status(subject StorageAccount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_Status instances for property testing - lazily instantiated by
//StorageAccount_StatusGenerator()
var storageAccount_statusGenerator gopter.Gen

// StorageAccount_StatusGenerator returns a generator of StorageAccount_Status instances for property testing.
// We first initialize storageAccount_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccount_StatusGenerator() gopter.Gen {
	if storageAccount_statusGenerator != nil {
		return storageAccount_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_Status(generators)
	storageAccount_statusGenerator = gen.Struct(reflect.TypeOf(StorageAccount_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccount_Status(generators)
	AddRelatedPropertyGeneratorsForStorageAccount_Status(generators)
	storageAccount_statusGenerator = gen.Struct(reflect.TypeOf(StorageAccount_Status{}), generators)

	return storageAccount_statusGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccount_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccount_Status(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_AccessTier_StatusCool, StorageAccountProperties_AccessTier_StatusHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		StorageAccount_Kind_StatusBlobStorage,
		StorageAccount_Kind_StatusBlockBlobStorage,
		StorageAccount_Kind_StatusFileStorage,
		StorageAccount_Kind_StatusStorage,
		StorageAccount_Kind_StatusStorageV2))
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_LargeFileSharesState_StatusDisabled, StorageAccountProperties_LargeFileSharesState_StatusEnabled))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_MinimumTlsVersion_StatusTLS1_0, StorageAccountProperties_MinimumTlsVersion_StatusTLS1_1, StorageAccountProperties_MinimumTlsVersion_StatusTLS1_2))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccount_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount_Status(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_StatusGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_StatusGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["Identity"] = gen.PtrOf(Identity_StatusGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_StatusGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_StatusGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_StatusGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_StatusGenerator())
	gens["Sku"] = gen.PtrOf(Sku_StatusGenerator())
}

func Test_StorageAccounts_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageAccounts_SPEC to StorageAccounts_SPEC via AssignPropertiesToStorageAccounts_SPEC & AssignPropertiesFromStorageAccounts_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageAccounts_SPEC, StorageAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageAccounts_SPEC tests if a specific instance of StorageAccounts_SPEC can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForStorageAccounts_SPEC(subject StorageAccounts_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.StorageAccounts_SPEC
	err := copied.AssignPropertiesToStorageAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageAccounts_SPEC
	err = actual.AssignPropertiesFromStorageAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccounts_SPEC, StorageAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccounts_SPEC runs a test to see if a specific instance of StorageAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccounts_SPEC(subject StorageAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_SPEC instances for property testing - lazily instantiated by
//StorageAccounts_SPECGenerator()
var storageAccounts_specGenerator gopter.Gen

// StorageAccounts_SPECGenerator returns a generator of StorageAccounts_SPEC instances for property testing.
// We first initialize storageAccounts_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccounts_SPECGenerator() gopter.Gen {
	if storageAccounts_specGenerator != nil {
		return storageAccounts_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SPEC(generators)
	storageAccounts_specGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccounts_SPEC(generators)
	AddRelatedPropertyGeneratorsForStorageAccounts_SPEC(generators)
	storageAccounts_specGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPEC{}), generators)

	return storageAccounts_specGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccounts_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_AccessTier_SpecCool, StorageAccountProperties_AccessTier_SpecHot))
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.OneConstOf(
		StorageAccounts_Kind_SPECBlobStorage,
		StorageAccounts_Kind_SPECBlockBlobStorage,
		StorageAccounts_Kind_SPECFileStorage,
		StorageAccounts_Kind_SPECStorage,
		StorageAccounts_Kind_SPECStorageV2)
	gens["LargeFileSharesState"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_LargeFileSharesState_SpecDisabled, StorageAccountProperties_LargeFileSharesState_SpecEnabled))
	gens["Location"] = gen.AlphaString()
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(StorageAccountProperties_MinimumTlsVersion_SpecTLS1_0, StorageAccountProperties_MinimumTlsVersion_SpecTLS1_1, StorageAccountProperties_MinimumTlsVersion_SpecTLS1_2))
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccounts_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthentication_SpecGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomain_SpecGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["Identity"] = gen.PtrOf(Identity_SpecGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicy_SpecGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_SpecGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreference_SpecGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicy_SpecGenerator())
	gens["Sku"] = Sku_SpecGenerator()
}

func Test_AzureFilesIdentityBasedAuthentication_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFilesIdentityBasedAuthentication_Spec to AzureFilesIdentityBasedAuthentication_Spec via AssignPropertiesToAzureFilesIdentityBasedAuthentication_Spec & AssignPropertiesFromAzureFilesIdentityBasedAuthentication_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Spec, AzureFilesIdentityBasedAuthentication_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Spec tests if a specific instance of AzureFilesIdentityBasedAuthentication_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Spec(subject AzureFilesIdentityBasedAuthentication_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.AzureFilesIdentityBasedAuthentication_Spec
	err := copied.AssignPropertiesToAzureFilesIdentityBasedAuthentication_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFilesIdentityBasedAuthentication_Spec
	err = actual.AssignPropertiesFromAzureFilesIdentityBasedAuthentication_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFilesIdentityBasedAuthentication_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Spec, AzureFilesIdentityBasedAuthentication_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Spec runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Spec(subject AzureFilesIdentityBasedAuthentication_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_Spec instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthentication_SpecGenerator()
var azureFilesIdentityBasedAuthentication_specGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_SpecGenerator returns a generator of AzureFilesIdentityBasedAuthentication_Spec instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_SpecGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_specGenerator != nil {
		return azureFilesIdentityBasedAuthentication_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec(generators)
	azureFilesIdentityBasedAuthentication_specGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec(generators)
	azureFilesIdentityBasedAuthentication_specGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Spec{}), generators)

	return azureFilesIdentityBasedAuthentication_specGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecNone,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_SpecStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecAADDS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecAD, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_SpecNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Spec(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_SpecGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFilesIdentityBasedAuthentication_Status to AzureFilesIdentityBasedAuthentication_Status via AssignPropertiesToAzureFilesIdentityBasedAuthentication_Status & AssignPropertiesFromAzureFilesIdentityBasedAuthentication_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Status, AzureFilesIdentityBasedAuthentication_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Status tests if a specific instance of AzureFilesIdentityBasedAuthentication_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForAzureFilesIdentityBasedAuthentication_Status(subject AzureFilesIdentityBasedAuthentication_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.AzureFilesIdentityBasedAuthentication_Status
	err := copied.AssignPropertiesToAzureFilesIdentityBasedAuthentication_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFilesIdentityBasedAuthentication_Status
	err = actual.AssignPropertiesFromAzureFilesIdentityBasedAuthentication_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFilesIdentityBasedAuthentication_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Status, AzureFilesIdentityBasedAuthentication_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Status runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication_Status(subject AzureFilesIdentityBasedAuthentication_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_Status instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthentication_StatusGenerator()
var azureFilesIdentityBasedAuthentication_statusGenerator gopter.Gen

// AzureFilesIdentityBasedAuthentication_StatusGenerator returns a generator of AzureFilesIdentityBasedAuthentication_Status instances for property testing.
// We first initialize azureFilesIdentityBasedAuthentication_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthentication_StatusGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthentication_statusGenerator != nil {
		return azureFilesIdentityBasedAuthentication_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status(generators)
	azureFilesIdentityBasedAuthentication_statusGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status(generators)
	azureFilesIdentityBasedAuthentication_statusGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Status{}), generators)

	return azureFilesIdentityBasedAuthentication_statusGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.OneConstOf(
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StatusNone,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StatusStorageFileDataSmbShareContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StatusStorageFileDataSmbShareElevatedContributor,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StatusStorageFileDataSmbShareOwner,
		AzureFilesIdentityBasedAuthentication_DefaultSharePermission_StatusStorageFileDataSmbShareReader))
	gens["DirectoryServiceOptions"] = gen.OneConstOf(AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_StatusAADDS, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_StatusAD, AzureFilesIdentityBasedAuthentication_DirectoryServiceOptions_StatusNone)
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication_Status(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryProperties_StatusGenerator())
}

func Test_CustomDomain_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain_Spec to CustomDomain_Spec via AssignPropertiesToCustomDomain_Spec & AssignPropertiesFromCustomDomain_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain_Spec, CustomDomain_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain_Spec tests if a specific instance of CustomDomain_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain_Spec(subject CustomDomain_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.CustomDomain_Spec
	err := copied.AssignPropertiesToCustomDomain_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain_Spec
	err = actual.AssignPropertiesFromCustomDomain_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_Spec, CustomDomain_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_Spec runs a test to see if a specific instance of CustomDomain_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_Spec(subject CustomDomain_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_Spec instances for property testing - lazily instantiated by CustomDomain_SpecGenerator()
var customDomain_specGenerator gopter.Gen

// CustomDomain_SpecGenerator returns a generator of CustomDomain_Spec instances for property testing.
func CustomDomain_SpecGenerator() gopter.Gen {
	if customDomain_specGenerator != nil {
		return customDomain_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_Spec(generators)
	customDomain_specGenerator = gen.Struct(reflect.TypeOf(CustomDomain_Spec{}), generators)

	return customDomain_specGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_CustomDomain_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain_Status to CustomDomain_Status via AssignPropertiesToCustomDomain_Status & AssignPropertiesFromCustomDomain_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain_Status, CustomDomain_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain_Status tests if a specific instance of CustomDomain_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain_Status(subject CustomDomain_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.CustomDomain_Status
	err := copied.AssignPropertiesToCustomDomain_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain_Status
	err = actual.AssignPropertiesFromCustomDomain_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_Status, CustomDomain_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_Status runs a test to see if a specific instance of CustomDomain_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_Status(subject CustomDomain_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_Status instances for property testing - lazily instantiated by
//CustomDomain_StatusGenerator()
var customDomain_statusGenerator gopter.Gen

// CustomDomain_StatusGenerator returns a generator of CustomDomain_Status instances for property testing.
func CustomDomain_StatusGenerator() gopter.Gen {
	if customDomain_statusGenerator != nil {
		return customDomain_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_Status(generators)
	customDomain_statusGenerator = gen.Struct(reflect.TypeOf(CustomDomain_Status{}), generators)

	return customDomain_statusGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Encryption_Spec to Encryption_Spec via AssignPropertiesToEncryption_Spec & AssignPropertiesFromEncryption_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryption_Spec tests if a specific instance of Encryption_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryption_Spec(subject Encryption_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Encryption_Spec
	err := copied.AssignPropertiesToEncryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Encryption_Spec
	err = actual.AssignPropertiesFromEncryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Spec runs a test to see if a specific instance of Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Spec(subject Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Spec instances for property testing - lazily instantiated by Encryption_SpecGenerator()
var encryption_specGenerator gopter.Gen

// Encryption_SpecGenerator returns a generator of Encryption_Spec instances for property testing.
// We first initialize encryption_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_SpecGenerator() gopter.Gen {
	if encryption_specGenerator != nil {
		return encryption_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	return encryption_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(Encryption_KeySource_SpecMicrosoftKeyvault, Encryption_KeySource_SpecMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_SpecGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_SpecGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_SpecGenerator())
}

func Test_Encryption_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Encryption_Status to Encryption_Status via AssignPropertiesToEncryption_Status & AssignPropertiesFromEncryption_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryption_Status tests if a specific instance of Encryption_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryption_Status(subject Encryption_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Encryption_Status
	err := copied.AssignPropertiesToEncryption_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Encryption_Status
	err = actual.AssignPropertiesFromEncryption_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Encryption_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Status runs a test to see if a specific instance of Encryption_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Status(subject Encryption_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Status instances for property testing - lazily instantiated by Encryption_StatusGenerator()
var encryption_statusGenerator gopter.Gen

// Encryption_StatusGenerator returns a generator of Encryption_Status instances for property testing.
// We first initialize encryption_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_StatusGenerator() gopter.Gen {
	if encryption_statusGenerator != nil {
		return encryption_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	AddRelatedPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	return encryption_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.OneConstOf(Encryption_KeySource_StatusMicrosoftKeyvault, Encryption_KeySource_StatusMicrosoftStorage)
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentity_StatusGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultProperties_StatusGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServices_StatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocation_Spec & AssignPropertiesFromExtendedLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Spec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocation_Status & AssignPropertiesFromExtendedLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Status tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_Identity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Identity_Spec to Identity_Spec via AssignPropertiesToIdentity_Spec & AssignPropertiesFromIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity_Spec, Identity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity_Spec tests if a specific instance of Identity_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForIdentity_Spec(subject Identity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Identity_Spec
	err := copied.AssignPropertiesToIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity_Spec
	err = actual.AssignPropertiesFromIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_Spec, Identity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_Spec runs a test to see if a specific instance of Identity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_Spec(subject Identity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Spec instances for property testing - lazily instantiated by Identity_SpecGenerator()
var identity_specGenerator gopter.Gen

// Identity_SpecGenerator returns a generator of Identity_Spec instances for property testing.
func Identity_SpecGenerator() gopter.Gen {
	if identity_specGenerator != nil {
		return identity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Spec(generators)
	identity_specGenerator = gen.Struct(reflect.TypeOf(Identity_Spec{}), generators)

	return identity_specGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(
		Identity_Type_SpecNone,
		Identity_Type_SpecSystemAssigned,
		Identity_Type_SpecSystemAssignedUserAssigned,
		Identity_Type_SpecUserAssigned)
}

func Test_Identity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Identity_Status to Identity_Status via AssignPropertiesToIdentity_Status & AssignPropertiesFromIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity_Status, Identity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity_Status tests if a specific instance of Identity_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForIdentity_Status(subject Identity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Identity_Status
	err := copied.AssignPropertiesToIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity_Status
	err = actual.AssignPropertiesFromIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_Status, Identity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_Status runs a test to see if a specific instance of Identity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_Status(subject Identity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Status instances for property testing - lazily instantiated by Identity_StatusGenerator()
var identity_statusGenerator gopter.Gen

// Identity_StatusGenerator returns a generator of Identity_Status instances for property testing.
// We first initialize identity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_StatusGenerator() gopter.Gen {
	if identity_statusGenerator != nil {
		return identity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Status(generators)
	identity_statusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForIdentity_Status(generators)
	identity_statusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	return identity_statusGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(
		Identity_Type_StatusNone,
		Identity_Type_StatusSystemAssigned,
		Identity_Type_StatusSystemAssignedUserAssigned,
		Identity_Type_StatusUserAssigned)
}

// AddRelatedPropertyGeneratorsForIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_StatusGenerator())
}

func Test_KeyPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyPolicy_Spec to KeyPolicy_Spec via AssignPropertiesToKeyPolicy_Spec & AssignPropertiesFromKeyPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyPolicy_Spec, KeyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyPolicy_Spec tests if a specific instance of KeyPolicy_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForKeyPolicy_Spec(subject KeyPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.KeyPolicy_Spec
	err := copied.AssignPropertiesToKeyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyPolicy_Spec
	err = actual.AssignPropertiesFromKeyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_Spec, KeyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_Spec runs a test to see if a specific instance of KeyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_Spec(subject KeyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_Spec instances for property testing - lazily instantiated by KeyPolicy_SpecGenerator()
var keyPolicy_specGenerator gopter.Gen

// KeyPolicy_SpecGenerator returns a generator of KeyPolicy_Spec instances for property testing.
func KeyPolicy_SpecGenerator() gopter.Gen {
	if keyPolicy_specGenerator != nil {
		return keyPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_Spec(generators)
	keyPolicy_specGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_Spec{}), generators)

	return keyPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_Spec(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_KeyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyPolicy_Status to KeyPolicy_Status via AssignPropertiesToKeyPolicy_Status & AssignPropertiesFromKeyPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyPolicy_Status, KeyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyPolicy_Status tests if a specific instance of KeyPolicy_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForKeyPolicy_Status(subject KeyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.KeyPolicy_Status
	err := copied.AssignPropertiesToKeyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyPolicy_Status
	err = actual.AssignPropertiesFromKeyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy_Status, KeyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy_Status runs a test to see if a specific instance of KeyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy_Status(subject KeyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_Status instances for property testing - lazily instantiated by KeyPolicy_StatusGenerator()
var keyPolicy_statusGenerator gopter.Gen

// KeyPolicy_StatusGenerator returns a generator of KeyPolicy_Status instances for property testing.
func KeyPolicy_StatusGenerator() gopter.Gen {
	if keyPolicy_statusGenerator != nil {
		return keyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy_Status(generators)
	keyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_Status{}), generators)

	return keyPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy_Status(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.Int()
}

func Test_NetworkRuleSet_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSet_Spec to NetworkRuleSet_Spec via AssignPropertiesToNetworkRuleSet_Spec & AssignPropertiesFromNetworkRuleSet_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSet_Spec, NetworkRuleSet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSet_Spec tests if a specific instance of NetworkRuleSet_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSet_Spec(subject NetworkRuleSet_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.NetworkRuleSet_Spec
	err := copied.AssignPropertiesToNetworkRuleSet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet_Spec
	err = actual.AssignPropertiesFromNetworkRuleSet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_Spec, NetworkRuleSet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_Spec runs a test to see if a specific instance of NetworkRuleSet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_Spec(subject NetworkRuleSet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_Spec instances for property testing - lazily instantiated by
//NetworkRuleSet_SpecGenerator()
var networkRuleSet_specGenerator gopter.Gen

// NetworkRuleSet_SpecGenerator returns a generator of NetworkRuleSet_Spec instances for property testing.
// We first initialize networkRuleSet_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_SpecGenerator() gopter.Gen {
	if networkRuleSet_specGenerator != nil {
		return networkRuleSet_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_Spec(generators)
	networkRuleSet_specGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_Spec(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_Spec(generators)
	networkRuleSet_specGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Spec{}), generators)

	return networkRuleSet_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_Spec(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_Bypass_SpecAzureServices,
		NetworkRuleSet_Bypass_SpecLogging,
		NetworkRuleSet_Bypass_SpecMetrics,
		NetworkRuleSet_Bypass_SpecNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSet_DefaultAction_SpecAllow, NetworkRuleSet_DefaultAction_SpecDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_Spec(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_SpecGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_SpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_SpecGenerator())
}

func Test_NetworkRuleSet_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSet_Status to NetworkRuleSet_Status via AssignPropertiesToNetworkRuleSet_Status & AssignPropertiesFromNetworkRuleSet_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSet_Status, NetworkRuleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSet_Status tests if a specific instance of NetworkRuleSet_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSet_Status(subject NetworkRuleSet_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.NetworkRuleSet_Status
	err := copied.AssignPropertiesToNetworkRuleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet_Status
	err = actual.AssignPropertiesFromNetworkRuleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_Status, NetworkRuleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_Status runs a test to see if a specific instance of NetworkRuleSet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_Status(subject NetworkRuleSet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_Status instances for property testing - lazily instantiated by
//NetworkRuleSet_StatusGenerator()
var networkRuleSet_statusGenerator gopter.Gen

// NetworkRuleSet_StatusGenerator returns a generator of NetworkRuleSet_Status instances for property testing.
// We first initialize networkRuleSet_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_StatusGenerator() gopter.Gen {
	if networkRuleSet_statusGenerator != nil {
		return networkRuleSet_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_Status(generators)
	networkRuleSet_statusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_Status(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_Status(generators)
	networkRuleSet_statusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	return networkRuleSet_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_Status(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(
		NetworkRuleSet_Bypass_StatusAzureServices,
		NetworkRuleSet_Bypass_StatusLogging,
		NetworkRuleSet_Bypass_StatusMetrics,
		NetworkRuleSet_Bypass_StatusNone))
	gens["DefaultAction"] = gen.OneConstOf(NetworkRuleSet_DefaultAction_StatusAllow, NetworkRuleSet_DefaultAction_StatusDeny)
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_Status(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_StatusGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRule_StatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusGenerator())
}

func Test_RoutingPreference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingPreference_Spec to RoutingPreference_Spec via AssignPropertiesToRoutingPreference_Spec & AssignPropertiesFromRoutingPreference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingPreference_Spec, RoutingPreference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingPreference_Spec tests if a specific instance of RoutingPreference_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForRoutingPreference_Spec(subject RoutingPreference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.RoutingPreference_Spec
	err := copied.AssignPropertiesToRoutingPreference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingPreference_Spec
	err = actual.AssignPropertiesFromRoutingPreference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingPreference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_Spec, RoutingPreference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_Spec runs a test to see if a specific instance of RoutingPreference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_Spec(subject RoutingPreference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_Spec instances for property testing - lazily instantiated by
//RoutingPreference_SpecGenerator()
var routingPreference_specGenerator gopter.Gen

// RoutingPreference_SpecGenerator returns a generator of RoutingPreference_Spec instances for property testing.
func RoutingPreference_SpecGenerator() gopter.Gen {
	if routingPreference_specGenerator != nil {
		return routingPreference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_Spec(generators)
	routingPreference_specGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_Spec{}), generators)

	return routingPreference_specGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_Spec(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_RoutingChoice_SpecInternetRouting, RoutingPreference_RoutingChoice_SpecMicrosoftRouting))
}

func Test_RoutingPreference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingPreference_Status to RoutingPreference_Status via AssignPropertiesToRoutingPreference_Status & AssignPropertiesFromRoutingPreference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingPreference_Status, RoutingPreference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingPreference_Status tests if a specific instance of RoutingPreference_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForRoutingPreference_Status(subject RoutingPreference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.RoutingPreference_Status
	err := copied.AssignPropertiesToRoutingPreference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingPreference_Status
	err = actual.AssignPropertiesFromRoutingPreference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingPreference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference_Status, RoutingPreference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference_Status runs a test to see if a specific instance of RoutingPreference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference_Status(subject RoutingPreference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_Status instances for property testing - lazily instantiated by
//RoutingPreference_StatusGenerator()
var routingPreference_statusGenerator gopter.Gen

// RoutingPreference_StatusGenerator returns a generator of RoutingPreference_Status instances for property testing.
func RoutingPreference_StatusGenerator() gopter.Gen {
	if routingPreference_statusGenerator != nil {
		return routingPreference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference_Status(generators)
	routingPreference_statusGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_Status{}), generators)

	return routingPreference_statusGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference_Status(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.OneConstOf(RoutingPreference_RoutingChoice_StatusInternetRouting, RoutingPreference_RoutingChoice_StatusMicrosoftRouting))
}

func Test_SasPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SasPolicy_Spec to SasPolicy_Spec via AssignPropertiesToSasPolicy_Spec & AssignPropertiesFromSasPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSasPolicy_Spec, SasPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSasPolicy_Spec tests if a specific instance of SasPolicy_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForSasPolicy_Spec(subject SasPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.SasPolicy_Spec
	err := copied.AssignPropertiesToSasPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SasPolicy_Spec
	err = actual.AssignPropertiesFromSasPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SasPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_Spec, SasPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_Spec runs a test to see if a specific instance of SasPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_Spec(subject SasPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_Spec instances for property testing - lazily instantiated by SasPolicy_SpecGenerator()
var sasPolicy_specGenerator gopter.Gen

// SasPolicy_SpecGenerator returns a generator of SasPolicy_Spec instances for property testing.
func SasPolicy_SpecGenerator() gopter.Gen {
	if sasPolicy_specGenerator != nil {
		return sasPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_Spec(generators)
	sasPolicy_specGenerator = gen.Struct(reflect.TypeOf(SasPolicy_Spec{}), generators)

	return sasPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_Spec(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicy_ExpirationAction_SpecLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_SasPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SasPolicy_Status to SasPolicy_Status via AssignPropertiesToSasPolicy_Status & AssignPropertiesFromSasPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSasPolicy_Status, SasPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSasPolicy_Status tests if a specific instance of SasPolicy_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForSasPolicy_Status(subject SasPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.SasPolicy_Status
	err := copied.AssignPropertiesToSasPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SasPolicy_Status
	err = actual.AssignPropertiesFromSasPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SasPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy_Status, SasPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy_Status runs a test to see if a specific instance of SasPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy_Status(subject SasPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_Status instances for property testing - lazily instantiated by SasPolicy_StatusGenerator()
var sasPolicy_statusGenerator gopter.Gen

// SasPolicy_StatusGenerator returns a generator of SasPolicy_Status instances for property testing.
func SasPolicy_StatusGenerator() gopter.Gen {
	if sasPolicy_statusGenerator != nil {
		return sasPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy_Status(generators)
	sasPolicy_statusGenerator = gen.Struct(reflect.TypeOf(SasPolicy_Status{}), generators)

	return sasPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy_Status(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.OneConstOf(SasPolicy_ExpirationAction_StatusLog)
	gens["SasExpirationPeriod"] = gen.AlphaString()
}

func Test_Sku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Spec to Sku_Spec via AssignPropertiesToSku_Spec & AssignPropertiesFromSku_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_Spec, Sku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_Spec tests if a specific instance of Sku_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForSku_Spec(subject Sku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Sku_Spec
	err := copied.AssignPropertiesToSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Spec
	err = actual.AssignPropertiesFromSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_Spec, Sku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_Spec runs a test to see if a specific instance of Sku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_Spec(subject Sku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Spec instances for property testing - lazily instantiated by Sku_SpecGenerator()
var sku_specGenerator gopter.Gen

// Sku_SpecGenerator returns a generator of Sku_Spec instances for property testing.
func Sku_SpecGenerator() gopter.Gen {
	if sku_specGenerator != nil {
		return sku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_Spec(generators)
	sku_specGenerator = gen.Struct(reflect.TypeOf(Sku_Spec{}), generators)

	return sku_specGenerator
}

// AddIndependentPropertyGeneratorsForSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(
		SkuName_SpecPremium_LRS,
		SkuName_SpecPremium_ZRS,
		SkuName_SpecStandard_GRS,
		SkuName_SpecStandard_GZRS,
		SkuName_SpecStandard_LRS,
		SkuName_SpecStandard_RAGRS,
		SkuName_SpecStandard_RAGZRS,
		SkuName_SpecStandard_ZRS)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Tier_SpecPremium, Tier_SpecStandard))
}

func Test_Sku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Status to Sku_Status via AssignPropertiesToSku_Status & AssignPropertiesFromSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_Status tests if a specific instance of Sku_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForSku_Status(subject Sku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.Sku_Status
	err := copied.AssignPropertiesToSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Status
	err = actual.AssignPropertiesFromSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_Status runs a test to see if a specific instance of Sku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_Status(subject Sku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Status instances for property testing - lazily instantiated by Sku_StatusGenerator()
var sku_statusGenerator gopter.Gen

// Sku_StatusGenerator returns a generator of Sku_Status instances for property testing.
func Sku_StatusGenerator() gopter.Gen {
	if sku_statusGenerator != nil {
		return sku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_Status(generators)
	sku_statusGenerator = gen.Struct(reflect.TypeOf(Sku_Status{}), generators)

	return sku_statusGenerator
}

// AddIndependentPropertyGeneratorsForSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(
		SkuName_StatusPremium_LRS,
		SkuName_StatusPremium_ZRS,
		SkuName_StatusStandard_GRS,
		SkuName_StatusStandard_GZRS,
		SkuName_StatusStandard_LRS,
		SkuName_StatusStandard_RAGRS,
		SkuName_StatusStandard_RAGZRS,
		SkuName_StatusStandard_ZRS)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(Tier_StatusPremium, Tier_StatusStandard))
}

func Test_ActiveDirectoryProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActiveDirectoryProperties_Spec to ActiveDirectoryProperties_Spec via AssignPropertiesToActiveDirectoryProperties_Spec & AssignPropertiesFromActiveDirectoryProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForActiveDirectoryProperties_Spec, ActiveDirectoryProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForActiveDirectoryProperties_Spec tests if a specific instance of ActiveDirectoryProperties_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForActiveDirectoryProperties_Spec(subject ActiveDirectoryProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ActiveDirectoryProperties_Spec
	err := copied.AssignPropertiesToActiveDirectoryProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ActiveDirectoryProperties_Spec
	err = actual.AssignPropertiesFromActiveDirectoryProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActiveDirectoryProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_Spec, ActiveDirectoryProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_Spec runs a test to see if a specific instance of ActiveDirectoryProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_Spec(subject ActiveDirectoryProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_Spec instances for property testing - lazily instantiated by
//ActiveDirectoryProperties_SpecGenerator()
var activeDirectoryProperties_specGenerator gopter.Gen

// ActiveDirectoryProperties_SpecGenerator returns a generator of ActiveDirectoryProperties_Spec instances for property testing.
func ActiveDirectoryProperties_SpecGenerator() gopter.Gen {
	if activeDirectoryProperties_specGenerator != nil {
		return activeDirectoryProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Spec(generators)
	activeDirectoryProperties_specGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_Spec{}), generators)

	return activeDirectoryProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Spec(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_ActiveDirectoryProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActiveDirectoryProperties_Status to ActiveDirectoryProperties_Status via AssignPropertiesToActiveDirectoryProperties_Status & AssignPropertiesFromActiveDirectoryProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForActiveDirectoryProperties_Status, ActiveDirectoryProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForActiveDirectoryProperties_Status tests if a specific instance of ActiveDirectoryProperties_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForActiveDirectoryProperties_Status(subject ActiveDirectoryProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ActiveDirectoryProperties_Status
	err := copied.AssignPropertiesToActiveDirectoryProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ActiveDirectoryProperties_Status
	err = actual.AssignPropertiesFromActiveDirectoryProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActiveDirectoryProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties_Status, ActiveDirectoryProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties_Status runs a test to see if a specific instance of ActiveDirectoryProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties_Status(subject ActiveDirectoryProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_Status instances for property testing - lazily instantiated by
//ActiveDirectoryProperties_StatusGenerator()
var activeDirectoryProperties_statusGenerator gopter.Gen

// ActiveDirectoryProperties_StatusGenerator returns a generator of ActiveDirectoryProperties_Status instances for property testing.
func ActiveDirectoryProperties_StatusGenerator() gopter.Gen {
	if activeDirectoryProperties_statusGenerator != nil {
		return activeDirectoryProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Status(generators)
	activeDirectoryProperties_statusGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_Status{}), generators)

	return activeDirectoryProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties_Status(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.AlphaString()
	gens["DomainGuid"] = gen.AlphaString()
	gens["DomainName"] = gen.AlphaString()
	gens["DomainSid"] = gen.AlphaString()
	gens["ForestName"] = gen.AlphaString()
	gens["NetBiosDomainName"] = gen.AlphaString()
}

func Test_EncryptionIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionIdentity_Spec to EncryptionIdentity_Spec via AssignPropertiesToEncryptionIdentity_Spec & AssignPropertiesFromEncryptionIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionIdentity_Spec, EncryptionIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionIdentity_Spec tests if a specific instance of EncryptionIdentity_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionIdentity_Spec(subject EncryptionIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionIdentity_Spec
	err := copied.AssignPropertiesToEncryptionIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionIdentity_Spec
	err = actual.AssignPropertiesFromEncryptionIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_Spec, EncryptionIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_Spec runs a test to see if a specific instance of EncryptionIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_Spec(subject EncryptionIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_Spec instances for property testing - lazily instantiated by
//EncryptionIdentity_SpecGenerator()
var encryptionIdentity_specGenerator gopter.Gen

// EncryptionIdentity_SpecGenerator returns a generator of EncryptionIdentity_Spec instances for property testing.
func EncryptionIdentity_SpecGenerator() gopter.Gen {
	if encryptionIdentity_specGenerator != nil {
		return encryptionIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	encryptionIdentity_specGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_Spec{}), generators)

	return encryptionIdentity_specGenerator
}

func Test_EncryptionIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionIdentity_Status to EncryptionIdentity_Status via AssignPropertiesToEncryptionIdentity_Status & AssignPropertiesFromEncryptionIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionIdentity_Status, EncryptionIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionIdentity_Status tests if a specific instance of EncryptionIdentity_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionIdentity_Status(subject EncryptionIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionIdentity_Status
	err := copied.AssignPropertiesToEncryptionIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionIdentity_Status
	err = actual.AssignPropertiesFromEncryptionIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity_Status, EncryptionIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity_Status runs a test to see if a specific instance of EncryptionIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity_Status(subject EncryptionIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_Status instances for property testing - lazily instantiated by
//EncryptionIdentity_StatusGenerator()
var encryptionIdentity_statusGenerator gopter.Gen

// EncryptionIdentity_StatusGenerator returns a generator of EncryptionIdentity_Status instances for property testing.
func EncryptionIdentity_StatusGenerator() gopter.Gen {
	if encryptionIdentity_statusGenerator != nil {
		return encryptionIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentity_Status(generators)
	encryptionIdentity_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_Status{}), generators)

	return encryptionIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionServices_Spec to EncryptionServices_Spec via AssignPropertiesToEncryptionServices_Spec & AssignPropertiesFromEncryptionServices_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionServices_Spec, EncryptionServices_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionServices_Spec tests if a specific instance of EncryptionServices_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionServices_Spec(subject EncryptionServices_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionServices_Spec
	err := copied.AssignPropertiesToEncryptionServices_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionServices_Spec
	err = actual.AssignPropertiesFromEncryptionServices_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionServices_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_Spec, EncryptionServices_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_Spec runs a test to see if a specific instance of EncryptionServices_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_Spec(subject EncryptionServices_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_Spec instances for property testing - lazily instantiated by
//EncryptionServices_SpecGenerator()
var encryptionServices_specGenerator gopter.Gen

// EncryptionServices_SpecGenerator returns a generator of EncryptionServices_Spec instances for property testing.
func EncryptionServices_SpecGenerator() gopter.Gen {
	if encryptionServices_specGenerator != nil {
		return encryptionServices_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_Spec(generators)
	encryptionServices_specGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_Spec{}), generators)

	return encryptionServices_specGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_Spec(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_SpecGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_SpecGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_SpecGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_SpecGenerator())
}

func Test_EncryptionServices_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionServices_Status to EncryptionServices_Status via AssignPropertiesToEncryptionServices_Status & AssignPropertiesFromEncryptionServices_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionServices_Status, EncryptionServices_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionServices_Status tests if a specific instance of EncryptionServices_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionServices_Status(subject EncryptionServices_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionServices_Status
	err := copied.AssignPropertiesToEncryptionServices_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionServices_Status
	err = actual.AssignPropertiesFromEncryptionServices_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionServices_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices_Status, EncryptionServices_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices_Status runs a test to see if a specific instance of EncryptionServices_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices_Status(subject EncryptionServices_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_Status instances for property testing - lazily instantiated by
//EncryptionServices_StatusGenerator()
var encryptionServices_statusGenerator gopter.Gen

// EncryptionServices_StatusGenerator returns a generator of EncryptionServices_Status instances for property testing.
func EncryptionServices_StatusGenerator() gopter.Gen {
	if encryptionServices_statusGenerator != nil {
		return encryptionServices_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices_Status(generators)
	encryptionServices_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_Status{}), generators)

	return encryptionServices_statusGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices_Status(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionService_StatusGenerator())
	gens["File"] = gen.PtrOf(EncryptionService_StatusGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionService_StatusGenerator())
	gens["Table"] = gen.PtrOf(EncryptionService_StatusGenerator())
}

func Test_IPRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPRule_Spec to IPRule_Spec via AssignPropertiesToIPRule_Spec & AssignPropertiesFromIPRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRule_Spec, IPRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRule_Spec tests if a specific instance of IPRule_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForIPRule_Spec(subject IPRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.IPRule_Spec
	err := copied.AssignPropertiesToIPRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule_Spec
	err = actual.AssignPropertiesFromIPRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_Spec, IPRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_Spec runs a test to see if a specific instance of IPRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_Spec(subject IPRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_Spec instances for property testing - lazily instantiated by IPRule_SpecGenerator()
var ipRule_specGenerator gopter.Gen

// IPRule_SpecGenerator returns a generator of IPRule_Spec instances for property testing.
func IPRule_SpecGenerator() gopter.Gen {
	if ipRule_specGenerator != nil {
		return ipRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_Spec(generators)
	ipRule_specGenerator = gen.Struct(reflect.TypeOf(IPRule_Spec{}), generators)

	return ipRule_specGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_Spec(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_SpecAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_IPRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPRule_Status to IPRule_Status via AssignPropertiesToIPRule_Status & AssignPropertiesFromIPRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRule_Status, IPRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRule_Status tests if a specific instance of IPRule_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForIPRule_Status(subject IPRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.IPRule_Status
	err := copied.AssignPropertiesToIPRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule_Status
	err = actual.AssignPropertiesFromIPRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_Status, IPRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_Status runs a test to see if a specific instance of IPRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_Status(subject IPRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_Status instances for property testing - lazily instantiated by IPRule_StatusGenerator()
var ipRule_statusGenerator gopter.Gen

// IPRule_StatusGenerator returns a generator of IPRule_Status instances for property testing.
func IPRule_StatusGenerator() gopter.Gen {
	if ipRule_statusGenerator != nil {
		return ipRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_Status(generators)
	ipRule_statusGenerator = gen.Struct(reflect.TypeOf(IPRule_Status{}), generators)

	return ipRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_Status(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_StatusAllow))
	gens["Value"] = gen.AlphaString()
}

func Test_KeyVaultProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Spec to KeyVaultProperties_Spec via AssignPropertiesToKeyVaultProperties_Spec & AssignPropertiesFromKeyVaultProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_Spec tests if a specific instance of KeyVaultProperties_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.KeyVaultProperties_Spec
	err := copied.AssignPropertiesToKeyVaultProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Spec
	err = actual.AssignPropertiesFromKeyVaultProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Spec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecGenerator()
var keyVaultProperties_specGenerator gopter.Gen

// KeyVaultProperties_SpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
func KeyVaultProperties_SpecGenerator() gopter.Gen {
	if keyVaultProperties_specGenerator != nil {
		return keyVaultProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	keyVaultProperties_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Status to KeyVaultProperties_Status via AssignPropertiesToKeyVaultProperties_Status & AssignPropertiesFromKeyVaultProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_Status tests if a specific instance of KeyVaultProperties_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.KeyVaultProperties_Status
	err := copied.AssignPropertiesToKeyVaultProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Status
	err = actual.AssignPropertiesFromKeyVaultProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Status runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultProperties_StatusGenerator()
var keyVaultProperties_statusGenerator gopter.Gen

// KeyVaultProperties_StatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
func KeyVaultProperties_StatusGenerator() gopter.Gen {
	if keyVaultProperties_statusGenerator != nil {
		return keyVaultProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(generators)
	keyVaultProperties_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceAccessRule_Spec to ResourceAccessRule_Spec via AssignPropertiesToResourceAccessRule_Spec & AssignPropertiesFromResourceAccessRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceAccessRule_Spec, ResourceAccessRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceAccessRule_Spec tests if a specific instance of ResourceAccessRule_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForResourceAccessRule_Spec(subject ResourceAccessRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ResourceAccessRule_Spec
	err := copied.AssignPropertiesToResourceAccessRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceAccessRule_Spec
	err = actual.AssignPropertiesFromResourceAccessRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceAccessRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_Spec, ResourceAccessRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_Spec runs a test to see if a specific instance of ResourceAccessRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_Spec(subject ResourceAccessRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_Spec instances for property testing - lazily instantiated by
//ResourceAccessRule_SpecGenerator()
var resourceAccessRule_specGenerator gopter.Gen

// ResourceAccessRule_SpecGenerator returns a generator of ResourceAccessRule_Spec instances for property testing.
func ResourceAccessRule_SpecGenerator() gopter.Gen {
	if resourceAccessRule_specGenerator != nil {
		return resourceAccessRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_Spec(generators)
	resourceAccessRule_specGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_Spec{}), generators)

	return resourceAccessRule_specGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_Spec(gens map[string]gopter.Gen) {
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceAccessRule_Status to ResourceAccessRule_Status via AssignPropertiesToResourceAccessRule_Status & AssignPropertiesFromResourceAccessRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceAccessRule_Status, ResourceAccessRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceAccessRule_Status tests if a specific instance of ResourceAccessRule_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForResourceAccessRule_Status(subject ResourceAccessRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.ResourceAccessRule_Status
	err := copied.AssignPropertiesToResourceAccessRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceAccessRule_Status
	err = actual.AssignPropertiesFromResourceAccessRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceAccessRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule_Status, ResourceAccessRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule_Status runs a test to see if a specific instance of ResourceAccessRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule_Status(subject ResourceAccessRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_Status instances for property testing - lazily instantiated by
//ResourceAccessRule_StatusGenerator()
var resourceAccessRule_statusGenerator gopter.Gen

// ResourceAccessRule_StatusGenerator returns a generator of ResourceAccessRule_Status instances for property testing.
func ResourceAccessRule_StatusGenerator() gopter.Gen {
	if resourceAccessRule_statusGenerator != nil {
		return resourceAccessRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule_Status(generators)
	resourceAccessRule_statusGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_Status{}), generators)

	return resourceAccessRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule_Status(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_Status to UserAssignedIdentity_Status via AssignPropertiesToUserAssignedIdentity_Status & AssignPropertiesFromUserAssignedIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_Status, UserAssignedIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_Status tests if a specific instance of UserAssignedIdentity_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_Status(subject UserAssignedIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.UserAssignedIdentity_Status
	err := copied.AssignPropertiesToUserAssignedIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_Status
	err = actual.AssignPropertiesFromUserAssignedIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_Status, UserAssignedIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_Status runs a test to see if a specific instance of UserAssignedIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_Status(subject UserAssignedIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_Status instances for property testing - lazily instantiated by
//UserAssignedIdentity_StatusGenerator()
var userAssignedIdentity_statusGenerator gopter.Gen

// UserAssignedIdentity_StatusGenerator returns a generator of UserAssignedIdentity_Status instances for property testing.
func UserAssignedIdentity_StatusGenerator() gopter.Gen {
	if userAssignedIdentity_statusGenerator != nil {
		return userAssignedIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_Status(generators)
	userAssignedIdentity_statusGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_Status{}), generators)

	return userAssignedIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Spec to VirtualNetworkRule_Spec via AssignPropertiesToVirtualNetworkRule_Spec & AssignPropertiesFromVirtualNetworkRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule_Spec, VirtualNetworkRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule_Spec tests if a specific instance of VirtualNetworkRule_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule_Spec(subject VirtualNetworkRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.VirtualNetworkRule_Spec
	err := copied.AssignPropertiesToVirtualNetworkRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Spec
	err = actual.AssignPropertiesFromVirtualNetworkRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Spec, VirtualNetworkRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Spec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Spec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRule_SpecGenerator()
var virtualNetworkRule_specGenerator gopter.Gen

// VirtualNetworkRule_SpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRule_SpecGenerator() gopter.Gen {
	if virtualNetworkRule_specGenerator != nil {
		return virtualNetworkRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(generators)
	virtualNetworkRule_specGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRule_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_Action_SpecAllow))
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_State_SpecDeprovisioning,
		VirtualNetworkRule_State_SpecFailed,
		VirtualNetworkRule_State_SpecNetworkSourceDeleted,
		VirtualNetworkRule_State_SpecProvisioning,
		VirtualNetworkRule_State_SpecSucceeded))
}

func Test_VirtualNetworkRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Status to VirtualNetworkRule_Status via AssignPropertiesToVirtualNetworkRule_Status & AssignPropertiesFromVirtualNetworkRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule_Status tests if a specific instance of VirtualNetworkRule_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.VirtualNetworkRule_Status
	err := copied.AssignPropertiesToVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Status
	err = actual.AssignPropertiesFromVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Status runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusGenerator()
var virtualNetworkRule_statusGenerator gopter.Gen

// VirtualNetworkRule_StatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRule_StatusGenerator() gopter.Gen {
	if virtualNetworkRule_statusGenerator != nil {
		return virtualNetworkRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(generators)
	virtualNetworkRule_statusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkRule_Action_StatusAllow))
	gens["Id"] = gen.AlphaString()
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkRule_State_StatusDeprovisioning,
		VirtualNetworkRule_State_StatusFailed,
		VirtualNetworkRule_State_StatusNetworkSourceDeleted,
		VirtualNetworkRule_State_StatusProvisioning,
		VirtualNetworkRule_State_StatusSucceeded))
}

func Test_EncryptionService_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionService_Spec to EncryptionService_Spec via AssignPropertiesToEncryptionService_Spec & AssignPropertiesFromEncryptionService_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionService_Spec, EncryptionService_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionService_Spec tests if a specific instance of EncryptionService_Spec can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionService_Spec(subject EncryptionService_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionService_Spec
	err := copied.AssignPropertiesToEncryptionService_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionService_Spec
	err = actual.AssignPropertiesFromEncryptionService_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionService_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_Spec, EncryptionService_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_Spec runs a test to see if a specific instance of EncryptionService_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_Spec(subject EncryptionService_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_Spec instances for property testing - lazily instantiated by
//EncryptionService_SpecGenerator()
var encryptionService_specGenerator gopter.Gen

// EncryptionService_SpecGenerator returns a generator of EncryptionService_Spec instances for property testing.
func EncryptionService_SpecGenerator() gopter.Gen {
	if encryptionService_specGenerator != nil {
		return encryptionService_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_Spec(generators)
	encryptionService_specGenerator = gen.Struct(reflect.TypeOf(EncryptionService_Spec{}), generators)

	return encryptionService_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_KeyType_SpecAccount, EncryptionService_KeyType_SpecService))
}

func Test_EncryptionService_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionService_Status to EncryptionService_Status via AssignPropertiesToEncryptionService_Status & AssignPropertiesFromEncryptionService_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionService_Status, EncryptionService_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionService_Status tests if a specific instance of EncryptionService_Status can be assigned to v1alpha1api20210401storage and back losslessly
func RunPropertyAssignmentTestForEncryptionService_Status(subject EncryptionService_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210401storage.EncryptionService_Status
	err := copied.AssignPropertiesToEncryptionService_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionService_Status
	err = actual.AssignPropertiesFromEncryptionService_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionService_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService_Status, EncryptionService_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService_Status runs a test to see if a specific instance of EncryptionService_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService_Status(subject EncryptionService_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_Status instances for property testing - lazily instantiated by
//EncryptionService_StatusGenerator()
var encryptionService_statusGenerator gopter.Gen

// EncryptionService_StatusGenerator returns a generator of EncryptionService_Status instances for property testing.
func EncryptionService_StatusGenerator() gopter.Gen {
	if encryptionService_statusGenerator != nil {
		return encryptionService_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService_Status(generators)
	encryptionService_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionService_Status{}), generators)

	return encryptionService_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.OneConstOf(EncryptionService_KeyType_StatusAccount, EncryptionService_KeyType_StatusService))
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
