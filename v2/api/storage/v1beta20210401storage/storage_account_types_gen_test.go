// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount, StorageAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount runs a test to see if a specific instance of StorageAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount(subject StorageAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount instances for property testing - lazily instantiated by StorageAccountGenerator()
var storageAccountGenerator gopter.Gen

// StorageAccountGenerator returns a generator of StorageAccount instances for property testing.
func StorageAccountGenerator() gopter.Gen {
	if storageAccountGenerator != nil {
		return storageAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccount(generators)
	storageAccountGenerator = gen.Struct(reflect.TypeOf(StorageAccount{}), generators)

	return storageAccountGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = StorageAccountsSpecGenerator()
	gens["Status"] = StorageAccountSTATUSGenerator()
}

func Test_StorageAccount_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountSTATUS, StorageAccountSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountSTATUS runs a test to see if a specific instance of StorageAccount_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountSTATUS(subject StorageAccount_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount_STATUS instances for property testing - lazily instantiated by
// StorageAccountSTATUSGenerator()
var storageAccountSTATUSGenerator gopter.Gen

// StorageAccountSTATUSGenerator returns a generator of StorageAccount_STATUS instances for property testing.
// We first initialize storageAccountSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountSTATUSGenerator() gopter.Gen {
	if storageAccountSTATUSGenerator != nil {
		return storageAccountSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountSTATUS(generators)
	storageAccountSTATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountSTATUS(generators)
	AddRelatedPropertyGeneratorsForStorageAccountSTATUS(generators)
	storageAccountSTATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccount_STATUS{}), generators)

	return storageAccountSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountSTATUS(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.AlphaString())
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["CreationTime"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverInProgress"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.AlphaString())
	gens["LastGeoFailoverTime"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["SecondaryLocation"] = gen.PtrOf(gen.AlphaString())
	gens["StatusOfPrimary"] = gen.PtrOf(gen.AlphaString())
	gens["StatusOfSecondary"] = gen.PtrOf(gen.AlphaString())
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountSTATUS(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationSTATUSGenerator())
	gens["BlobRestoreStatus"] = gen.PtrOf(BlobRestoreStatusSTATUSGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainSTATUSGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionSTATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSGenerator())
	gens["GeoReplicationStats"] = gen.PtrOf(GeoReplicationStatsSTATUSGenerator())
	gens["Identity"] = gen.PtrOf(IdentitySTATUSGenerator())
	gens["KeyCreationTime"] = gen.PtrOf(KeyCreationTimeSTATUSGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicySTATUSGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetSTATUSGenerator())
	gens["PrimaryEndpoints"] = gen.PtrOf(EndpointsSTATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceSTATUSGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicySTATUSGenerator())
	gens["SecondaryEndpoints"] = gen.PtrOf(EndpointsSTATUSGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSGenerator())
}

func Test_StorageAccounts_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsSpec, StorageAccountsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsSpec runs a test to see if a specific instance of StorageAccounts_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsSpec(subject StorageAccounts_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_Spec instances for property testing - lazily instantiated by
// StorageAccountsSpecGenerator()
var storageAccountsSpecGenerator gopter.Gen

// StorageAccountsSpecGenerator returns a generator of StorageAccounts_Spec instances for property testing.
// We first initialize storageAccountsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsSpecGenerator() gopter.Gen {
	if storageAccountsSpecGenerator != nil {
		return storageAccountsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSpec(generators)
	storageAccountsSpecGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSpec(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsSpec(generators)
	storageAccountsSpecGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_Spec{}), generators)

	return storageAccountsSpecGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsSpec(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.AlphaString())
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsSpec(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["OperatorSpec"] = gen.PtrOf(StorageAccountOperatorSpecGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication, AzureFilesIdentityBasedAuthenticationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthentication(subject AzureFilesIdentityBasedAuthentication) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthenticationGenerator()
var azureFilesIdentityBasedAuthenticationGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationGenerator returns a generator of AzureFilesIdentityBasedAuthentication instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationGenerator != nil {
		return azureFilesIdentityBasedAuthenticationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication(generators)
	azureFilesIdentityBasedAuthenticationGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication(generators)
	azureFilesIdentityBasedAuthenticationGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication{}), generators)

	return azureFilesIdentityBasedAuthenticationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthentication(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.AlphaString())
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthentication(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUS, AzureFilesIdentityBasedAuthenticationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUS runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSTATUS(subject AzureFilesIdentityBasedAuthentication_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_STATUS instances for property testing - lazily instantiated by
// AzureFilesIdentityBasedAuthenticationSTATUSGenerator()
var azureFilesIdentityBasedAuthenticationSTATUSGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationSTATUSGenerator returns a generator of AzureFilesIdentityBasedAuthentication_STATUS instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationSTATUSGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationSTATUSGenerator != nil {
		return azureFilesIdentityBasedAuthenticationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS(generators)
	azureFilesIdentityBasedAuthenticationSTATUSGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS(generators)
	azureFilesIdentityBasedAuthenticationSTATUSGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_STATUS{}), generators)

	return azureFilesIdentityBasedAuthenticationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.AlphaString())
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSTATUS(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesSTATUSGenerator())
}

func Test_BlobRestoreStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreStatusSTATUS, BlobRestoreStatusSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreStatusSTATUS runs a test to see if a specific instance of BlobRestoreStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreStatusSTATUS(subject BlobRestoreStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreStatus_STATUS instances for property testing - lazily instantiated by
// BlobRestoreStatusSTATUSGenerator()
var blobRestoreStatusSTATUSGenerator gopter.Gen

// BlobRestoreStatusSTATUSGenerator returns a generator of BlobRestoreStatus_STATUS instances for property testing.
// We first initialize blobRestoreStatusSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreStatusSTATUSGenerator() gopter.Gen {
	if blobRestoreStatusSTATUSGenerator != nil {
		return blobRestoreStatusSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUS(generators)
	blobRestoreStatusSTATUSGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUS(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUS(generators)
	blobRestoreStatusSTATUSGenerator = gen.Struct(reflect.TypeOf(BlobRestoreStatus_STATUS{}), generators)

	return blobRestoreStatusSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreStatusSTATUS(gens map[string]gopter.Gen) {
	gens["FailureReason"] = gen.PtrOf(gen.AlphaString())
	gens["RestoreId"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreStatusSTATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(BlobRestoreParametersSTATUSGenerator())
}

func Test_CustomDomain_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain runs a test to see if a specific instance of CustomDomain round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain(subject CustomDomain) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain instances for property testing - lazily instantiated by CustomDomainGenerator()
var customDomainGenerator gopter.Gen

// CustomDomainGenerator returns a generator of CustomDomain instances for property testing.
func CustomDomainGenerator() gopter.Gen {
	if customDomainGenerator != nil {
		return customDomainGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain(generators)
	customDomainGenerator = gen.Struct(reflect.TypeOf(CustomDomain{}), generators)

	return customDomainGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_CustomDomain_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainSTATUS, CustomDomainSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainSTATUS runs a test to see if a specific instance of CustomDomain_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainSTATUS(subject CustomDomain_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUS instances for property testing - lazily instantiated by CustomDomainSTATUSGenerator()
var customDomainSTATUSGenerator gopter.Gen

// CustomDomainSTATUSGenerator returns a generator of CustomDomain_STATUS instances for property testing.
func CustomDomainSTATUSGenerator() gopter.Gen {
	if customDomainSTATUSGenerator != nil {
		return customDomainSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSTATUS(generators)
	customDomainSTATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS{}), generators)

	return customDomainSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption, EncryptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption runs a test to see if a specific instance of Encryption round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption(subject Encryption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption instances for property testing - lazily instantiated by EncryptionGenerator()
var encryptionGenerator gopter.Gen

// EncryptionGenerator returns a generator of Encryption instances for property testing.
// We first initialize encryptionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionGenerator() gopter.Gen {
	if encryptionGenerator != nil {
		return encryptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	AddRelatedPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	return encryptionGenerator
}

// AddIndependentPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesGenerator())
}

func Test_Encryption_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSTATUS, EncryptionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSTATUS runs a test to see if a specific instance of Encryption_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSTATUS(subject Encryption_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUS instances for property testing - lazily instantiated by EncryptionSTATUSGenerator()
var encryptionSTATUSGenerator gopter.Gen

// EncryptionSTATUSGenerator returns a generator of Encryption_STATUS instances for property testing.
// We first initialize encryptionSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSTATUSGenerator() gopter.Gen {
	if encryptionSTATUSGenerator != nil {
		return encryptionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSTATUS(generators)
	encryptionSTATUSGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSTATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionSTATUS(generators)
	encryptionSTATUSGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUS{}), generators)

	return encryptionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSTATUS(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSTATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentitySTATUSGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesSTATUSGenerator())
}

func Test_Endpoints_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Endpoints_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointsSTATUS, EndpointsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointsSTATUS runs a test to see if a specific instance of Endpoints_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointsSTATUS(subject Endpoints_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Endpoints_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Endpoints_STATUS instances for property testing - lazily instantiated by EndpointsSTATUSGenerator()
var endpointsSTATUSGenerator gopter.Gen

// EndpointsSTATUSGenerator returns a generator of Endpoints_STATUS instances for property testing.
// We first initialize endpointsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointsSTATUSGenerator() gopter.Gen {
	if endpointsSTATUSGenerator != nil {
		return endpointsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSTATUS(generators)
	endpointsSTATUSGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSTATUS(generators)
	AddRelatedPropertyGeneratorsForEndpointsSTATUS(generators)
	endpointsSTATUSGenerator = gen.Struct(reflect.TypeOf(Endpoints_STATUS{}), generators)

	return endpointsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointsSTATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointsSTATUS(gens map[string]gopter.Gen) {
	gens["InternetEndpoints"] = gen.PtrOf(StorageAccountInternetEndpointsSTATUSGenerator())
	gens["MicrosoftEndpoints"] = gen.PtrOf(StorageAccountMicrosoftEndpointsSTATUSGenerator())
}

func Test_ExtendedLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation runs a test to see if a specific instance of ExtendedLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation(subject ExtendedLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation instances for property testing - lazily instantiated by ExtendedLocationGenerator()
var extendedLocationGenerator gopter.Gen

// ExtendedLocationGenerator returns a generator of ExtendedLocation instances for property testing.
func ExtendedLocationGenerator() gopter.Gen {
	if extendedLocationGenerator != nil {
		return extendedLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation(generators)
	extendedLocationGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation{}), generators)

	return extendedLocationGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSTATUS, ExtendedLocationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSTATUS runs a test to see if a specific instance of ExtendedLocation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSTATUS(subject ExtendedLocation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUS instances for property testing - lazily instantiated by
// ExtendedLocationSTATUSGenerator()
var extendedLocationSTATUSGenerator gopter.Gen

// ExtendedLocationSTATUSGenerator returns a generator of ExtendedLocation_STATUS instances for property testing.
func ExtendedLocationSTATUSGenerator() gopter.Gen {
	if extendedLocationSTATUSGenerator != nil {
		return extendedLocationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSTATUS(generators)
	extendedLocationSTATUSGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUS{}), generators)

	return extendedLocationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoReplicationStats_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoReplicationStats_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoReplicationStatsSTATUS, GeoReplicationStatsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoReplicationStatsSTATUS runs a test to see if a specific instance of GeoReplicationStats_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoReplicationStatsSTATUS(subject GeoReplicationStats_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoReplicationStats_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoReplicationStats_STATUS instances for property testing - lazily instantiated by
// GeoReplicationStatsSTATUSGenerator()
var geoReplicationStatsSTATUSGenerator gopter.Gen

// GeoReplicationStatsSTATUSGenerator returns a generator of GeoReplicationStats_STATUS instances for property testing.
func GeoReplicationStatsSTATUSGenerator() gopter.Gen {
	if geoReplicationStatsSTATUSGenerator != nil {
		return geoReplicationStatsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUS(generators)
	geoReplicationStatsSTATUSGenerator = gen.Struct(reflect.TypeOf(GeoReplicationStats_STATUS{}), generators)

	return geoReplicationStatsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoReplicationStatsSTATUS(gens map[string]gopter.Gen) {
	gens["CanFailover"] = gen.PtrOf(gen.Bool())
	gens["LastSyncTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentitySTATUS, IdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentitySTATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentitySTATUS(subject Identity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUS instances for property testing - lazily instantiated by IdentitySTATUSGenerator()
var identitySTATUSGenerator gopter.Gen

// IdentitySTATUSGenerator returns a generator of Identity_STATUS instances for property testing.
// We first initialize identitySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentitySTATUSGenerator() gopter.Gen {
	if identitySTATUSGenerator != nil {
		return identitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUS(generators)
	identitySTATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUS(generators)
	AddRelatedPropertyGeneratorsForIdentitySTATUS(generators)
	identitySTATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIdentitySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentitySTATUSGenerator())
}

func Test_KeyCreationTime_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyCreationTime_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyCreationTimeSTATUS, KeyCreationTimeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyCreationTimeSTATUS runs a test to see if a specific instance of KeyCreationTime_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyCreationTimeSTATUS(subject KeyCreationTime_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyCreationTime_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyCreationTime_STATUS instances for property testing - lazily instantiated by
// KeyCreationTimeSTATUSGenerator()
var keyCreationTimeSTATUSGenerator gopter.Gen

// KeyCreationTimeSTATUSGenerator returns a generator of KeyCreationTime_STATUS instances for property testing.
func KeyCreationTimeSTATUSGenerator() gopter.Gen {
	if keyCreationTimeSTATUSGenerator != nil {
		return keyCreationTimeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUS(generators)
	keyCreationTimeSTATUSGenerator = gen.Struct(reflect.TypeOf(KeyCreationTime_STATUS{}), generators)

	return keyCreationTimeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyCreationTimeSTATUS(gens map[string]gopter.Gen) {
	gens["Key1"] = gen.PtrOf(gen.AlphaString())
	gens["Key2"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicy, KeyPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicy runs a test to see if a specific instance of KeyPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicy(subject KeyPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy instances for property testing - lazily instantiated by KeyPolicyGenerator()
var keyPolicyGenerator gopter.Gen

// KeyPolicyGenerator returns a generator of KeyPolicy instances for property testing.
func KeyPolicyGenerator() gopter.Gen {
	if keyPolicyGenerator != nil {
		return keyPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicy(generators)
	keyPolicyGenerator = gen.Struct(reflect.TypeOf(KeyPolicy{}), generators)

	return keyPolicyGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicy(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_KeyPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicySTATUS, KeyPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicySTATUS runs a test to see if a specific instance of KeyPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicySTATUS(subject KeyPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_STATUS instances for property testing - lazily instantiated by KeyPolicySTATUSGenerator()
var keyPolicySTATUSGenerator gopter.Gen

// KeyPolicySTATUSGenerator returns a generator of KeyPolicy_STATUS instances for property testing.
func KeyPolicySTATUSGenerator() gopter.Gen {
	if keyPolicySTATUSGenerator != nil {
		return keyPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicySTATUS(generators)
	keyPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_STATUS{}), generators)

	return keyPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicySTATUS(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet runs a test to see if a specific instance of NetworkRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet instances for property testing - lazily instantiated by NetworkRuleSetGenerator()
var networkRuleSetGenerator gopter.Gen

// NetworkRuleSetGenerator returns a generator of NetworkRuleSet instances for property testing.
// We first initialize networkRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetGenerator() gopter.Gen {
	if networkRuleSetGenerator != nil {
		return networkRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	return networkRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleGenerator())
}

func Test_NetworkRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSTATUS, NetworkRuleSetSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSTATUS runs a test to see if a specific instance of NetworkRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSTATUS(subject NetworkRuleSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSetSTATUSGenerator()
var networkRuleSetSTATUSGenerator gopter.Gen

// NetworkRuleSetSTATUSGenerator returns a generator of NetworkRuleSet_STATUS instances for property testing.
// We first initialize networkRuleSetSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSTATUSGenerator() gopter.Gen {
	if networkRuleSetSTATUSGenerator != nil {
		return networkRuleSetSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	networkRuleSetSTATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	networkRuleSetSTATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	return networkRuleSetSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSTATUSGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleSTATUSGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSTATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded, PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()
var privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing.
func PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator != nil {
		return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbedded{}), generators)

	return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreference, RoutingPreferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreference runs a test to see if a specific instance of RoutingPreference round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreference(subject RoutingPreference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference instances for property testing - lazily instantiated by RoutingPreferenceGenerator()
var routingPreferenceGenerator gopter.Gen

// RoutingPreferenceGenerator returns a generator of RoutingPreference instances for property testing.
func RoutingPreferenceGenerator() gopter.Gen {
	if routingPreferenceGenerator != nil {
		return routingPreferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreference(generators)
	routingPreferenceGenerator = gen.Struct(reflect.TypeOf(RoutingPreference{}), generators)

	return routingPreferenceGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreference(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceSTATUS, RoutingPreferenceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceSTATUS runs a test to see if a specific instance of RoutingPreference_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceSTATUS(subject RoutingPreference_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_STATUS instances for property testing - lazily instantiated by
// RoutingPreferenceSTATUSGenerator()
var routingPreferenceSTATUSGenerator gopter.Gen

// RoutingPreferenceSTATUSGenerator returns a generator of RoutingPreference_STATUS instances for property testing.
func RoutingPreferenceSTATUSGenerator() gopter.Gen {
	if routingPreferenceSTATUSGenerator != nil {
		return routingPreferenceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUS(generators)
	routingPreferenceSTATUSGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_STATUS{}), generators)

	return routingPreferenceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceSTATUS(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.AlphaString())
}

func Test_SasPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicy, SasPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicy runs a test to see if a specific instance of SasPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicy(subject SasPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy instances for property testing - lazily instantiated by SasPolicyGenerator()
var sasPolicyGenerator gopter.Gen

// SasPolicyGenerator returns a generator of SasPolicy instances for property testing.
func SasPolicyGenerator() gopter.Gen {
	if sasPolicyGenerator != nil {
		return sasPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicy(generators)
	sasPolicyGenerator = gen.Struct(reflect.TypeOf(SasPolicy{}), generators)

	return sasPolicyGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicy(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.AlphaString())
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_SasPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicySTATUS, SasPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicySTATUS runs a test to see if a specific instance of SasPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicySTATUS(subject SasPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_STATUS instances for property testing - lazily instantiated by SasPolicySTATUSGenerator()
var sasPolicySTATUSGenerator gopter.Gen

// SasPolicySTATUSGenerator returns a generator of SasPolicy_STATUS instances for property testing.
func SasPolicySTATUSGenerator() gopter.Gen {
	if sasPolicySTATUSGenerator != nil {
		return sasPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicySTATUS(generators)
	sasPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(SasPolicy_STATUS{}), generators)

	return sasPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicySTATUS(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.AlphaString())
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSTATUS, SkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by SkuSTATUSGenerator()
var skuSTATUSGenerator gopter.Gen

// SkuSTATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func SkuSTATUSGenerator() gopter.Gen {
	if skuSTATUSGenerator != nil {
		return skuSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUS(generators)
	skuSTATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return skuSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountOperatorSpec, StorageAccountOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountOperatorSpec runs a test to see if a specific instance of StorageAccountOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountOperatorSpec(subject StorageAccountOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountOperatorSpec instances for property testing - lazily instantiated by
// StorageAccountOperatorSpecGenerator()
var storageAccountOperatorSpecGenerator gopter.Gen

// StorageAccountOperatorSpecGenerator returns a generator of StorageAccountOperatorSpec instances for property testing.
func StorageAccountOperatorSpecGenerator() gopter.Gen {
	if storageAccountOperatorSpecGenerator != nil {
		return storageAccountOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccountOperatorSpec(generators)
	storageAccountOperatorSpecGenerator = gen.Struct(reflect.TypeOf(StorageAccountOperatorSpec{}), generators)

	return storageAccountOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccountOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(StorageAccountOperatorSecretsGenerator())
}

func Test_ActiveDirectoryProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryProperties, ActiveDirectoryPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryProperties runs a test to see if a specific instance of ActiveDirectoryProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryProperties(subject ActiveDirectoryProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties instances for property testing - lazily instantiated by
// ActiveDirectoryPropertiesGenerator()
var activeDirectoryPropertiesGenerator gopter.Gen

// ActiveDirectoryPropertiesGenerator returns a generator of ActiveDirectoryProperties instances for property testing.
func ActiveDirectoryPropertiesGenerator() gopter.Gen {
	if activeDirectoryPropertiesGenerator != nil {
		return activeDirectoryPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryProperties(generators)
	activeDirectoryPropertiesGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties{}), generators)

	return activeDirectoryPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryProperties(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesSTATUS, ActiveDirectoryPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesSTATUS runs a test to see if a specific instance of ActiveDirectoryProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesSTATUS(subject ActiveDirectoryProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_STATUS instances for property testing - lazily instantiated by
// ActiveDirectoryPropertiesSTATUSGenerator()
var activeDirectoryPropertiesSTATUSGenerator gopter.Gen

// ActiveDirectoryPropertiesSTATUSGenerator returns a generator of ActiveDirectoryProperties_STATUS instances for property testing.
func ActiveDirectoryPropertiesSTATUSGenerator() gopter.Gen {
	if activeDirectoryPropertiesSTATUSGenerator != nil {
		return activeDirectoryPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUS(generators)
	activeDirectoryPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_STATUS{}), generators)

	return activeDirectoryPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSTATUS(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobRestoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreParametersSTATUS, BlobRestoreParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreParametersSTATUS runs a test to see if a specific instance of BlobRestoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreParametersSTATUS(subject BlobRestoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreParameters_STATUS instances for property testing - lazily instantiated by
// BlobRestoreParametersSTATUSGenerator()
var blobRestoreParametersSTATUSGenerator gopter.Gen

// BlobRestoreParametersSTATUSGenerator returns a generator of BlobRestoreParameters_STATUS instances for property testing.
// We first initialize blobRestoreParametersSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BlobRestoreParametersSTATUSGenerator() gopter.Gen {
	if blobRestoreParametersSTATUSGenerator != nil {
		return blobRestoreParametersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUS(generators)
	blobRestoreParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUS(generators)
	AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUS(generators)
	blobRestoreParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(BlobRestoreParameters_STATUS{}), generators)

	return blobRestoreParametersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreParametersSTATUS(gens map[string]gopter.Gen) {
	gens["TimeToRestore"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBlobRestoreParametersSTATUS(gens map[string]gopter.Gen) {
	gens["BlobRanges"] = gen.SliceOf(BlobRestoreRangeSTATUSGenerator())
}

func Test_EncryptionIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentity, EncryptionIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentity runs a test to see if a specific instance of EncryptionIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentity(subject EncryptionIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity instances for property testing - lazily instantiated by EncryptionIdentityGenerator()
var encryptionIdentityGenerator gopter.Gen

// EncryptionIdentityGenerator returns a generator of EncryptionIdentity instances for property testing.
func EncryptionIdentityGenerator() gopter.Gen {
	if encryptionIdentityGenerator != nil {
		return encryptionIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	encryptionIdentityGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity{}), generators)

	return encryptionIdentityGenerator
}

func Test_EncryptionIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentitySTATUS, EncryptionIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentitySTATUS runs a test to see if a specific instance of EncryptionIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentitySTATUS(subject EncryptionIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_STATUS instances for property testing - lazily instantiated by
// EncryptionIdentitySTATUSGenerator()
var encryptionIdentitySTATUSGenerator gopter.Gen

// EncryptionIdentitySTATUSGenerator returns a generator of EncryptionIdentity_STATUS instances for property testing.
func EncryptionIdentitySTATUSGenerator() gopter.Gen {
	if encryptionIdentitySTATUSGenerator != nil {
		return encryptionIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUS(generators)
	encryptionIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_STATUS{}), generators)

	return encryptionIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServices, EncryptionServicesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServices runs a test to see if a specific instance of EncryptionServices round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServices(subject EncryptionServices) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices instances for property testing - lazily instantiated by EncryptionServicesGenerator()
var encryptionServicesGenerator gopter.Gen

// EncryptionServicesGenerator returns a generator of EncryptionServices instances for property testing.
func EncryptionServicesGenerator() gopter.Gen {
	if encryptionServicesGenerator != nil {
		return encryptionServicesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServices(generators)
	encryptionServicesGenerator = gen.Struct(reflect.TypeOf(EncryptionServices{}), generators)

	return encryptionServicesGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServices is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServices(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceGenerator())
}

func Test_EncryptionServices_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesSTATUS, EncryptionServicesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesSTATUS runs a test to see if a specific instance of EncryptionServices_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesSTATUS(subject EncryptionServices_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_STATUS instances for property testing - lazily instantiated by
// EncryptionServicesSTATUSGenerator()
var encryptionServicesSTATUSGenerator gopter.Gen

// EncryptionServicesSTATUSGenerator returns a generator of EncryptionServices_STATUS instances for property testing.
func EncryptionServicesSTATUSGenerator() gopter.Gen {
	if encryptionServicesSTATUSGenerator != nil {
		return encryptionServicesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesSTATUS(generators)
	encryptionServicesSTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_STATUS{}), generators)

	return encryptionServicesSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesSTATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceSTATUSGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceSTATUSGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceSTATUSGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceSTATUSGenerator())
}

func Test_IPRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule, IPRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule runs a test to see if a specific instance of IPRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule(subject IPRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule instances for property testing - lazily instantiated by IPRuleGenerator()
var ipRuleGenerator gopter.Gen

// IPRuleGenerator returns a generator of IPRule instances for property testing.
func IPRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IPRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIPRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSTATUS, IPRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSTATUS runs a test to see if a specific instance of IPRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSTATUS(subject IPRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUS instances for property testing - lazily instantiated by IPRuleSTATUSGenerator()
var ipRuleSTATUSGenerator gopter.Gen

// IPRuleSTATUSGenerator returns a generator of IPRule_STATUS instances for property testing.
func IPRuleSTATUSGenerator() gopter.Gen {
	if ipRuleSTATUSGenerator != nil {
		return ipRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSTATUS(generators)
	ipRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUS{}), generators)

	return ipRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties runs a test to see if a specific instance of KeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties instances for property testing - lazily instantiated by KeyVaultPropertiesGenerator()
var keyVaultPropertiesGenerator gopter.Gen

// KeyVaultPropertiesGenerator returns a generator of KeyVaultProperties instances for property testing.
func KeyVaultPropertiesGenerator() gopter.Gen {
	if keyVaultPropertiesGenerator != nil {
		return keyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties(generators)
	keyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties{}), generators)

	return keyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUS, KeyVaultPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUS(subject KeyVaultProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUS instances for property testing - lazily instantiated by
// KeyVaultPropertiesSTATUSGenerator()
var keyVaultPropertiesSTATUSGenerator gopter.Gen

// KeyVaultPropertiesSTATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultPropertiesSTATUSGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSGenerator != nil {
		return keyVaultPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(generators)
	keyVaultPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRule, ResourceAccessRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRule runs a test to see if a specific instance of ResourceAccessRule round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRule(subject ResourceAccessRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule instances for property testing - lazily instantiated by ResourceAccessRuleGenerator()
var resourceAccessRuleGenerator gopter.Gen

// ResourceAccessRuleGenerator returns a generator of ResourceAccessRule instances for property testing.
func ResourceAccessRuleGenerator() gopter.Gen {
	if resourceAccessRuleGenerator != nil {
		return resourceAccessRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRule(generators)
	resourceAccessRuleGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule{}), generators)

	return resourceAccessRuleGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRule(gens map[string]gopter.Gen) {
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleSTATUS, ResourceAccessRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleSTATUS runs a test to see if a specific instance of ResourceAccessRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleSTATUS(subject ResourceAccessRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_STATUS instances for property testing - lazily instantiated by
// ResourceAccessRuleSTATUSGenerator()
var resourceAccessRuleSTATUSGenerator gopter.Gen

// ResourceAccessRuleSTATUSGenerator returns a generator of ResourceAccessRule_STATUS instances for property testing.
func ResourceAccessRuleSTATUSGenerator() gopter.Gen {
	if resourceAccessRuleSTATUSGenerator != nil {
		return resourceAccessRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUS(generators)
	resourceAccessRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_STATUS{}), generators)

	return resourceAccessRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleSTATUS(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountInternetEndpoints_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountInternetEndpoints_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUS, StorageAccountInternetEndpointsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUS runs a test to see if a specific instance of StorageAccountInternetEndpoints_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountInternetEndpointsSTATUS(subject StorageAccountInternetEndpoints_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountInternetEndpoints_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountInternetEndpoints_STATUS instances for property testing - lazily instantiated by
// StorageAccountInternetEndpointsSTATUSGenerator()
var storageAccountInternetEndpointsSTATUSGenerator gopter.Gen

// StorageAccountInternetEndpointsSTATUSGenerator returns a generator of StorageAccountInternetEndpoints_STATUS instances for property testing.
func StorageAccountInternetEndpointsSTATUSGenerator() gopter.Gen {
	if storageAccountInternetEndpointsSTATUSGenerator != nil {
		return storageAccountInternetEndpointsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUS(generators)
	storageAccountInternetEndpointsSTATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccountInternetEndpoints_STATUS{}), generators)

	return storageAccountInternetEndpointsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountInternetEndpointsSTATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountMicrosoftEndpoints_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountMicrosoftEndpoints_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUS, StorageAccountMicrosoftEndpointsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUS runs a test to see if a specific instance of StorageAccountMicrosoftEndpoints_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountMicrosoftEndpointsSTATUS(subject StorageAccountMicrosoftEndpoints_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountMicrosoftEndpoints_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountMicrosoftEndpoints_STATUS instances for property testing - lazily instantiated by
// StorageAccountMicrosoftEndpointsSTATUSGenerator()
var storageAccountMicrosoftEndpointsSTATUSGenerator gopter.Gen

// StorageAccountMicrosoftEndpointsSTATUSGenerator returns a generator of StorageAccountMicrosoftEndpoints_STATUS instances for property testing.
func StorageAccountMicrosoftEndpointsSTATUSGenerator() gopter.Gen {
	if storageAccountMicrosoftEndpointsSTATUSGenerator != nil {
		return storageAccountMicrosoftEndpointsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUS(generators)
	storageAccountMicrosoftEndpointsSTATUSGenerator = gen.Struct(reflect.TypeOf(StorageAccountMicrosoftEndpoints_STATUS{}), generators)

	return storageAccountMicrosoftEndpointsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountMicrosoftEndpointsSTATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(gen.AlphaString())
	gens["Dfs"] = gen.PtrOf(gen.AlphaString())
	gens["File"] = gen.PtrOf(gen.AlphaString())
	gens["Queue"] = gen.PtrOf(gen.AlphaString())
	gens["Table"] = gen.PtrOf(gen.AlphaString())
	gens["Web"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageAccountOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountOperatorSecrets, StorageAccountOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountOperatorSecrets runs a test to see if a specific instance of StorageAccountOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountOperatorSecrets(subject StorageAccountOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountOperatorSecrets instances for property testing - lazily instantiated by
// StorageAccountOperatorSecretsGenerator()
var storageAccountOperatorSecretsGenerator gopter.Gen

// StorageAccountOperatorSecretsGenerator returns a generator of StorageAccountOperatorSecrets instances for property testing.
func StorageAccountOperatorSecretsGenerator() gopter.Gen {
	if storageAccountOperatorSecretsGenerator != nil {
		return storageAccountOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	storageAccountOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(StorageAccountOperatorSecrets{}), generators)

	return storageAccountOperatorSecretsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySTATUS, UserAssignedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySTATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySTATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentitySTATUSGenerator()
var userAssignedIdentitySTATUSGenerator gopter.Gen

// UserAssignedIdentitySTATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentitySTATUSGenerator() gopter.Gen {
	if userAssignedIdentitySTATUSGenerator != nil {
		return userAssignedIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(generators)
	userAssignedIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule runs a test to see if a specific instance of VirtualNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule instances for property testing - lazily instantiated by VirtualNetworkRuleGenerator()
var virtualNetworkRuleGenerator gopter.Gen

// VirtualNetworkRuleGenerator returns a generator of VirtualNetworkRule instances for property testing.
func VirtualNetworkRuleGenerator() gopter.Gen {
	if virtualNetworkRuleGenerator != nil {
		return virtualNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule(generators)
	virtualNetworkRuleGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule{}), generators)

	return virtualNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSTATUS, VirtualNetworkRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSTATUS runs a test to see if a specific instance of VirtualNetworkRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSTATUS(subject VirtualNetworkRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUS instances for property testing - lazily instantiated by
// VirtualNetworkRuleSTATUSGenerator()
var virtualNetworkRuleSTATUSGenerator gopter.Gen

// VirtualNetworkRuleSTATUSGenerator returns a generator of VirtualNetworkRule_STATUS instances for property testing.
func VirtualNetworkRuleSTATUSGenerator() gopter.Gen {
	if virtualNetworkRuleSTATUSGenerator != nil {
		return virtualNetworkRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUS(generators)
	virtualNetworkRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUS{}), generators)

	return virtualNetworkRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobRestoreRange_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobRestoreRange_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobRestoreRangeSTATUS, BlobRestoreRangeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobRestoreRangeSTATUS runs a test to see if a specific instance of BlobRestoreRange_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobRestoreRangeSTATUS(subject BlobRestoreRange_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobRestoreRange_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobRestoreRange_STATUS instances for property testing - lazily instantiated by
// BlobRestoreRangeSTATUSGenerator()
var blobRestoreRangeSTATUSGenerator gopter.Gen

// BlobRestoreRangeSTATUSGenerator returns a generator of BlobRestoreRange_STATUS instances for property testing.
func BlobRestoreRangeSTATUSGenerator() gopter.Gen {
	if blobRestoreRangeSTATUSGenerator != nil {
		return blobRestoreRangeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUS(generators)
	blobRestoreRangeSTATUSGenerator = gen.Struct(reflect.TypeOf(BlobRestoreRange_STATUS{}), generators)

	return blobRestoreRangeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobRestoreRangeSTATUS(gens map[string]gopter.Gen) {
	gens["EndRange"] = gen.PtrOf(gen.AlphaString())
	gens["StartRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionService, EncryptionServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionService runs a test to see if a specific instance of EncryptionService round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionService(subject EncryptionService) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService instances for property testing - lazily instantiated by EncryptionServiceGenerator()
var encryptionServiceGenerator gopter.Gen

// EncryptionServiceGenerator returns a generator of EncryptionService instances for property testing.
func EncryptionServiceGenerator() gopter.Gen {
	if encryptionServiceGenerator != nil {
		return encryptionServiceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionService(generators)
	encryptionServiceGenerator = gen.Struct(reflect.TypeOf(EncryptionService{}), generators)

	return encryptionServiceGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionService is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionService(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceSTATUS, EncryptionServiceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceSTATUS runs a test to see if a specific instance of EncryptionService_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceSTATUS(subject EncryptionService_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_STATUS instances for property testing - lazily instantiated by
// EncryptionServiceSTATUSGenerator()
var encryptionServiceSTATUSGenerator gopter.Gen

// EncryptionServiceSTATUSGenerator returns a generator of EncryptionService_STATUS instances for property testing.
func EncryptionServiceSTATUSGenerator() gopter.Gen {
	if encryptionServiceSTATUSGenerator != nil {
		return encryptionServiceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceSTATUS(generators)
	encryptionServiceSTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionService_STATUS{}), generators)

	return encryptionServiceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceSTATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.AlphaString())
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
