// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_StorageAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccount, StorageAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccount runs a test to see if a specific instance of StorageAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccount(subject StorageAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccount instances for property testing - lazily instantiated by StorageAccountGenerator()
var storageAccountGenerator gopter.Gen

// StorageAccountGenerator returns a generator of StorageAccount instances for property testing.
func StorageAccountGenerator() gopter.Gen {
	if storageAccountGenerator != nil {
		return storageAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccount(generators)
	storageAccountGenerator = gen.Struct(reflect.TypeOf(StorageAccount{}), generators)

	return storageAccountGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = StorageAccountsSPECGenerator()
	gens["Status"] = StorageAccountCreateParametersStatusGenerator()
}

func Test_StorageAccountCreateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountCreateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountCreateParametersStatus, StorageAccountCreateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountCreateParametersStatus runs a test to see if a specific instance of StorageAccountCreateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountCreateParametersStatus(subject StorageAccountCreateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountCreateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountCreateParameters_Status instances for property testing - lazily instantiated by
//StorageAccountCreateParametersStatusGenerator()
var storageAccountCreateParametersStatusGenerator gopter.Gen

// StorageAccountCreateParametersStatusGenerator returns a generator of StorageAccountCreateParameters_Status instances for property testing.
// We first initialize storageAccountCreateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountCreateParametersStatusGenerator() gopter.Gen {
	if storageAccountCreateParametersStatusGenerator != nil {
		return storageAccountCreateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatus(generators)
	storageAccountCreateParametersStatusGenerator = gen.Struct(reflect.TypeOf(StorageAccountCreateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatus(generators)
	storageAccountCreateParametersStatusGenerator = gen.Struct(reflect.TypeOf(StorageAccountCreateParameters_Status{}), generators)

	return storageAccountCreateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountCreateParametersStatus(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.AlphaString())
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountCreateParametersStatus(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationStatusGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainStatusGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["Identity"] = gen.PtrOf(IdentityStatusGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicyStatusGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetStatusGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceStatusGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicyStatusGenerator())
	gens["Sku"] = gen.PtrOf(SkuStatusGenerator())
}

func Test_StorageAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountsSPEC, StorageAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountsSPEC runs a test to see if a specific instance of StorageAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountsSPEC(subject StorageAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccounts_SPEC instances for property testing - lazily instantiated by
//StorageAccountsSPECGenerator()
var storageAccountsSPECGenerator gopter.Gen

// StorageAccountsSPECGenerator returns a generator of StorageAccounts_SPEC instances for property testing.
// We first initialize storageAccountsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageAccountsSPECGenerator() gopter.Gen {
	if storageAccountsSPECGenerator != nil {
		return storageAccountsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSPEC(generators)
	storageAccountsSPECGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageAccountsSPEC(generators)
	AddRelatedPropertyGeneratorsForStorageAccountsSPEC(generators)
	storageAccountsSPECGenerator = gen.Struct(reflect.TypeOf(StorageAccounts_SPEC{}), generators)

	return storageAccountsSPECGenerator
}

// AddIndependentPropertyGeneratorsForStorageAccountsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AccessTier"] = gen.PtrOf(gen.AlphaString())
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["AllowCrossTenantReplication"] = gen.PtrOf(gen.Bool())
	gens["AllowSharedKeyAccess"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["IsHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsNfsV3Enabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["LargeFileSharesState"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["SupportsHttpsTrafficOnly"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageAccountsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AzureFilesIdentityBasedAuthentication"] = gen.PtrOf(AzureFilesIdentityBasedAuthenticationSpecGenerator())
	gens["CustomDomain"] = gen.PtrOf(CustomDomainSpecGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["Identity"] = gen.PtrOf(IdentitySpecGenerator())
	gens["KeyPolicy"] = gen.PtrOf(KeyPolicySpecGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetSpecGenerator())
	gens["RoutingPreference"] = gen.PtrOf(RoutingPreferenceSpecGenerator())
	gens["SasPolicy"] = gen.PtrOf(SasPolicySpecGenerator())
	gens["Sku"] = gen.PtrOf(SkuSpecGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpec, AzureFilesIdentityBasedAuthenticationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpec runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationSpec(subject AzureFilesIdentityBasedAuthentication_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_Spec instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationSpecGenerator()
var azureFilesIdentityBasedAuthenticationSpecGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationSpecGenerator returns a generator of AzureFilesIdentityBasedAuthentication_Spec instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationSpecGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationSpecGenerator != nil {
		return azureFilesIdentityBasedAuthenticationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec(generators)
	azureFilesIdentityBasedAuthenticationSpecGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec(generators)
	azureFilesIdentityBasedAuthenticationSpecGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Spec{}), generators)

	return azureFilesIdentityBasedAuthenticationSpecGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.AlphaString())
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationSpec(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesSpecGenerator())
}

func Test_AzureFilesIdentityBasedAuthentication_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFilesIdentityBasedAuthentication_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatus, AzureFilesIdentityBasedAuthenticationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatus runs a test to see if a specific instance of AzureFilesIdentityBasedAuthentication_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFilesIdentityBasedAuthenticationStatus(subject AzureFilesIdentityBasedAuthentication_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFilesIdentityBasedAuthentication_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFilesIdentityBasedAuthentication_Status instances for property testing - lazily instantiated by
//AzureFilesIdentityBasedAuthenticationStatusGenerator()
var azureFilesIdentityBasedAuthenticationStatusGenerator gopter.Gen

// AzureFilesIdentityBasedAuthenticationStatusGenerator returns a generator of AzureFilesIdentityBasedAuthentication_Status instances for property testing.
// We first initialize azureFilesIdentityBasedAuthenticationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFilesIdentityBasedAuthenticationStatusGenerator() gopter.Gen {
	if azureFilesIdentityBasedAuthenticationStatusGenerator != nil {
		return azureFilesIdentityBasedAuthenticationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus(generators)
	azureFilesIdentityBasedAuthenticationStatusGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus(generators)
	AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus(generators)
	azureFilesIdentityBasedAuthenticationStatusGenerator = gen.Struct(reflect.TypeOf(AzureFilesIdentityBasedAuthentication_Status{}), generators)

	return azureFilesIdentityBasedAuthenticationStatusGenerator
}

// AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus(gens map[string]gopter.Gen) {
	gens["DefaultSharePermission"] = gen.PtrOf(gen.AlphaString())
	gens["DirectoryServiceOptions"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFilesIdentityBasedAuthenticationStatus(gens map[string]gopter.Gen) {
	gens["ActiveDirectoryProperties"] = gen.PtrOf(ActiveDirectoryPropertiesStatusGenerator())
}

func Test_CustomDomain_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainSpec, CustomDomainSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainSpec runs a test to see if a specific instance of CustomDomain_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainSpec(subject CustomDomain_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_Spec instances for property testing - lazily instantiated by CustomDomainSpecGenerator()
var customDomainSpecGenerator gopter.Gen

// CustomDomainSpecGenerator returns a generator of CustomDomain_Spec instances for property testing.
func CustomDomainSpecGenerator() gopter.Gen {
	if customDomainSpecGenerator != nil {
		return customDomainSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSpec(generators)
	customDomainSpecGenerator = gen.Struct(reflect.TypeOf(CustomDomain_Spec{}), generators)

	return customDomainSpecGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_CustomDomain_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainStatus, CustomDomainStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainStatus runs a test to see if a specific instance of CustomDomain_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainStatus(subject CustomDomain_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_Status instances for property testing - lazily instantiated by CustomDomainStatusGenerator()
var customDomainStatusGenerator gopter.Gen

// CustomDomainStatusGenerator returns a generator of CustomDomain_Status instances for property testing.
func CustomDomainStatusGenerator() gopter.Gen {
	if customDomainStatusGenerator != nil {
		return customDomainStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainStatus(generators)
	customDomainStatusGenerator = gen.Struct(reflect.TypeOf(CustomDomain_Status{}), generators)

	return customDomainStatusGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseSubDomainName"] = gen.PtrOf(gen.Bool())
}

func Test_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSpec, EncryptionSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSpec runs a test to see if a specific instance of Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSpec(subject Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Spec instances for property testing - lazily instantiated by EncryptionSpecGenerator()
var encryptionSpecGenerator gopter.Gen

// EncryptionSpecGenerator returns a generator of Encryption_Spec instances for property testing.
// We first initialize encryptionSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSpecGenerator() gopter.Gen {
	if encryptionSpecGenerator != nil {
		return encryptionSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSpec(generators)
	encryptionSpecGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSpec(generators)
	AddRelatedPropertyGeneratorsForEncryptionSpec(generators)
	encryptionSpecGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	return encryptionSpecGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSpec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSpec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentitySpecGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesSpecGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesSpecGenerator())
}

func Test_Encryption_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionStatus, EncryptionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionStatus runs a test to see if a specific instance of Encryption_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionStatus(subject Encryption_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Status instances for property testing - lazily instantiated by EncryptionStatusGenerator()
var encryptionStatusGenerator gopter.Gen

// EncryptionStatusGenerator returns a generator of Encryption_Status instances for property testing.
// We first initialize encryptionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionStatusGenerator() gopter.Gen {
	if encryptionStatusGenerator != nil {
		return encryptionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatus(generators)
	encryptionStatusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatus(generators)
	AddRelatedPropertyGeneratorsForEncryptionStatus(generators)
	encryptionStatusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	return encryptionStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionStatus(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionStatus(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(EncryptionIdentityStatusGenerator())
	gens["Keyvaultproperties"] = gen.PtrOf(KeyVaultPropertiesStatusGenerator())
	gens["Services"] = gen.PtrOf(EncryptionServicesStatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocationSpecGenerator()
var extendedLocationSpecGenerator gopter.Gen

// ExtendedLocationSpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocationSpecGenerator() gopter.Gen {
	if extendedLocationSpecGenerator != nil {
		return extendedLocationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpec(generators)
	extendedLocationSpecGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocationSpecGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatus runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocationStatusGenerator()
var extendedLocationStatusGenerator gopter.Gen

// ExtendedLocationStatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocationStatusGenerator() gopter.Gen {
	if extendedLocationStatusGenerator != nil {
		return extendedLocationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatus(generators)
	extendedLocationStatusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocationStatusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentitySpec, IdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentitySpec runs a test to see if a specific instance of Identity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentitySpec(subject Identity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Spec instances for property testing - lazily instantiated by IdentitySpecGenerator()
var identitySpecGenerator gopter.Gen

// IdentitySpecGenerator returns a generator of Identity_Spec instances for property testing.
func IdentitySpecGenerator() gopter.Gen {
	if identitySpecGenerator != nil {
		return identitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySpec(generators)
	identitySpecGenerator = gen.Struct(reflect.TypeOf(Identity_Spec{}), generators)

	return identitySpecGenerator
}

// AddIndependentPropertyGeneratorsForIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityStatus, IdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityStatus runs a test to see if a specific instance of Identity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityStatus(subject Identity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Status instances for property testing - lazily instantiated by IdentityStatusGenerator()
var identityStatusGenerator gopter.Gen

// IdentityStatusGenerator returns a generator of Identity_Status instances for property testing.
// We first initialize identityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityStatusGenerator() gopter.Gen {
	if identityStatusGenerator != nil {
		return identityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatus(generators)
	identityStatusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForIdentityStatus(generators)
	identityStatusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	return identityStatusGenerator
}

// AddIndependentPropertyGeneratorsForIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityStatusGenerator())
}

func Test_KeyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicySpec, KeyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicySpec runs a test to see if a specific instance of KeyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicySpec(subject KeyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_Spec instances for property testing - lazily instantiated by KeyPolicySpecGenerator()
var keyPolicySpecGenerator gopter.Gen

// KeyPolicySpecGenerator returns a generator of KeyPolicy_Spec instances for property testing.
func KeyPolicySpecGenerator() gopter.Gen {
	if keyPolicySpecGenerator != nil {
		return keyPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicySpec(generators)
	keyPolicySpecGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_Spec{}), generators)

	return keyPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicySpec(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_KeyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyPolicyStatus, KeyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyPolicyStatus runs a test to see if a specific instance of KeyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyPolicyStatus(subject KeyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyPolicy_Status instances for property testing - lazily instantiated by KeyPolicyStatusGenerator()
var keyPolicyStatusGenerator gopter.Gen

// KeyPolicyStatusGenerator returns a generator of KeyPolicy_Status instances for property testing.
func KeyPolicyStatusGenerator() gopter.Gen {
	if keyPolicyStatusGenerator != nil {
		return keyPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyPolicyStatus(generators)
	keyPolicyStatusGenerator = gen.Struct(reflect.TypeOf(KeyPolicy_Status{}), generators)

	return keyPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyPolicyStatus(gens map[string]gopter.Gen) {
	gens["KeyExpirationPeriodInDays"] = gen.PtrOf(gen.Int())
}

func Test_NetworkRuleSet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSpec, NetworkRuleSetSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSpec runs a test to see if a specific instance of NetworkRuleSet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSpec(subject NetworkRuleSet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_Spec instances for property testing - lazily instantiated by NetworkRuleSetSpecGenerator()
var networkRuleSetSpecGenerator gopter.Gen

// NetworkRuleSetSpecGenerator returns a generator of NetworkRuleSet_Spec instances for property testing.
// We first initialize networkRuleSetSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSpecGenerator() gopter.Gen {
	if networkRuleSetSpecGenerator != nil {
		return networkRuleSetSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSpec(generators)
	networkRuleSetSpecGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSpec(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSpec(generators)
	networkRuleSetSpecGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Spec{}), generators)

	return networkRuleSetSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSpec(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSpec(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSpecGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleSpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSpecGenerator())
}

func Test_NetworkRuleSet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetStatus, NetworkRuleSetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetStatus runs a test to see if a specific instance of NetworkRuleSet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetStatus(subject NetworkRuleSet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_Status instances for property testing - lazily instantiated by
//NetworkRuleSetStatusGenerator()
var networkRuleSetStatusGenerator gopter.Gen

// NetworkRuleSetStatusGenerator returns a generator of NetworkRuleSet_Status instances for property testing.
// We first initialize networkRuleSetStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetStatusGenerator() gopter.Gen {
	if networkRuleSetStatusGenerator != nil {
		return networkRuleSetStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(generators)
	networkRuleSetStatusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetStatus(generators)
	networkRuleSetStatusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	return networkRuleSetStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetStatus(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleStatusGenerator())
	gens["ResourceAccessRules"] = gen.SliceOf(ResourceAccessRuleStatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusGenerator())
}

func Test_RoutingPreference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceSpec, RoutingPreferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceSpec runs a test to see if a specific instance of RoutingPreference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceSpec(subject RoutingPreference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_Spec instances for property testing - lazily instantiated by
//RoutingPreferenceSpecGenerator()
var routingPreferenceSpecGenerator gopter.Gen

// RoutingPreferenceSpecGenerator returns a generator of RoutingPreference_Spec instances for property testing.
func RoutingPreferenceSpecGenerator() gopter.Gen {
	if routingPreferenceSpecGenerator != nil {
		return routingPreferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceSpec(generators)
	routingPreferenceSpecGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_Spec{}), generators)

	return routingPreferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceSpec(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingPreference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingPreference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingPreferenceStatus, RoutingPreferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingPreferenceStatus runs a test to see if a specific instance of RoutingPreference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingPreferenceStatus(subject RoutingPreference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingPreference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingPreference_Status instances for property testing - lazily instantiated by
//RoutingPreferenceStatusGenerator()
var routingPreferenceStatusGenerator gopter.Gen

// RoutingPreferenceStatusGenerator returns a generator of RoutingPreference_Status instances for property testing.
func RoutingPreferenceStatusGenerator() gopter.Gen {
	if routingPreferenceStatusGenerator != nil {
		return routingPreferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingPreferenceStatus(generators)
	routingPreferenceStatusGenerator = gen.Struct(reflect.TypeOf(RoutingPreference_Status{}), generators)

	return routingPreferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForRoutingPreferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingPreferenceStatus(gens map[string]gopter.Gen) {
	gens["PublishInternetEndpoints"] = gen.PtrOf(gen.Bool())
	gens["PublishMicrosoftEndpoints"] = gen.PtrOf(gen.Bool())
	gens["RoutingChoice"] = gen.PtrOf(gen.AlphaString())
}

func Test_SasPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicySpec, SasPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicySpec runs a test to see if a specific instance of SasPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicySpec(subject SasPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_Spec instances for property testing - lazily instantiated by SasPolicySpecGenerator()
var sasPolicySpecGenerator gopter.Gen

// SasPolicySpecGenerator returns a generator of SasPolicy_Spec instances for property testing.
func SasPolicySpecGenerator() gopter.Gen {
	if sasPolicySpecGenerator != nil {
		return sasPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicySpec(generators)
	sasPolicySpecGenerator = gen.Struct(reflect.TypeOf(SasPolicy_Spec{}), generators)

	return sasPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicySpec(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.AlphaString())
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_SasPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SasPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSasPolicyStatus, SasPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSasPolicyStatus runs a test to see if a specific instance of SasPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSasPolicyStatus(subject SasPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SasPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SasPolicy_Status instances for property testing - lazily instantiated by SasPolicyStatusGenerator()
var sasPolicyStatusGenerator gopter.Gen

// SasPolicyStatusGenerator returns a generator of SasPolicy_Status instances for property testing.
func SasPolicyStatusGenerator() gopter.Gen {
	if sasPolicyStatusGenerator != nil {
		return sasPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSasPolicyStatus(generators)
	sasPolicyStatusGenerator = gen.Struct(reflect.TypeOf(SasPolicy_Status{}), generators)

	return sasPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForSasPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSasPolicyStatus(gens map[string]gopter.Gen) {
	gens["ExpirationAction"] = gen.PtrOf(gen.AlphaString())
	gens["SasExpirationPeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSpec, SkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSpec runs a test to see if a specific instance of Sku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSpec(subject Sku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Spec instances for property testing - lazily instantiated by SkuSpecGenerator()
var skuSpecGenerator gopter.Gen

// SkuSpecGenerator returns a generator of Sku_Spec instances for property testing.
func SkuSpecGenerator() gopter.Gen {
	if skuSpecGenerator != nil {
		return skuSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSpec(generators)
	skuSpecGenerator = gen.Struct(reflect.TypeOf(Sku_Spec{}), generators)

	return skuSpecGenerator
}

// AddIndependentPropertyGeneratorsForSkuSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuStatus, SkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuStatus runs a test to see if a specific instance of Sku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuStatus(subject Sku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Status instances for property testing - lazily instantiated by SkuStatusGenerator()
var skuStatusGenerator gopter.Gen

// SkuStatusGenerator returns a generator of Sku_Status instances for property testing.
func SkuStatusGenerator() gopter.Gen {
	if skuStatusGenerator != nil {
		return skuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuStatus(generators)
	skuStatusGenerator = gen.Struct(reflect.TypeOf(Sku_Status{}), generators)

	return skuStatusGenerator
}

// AddIndependentPropertyGeneratorsForSkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesSpec, ActiveDirectoryPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesSpec runs a test to see if a specific instance of ActiveDirectoryProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesSpec(subject ActiveDirectoryProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_Spec instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesSpecGenerator()
var activeDirectoryPropertiesSpecGenerator gopter.Gen

// ActiveDirectoryPropertiesSpecGenerator returns a generator of ActiveDirectoryProperties_Spec instances for property testing.
func ActiveDirectoryPropertiesSpecGenerator() gopter.Gen {
	if activeDirectoryPropertiesSpecGenerator != nil {
		return activeDirectoryPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpec(generators)
	activeDirectoryPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_Spec{}), generators)

	return activeDirectoryPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesSpec(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ActiveDirectoryProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActiveDirectoryProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActiveDirectoryPropertiesStatus, ActiveDirectoryPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActiveDirectoryPropertiesStatus runs a test to see if a specific instance of ActiveDirectoryProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForActiveDirectoryPropertiesStatus(subject ActiveDirectoryProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActiveDirectoryProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActiveDirectoryProperties_Status instances for property testing - lazily instantiated by
//ActiveDirectoryPropertiesStatusGenerator()
var activeDirectoryPropertiesStatusGenerator gopter.Gen

// ActiveDirectoryPropertiesStatusGenerator returns a generator of ActiveDirectoryProperties_Status instances for property testing.
func ActiveDirectoryPropertiesStatusGenerator() gopter.Gen {
	if activeDirectoryPropertiesStatusGenerator != nil {
		return activeDirectoryPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatus(generators)
	activeDirectoryPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(ActiveDirectoryProperties_Status{}), generators)

	return activeDirectoryPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActiveDirectoryPropertiesStatus(gens map[string]gopter.Gen) {
	gens["AzureStorageSid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainGuid"] = gen.PtrOf(gen.AlphaString())
	gens["DomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DomainSid"] = gen.PtrOf(gen.AlphaString())
	gens["ForestName"] = gen.PtrOf(gen.AlphaString())
	gens["NetBiosDomainName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentitySpec, EncryptionIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentitySpec runs a test to see if a specific instance of EncryptionIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentitySpec(subject EncryptionIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_Spec instances for property testing - lazily instantiated by
//EncryptionIdentitySpecGenerator()
var encryptionIdentitySpecGenerator gopter.Gen

// EncryptionIdentitySpecGenerator returns a generator of EncryptionIdentity_Spec instances for property testing.
func EncryptionIdentitySpecGenerator() gopter.Gen {
	if encryptionIdentitySpecGenerator != nil {
		return encryptionIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	encryptionIdentitySpecGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_Spec{}), generators)

	return encryptionIdentitySpecGenerator
}

func Test_EncryptionIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionIdentityStatus, EncryptionIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionIdentityStatus runs a test to see if a specific instance of EncryptionIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionIdentityStatus(subject EncryptionIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionIdentity_Status instances for property testing - lazily instantiated by
//EncryptionIdentityStatusGenerator()
var encryptionIdentityStatusGenerator gopter.Gen

// EncryptionIdentityStatusGenerator returns a generator of EncryptionIdentity_Status instances for property testing.
func EncryptionIdentityStatusGenerator() gopter.Gen {
	if encryptionIdentityStatusGenerator != nil {
		return encryptionIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionIdentityStatus(generators)
	encryptionIdentityStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionIdentity_Status{}), generators)

	return encryptionIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionServices_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesSpec, EncryptionServicesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesSpec runs a test to see if a specific instance of EncryptionServices_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesSpec(subject EncryptionServices_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_Spec instances for property testing - lazily instantiated by
//EncryptionServicesSpecGenerator()
var encryptionServicesSpecGenerator gopter.Gen

// EncryptionServicesSpecGenerator returns a generator of EncryptionServices_Spec instances for property testing.
func EncryptionServicesSpecGenerator() gopter.Gen {
	if encryptionServicesSpecGenerator != nil {
		return encryptionServicesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesSpec(generators)
	encryptionServicesSpecGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_Spec{}), generators)

	return encryptionServicesSpecGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesSpec(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceSpecGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceSpecGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceSpecGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceSpecGenerator())
}

func Test_EncryptionServices_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionServices_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServicesStatus, EncryptionServicesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServicesStatus runs a test to see if a specific instance of EncryptionServices_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServicesStatus(subject EncryptionServices_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionServices_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionServices_Status instances for property testing - lazily instantiated by
//EncryptionServicesStatusGenerator()
var encryptionServicesStatusGenerator gopter.Gen

// EncryptionServicesStatusGenerator returns a generator of EncryptionServices_Status instances for property testing.
func EncryptionServicesStatusGenerator() gopter.Gen {
	if encryptionServicesStatusGenerator != nil {
		return encryptionServicesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionServicesStatus(generators)
	encryptionServicesStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionServices_Status{}), generators)

	return encryptionServicesStatusGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionServicesStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionServicesStatus(gens map[string]gopter.Gen) {
	gens["Blob"] = gen.PtrOf(EncryptionServiceStatusGenerator())
	gens["File"] = gen.PtrOf(EncryptionServiceStatusGenerator())
	gens["Queue"] = gen.PtrOf(EncryptionServiceStatusGenerator())
	gens["Table"] = gen.PtrOf(EncryptionServiceStatusGenerator())
}

func Test_IPRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSpec, IPRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSpec runs a test to see if a specific instance of IPRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSpec(subject IPRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_Spec instances for property testing - lazily instantiated by IPRuleSpecGenerator()
var ipRuleSpecGenerator gopter.Gen

// IPRuleSpecGenerator returns a generator of IPRule_Spec instances for property testing.
func IPRuleSpecGenerator() gopter.Gen {
	if ipRuleSpecGenerator != nil {
		return ipRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSpec(generators)
	ipRuleSpecGenerator = gen.Struct(reflect.TypeOf(IPRule_Spec{}), generators)

	return ipRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSpec(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleStatus, IPRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleStatus runs a test to see if a specific instance of IPRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleStatus(subject IPRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_Status instances for property testing - lazily instantiated by IPRuleStatusGenerator()
var ipRuleStatusGenerator gopter.Gen

// IPRuleStatusGenerator returns a generator of IPRule_Status instances for property testing.
func IPRuleStatusGenerator() gopter.Gen {
	if ipRuleStatusGenerator != nil {
		return ipRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleStatus(generators)
	ipRuleStatusGenerator = gen.Struct(reflect.TypeOf(IPRule_Status{}), generators)

	return ipRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleStatus(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSpec, KeyVaultPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSpec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSpec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultPropertiesSpecGenerator()
var keyVaultPropertiesSpecGenerator gopter.Gen

// KeyVaultPropertiesSpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
func KeyVaultPropertiesSpecGenerator() gopter.Gen {
	if keyVaultPropertiesSpecGenerator != nil {
		return keyVaultPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec(generators)
	keyVaultPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec(gens map[string]gopter.Gen) {
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatus, KeyVaultPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatus runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatus(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultPropertiesStatusGenerator()
var keyVaultPropertiesStatusGenerator gopter.Gen

// KeyVaultPropertiesStatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
func KeyVaultPropertiesStatusGenerator() gopter.Gen {
	if keyVaultPropertiesStatusGenerator != nil {
		return keyVaultPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus(generators)
	keyVaultPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus(gens map[string]gopter.Gen) {
	gens["CurrentVersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["Keyname"] = gen.PtrOf(gen.AlphaString())
	gens["Keyvaulturi"] = gen.PtrOf(gen.AlphaString())
	gens["Keyversion"] = gen.PtrOf(gen.AlphaString())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleSpec, ResourceAccessRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleSpec runs a test to see if a specific instance of ResourceAccessRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleSpec(subject ResourceAccessRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_Spec instances for property testing - lazily instantiated by
//ResourceAccessRuleSpecGenerator()
var resourceAccessRuleSpecGenerator gopter.Gen

// ResourceAccessRuleSpecGenerator returns a generator of ResourceAccessRule_Spec instances for property testing.
func ResourceAccessRuleSpecGenerator() gopter.Gen {
	if resourceAccessRuleSpecGenerator != nil {
		return resourceAccessRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleSpec(generators)
	resourceAccessRuleSpecGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_Spec{}), generators)

	return resourceAccessRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleSpec(gens map[string]gopter.Gen) {
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceAccessRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceAccessRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceAccessRuleStatus, ResourceAccessRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceAccessRuleStatus runs a test to see if a specific instance of ResourceAccessRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceAccessRuleStatus(subject ResourceAccessRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceAccessRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceAccessRule_Status instances for property testing - lazily instantiated by
//ResourceAccessRuleStatusGenerator()
var resourceAccessRuleStatusGenerator gopter.Gen

// ResourceAccessRuleStatusGenerator returns a generator of ResourceAccessRule_Status instances for property testing.
func ResourceAccessRuleStatusGenerator() gopter.Gen {
	if resourceAccessRuleStatusGenerator != nil {
		return resourceAccessRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceAccessRuleStatus(generators)
	resourceAccessRuleStatusGenerator = gen.Struct(reflect.TypeOf(ResourceAccessRule_Status{}), generators)

	return resourceAccessRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceAccessRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceAccessRuleStatus(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityStatus, UserAssignedIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityStatus runs a test to see if a specific instance of UserAssignedIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityStatus(subject UserAssignedIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_Status instances for property testing - lazily instantiated by
//UserAssignedIdentityStatusGenerator()
var userAssignedIdentityStatusGenerator gopter.Gen

// UserAssignedIdentityStatusGenerator returns a generator of UserAssignedIdentity_Status instances for property testing.
func UserAssignedIdentityStatusGenerator() gopter.Gen {
	if userAssignedIdentityStatusGenerator != nil {
		return userAssignedIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityStatus(generators)
	userAssignedIdentityStatusGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_Status{}), generators)

	return userAssignedIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityStatus(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSpec, VirtualNetworkRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSpec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSpec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRuleSpecGenerator()
var virtualNetworkRuleSpecGenerator gopter.Gen

// VirtualNetworkRuleSpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRuleSpecGenerator() gopter.Gen {
	if virtualNetworkRuleSpecGenerator != nil {
		return virtualNetworkRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(generators)
	virtualNetworkRuleSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatus runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRuleStatusGenerator()
var virtualNetworkRuleStatusGenerator gopter.Gen

// VirtualNetworkRuleStatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRuleStatusGenerator() gopter.Gen {
	if virtualNetworkRuleStatusGenerator != nil {
		return virtualNetworkRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(generators)
	virtualNetworkRuleStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceSpec, EncryptionServiceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceSpec runs a test to see if a specific instance of EncryptionService_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceSpec(subject EncryptionService_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_Spec instances for property testing - lazily instantiated by
//EncryptionServiceSpecGenerator()
var encryptionServiceSpecGenerator gopter.Gen

// EncryptionServiceSpecGenerator returns a generator of EncryptionService_Spec instances for property testing.
func EncryptionServiceSpecGenerator() gopter.Gen {
	if encryptionServiceSpecGenerator != nil {
		return encryptionServiceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceSpec(generators)
	encryptionServiceSpecGenerator = gen.Struct(reflect.TypeOf(EncryptionService_Spec{}), generators)

	return encryptionServiceSpecGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionService_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionService_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionServiceStatus, EncryptionServiceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionServiceStatus runs a test to see if a specific instance of EncryptionService_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionServiceStatus(subject EncryptionService_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionService_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionService_Status instances for property testing - lazily instantiated by
//EncryptionServiceStatusGenerator()
var encryptionServiceStatusGenerator gopter.Gen

// EncryptionServiceStatusGenerator returns a generator of EncryptionService_Status instances for property testing.
func EncryptionServiceStatusGenerator() gopter.Gen {
	if encryptionServiceStatusGenerator != nil {
		return encryptionServiceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionServiceStatus(generators)
	encryptionServiceStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionService_Status{}), generators)

	return encryptionServiceStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionServiceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionServiceStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["KeyType"] = gen.PtrOf(gen.AlphaString())
	gens["LastEnabledTime"] = gen.PtrOf(gen.AlphaString())
}
