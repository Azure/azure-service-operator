// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AccountProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountProperties, AccountPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountProperties runs a test to see if a specific instance of AccountProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountProperties(subject AccountProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountProperties instances for property testing - lazily instantiated by AccountPropertiesGenerator()
var accountPropertiesGenerator gopter.Gen

// AccountPropertiesGenerator returns a generator of AccountProperties instances for property testing.
// We first initialize accountPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccountPropertiesGenerator() gopter.Gen {
	if accountPropertiesGenerator != nil {
		return accountPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties(generators)
	accountPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties(generators)
	AddRelatedPropertyGeneratorsForAccountProperties(generators)
	accountPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountProperties{}), generators)

	return accountPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAccountProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccountProperties(gens map[string]gopter.Gen) {
	gens["AllowProjectManagement"] = gen.PtrOf(gen.Bool())
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["AssociatedProjects"] = gen.SliceOf(gen.AlphaString())
	gens["CustomSubDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultProject"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DynamicThrottlingEnabled"] = gen.PtrOf(gen.Bool())
	gens["MigrationToken"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(AccountProperties_PublicNetworkAccess_Disabled, AccountProperties_PublicNetworkAccess_Enabled))
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAccountProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountProperties(gens map[string]gopter.Gen) {
	gens["AmlWorkspace"] = gen.PtrOf(UserOwnedAmlWorkspaceGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionGenerator())
	gens["Locations"] = gen.PtrOf(MultiRegionSettingsGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["NetworkInjections"] = gen.PtrOf(NetworkInjectionsGenerator())
	gens["RaiMonitorConfig"] = gen.PtrOf(RaiMonitorConfigGenerator())
	gens["UserOwnedStorage"] = gen.SliceOf(UserOwnedStorageGenerator())
}

func Test_Account_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Account_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccount_Spec, Account_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccount_Spec runs a test to see if a specific instance of Account_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAccount_Spec(subject Account_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Account_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Account_Spec instances for property testing - lazily instantiated by Account_SpecGenerator()
var account_SpecGenerator gopter.Gen

// Account_SpecGenerator returns a generator of Account_Spec instances for property testing.
// We first initialize account_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Account_SpecGenerator() gopter.Gen {
	if account_SpecGenerator != nil {
		return account_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_Spec(generators)
	account_SpecGenerator = gen.Struct(reflect.TypeOf(Account_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_Spec(generators)
	AddRelatedPropertyGeneratorsForAccount_Spec(generators)
	account_SpecGenerator = gen.Struct(reflect.TypeOf(Account_Spec{}), generators)

	return account_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAccount_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccount_Spec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccount_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccount_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["Properties"] = gen.PtrOf(AccountPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_ApiProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties, ApiPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties runs a test to see if a specific instance of ApiProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties(subject ApiProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties instances for property testing - lazily instantiated by ApiPropertiesGenerator()
var apiPropertiesGenerator gopter.Gen

// ApiPropertiesGenerator returns a generator of ApiProperties instances for property testing.
func ApiPropertiesGenerator() gopter.Gen {
	if apiPropertiesGenerator != nil {
		return apiPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties(generators)
	apiPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiProperties{}), generators)

	return apiPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties(gens map[string]gopter.Gen) {
	gens["AadClientId"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["QnaAzureSearchEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["QnaAzureSearchEndpointKey"] = gen.PtrOf(gen.AlphaString())
	gens["QnaRuntimeEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["StatisticsEnabled"] = gen.PtrOf(gen.Bool())
	gens["StorageAccountConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["SuperUser"] = gen.PtrOf(gen.AlphaString())
	gens["WebsiteName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Encryption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption, EncryptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption runs a test to see if a specific instance of Encryption round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption(subject Encryption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption instances for property testing - lazily instantiated by EncryptionGenerator()
var encryptionGenerator gopter.Gen

// EncryptionGenerator returns a generator of Encryption instances for property testing.
// We first initialize encryptionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionGenerator() gopter.Gen {
	if encryptionGenerator != nil {
		return encryptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	AddRelatedPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	return encryptionGenerator
}

// AddIndependentPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(Encryption_KeySource_MicrosoftCognitiveServices, Encryption_KeySource_MicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesGenerator())
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
// We first initialize identityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	AddRelatedPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_None,
		Identity_Type_SystemAssigned,
		Identity_Type_SystemAssignedUserAssigned,
		Identity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_IpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule runs a test to see if a specific instance of IpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule(subject IpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule instances for property testing - lazily instantiated by IpRuleGenerator()
var ipRuleGenerator gopter.Gen

// IpRuleGenerator returns a generator of IpRule instances for property testing.
func IpRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IpRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties runs a test to see if a specific instance of KeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties instances for property testing - lazily instantiated by KeyVaultPropertiesGenerator()
var keyVaultPropertiesGenerator gopter.Gen

// KeyVaultPropertiesGenerator returns a generator of KeyVaultProperties instances for property testing.
func KeyVaultPropertiesGenerator() gopter.Gen {
	if keyVaultPropertiesGenerator != nil {
		return keyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties(generators)
	keyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties{}), generators)

	return keyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_MultiRegionSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiRegionSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiRegionSettings, MultiRegionSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiRegionSettings runs a test to see if a specific instance of MultiRegionSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiRegionSettings(subject MultiRegionSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiRegionSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiRegionSettings instances for property testing - lazily instantiated by
// MultiRegionSettingsGenerator()
var multiRegionSettingsGenerator gopter.Gen

// MultiRegionSettingsGenerator returns a generator of MultiRegionSettings instances for property testing.
// We first initialize multiRegionSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MultiRegionSettingsGenerator() gopter.Gen {
	if multiRegionSettingsGenerator != nil {
		return multiRegionSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings(generators)
	multiRegionSettingsGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings(generators)
	AddRelatedPropertyGeneratorsForMultiRegionSettings(generators)
	multiRegionSettingsGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings{}), generators)

	return multiRegionSettingsGenerator
}

// AddIndependentPropertyGeneratorsForMultiRegionSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMultiRegionSettings(gens map[string]gopter.Gen) {
	gens["RoutingMethod"] = gen.PtrOf(gen.OneConstOf(MultiRegionSettings_RoutingMethod_Performance, MultiRegionSettings_RoutingMethod_Priority, MultiRegionSettings_RoutingMethod_Weighted))
}

// AddRelatedPropertyGeneratorsForMultiRegionSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiRegionSettings(gens map[string]gopter.Gen) {
	gens["Regions"] = gen.SliceOf(RegionSettingGenerator())
}

func Test_NetworkInjections_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInjections via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInjections, NetworkInjectionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInjections runs a test to see if a specific instance of NetworkInjections round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInjections(subject NetworkInjections) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInjections
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInjections instances for property testing - lazily instantiated by NetworkInjectionsGenerator()
var networkInjectionsGenerator gopter.Gen

// NetworkInjectionsGenerator returns a generator of NetworkInjections instances for property testing.
func NetworkInjectionsGenerator() gopter.Gen {
	if networkInjectionsGenerator != nil {
		return networkInjectionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInjections(generators)
	networkInjectionsGenerator = gen.Struct(reflect.TypeOf(NetworkInjections{}), generators)

	return networkInjectionsGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInjections is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInjections(gens map[string]gopter.Gen) {
	gens["Scenario"] = gen.PtrOf(gen.OneConstOf(NetworkInjections_Scenario_Agent, NetworkInjections_Scenario_None))
	gens["SubnetArmId"] = gen.PtrOf(gen.AlphaString())
	gens["UseMicrosoftManagedNetwork"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet runs a test to see if a specific instance of NetworkRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet instances for property testing - lazily instantiated by NetworkRuleSetGenerator()
var networkRuleSetGenerator gopter.Gen

// NetworkRuleSetGenerator returns a generator of NetworkRuleSet instances for property testing.
// We first initialize networkRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetGenerator() gopter.Gen {
	if networkRuleSetGenerator != nil {
		return networkRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	return networkRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_Bypass_AzureServices, NetworkRuleSet_Bypass_None))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_DefaultAction_Allow, NetworkRuleSet_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRuleGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleGenerator())
}

func Test_RaiMonitorConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RaiMonitorConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRaiMonitorConfig, RaiMonitorConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRaiMonitorConfig runs a test to see if a specific instance of RaiMonitorConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForRaiMonitorConfig(subject RaiMonitorConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RaiMonitorConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RaiMonitorConfig instances for property testing - lazily instantiated by RaiMonitorConfigGenerator()
var raiMonitorConfigGenerator gopter.Gen

// RaiMonitorConfigGenerator returns a generator of RaiMonitorConfig instances for property testing.
func RaiMonitorConfigGenerator() gopter.Gen {
	if raiMonitorConfigGenerator != nil {
		return raiMonitorConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRaiMonitorConfig(generators)
	raiMonitorConfigGenerator = gen.Struct(reflect.TypeOf(RaiMonitorConfig{}), generators)

	return raiMonitorConfigGenerator
}

// AddIndependentPropertyGeneratorsForRaiMonitorConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRaiMonitorConfig(gens map[string]gopter.Gen) {
	gens["AdxStorageResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_RegionSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegionSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegionSetting, RegionSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegionSetting runs a test to see if a specific instance of RegionSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForRegionSetting(subject RegionSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegionSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegionSetting instances for property testing - lazily instantiated by RegionSettingGenerator()
var regionSettingGenerator gopter.Gen

// RegionSettingGenerator returns a generator of RegionSetting instances for property testing.
func RegionSettingGenerator() gopter.Gen {
	if regionSettingGenerator != nil {
		return regionSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegionSetting(generators)
	regionSettingGenerator = gen.Struct(reflect.TypeOf(RegionSetting{}), generators)

	return regionSettingGenerator
}

// AddIndependentPropertyGeneratorsForRegionSetting is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegionSetting(gens map[string]gopter.Gen) {
	gens["Customsubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		Sku_Tier_Basic,
		Sku_Tier_Enterprise,
		Sku_Tier_Free,
		Sku_Tier_Premium,
		Sku_Tier_Standard))
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserOwnedAmlWorkspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedAmlWorkspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedAmlWorkspace, UserOwnedAmlWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedAmlWorkspace runs a test to see if a specific instance of UserOwnedAmlWorkspace round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedAmlWorkspace(subject UserOwnedAmlWorkspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedAmlWorkspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedAmlWorkspace instances for property testing - lazily instantiated by
// UserOwnedAmlWorkspaceGenerator()
var userOwnedAmlWorkspaceGenerator gopter.Gen

// UserOwnedAmlWorkspaceGenerator returns a generator of UserOwnedAmlWorkspace instances for property testing.
func UserOwnedAmlWorkspaceGenerator() gopter.Gen {
	if userOwnedAmlWorkspaceGenerator != nil {
		return userOwnedAmlWorkspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace(generators)
	userOwnedAmlWorkspaceGenerator = gen.Struct(reflect.TypeOf(UserOwnedAmlWorkspace{}), generators)

	return userOwnedAmlWorkspaceGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserOwnedStorage_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedStorage via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedStorage, UserOwnedStorageGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedStorage runs a test to see if a specific instance of UserOwnedStorage round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedStorage(subject UserOwnedStorage) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedStorage
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedStorage instances for property testing - lazily instantiated by UserOwnedStorageGenerator()
var userOwnedStorageGenerator gopter.Gen

// UserOwnedStorageGenerator returns a generator of UserOwnedStorage instances for property testing.
func UserOwnedStorageGenerator() gopter.Gen {
	if userOwnedStorageGenerator != nil {
		return userOwnedStorageGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedStorage(generators)
	userOwnedStorageGenerator = gen.Struct(reflect.TypeOf(UserOwnedStorage{}), generators)

	return userOwnedStorageGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedStorage is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedStorage(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule runs a test to see if a specific instance of VirtualNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule instances for property testing - lazily instantiated by VirtualNetworkRuleGenerator()
var virtualNetworkRuleGenerator gopter.Gen

// VirtualNetworkRuleGenerator returns a generator of VirtualNetworkRule instances for property testing.
func VirtualNetworkRuleGenerator() gopter.Gen {
	if virtualNetworkRuleGenerator != nil {
		return virtualNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule(generators)
	virtualNetworkRuleGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule{}), generators)

	return virtualNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}
