// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20250601

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/cognitiveservices/v1api20250601/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/cognitiveservices/v1api20250601/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,cognitiveservices}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /cognitiveservices/resource-manager/Microsoft.CognitiveServices/stable/2025-06-01/cognitiveservices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CognitiveServices/accounts/{accountName}
type Account struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Account_Spec   `json:"spec,omitempty"`
	Status            Account_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Account{}

// GetConditions returns the conditions of the resource
func (account *Account) GetConditions() conditions.Conditions {
	return account.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (account *Account) SetConditions(conditions conditions.Conditions) {
	account.Status.Conditions = conditions
}

var _ conversion.Convertible = &Account{}

// ConvertFrom populates our Account from the provided hub Account
func (account *Account) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Account)
	if !ok {
		return fmt.Errorf("expected cognitiveservices/v1api20250601/storage/Account but received %T instead", hub)
	}

	return account.AssignProperties_From_Account(source)
}

// ConvertTo populates the provided hub Account from our Account
func (account *Account) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Account)
	if !ok {
		return fmt.Errorf("expected cognitiveservices/v1api20250601/storage/Account but received %T instead", hub)
	}

	return account.AssignProperties_To_Account(destination)
}

var _ configmaps.Exporter = &Account{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (account *Account) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if account.Spec.OperatorSpec == nil {
		return nil
	}
	return account.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Account{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (account *Account) SecretDestinationExpressions() []*core.DestinationExpression {
	if account.Spec.OperatorSpec == nil {
		return nil
	}
	return account.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Account{}

// InitializeSpec initializes the spec for this resource from the given status
func (account *Account) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Account_STATUS); ok {
		return account.Spec.Initialize_From_Account_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Account_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Account{}

// AzureName returns the Azure name of the resource
func (account *Account) AzureName() string {
	return account.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2025-06-01"
func (account Account) GetAPIVersion() string {
	return "2025-06-01"
}

// GetResourceScope returns the scope of the resource
func (account *Account) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (account *Account) GetSpec() genruntime.ConvertibleSpec {
	return &account.Spec
}

// GetStatus returns the status of this resource
func (account *Account) GetStatus() genruntime.ConvertibleStatus {
	return &account.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (account *Account) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.CognitiveServices/accounts"
func (account *Account) GetType() string {
	return "Microsoft.CognitiveServices/accounts"
}

// NewEmptyStatus returns a new empty (blank) status
func (account *Account) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Account_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (account *Account) Owner() *genruntime.ResourceReference {
	if account.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(account.Spec)
	return account.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (account *Account) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Account_STATUS); ok {
		account.Status = *st
		return nil
	}

	// Convert status to required version
	var st Account_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	account.Status = st
	return nil
}

// AssignProperties_From_Account populates our Account from the provided source Account
func (account *Account) AssignProperties_From_Account(source *storage.Account) error {

	// ObjectMeta
	account.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Account_Spec
	err := spec.AssignProperties_From_Account_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Account_Spec() to populate field Spec")
	}
	account.Spec = spec

	// Status
	var status Account_STATUS
	err = status.AssignProperties_From_Account_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Account_STATUS() to populate field Status")
	}
	account.Status = status

	// No error
	return nil
}

// AssignProperties_To_Account populates the provided destination Account from our Account
func (account *Account) AssignProperties_To_Account(destination *storage.Account) error {

	// ObjectMeta
	destination.ObjectMeta = *account.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Account_Spec
	err := account.Spec.AssignProperties_To_Account_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Account_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Account_STATUS
	err = account.Status.AssignProperties_To_Account_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Account_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (account *Account) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: account.Spec.OriginalVersion(),
		Kind:    "Account",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /cognitiveservices/resource-manager/Microsoft.CognitiveServices/stable/2025-06-01/cognitiveservices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CognitiveServices/accounts/{accountName}
type AccountList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Account `json:"items"`
}

type Account_Spec struct {
	// +kubebuilder:validation:MaxLength=64
	// +kubebuilder:validation:MinLength=2
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9][a-zA-Z0-9_.-]*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: Identity for the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Kind: The Kind of the resource.
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *AccountOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Properties: Properties of Cognitive Services account.
	Properties *AccountProperties `json:"properties,omitempty"`

	// Sku: The resource model definition representing SKU
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Account_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *Account_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.Account_Spec{}

	// Set property "Identity":
	if account.Identity != nil {
		identity_ARM, err := (*account.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.Identity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if account.Kind != nil {
		kind := *account.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if account.Location != nil {
		location := *account.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if account.Properties != nil {
		properties_ARM, err := (*account.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.AccountProperties)
		result.Properties = &properties
	}

	// Set property "Sku":
	if account.Sku != nil {
		sku_ARM, err := (*account.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if account.Tags != nil {
		result.Tags = make(map[string]string, len(account.Tags))
		for key, value := range account.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *Account_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Account_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *Account_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Account_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Account_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	account.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		account.Identity = &identity
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		account.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		account.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	account.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AccountProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		account.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		account.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		account.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			account.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Account_Spec{}

// ConvertSpecFrom populates our Account_Spec from the provided source
func (account *Account_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Account_Spec)
	if ok {
		// Populate our instance from source
		return account.AssignProperties_From_Account_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Account_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = account.AssignProperties_From_Account_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Account_Spec
func (account *Account_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Account_Spec)
	if ok {
		// Populate destination from our instance
		return account.AssignProperties_To_Account_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Account_Spec{}
	err := account.AssignProperties_To_Account_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Account_Spec populates our Account_Spec from the provided source Account_Spec
func (account *Account_Spec) AssignProperties_From_Account_Spec(source *storage.Account_Spec) error {

	// AzureName
	account.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// Kind
	account.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec AccountOperatorSpec
		err := operatorSpec.AssignProperties_From_AccountOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AccountOperatorSpec() to populate field OperatorSpec")
		}
		account.OperatorSpec = &operatorSpec
	} else {
		account.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		account.Owner = &owner
	} else {
		account.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property AccountProperties
		err := property.AssignProperties_From_AccountProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AccountProperties() to populate field Properties")
		}
		account.Properties = &property
	} else {
		account.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		account.Sku = &sku
	} else {
		account.Sku = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Account_Spec populates the provided destination Account_Spec from our Account_Spec
func (account *Account_Spec) AssignProperties_To_Account_Spec(destination *storage.Account_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = account.AzureName

	// Identity
	if account.Identity != nil {
		var identity storage.Identity
		err := account.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(account.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(account.Location)

	// OperatorSpec
	if account.OperatorSpec != nil {
		var operatorSpec storage.AccountOperatorSpec
		err := account.OperatorSpec.AssignProperties_To_AccountOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AccountOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = account.OriginalVersion()

	// Owner
	if account.Owner != nil {
		owner := account.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if account.Properties != nil {
		var property storage.AccountProperties
		err := account.Properties.AssignProperties_To_AccountProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AccountProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if account.Sku != nil {
		var sku storage.Sku
		err := account.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(account.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Account_STATUS populates our Account_Spec from the provided source Account_STATUS
func (account *Account_Spec) Initialize_From_Account_STATUS(source *Account_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.Initialize_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Identity_STATUS() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// Kind
	account.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property AccountProperties
		err := property.Initialize_From_AccountProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AccountProperties_STATUS() to populate field Properties")
		}
		account.Properties = &property
	} else {
		account.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		account.Sku = &sku
	} else {
		account.Sku = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (account *Account_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (account *Account_Spec) SetAzureName(azureName string) { account.AzureName = azureName }

// Cognitive Services account is an Azure resource representing the provisioned account, it's type, location and SKU.
type Account_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Etag: Resource Etag.
	Etag *string `json:"etag,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: Identity for the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Kind: The Kind of the resource.
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Properties of Cognitive Services account.
	Properties *AccountProperties_STATUS `json:"properties,omitempty"`

	// Sku: The resource model definition representing SKU
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Account_STATUS{}

// ConvertStatusFrom populates our Account_STATUS from the provided source
func (account *Account_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Account_STATUS)
	if ok {
		// Populate our instance from source
		return account.AssignProperties_From_Account_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Account_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = account.AssignProperties_From_Account_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Account_STATUS
func (account *Account_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Account_STATUS)
	if ok {
		// Populate destination from our instance
		return account.AssignProperties_To_Account_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Account_STATUS{}
	err := account.AssignProperties_To_Account_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Account_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *Account_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Account_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *Account_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Account_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Account_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		account.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		account.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		account.Identity = &identity
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		account.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		account.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		account.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AccountProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		account.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		account.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		account.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		account.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			account.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		account.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Account_STATUS populates our Account_STATUS from the provided source Account_STATUS
func (account *Account_STATUS) AssignProperties_From_Account_STATUS(source *storage.Account_STATUS) error {

	// Conditions
	account.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	account.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	account.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// Kind
	account.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	account.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property AccountProperties_STATUS
		err := property.AssignProperties_From_AccountProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AccountProperties_STATUS() to populate field Properties")
		}
		account.Properties = &property
	} else {
		account.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		account.Sku = &sku
	} else {
		account.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		account.SystemData = &systemDatum
	} else {
		account.SystemData = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	account.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Account_STATUS populates the provided destination Account_STATUS from our Account_STATUS
func (account *Account_STATUS) AssignProperties_To_Account_STATUS(destination *storage.Account_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(account.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(account.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(account.Id)

	// Identity
	if account.Identity != nil {
		var identity storage.Identity_STATUS
		err := account.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(account.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(account.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(account.Name)

	// Properties
	if account.Properties != nil {
		var property storage.AccountProperties_STATUS
		err := account.Properties.AssignProperties_To_AccountProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AccountProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if account.Sku != nil {
		var sku storage.Sku_STATUS
		err := account.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if account.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := account.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(account.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(account.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"2025-06-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2025-06-01")

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type AccountOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *AccountOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_AccountOperatorSpec populates our AccountOperatorSpec from the provided source AccountOperatorSpec
func (operator *AccountOperatorSpec) AssignProperties_From_AccountOperatorSpec(source *storage.AccountOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret AccountOperatorSecrets
		err := secret.AssignProperties_From_AccountOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AccountOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountOperatorSpec populates the provided destination AccountOperatorSpec from our AccountOperatorSpec
func (operator *AccountOperatorSpec) AssignProperties_To_AccountOperatorSpec(destination *storage.AccountOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.AccountOperatorSecrets
		err := operator.Secrets.AssignProperties_To_AccountOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AccountOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account.
type AccountProperties struct {
	// AllowProjectManagement: Specifies whether this resource support project management as child resources, used as
	// containers for access management, data isolation and cost in AI Foundry.
	AllowProjectManagement *bool    `json:"allowProjectManagement,omitempty"`
	AllowedFqdnList        []string `json:"allowedFqdnList,omitempty"`

	// AmlWorkspace: The user owned AML account properties.
	AmlWorkspace *UserOwnedAmlWorkspace `json:"amlWorkspace,omitempty"`

	// ApiProperties: The api properties for special APIs.
	ApiProperties *ApiProperties `json:"apiProperties,omitempty"`

	// AssociatedProjects: Specifies the projects, by project name, that are associated with this resource.
	AssociatedProjects []string `json:"associatedProjects,omitempty"`

	// CustomSubDomainName: Optional subdomain name used for token-based authentication.
	CustomSubDomainName *string `json:"customSubDomainName,omitempty"`

	// DefaultProject: Specifies the project, by project name, that is targeted when data plane endpoints are called without a
	// project parameter.
	DefaultProject   *string `json:"defaultProject,omitempty"`
	DisableLocalAuth *bool   `json:"disableLocalAuth,omitempty"`

	// DynamicThrottlingEnabled: The flag to enable dynamic throttling.
	DynamicThrottlingEnabled *bool `json:"dynamicThrottlingEnabled,omitempty"`

	// Encryption: The encryption properties for this resource.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Locations: The multiregion settings of Cognitive Services account.
	Locations *MultiRegionSettings `json:"locations,omitempty"`

	// MigrationToken: Resource migration token.
	MigrationToken *genruntime.SecretReference `json:"migrationToken,omitempty"`

	// NetworkAcls: A collection of rules governing the accessibility from specific network locations.
	NetworkAcls *NetworkRuleSet `json:"networkAcls,omitempty"`

	// NetworkInjections: Specifies in AI Foundry where virtual network injection occurs to secure scenarios like Agents
	// entirely within the  user's private network, eliminating public internet exposure while maintaining control over network
	// configurations and  resources.
	NetworkInjections *NetworkInjections `json:"networkInjections,omitempty"`

	// PublicNetworkAccess: Whether or not public endpoint access is allowed for this account.
	PublicNetworkAccess *AccountProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// RaiMonitorConfig: Cognitive Services Rai Monitor Config.
	RaiMonitorConfig              *RaiMonitorConfig `json:"raiMonitorConfig,omitempty"`
	Restore                       *bool             `json:"restore,omitempty"`
	RestrictOutboundNetworkAccess *bool             `json:"restrictOutboundNetworkAccess,omitempty"`

	// UserOwnedStorage: The storage accounts for this resource.
	UserOwnedStorage []UserOwnedStorage `json:"userOwnedStorage,omitempty"`
}

var _ genruntime.ARMTransformer = &AccountProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AccountProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AccountProperties{}

	// Set property "AllowProjectManagement":
	if properties.AllowProjectManagement != nil {
		allowProjectManagement := *properties.AllowProjectManagement
		result.AllowProjectManagement = &allowProjectManagement
	}

	// Set property "AllowedFqdnList":
	for _, item := range properties.AllowedFqdnList {
		result.AllowedFqdnList = append(result.AllowedFqdnList, item)
	}

	// Set property "AmlWorkspace":
	if properties.AmlWorkspace != nil {
		amlWorkspace_ARM, err := (*properties.AmlWorkspace).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		amlWorkspace := *amlWorkspace_ARM.(*arm.UserOwnedAmlWorkspace)
		result.AmlWorkspace = &amlWorkspace
	}

	// Set property "ApiProperties":
	if properties.ApiProperties != nil {
		apiProperties_ARM, err := (*properties.ApiProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiProperties := *apiProperties_ARM.(*arm.ApiProperties)
		result.ApiProperties = &apiProperties
	}

	// Set property "AssociatedProjects":
	for _, item := range properties.AssociatedProjects {
		result.AssociatedProjects = append(result.AssociatedProjects, item)
	}

	// Set property "CustomSubDomainName":
	if properties.CustomSubDomainName != nil {
		customSubDomainName := *properties.CustomSubDomainName
		result.CustomSubDomainName = &customSubDomainName
	}

	// Set property "DefaultProject":
	if properties.DefaultProject != nil {
		defaultProject := *properties.DefaultProject
		result.DefaultProject = &defaultProject
	}

	// Set property "DisableLocalAuth":
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DynamicThrottlingEnabled":
	if properties.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *properties.DynamicThrottlingEnabled
		result.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	}

	// Set property "Encryption":
	if properties.Encryption != nil {
		encryption_ARM, err := (*properties.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.Encryption)
		result.Encryption = &encryption
	}

	// Set property "Locations":
	if properties.Locations != nil {
		locations_ARM, err := (*properties.Locations).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		locations := *locations_ARM.(*arm.MultiRegionSettings)
		result.Locations = &locations
	}

	// Set property "MigrationToken":
	if properties.MigrationToken != nil {
		migrationTokenSecret, err := resolved.ResolvedSecrets.Lookup(*properties.MigrationToken)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property MigrationToken")
		}
		migrationToken := migrationTokenSecret
		result.MigrationToken = &migrationToken
	}

	// Set property "NetworkAcls":
	if properties.NetworkAcls != nil {
		networkAcls_ARM, err := (*properties.NetworkAcls).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkAcls := *networkAcls_ARM.(*arm.NetworkRuleSet)
		result.NetworkAcls = &networkAcls
	}

	// Set property "NetworkInjections":
	if properties.NetworkInjections != nil {
		networkInjections_ARM, err := (*properties.NetworkInjections).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkInjections := *networkInjections_ARM.(*arm.NetworkInjections)
		result.NetworkInjections = &networkInjections
	}

	// Set property "PublicNetworkAccess":
	if properties.PublicNetworkAccess != nil {
		var temp string
		temp = string(*properties.PublicNetworkAccess)
		publicNetworkAccess := arm.AccountProperties_PublicNetworkAccess(temp)
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RaiMonitorConfig":
	if properties.RaiMonitorConfig != nil {
		raiMonitorConfig_ARM, err := (*properties.RaiMonitorConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		raiMonitorConfig := *raiMonitorConfig_ARM.(*arm.RaiMonitorConfig)
		result.RaiMonitorConfig = &raiMonitorConfig
	}

	// Set property "Restore":
	if properties.Restore != nil {
		restore := *properties.Restore
		result.Restore = &restore
	}

	// Set property "RestrictOutboundNetworkAccess":
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		result.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "UserOwnedStorage":
	for _, item := range properties.UserOwnedStorage {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserOwnedStorage = append(result.UserOwnedStorage, *item_ARM.(*arm.UserOwnedStorage))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccountProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccountProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccountProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccountProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccountProperties, got %T", armInput)
	}

	// Set property "AllowProjectManagement":
	if typedInput.AllowProjectManagement != nil {
		allowProjectManagement := *typedInput.AllowProjectManagement
		properties.AllowProjectManagement = &allowProjectManagement
	}

	// Set property "AllowedFqdnList":
	for _, item := range typedInput.AllowedFqdnList {
		properties.AllowedFqdnList = append(properties.AllowedFqdnList, item)
	}

	// Set property "AmlWorkspace":
	if typedInput.AmlWorkspace != nil {
		var amlWorkspace1 UserOwnedAmlWorkspace
		err := amlWorkspace1.PopulateFromARM(owner, *typedInput.AmlWorkspace)
		if err != nil {
			return err
		}
		amlWorkspace := amlWorkspace1
		properties.AmlWorkspace = &amlWorkspace
	}

	// Set property "ApiProperties":
	if typedInput.ApiProperties != nil {
		var apiProperties1 ApiProperties
		err := apiProperties1.PopulateFromARM(owner, *typedInput.ApiProperties)
		if err != nil {
			return err
		}
		apiProperties := apiProperties1
		properties.ApiProperties = &apiProperties
	}

	// Set property "AssociatedProjects":
	for _, item := range typedInput.AssociatedProjects {
		properties.AssociatedProjects = append(properties.AssociatedProjects, item)
	}

	// Set property "CustomSubDomainName":
	if typedInput.CustomSubDomainName != nil {
		customSubDomainName := *typedInput.CustomSubDomainName
		properties.CustomSubDomainName = &customSubDomainName
	}

	// Set property "DefaultProject":
	if typedInput.DefaultProject != nil {
		defaultProject := *typedInput.DefaultProject
		properties.DefaultProject = &defaultProject
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DynamicThrottlingEnabled":
	if typedInput.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *typedInput.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 Encryption
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		properties.Encryption = &encryption
	}

	// Set property "Locations":
	if typedInput.Locations != nil {
		var locations1 MultiRegionSettings
		err := locations1.PopulateFromARM(owner, *typedInput.Locations)
		if err != nil {
			return err
		}
		locations := locations1
		properties.Locations = &locations
	}

	// no assignment for property "MigrationToken"

	// Set property "NetworkAcls":
	if typedInput.NetworkAcls != nil {
		var networkAcls1 NetworkRuleSet
		err := networkAcls1.PopulateFromARM(owner, *typedInput.NetworkAcls)
		if err != nil {
			return err
		}
		networkAcls := networkAcls1
		properties.NetworkAcls = &networkAcls
	}

	// Set property "NetworkInjections":
	if typedInput.NetworkInjections != nil {
		var networkInjections1 NetworkInjections
		err := networkInjections1.PopulateFromARM(owner, *typedInput.NetworkInjections)
		if err != nil {
			return err
		}
		networkInjections := networkInjections1
		properties.NetworkInjections = &networkInjections
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := AccountProperties_PublicNetworkAccess(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RaiMonitorConfig":
	if typedInput.RaiMonitorConfig != nil {
		var raiMonitorConfig1 RaiMonitorConfig
		err := raiMonitorConfig1.PopulateFromARM(owner, *typedInput.RaiMonitorConfig)
		if err != nil {
			return err
		}
		raiMonitorConfig := raiMonitorConfig1
		properties.RaiMonitorConfig = &raiMonitorConfig
	}

	// Set property "Restore":
	if typedInput.Restore != nil {
		restore := *typedInput.Restore
		properties.Restore = &restore
	}

	// Set property "RestrictOutboundNetworkAccess":
	if typedInput.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *typedInput.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "UserOwnedStorage":
	for _, item := range typedInput.UserOwnedStorage {
		var item1 UserOwnedStorage
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.UserOwnedStorage = append(properties.UserOwnedStorage, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AccountProperties populates our AccountProperties from the provided source AccountProperties
func (properties *AccountProperties) AssignProperties_From_AccountProperties(source *storage.AccountProperties) error {

	// AllowProjectManagement
	if source.AllowProjectManagement != nil {
		allowProjectManagement := *source.AllowProjectManagement
		properties.AllowProjectManagement = &allowProjectManagement
	} else {
		properties.AllowProjectManagement = nil
	}

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AmlWorkspace
	if source.AmlWorkspace != nil {
		var amlWorkspace UserOwnedAmlWorkspace
		err := amlWorkspace.AssignProperties_From_UserOwnedAmlWorkspace(source.AmlWorkspace)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserOwnedAmlWorkspace() to populate field AmlWorkspace")
		}
		properties.AmlWorkspace = &amlWorkspace
	} else {
		properties.AmlWorkspace = nil
	}

	// ApiProperties
	if source.ApiProperties != nil {
		var apiProperty ApiProperties
		err := apiProperty.AssignProperties_From_ApiProperties(source.ApiProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiProperties() to populate field ApiProperties")
		}
		properties.ApiProperties = &apiProperty
	} else {
		properties.ApiProperties = nil
	}

	// AssociatedProjects
	properties.AssociatedProjects = genruntime.CloneSliceOfString(source.AssociatedProjects)

	// CustomSubDomainName
	properties.CustomSubDomainName = genruntime.ClonePointerToString(source.CustomSubDomainName)

	// DefaultProject
	properties.DefaultProject = genruntime.ClonePointerToString(source.DefaultProject)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DynamicThrottlingEnabled
	if source.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *source.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		properties.DynamicThrottlingEnabled = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption
		err := encryption.AssignProperties_From_Encryption(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Encryption() to populate field Encryption")
		}
		properties.Encryption = &encryption
	} else {
		properties.Encryption = nil
	}

	// Locations
	if source.Locations != nil {
		var location MultiRegionSettings
		err := location.AssignProperties_From_MultiRegionSettings(source.Locations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MultiRegionSettings() to populate field Locations")
		}
		properties.Locations = &location
	} else {
		properties.Locations = nil
	}

	// MigrationToken
	if source.MigrationToken != nil {
		migrationToken := source.MigrationToken.Copy()
		properties.MigrationToken = &migrationToken
	} else {
		properties.MigrationToken = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkRuleSet
		err := networkAcl.AssignProperties_From_NetworkRuleSet(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSet() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// NetworkInjections
	if source.NetworkInjections != nil {
		var networkInjection NetworkInjections
		err := networkInjection.AssignProperties_From_NetworkInjections(source.NetworkInjections)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkInjections() to populate field NetworkInjections")
		}
		properties.NetworkInjections = &networkInjection
	} else {
		properties.NetworkInjections = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, accountProperties_PublicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// RaiMonitorConfig
	if source.RaiMonitorConfig != nil {
		var raiMonitorConfig RaiMonitorConfig
		err := raiMonitorConfig.AssignProperties_From_RaiMonitorConfig(source.RaiMonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RaiMonitorConfig() to populate field RaiMonitorConfig")
		}
		properties.RaiMonitorConfig = &raiMonitorConfig
	} else {
		properties.RaiMonitorConfig = nil
	}

	// Restore
	if source.Restore != nil {
		restore := *source.Restore
		properties.Restore = &restore
	} else {
		properties.Restore = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// UserOwnedStorage
	if source.UserOwnedStorage != nil {
		userOwnedStorageList := make([]UserOwnedStorage, len(source.UserOwnedStorage))
		for userOwnedStorageIndex, userOwnedStorageItem := range source.UserOwnedStorage {
			// Shadow the loop variable to avoid aliasing
			userOwnedStorageItem := userOwnedStorageItem
			var userOwnedStorage UserOwnedStorage
			err := userOwnedStorage.AssignProperties_From_UserOwnedStorage(&userOwnedStorageItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserOwnedStorage() to populate field UserOwnedStorage")
			}
			userOwnedStorageList[userOwnedStorageIndex] = userOwnedStorage
		}
		properties.UserOwnedStorage = userOwnedStorageList
	} else {
		properties.UserOwnedStorage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountProperties populates the provided destination AccountProperties from our AccountProperties
func (properties *AccountProperties) AssignProperties_To_AccountProperties(destination *storage.AccountProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowProjectManagement
	if properties.AllowProjectManagement != nil {
		allowProjectManagement := *properties.AllowProjectManagement
		destination.AllowProjectManagement = &allowProjectManagement
	} else {
		destination.AllowProjectManagement = nil
	}

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(properties.AllowedFqdnList)

	// AmlWorkspace
	if properties.AmlWorkspace != nil {
		var amlWorkspace storage.UserOwnedAmlWorkspace
		err := properties.AmlWorkspace.AssignProperties_To_UserOwnedAmlWorkspace(&amlWorkspace)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserOwnedAmlWorkspace() to populate field AmlWorkspace")
		}
		destination.AmlWorkspace = &amlWorkspace
	} else {
		destination.AmlWorkspace = nil
	}

	// ApiProperties
	if properties.ApiProperties != nil {
		var apiProperty storage.ApiProperties
		err := properties.ApiProperties.AssignProperties_To_ApiProperties(&apiProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiProperties() to populate field ApiProperties")
		}
		destination.ApiProperties = &apiProperty
	} else {
		destination.ApiProperties = nil
	}

	// AssociatedProjects
	destination.AssociatedProjects = genruntime.CloneSliceOfString(properties.AssociatedProjects)

	// CustomSubDomainName
	destination.CustomSubDomainName = genruntime.ClonePointerToString(properties.CustomSubDomainName)

	// DefaultProject
	destination.DefaultProject = genruntime.ClonePointerToString(properties.DefaultProject)

	// DisableLocalAuth
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// DynamicThrottlingEnabled
	if properties.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *properties.DynamicThrottlingEnabled
		destination.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		destination.DynamicThrottlingEnabled = nil
	}

	// Encryption
	if properties.Encryption != nil {
		var encryption storage.Encryption
		err := properties.Encryption.AssignProperties_To_Encryption(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Encryption() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Locations
	if properties.Locations != nil {
		var location storage.MultiRegionSettings
		err := properties.Locations.AssignProperties_To_MultiRegionSettings(&location)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MultiRegionSettings() to populate field Locations")
		}
		destination.Locations = &location
	} else {
		destination.Locations = nil
	}

	// MigrationToken
	if properties.MigrationToken != nil {
		migrationToken := properties.MigrationToken.Copy()
		destination.MigrationToken = &migrationToken
	} else {
		destination.MigrationToken = nil
	}

	// NetworkAcls
	if properties.NetworkAcls != nil {
		var networkAcl storage.NetworkRuleSet
		err := properties.NetworkAcls.AssignProperties_To_NetworkRuleSet(&networkAcl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSet() to populate field NetworkAcls")
		}
		destination.NetworkAcls = &networkAcl
	} else {
		destination.NetworkAcls = nil
	}

	// NetworkInjections
	if properties.NetworkInjections != nil {
		var networkInjection storage.NetworkInjections
		err := properties.NetworkInjections.AssignProperties_To_NetworkInjections(&networkInjection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkInjections() to populate field NetworkInjections")
		}
		destination.NetworkInjections = &networkInjection
	} else {
		destination.NetworkInjections = nil
	}

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RaiMonitorConfig
	if properties.RaiMonitorConfig != nil {
		var raiMonitorConfig storage.RaiMonitorConfig
		err := properties.RaiMonitorConfig.AssignProperties_To_RaiMonitorConfig(&raiMonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RaiMonitorConfig() to populate field RaiMonitorConfig")
		}
		destination.RaiMonitorConfig = &raiMonitorConfig
	} else {
		destination.RaiMonitorConfig = nil
	}

	// Restore
	if properties.Restore != nil {
		restore := *properties.Restore
		destination.Restore = &restore
	} else {
		destination.Restore = nil
	}

	// RestrictOutboundNetworkAccess
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// UserOwnedStorage
	if properties.UserOwnedStorage != nil {
		userOwnedStorageList := make([]storage.UserOwnedStorage, len(properties.UserOwnedStorage))
		for userOwnedStorageIndex, userOwnedStorageItem := range properties.UserOwnedStorage {
			// Shadow the loop variable to avoid aliasing
			userOwnedStorageItem := userOwnedStorageItem
			var userOwnedStorage storage.UserOwnedStorage
			err := userOwnedStorageItem.AssignProperties_To_UserOwnedStorage(&userOwnedStorage)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserOwnedStorage() to populate field UserOwnedStorage")
			}
			userOwnedStorageList[userOwnedStorageIndex] = userOwnedStorage
		}
		destination.UserOwnedStorage = userOwnedStorageList
	} else {
		destination.UserOwnedStorage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AccountProperties_STATUS populates our AccountProperties from the provided source AccountProperties_STATUS
func (properties *AccountProperties) Initialize_From_AccountProperties_STATUS(source *AccountProperties_STATUS) error {

	// AllowProjectManagement
	if source.AllowProjectManagement != nil {
		allowProjectManagement := *source.AllowProjectManagement
		properties.AllowProjectManagement = &allowProjectManagement
	} else {
		properties.AllowProjectManagement = nil
	}

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AmlWorkspace
	if source.AmlWorkspace != nil {
		var amlWorkspace UserOwnedAmlWorkspace
		err := amlWorkspace.Initialize_From_UserOwnedAmlWorkspace_STATUS(source.AmlWorkspace)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_UserOwnedAmlWorkspace_STATUS() to populate field AmlWorkspace")
		}
		properties.AmlWorkspace = &amlWorkspace
	} else {
		properties.AmlWorkspace = nil
	}

	// ApiProperties
	if source.ApiProperties != nil {
		var apiProperty ApiProperties
		err := apiProperty.Initialize_From_ApiProperties_STATUS(source.ApiProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApiProperties_STATUS() to populate field ApiProperties")
		}
		properties.ApiProperties = &apiProperty
	} else {
		properties.ApiProperties = nil
	}

	// AssociatedProjects
	properties.AssociatedProjects = genruntime.CloneSliceOfString(source.AssociatedProjects)

	// CustomSubDomainName
	properties.CustomSubDomainName = genruntime.ClonePointerToString(source.CustomSubDomainName)

	// DefaultProject
	properties.DefaultProject = genruntime.ClonePointerToString(source.DefaultProject)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DynamicThrottlingEnabled
	if source.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *source.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		properties.DynamicThrottlingEnabled = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption
		err := encryption.Initialize_From_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Encryption_STATUS() to populate field Encryption")
		}
		properties.Encryption = &encryption
	} else {
		properties.Encryption = nil
	}

	// Locations
	if source.Locations != nil {
		var location MultiRegionSettings
		err := location.Initialize_From_MultiRegionSettings_STATUS(source.Locations)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_MultiRegionSettings_STATUS() to populate field Locations")
		}
		properties.Locations = &location
	} else {
		properties.Locations = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkRuleSet
		err := networkAcl.Initialize_From_NetworkRuleSet_STATUS(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkRuleSet_STATUS() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// NetworkInjections
	if source.NetworkInjections != nil {
		var networkInjection NetworkInjections
		err := networkInjection.Initialize_From_NetworkInjections_STATUS(source.NetworkInjections)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkInjections_STATUS() to populate field NetworkInjections")
		}
		properties.NetworkInjections = &networkInjection
	} else {
		properties.NetworkInjections = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), accountProperties_PublicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccess
	} else {
		properties.PublicNetworkAccess = nil
	}

	// RaiMonitorConfig
	if source.RaiMonitorConfig != nil {
		var raiMonitorConfig RaiMonitorConfig
		err := raiMonitorConfig.Initialize_From_RaiMonitorConfig_STATUS(source.RaiMonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_RaiMonitorConfig_STATUS() to populate field RaiMonitorConfig")
		}
		properties.RaiMonitorConfig = &raiMonitorConfig
	} else {
		properties.RaiMonitorConfig = nil
	}

	// Restore
	if source.Restore != nil {
		restore := *source.Restore
		properties.Restore = &restore
	} else {
		properties.Restore = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// UserOwnedStorage
	if source.UserOwnedStorage != nil {
		userOwnedStorageList := make([]UserOwnedStorage, len(source.UserOwnedStorage))
		for userOwnedStorageIndex, userOwnedStorageItem := range source.UserOwnedStorage {
			// Shadow the loop variable to avoid aliasing
			userOwnedStorageItem := userOwnedStorageItem
			var userOwnedStorage UserOwnedStorage
			err := userOwnedStorage.Initialize_From_UserOwnedStorage_STATUS(&userOwnedStorageItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_UserOwnedStorage_STATUS() to populate field UserOwnedStorage")
			}
			userOwnedStorageList[userOwnedStorageIndex] = userOwnedStorage
		}
		properties.UserOwnedStorage = userOwnedStorageList
	} else {
		properties.UserOwnedStorage = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account.
type AccountProperties_STATUS struct {
	// AbusePenalty: The abuse penalty.
	AbusePenalty *AbusePenalty_STATUS `json:"abusePenalty,omitempty"`

	// AllowProjectManagement: Specifies whether this resource support project management as child resources, used as
	// containers for access management, data isolation and cost in AI Foundry.
	AllowProjectManagement *bool    `json:"allowProjectManagement,omitempty"`
	AllowedFqdnList        []string `json:"allowedFqdnList,omitempty"`

	// AmlWorkspace: The user owned AML account properties.
	AmlWorkspace *UserOwnedAmlWorkspace_STATUS `json:"amlWorkspace,omitempty"`

	// ApiProperties: The api properties for special APIs.
	ApiProperties *ApiProperties_STATUS `json:"apiProperties,omitempty"`

	// AssociatedProjects: Specifies the projects, by project name, that are associated with this resource.
	AssociatedProjects []string `json:"associatedProjects,omitempty"`

	// CallRateLimit: The call rate limit Cognitive Services account.
	CallRateLimit *CallRateLimit_STATUS `json:"callRateLimit,omitempty"`

	// Capabilities: Gets the capabilities of the cognitive services account. Each item indicates the capability of a specific
	// feature. The values are read-only and for reference only.
	Capabilities []SkuCapability_STATUS `json:"capabilities,omitempty"`

	// CommitmentPlanAssociations: The commitment plan associations of Cognitive Services account.
	CommitmentPlanAssociations []CommitmentPlanAssociation_STATUS `json:"commitmentPlanAssociations,omitempty"`

	// CustomSubDomainName: Optional subdomain name used for token-based authentication.
	CustomSubDomainName *string `json:"customSubDomainName,omitempty"`

	// DateCreated: Gets the date of cognitive services account creation.
	DateCreated *string `json:"dateCreated,omitempty"`

	// DefaultProject: Specifies the project, by project name, that is targeted when data plane endpoints are called without a
	// project parameter.
	DefaultProject *string `json:"defaultProject,omitempty"`

	// DeletionDate: The deletion date, only available for deleted account.
	DeletionDate     *string `json:"deletionDate,omitempty"`
	DisableLocalAuth *bool   `json:"disableLocalAuth,omitempty"`

	// DynamicThrottlingEnabled: The flag to enable dynamic throttling.
	DynamicThrottlingEnabled *bool `json:"dynamicThrottlingEnabled,omitempty"`

	// Encryption: The encryption properties for this resource.
	Encryption *Encryption_STATUS `json:"encryption,omitempty"`

	// Endpoint: Endpoint of the created account.
	Endpoint  *string           `json:"endpoint,omitempty"`
	Endpoints map[string]string `json:"endpoints,omitempty"`

	// InternalId: The internal identifier (deprecated, do not use this property).
	InternalId *string `json:"internalId,omitempty"`

	// IsMigrated: If the resource is migrated from an existing key.
	IsMigrated *bool `json:"isMigrated,omitempty"`

	// Locations: The multiregion settings of Cognitive Services account.
	Locations *MultiRegionSettings_STATUS `json:"locations,omitempty"`

	// NetworkAcls: A collection of rules governing the accessibility from specific network locations.
	NetworkAcls *NetworkRuleSet_STATUS `json:"networkAcls,omitempty"`

	// NetworkInjections: Specifies in AI Foundry where virtual network injection occurs to secure scenarios like Agents
	// entirely within the  user's private network, eliminating public internet exposure while maintaining control over network
	// configurations and  resources.
	NetworkInjections *NetworkInjections_STATUS `json:"networkInjections,omitempty"`

	// PrivateEndpointConnections: The private endpoint connection associated with the Cognitive Services account.
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: Gets the status of the cognitive services account at the time the operation was called.
	ProvisioningState *AccountProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Whether or not public endpoint access is allowed for this account.
	PublicNetworkAccess *AccountProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`
	QuotaLimit          *QuotaLimit_STATUS                            `json:"quotaLimit,omitempty"`

	// RaiMonitorConfig: Cognitive Services Rai Monitor Config.
	RaiMonitorConfig              *RaiMonitorConfig_STATUS `json:"raiMonitorConfig,omitempty"`
	Restore                       *bool                    `json:"restore,omitempty"`
	RestrictOutboundNetworkAccess *bool                    `json:"restrictOutboundNetworkAccess,omitempty"`

	// ScheduledPurgeDate: The scheduled purge date, only available for deleted account.
	ScheduledPurgeDate *string `json:"scheduledPurgeDate,omitempty"`

	// SkuChangeInfo: Sku change info of account.
	SkuChangeInfo *SkuChangeInfo_STATUS `json:"skuChangeInfo,omitempty"`

	// UserOwnedStorage: The storage accounts for this resource.
	UserOwnedStorage []UserOwnedStorage_STATUS `json:"userOwnedStorage,omitempty"`
}

var _ genruntime.FromARMConverter = &AccountProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccountProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccountProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccountProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccountProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccountProperties_STATUS, got %T", armInput)
	}

	// Set property "AbusePenalty":
	if typedInput.AbusePenalty != nil {
		var abusePenalty1 AbusePenalty_STATUS
		err := abusePenalty1.PopulateFromARM(owner, *typedInput.AbusePenalty)
		if err != nil {
			return err
		}
		abusePenalty := abusePenalty1
		properties.AbusePenalty = &abusePenalty
	}

	// Set property "AllowProjectManagement":
	if typedInput.AllowProjectManagement != nil {
		allowProjectManagement := *typedInput.AllowProjectManagement
		properties.AllowProjectManagement = &allowProjectManagement
	}

	// Set property "AllowedFqdnList":
	for _, item := range typedInput.AllowedFqdnList {
		properties.AllowedFqdnList = append(properties.AllowedFqdnList, item)
	}

	// Set property "AmlWorkspace":
	if typedInput.AmlWorkspace != nil {
		var amlWorkspace1 UserOwnedAmlWorkspace_STATUS
		err := amlWorkspace1.PopulateFromARM(owner, *typedInput.AmlWorkspace)
		if err != nil {
			return err
		}
		amlWorkspace := amlWorkspace1
		properties.AmlWorkspace = &amlWorkspace
	}

	// Set property "ApiProperties":
	if typedInput.ApiProperties != nil {
		var apiProperties1 ApiProperties_STATUS
		err := apiProperties1.PopulateFromARM(owner, *typedInput.ApiProperties)
		if err != nil {
			return err
		}
		apiProperties := apiProperties1
		properties.ApiProperties = &apiProperties
	}

	// Set property "AssociatedProjects":
	for _, item := range typedInput.AssociatedProjects {
		properties.AssociatedProjects = append(properties.AssociatedProjects, item)
	}

	// Set property "CallRateLimit":
	if typedInput.CallRateLimit != nil {
		var callRateLimit1 CallRateLimit_STATUS
		err := callRateLimit1.PopulateFromARM(owner, *typedInput.CallRateLimit)
		if err != nil {
			return err
		}
		callRateLimit := callRateLimit1
		properties.CallRateLimit = &callRateLimit
	}

	// Set property "Capabilities":
	for _, item := range typedInput.Capabilities {
		var item1 SkuCapability_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Capabilities = append(properties.Capabilities, item1)
	}

	// Set property "CommitmentPlanAssociations":
	for _, item := range typedInput.CommitmentPlanAssociations {
		var item1 CommitmentPlanAssociation_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.CommitmentPlanAssociations = append(properties.CommitmentPlanAssociations, item1)
	}

	// Set property "CustomSubDomainName":
	if typedInput.CustomSubDomainName != nil {
		customSubDomainName := *typedInput.CustomSubDomainName
		properties.CustomSubDomainName = &customSubDomainName
	}

	// Set property "DateCreated":
	if typedInput.DateCreated != nil {
		dateCreated := *typedInput.DateCreated
		properties.DateCreated = &dateCreated
	}

	// Set property "DefaultProject":
	if typedInput.DefaultProject != nil {
		defaultProject := *typedInput.DefaultProject
		properties.DefaultProject = &defaultProject
	}

	// Set property "DeletionDate":
	if typedInput.DeletionDate != nil {
		deletionDate := *typedInput.DeletionDate
		properties.DeletionDate = &deletionDate
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DynamicThrottlingEnabled":
	if typedInput.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *typedInput.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 Encryption_STATUS
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		properties.Encryption = &encryption
	}

	// Set property "Endpoint":
	if typedInput.Endpoint != nil {
		endpoint := *typedInput.Endpoint
		properties.Endpoint = &endpoint
	}

	// Set property "Endpoints":
	if typedInput.Endpoints != nil {
		properties.Endpoints = make(map[string]string, len(typedInput.Endpoints))
		for key, value := range typedInput.Endpoints {
			properties.Endpoints[key] = value
		}
	}

	// Set property "InternalId":
	if typedInput.InternalId != nil {
		internalId := *typedInput.InternalId
		properties.InternalId = &internalId
	}

	// Set property "IsMigrated":
	if typedInput.IsMigrated != nil {
		isMigrated := *typedInput.IsMigrated
		properties.IsMigrated = &isMigrated
	}

	// Set property "Locations":
	if typedInput.Locations != nil {
		var locations1 MultiRegionSettings_STATUS
		err := locations1.PopulateFromARM(owner, *typedInput.Locations)
		if err != nil {
			return err
		}
		locations := locations1
		properties.Locations = &locations
	}

	// Set property "NetworkAcls":
	if typedInput.NetworkAcls != nil {
		var networkAcls1 NetworkRuleSet_STATUS
		err := networkAcls1.PopulateFromARM(owner, *typedInput.NetworkAcls)
		if err != nil {
			return err
		}
		networkAcls := networkAcls1
		properties.NetworkAcls = &networkAcls
	}

	// Set property "NetworkInjections":
	if typedInput.NetworkInjections != nil {
		var networkInjections1 NetworkInjections_STATUS
		err := networkInjections1.PopulateFromARM(owner, *typedInput.NetworkInjections)
		if err != nil {
			return err
		}
		networkInjections := networkInjections1
		properties.NetworkInjections = &networkInjections
	}

	// Set property "PrivateEndpointConnections":
	for _, item := range typedInput.PrivateEndpointConnections {
		var item1 PrivateEndpointConnection_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.PrivateEndpointConnections = append(properties.PrivateEndpointConnections, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := AccountProperties_ProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := AccountProperties_PublicNetworkAccess_STATUS(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "QuotaLimit":
	if typedInput.QuotaLimit != nil {
		var quotaLimit1 QuotaLimit_STATUS
		err := quotaLimit1.PopulateFromARM(owner, *typedInput.QuotaLimit)
		if err != nil {
			return err
		}
		quotaLimit := quotaLimit1
		properties.QuotaLimit = &quotaLimit
	}

	// Set property "RaiMonitorConfig":
	if typedInput.RaiMonitorConfig != nil {
		var raiMonitorConfig1 RaiMonitorConfig_STATUS
		err := raiMonitorConfig1.PopulateFromARM(owner, *typedInput.RaiMonitorConfig)
		if err != nil {
			return err
		}
		raiMonitorConfig := raiMonitorConfig1
		properties.RaiMonitorConfig = &raiMonitorConfig
	}

	// Set property "Restore":
	if typedInput.Restore != nil {
		restore := *typedInput.Restore
		properties.Restore = &restore
	}

	// Set property "RestrictOutboundNetworkAccess":
	if typedInput.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *typedInput.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "ScheduledPurgeDate":
	if typedInput.ScheduledPurgeDate != nil {
		scheduledPurgeDate := *typedInput.ScheduledPurgeDate
		properties.ScheduledPurgeDate = &scheduledPurgeDate
	}

	// Set property "SkuChangeInfo":
	if typedInput.SkuChangeInfo != nil {
		var skuChangeInfo1 SkuChangeInfo_STATUS
		err := skuChangeInfo1.PopulateFromARM(owner, *typedInput.SkuChangeInfo)
		if err != nil {
			return err
		}
		skuChangeInfo := skuChangeInfo1
		properties.SkuChangeInfo = &skuChangeInfo
	}

	// Set property "UserOwnedStorage":
	for _, item := range typedInput.UserOwnedStorage {
		var item1 UserOwnedStorage_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.UserOwnedStorage = append(properties.UserOwnedStorage, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AccountProperties_STATUS populates our AccountProperties_STATUS from the provided source AccountProperties_STATUS
func (properties *AccountProperties_STATUS) AssignProperties_From_AccountProperties_STATUS(source *storage.AccountProperties_STATUS) error {

	// AbusePenalty
	if source.AbusePenalty != nil {
		var abusePenalty AbusePenalty_STATUS
		err := abusePenalty.AssignProperties_From_AbusePenalty_STATUS(source.AbusePenalty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AbusePenalty_STATUS() to populate field AbusePenalty")
		}
		properties.AbusePenalty = &abusePenalty
	} else {
		properties.AbusePenalty = nil
	}

	// AllowProjectManagement
	if source.AllowProjectManagement != nil {
		allowProjectManagement := *source.AllowProjectManagement
		properties.AllowProjectManagement = &allowProjectManagement
	} else {
		properties.AllowProjectManagement = nil
	}

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AmlWorkspace
	if source.AmlWorkspace != nil {
		var amlWorkspace UserOwnedAmlWorkspace_STATUS
		err := amlWorkspace.AssignProperties_From_UserOwnedAmlWorkspace_STATUS(source.AmlWorkspace)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserOwnedAmlWorkspace_STATUS() to populate field AmlWorkspace")
		}
		properties.AmlWorkspace = &amlWorkspace
	} else {
		properties.AmlWorkspace = nil
	}

	// ApiProperties
	if source.ApiProperties != nil {
		var apiProperty ApiProperties_STATUS
		err := apiProperty.AssignProperties_From_ApiProperties_STATUS(source.ApiProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiProperties_STATUS() to populate field ApiProperties")
		}
		properties.ApiProperties = &apiProperty
	} else {
		properties.ApiProperties = nil
	}

	// AssociatedProjects
	properties.AssociatedProjects = genruntime.CloneSliceOfString(source.AssociatedProjects)

	// CallRateLimit
	if source.CallRateLimit != nil {
		var callRateLimit CallRateLimit_STATUS
		err := callRateLimit.AssignProperties_From_CallRateLimit_STATUS(source.CallRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		properties.CallRateLimit = &callRateLimit
	} else {
		properties.CallRateLimit = nil
	}

	// Capabilities
	if source.Capabilities != nil {
		capabilityList := make([]SkuCapability_STATUS, len(source.Capabilities))
		for capabilityIndex, capabilityItem := range source.Capabilities {
			// Shadow the loop variable to avoid aliasing
			capabilityItem := capabilityItem
			var capability SkuCapability_STATUS
			err := capability.AssignProperties_From_SkuCapability_STATUS(&capabilityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SkuCapability_STATUS() to populate field Capabilities")
			}
			capabilityList[capabilityIndex] = capability
		}
		properties.Capabilities = capabilityList
	} else {
		properties.Capabilities = nil
	}

	// CommitmentPlanAssociations
	if source.CommitmentPlanAssociations != nil {
		commitmentPlanAssociationList := make([]CommitmentPlanAssociation_STATUS, len(source.CommitmentPlanAssociations))
		for commitmentPlanAssociationIndex, commitmentPlanAssociationItem := range source.CommitmentPlanAssociations {
			// Shadow the loop variable to avoid aliasing
			commitmentPlanAssociationItem := commitmentPlanAssociationItem
			var commitmentPlanAssociation CommitmentPlanAssociation_STATUS
			err := commitmentPlanAssociation.AssignProperties_From_CommitmentPlanAssociation_STATUS(&commitmentPlanAssociationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CommitmentPlanAssociation_STATUS() to populate field CommitmentPlanAssociations")
			}
			commitmentPlanAssociationList[commitmentPlanAssociationIndex] = commitmentPlanAssociation
		}
		properties.CommitmentPlanAssociations = commitmentPlanAssociationList
	} else {
		properties.CommitmentPlanAssociations = nil
	}

	// CustomSubDomainName
	properties.CustomSubDomainName = genruntime.ClonePointerToString(source.CustomSubDomainName)

	// DateCreated
	properties.DateCreated = genruntime.ClonePointerToString(source.DateCreated)

	// DefaultProject
	properties.DefaultProject = genruntime.ClonePointerToString(source.DefaultProject)

	// DeletionDate
	properties.DeletionDate = genruntime.ClonePointerToString(source.DeletionDate)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DynamicThrottlingEnabled
	if source.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *source.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		properties.DynamicThrottlingEnabled = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption_STATUS
		err := encryption.AssignProperties_From_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Encryption_STATUS() to populate field Encryption")
		}
		properties.Encryption = &encryption
	} else {
		properties.Encryption = nil
	}

	// Endpoint
	properties.Endpoint = genruntime.ClonePointerToString(source.Endpoint)

	// Endpoints
	properties.Endpoints = genruntime.CloneMapOfStringToString(source.Endpoints)

	// InternalId
	properties.InternalId = genruntime.ClonePointerToString(source.InternalId)

	// IsMigrated
	if source.IsMigrated != nil {
		isMigrated := *source.IsMigrated
		properties.IsMigrated = &isMigrated
	} else {
		properties.IsMigrated = nil
	}

	// Locations
	if source.Locations != nil {
		var location MultiRegionSettings_STATUS
		err := location.AssignProperties_From_MultiRegionSettings_STATUS(source.Locations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MultiRegionSettings_STATUS() to populate field Locations")
		}
		properties.Locations = &location
	} else {
		properties.Locations = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkRuleSet_STATUS
		err := networkAcl.AssignProperties_From_NetworkRuleSet_STATUS(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSet_STATUS() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// NetworkInjections
	if source.NetworkInjections != nil {
		var networkInjection NetworkInjections_STATUS
		err := networkInjection.AssignProperties_From_NetworkInjections_STATUS(source.NetworkInjections)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkInjections_STATUS() to populate field NetworkInjections")
		}
		properties.NetworkInjections = &networkInjection
	} else {
		properties.NetworkInjections = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		properties.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		properties.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, accountProperties_ProvisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, accountProperties_PublicNetworkAccess_STATUS_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// QuotaLimit
	if source.QuotaLimit != nil {
		var quotaLimit QuotaLimit_STATUS
		err := quotaLimit.AssignProperties_From_QuotaLimit_STATUS(source.QuotaLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_QuotaLimit_STATUS() to populate field QuotaLimit")
		}
		properties.QuotaLimit = &quotaLimit
	} else {
		properties.QuotaLimit = nil
	}

	// RaiMonitorConfig
	if source.RaiMonitorConfig != nil {
		var raiMonitorConfig RaiMonitorConfig_STATUS
		err := raiMonitorConfig.AssignProperties_From_RaiMonitorConfig_STATUS(source.RaiMonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RaiMonitorConfig_STATUS() to populate field RaiMonitorConfig")
		}
		properties.RaiMonitorConfig = &raiMonitorConfig
	} else {
		properties.RaiMonitorConfig = nil
	}

	// Restore
	if source.Restore != nil {
		restore := *source.Restore
		properties.Restore = &restore
	} else {
		properties.Restore = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// ScheduledPurgeDate
	properties.ScheduledPurgeDate = genruntime.ClonePointerToString(source.ScheduledPurgeDate)

	// SkuChangeInfo
	if source.SkuChangeInfo != nil {
		var skuChangeInfo SkuChangeInfo_STATUS
		err := skuChangeInfo.AssignProperties_From_SkuChangeInfo_STATUS(source.SkuChangeInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SkuChangeInfo_STATUS() to populate field SkuChangeInfo")
		}
		properties.SkuChangeInfo = &skuChangeInfo
	} else {
		properties.SkuChangeInfo = nil
	}

	// UserOwnedStorage
	if source.UserOwnedStorage != nil {
		userOwnedStorageList := make([]UserOwnedStorage_STATUS, len(source.UserOwnedStorage))
		for userOwnedStorageIndex, userOwnedStorageItem := range source.UserOwnedStorage {
			// Shadow the loop variable to avoid aliasing
			userOwnedStorageItem := userOwnedStorageItem
			var userOwnedStorage UserOwnedStorage_STATUS
			err := userOwnedStorage.AssignProperties_From_UserOwnedStorage_STATUS(&userOwnedStorageItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserOwnedStorage_STATUS() to populate field UserOwnedStorage")
			}
			userOwnedStorageList[userOwnedStorageIndex] = userOwnedStorage
		}
		properties.UserOwnedStorage = userOwnedStorageList
	} else {
		properties.UserOwnedStorage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountProperties_STATUS populates the provided destination AccountProperties_STATUS from our AccountProperties_STATUS
func (properties *AccountProperties_STATUS) AssignProperties_To_AccountProperties_STATUS(destination *storage.AccountProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AbusePenalty
	if properties.AbusePenalty != nil {
		var abusePenalty storage.AbusePenalty_STATUS
		err := properties.AbusePenalty.AssignProperties_To_AbusePenalty_STATUS(&abusePenalty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AbusePenalty_STATUS() to populate field AbusePenalty")
		}
		destination.AbusePenalty = &abusePenalty
	} else {
		destination.AbusePenalty = nil
	}

	// AllowProjectManagement
	if properties.AllowProjectManagement != nil {
		allowProjectManagement := *properties.AllowProjectManagement
		destination.AllowProjectManagement = &allowProjectManagement
	} else {
		destination.AllowProjectManagement = nil
	}

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(properties.AllowedFqdnList)

	// AmlWorkspace
	if properties.AmlWorkspace != nil {
		var amlWorkspace storage.UserOwnedAmlWorkspace_STATUS
		err := properties.AmlWorkspace.AssignProperties_To_UserOwnedAmlWorkspace_STATUS(&amlWorkspace)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserOwnedAmlWorkspace_STATUS() to populate field AmlWorkspace")
		}
		destination.AmlWorkspace = &amlWorkspace
	} else {
		destination.AmlWorkspace = nil
	}

	// ApiProperties
	if properties.ApiProperties != nil {
		var apiProperty storage.ApiProperties_STATUS
		err := properties.ApiProperties.AssignProperties_To_ApiProperties_STATUS(&apiProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiProperties_STATUS() to populate field ApiProperties")
		}
		destination.ApiProperties = &apiProperty
	} else {
		destination.ApiProperties = nil
	}

	// AssociatedProjects
	destination.AssociatedProjects = genruntime.CloneSliceOfString(properties.AssociatedProjects)

	// CallRateLimit
	if properties.CallRateLimit != nil {
		var callRateLimit storage.CallRateLimit_STATUS
		err := properties.CallRateLimit.AssignProperties_To_CallRateLimit_STATUS(&callRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		destination.CallRateLimit = &callRateLimit
	} else {
		destination.CallRateLimit = nil
	}

	// Capabilities
	if properties.Capabilities != nil {
		capabilityList := make([]storage.SkuCapability_STATUS, len(properties.Capabilities))
		for capabilityIndex, capabilityItem := range properties.Capabilities {
			// Shadow the loop variable to avoid aliasing
			capabilityItem := capabilityItem
			var capability storage.SkuCapability_STATUS
			err := capabilityItem.AssignProperties_To_SkuCapability_STATUS(&capability)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SkuCapability_STATUS() to populate field Capabilities")
			}
			capabilityList[capabilityIndex] = capability
		}
		destination.Capabilities = capabilityList
	} else {
		destination.Capabilities = nil
	}

	// CommitmentPlanAssociations
	if properties.CommitmentPlanAssociations != nil {
		commitmentPlanAssociationList := make([]storage.CommitmentPlanAssociation_STATUS, len(properties.CommitmentPlanAssociations))
		for commitmentPlanAssociationIndex, commitmentPlanAssociationItem := range properties.CommitmentPlanAssociations {
			// Shadow the loop variable to avoid aliasing
			commitmentPlanAssociationItem := commitmentPlanAssociationItem
			var commitmentPlanAssociation storage.CommitmentPlanAssociation_STATUS
			err := commitmentPlanAssociationItem.AssignProperties_To_CommitmentPlanAssociation_STATUS(&commitmentPlanAssociation)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CommitmentPlanAssociation_STATUS() to populate field CommitmentPlanAssociations")
			}
			commitmentPlanAssociationList[commitmentPlanAssociationIndex] = commitmentPlanAssociation
		}
		destination.CommitmentPlanAssociations = commitmentPlanAssociationList
	} else {
		destination.CommitmentPlanAssociations = nil
	}

	// CustomSubDomainName
	destination.CustomSubDomainName = genruntime.ClonePointerToString(properties.CustomSubDomainName)

	// DateCreated
	destination.DateCreated = genruntime.ClonePointerToString(properties.DateCreated)

	// DefaultProject
	destination.DefaultProject = genruntime.ClonePointerToString(properties.DefaultProject)

	// DeletionDate
	destination.DeletionDate = genruntime.ClonePointerToString(properties.DeletionDate)

	// DisableLocalAuth
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// DynamicThrottlingEnabled
	if properties.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *properties.DynamicThrottlingEnabled
		destination.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		destination.DynamicThrottlingEnabled = nil
	}

	// Encryption
	if properties.Encryption != nil {
		var encryption storage.Encryption_STATUS
		err := properties.Encryption.AssignProperties_To_Encryption_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Encryption_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Endpoint
	destination.Endpoint = genruntime.ClonePointerToString(properties.Endpoint)

	// Endpoints
	destination.Endpoints = genruntime.CloneMapOfStringToString(properties.Endpoints)

	// InternalId
	destination.InternalId = genruntime.ClonePointerToString(properties.InternalId)

	// IsMigrated
	if properties.IsMigrated != nil {
		isMigrated := *properties.IsMigrated
		destination.IsMigrated = &isMigrated
	} else {
		destination.IsMigrated = nil
	}

	// Locations
	if properties.Locations != nil {
		var location storage.MultiRegionSettings_STATUS
		err := properties.Locations.AssignProperties_To_MultiRegionSettings_STATUS(&location)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MultiRegionSettings_STATUS() to populate field Locations")
		}
		destination.Locations = &location
	} else {
		destination.Locations = nil
	}

	// NetworkAcls
	if properties.NetworkAcls != nil {
		var networkAcl storage.NetworkRuleSet_STATUS
		err := properties.NetworkAcls.AssignProperties_To_NetworkRuleSet_STATUS(&networkAcl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSet_STATUS() to populate field NetworkAcls")
		}
		destination.NetworkAcls = &networkAcl
	} else {
		destination.NetworkAcls = nil
	}

	// NetworkInjections
	if properties.NetworkInjections != nil {
		var networkInjection storage.NetworkInjections_STATUS
		err := properties.NetworkInjections.AssignProperties_To_NetworkInjections_STATUS(&networkInjection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkInjections_STATUS() to populate field NetworkInjections")
		}
		destination.NetworkInjections = &networkInjection
	} else {
		destination.NetworkInjections = nil
	}

	// PrivateEndpointConnections
	if properties.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(properties.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range properties.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// QuotaLimit
	if properties.QuotaLimit != nil {
		var quotaLimit storage.QuotaLimit_STATUS
		err := properties.QuotaLimit.AssignProperties_To_QuotaLimit_STATUS(&quotaLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_QuotaLimit_STATUS() to populate field QuotaLimit")
		}
		destination.QuotaLimit = &quotaLimit
	} else {
		destination.QuotaLimit = nil
	}

	// RaiMonitorConfig
	if properties.RaiMonitorConfig != nil {
		var raiMonitorConfig storage.RaiMonitorConfig_STATUS
		err := properties.RaiMonitorConfig.AssignProperties_To_RaiMonitorConfig_STATUS(&raiMonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RaiMonitorConfig_STATUS() to populate field RaiMonitorConfig")
		}
		destination.RaiMonitorConfig = &raiMonitorConfig
	} else {
		destination.RaiMonitorConfig = nil
	}

	// Restore
	if properties.Restore != nil {
		restore := *properties.Restore
		destination.Restore = &restore
	} else {
		destination.Restore = nil
	}

	// RestrictOutboundNetworkAccess
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// ScheduledPurgeDate
	destination.ScheduledPurgeDate = genruntime.ClonePointerToString(properties.ScheduledPurgeDate)

	// SkuChangeInfo
	if properties.SkuChangeInfo != nil {
		var skuChangeInfo storage.SkuChangeInfo_STATUS
		err := properties.SkuChangeInfo.AssignProperties_To_SkuChangeInfo_STATUS(&skuChangeInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SkuChangeInfo_STATUS() to populate field SkuChangeInfo")
		}
		destination.SkuChangeInfo = &skuChangeInfo
	} else {
		destination.SkuChangeInfo = nil
	}

	// UserOwnedStorage
	if properties.UserOwnedStorage != nil {
		userOwnedStorageList := make([]storage.UserOwnedStorage_STATUS, len(properties.UserOwnedStorage))
		for userOwnedStorageIndex, userOwnedStorageItem := range properties.UserOwnedStorage {
			// Shadow the loop variable to avoid aliasing
			userOwnedStorageItem := userOwnedStorageItem
			var userOwnedStorage storage.UserOwnedStorage_STATUS
			err := userOwnedStorageItem.AssignProperties_To_UserOwnedStorage_STATUS(&userOwnedStorage)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserOwnedStorage_STATUS() to populate field UserOwnedStorage")
			}
			userOwnedStorageList[userOwnedStorageIndex] = userOwnedStorage
		}
		destination.UserOwnedStorage = userOwnedStorageList
	} else {
		destination.UserOwnedStorage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity struct {
	// Type: The identity type.
	Type *Identity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &Identity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Identity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.Identity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.Identity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_Identity populates our Identity from the provided source Identity
func (identity *Identity) AssignProperties_From_Identity(source *storage.Identity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity populates the provided destination Identity from our Identity
func (identity *Identity) AssignProperties_To_Identity(destination *storage.Identity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Identity_STATUS populates our Identity from the provided source Identity_STATUS
func (identity *Identity) Initialize_From_Identity_STATUS(source *Identity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), identity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of resource identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *Identity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_STATUS populates our Identity_STATUS from the provided source Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_From_Identity_STATUS(source *storage.Identity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity_STATUS populates the provided destination Identity_STATUS from our Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_To_Identity_STATUS(destination *storage.Identity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource model definition representing SKU
type Sku struct {
	// Capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible
	// for the resource this may be omitted.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// Size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone
	// code.
	Size *string `json:"size,omitempty"`

	// Tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is
	// not required on a PUT.
	Tier *Sku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Family":
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Size":
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property "Tier":
	if sku.Tier != nil {
		var temp string
		temp = string(*sku.Tier)
		tier := arm.Sku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := Sku_Tier(temp)
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, sku_Tier_Values)
		sku.Tier = &tierTemp
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), sku_Tier_Values)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// The resource model definition representing SKU
type Sku_STATUS struct {
	// Capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible
	// for the resource this may be omitted.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// Name: The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// Size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone
	// code.
	Size *string `json:"size,omitempty"`

	// Tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is
	// not required on a PUT.
	Tier *Sku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := Sku_Tier_STATUS(temp)
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, sku_Tier_STATUS_Values)
		sku.Tier = &tierTemp
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The abuse penalty.
type AbusePenalty_STATUS struct {
	// Action: The action of AbusePenalty.
	Action *AbusePenalty_Action_STATUS `json:"action,omitempty"`

	// Expiration: The datetime of expiration of the AbusePenalty.
	Expiration *string `json:"expiration,omitempty"`

	// RateLimitPercentage: The percentage of rate limit.
	RateLimitPercentage *float64 `json:"rateLimitPercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &AbusePenalty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (penalty *AbusePenalty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AbusePenalty_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (penalty *AbusePenalty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AbusePenalty_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AbusePenalty_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := AbusePenalty_Action_STATUS(temp)
		penalty.Action = &action
	}

	// Set property "Expiration":
	if typedInput.Expiration != nil {
		expiration := *typedInput.Expiration
		penalty.Expiration = &expiration
	}

	// Set property "RateLimitPercentage":
	if typedInput.RateLimitPercentage != nil {
		rateLimitPercentage := *typedInput.RateLimitPercentage
		penalty.RateLimitPercentage = &rateLimitPercentage
	}

	// No error
	return nil
}

// AssignProperties_From_AbusePenalty_STATUS populates our AbusePenalty_STATUS from the provided source AbusePenalty_STATUS
func (penalty *AbusePenalty_STATUS) AssignProperties_From_AbusePenalty_STATUS(source *storage.AbusePenalty_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, abusePenalty_Action_STATUS_Values)
		penalty.Action = &actionTemp
	} else {
		penalty.Action = nil
	}

	// Expiration
	penalty.Expiration = genruntime.ClonePointerToString(source.Expiration)

	// RateLimitPercentage
	if source.RateLimitPercentage != nil {
		rateLimitPercentage := *source.RateLimitPercentage
		penalty.RateLimitPercentage = &rateLimitPercentage
	} else {
		penalty.RateLimitPercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AbusePenalty_STATUS populates the provided destination AbusePenalty_STATUS from our AbusePenalty_STATUS
func (penalty *AbusePenalty_STATUS) AssignProperties_To_AbusePenalty_STATUS(destination *storage.AbusePenalty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if penalty.Action != nil {
		action := string(*penalty.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Expiration
	destination.Expiration = genruntime.ClonePointerToString(penalty.Expiration)

	// RateLimitPercentage
	if penalty.RateLimitPercentage != nil {
		rateLimitPercentage := *penalty.RateLimitPercentage
		destination.RateLimitPercentage = &rateLimitPercentage
	} else {
		destination.RateLimitPercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AccountOperatorSecrets struct {
	// Key1: indicates where the Key1 secret should be placed. If omitted, the secret will not be retrieved from Azure.
	Key1 *genruntime.SecretDestination `json:"key1,omitempty"`

	// Key2: indicates where the Key2 secret should be placed. If omitted, the secret will not be retrieved from Azure.
	Key2 *genruntime.SecretDestination `json:"key2,omitempty"`
}

// AssignProperties_From_AccountOperatorSecrets populates our AccountOperatorSecrets from the provided source AccountOperatorSecrets
func (secrets *AccountOperatorSecrets) AssignProperties_From_AccountOperatorSecrets(source *storage.AccountOperatorSecrets) error {

	// Key1
	if source.Key1 != nil {
		key1 := source.Key1.Copy()
		secrets.Key1 = &key1
	} else {
		secrets.Key1 = nil
	}

	// Key2
	if source.Key2 != nil {
		key2 := source.Key2.Copy()
		secrets.Key2 = &key2
	} else {
		secrets.Key2 = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountOperatorSecrets populates the provided destination AccountOperatorSecrets from our AccountOperatorSecrets
func (secrets *AccountOperatorSecrets) AssignProperties_To_AccountOperatorSecrets(destination *storage.AccountOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Key1
	if secrets.Key1 != nil {
		key1 := secrets.Key1.Copy()
		destination.Key1 = &key1
	} else {
		destination.Key1 = nil
	}

	// Key2
	if secrets.Key2 != nil {
		key2 := secrets.Key2.Copy()
		destination.Key2 = &key2
	} else {
		destination.Key2 = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AccountProperties_ProvisioningState_STATUS string

const (
	AccountProperties_ProvisioningState_STATUS_Accepted     = AccountProperties_ProvisioningState_STATUS("Accepted")
	AccountProperties_ProvisioningState_STATUS_Creating     = AccountProperties_ProvisioningState_STATUS("Creating")
	AccountProperties_ProvisioningState_STATUS_Deleting     = AccountProperties_ProvisioningState_STATUS("Deleting")
	AccountProperties_ProvisioningState_STATUS_Failed       = AccountProperties_ProvisioningState_STATUS("Failed")
	AccountProperties_ProvisioningState_STATUS_Moving       = AccountProperties_ProvisioningState_STATUS("Moving")
	AccountProperties_ProvisioningState_STATUS_ResolvingDNS = AccountProperties_ProvisioningState_STATUS("ResolvingDNS")
	AccountProperties_ProvisioningState_STATUS_Succeeded    = AccountProperties_ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to AccountProperties_ProvisioningState_STATUS
var accountProperties_ProvisioningState_STATUS_Values = map[string]AccountProperties_ProvisioningState_STATUS{
	"accepted":     AccountProperties_ProvisioningState_STATUS_Accepted,
	"creating":     AccountProperties_ProvisioningState_STATUS_Creating,
	"deleting":     AccountProperties_ProvisioningState_STATUS_Deleting,
	"failed":       AccountProperties_ProvisioningState_STATUS_Failed,
	"moving":       AccountProperties_ProvisioningState_STATUS_Moving,
	"resolvingdns": AccountProperties_ProvisioningState_STATUS_ResolvingDNS,
	"succeeded":    AccountProperties_ProvisioningState_STATUS_Succeeded,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type AccountProperties_PublicNetworkAccess string

const (
	AccountProperties_PublicNetworkAccess_Disabled = AccountProperties_PublicNetworkAccess("Disabled")
	AccountProperties_PublicNetworkAccess_Enabled  = AccountProperties_PublicNetworkAccess("Enabled")
)

// Mapping from string to AccountProperties_PublicNetworkAccess
var accountProperties_PublicNetworkAccess_Values = map[string]AccountProperties_PublicNetworkAccess{
	"disabled": AccountProperties_PublicNetworkAccess_Disabled,
	"enabled":  AccountProperties_PublicNetworkAccess_Enabled,
}

type AccountProperties_PublicNetworkAccess_STATUS string

const (
	AccountProperties_PublicNetworkAccess_STATUS_Disabled = AccountProperties_PublicNetworkAccess_STATUS("Disabled")
	AccountProperties_PublicNetworkAccess_STATUS_Enabled  = AccountProperties_PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to AccountProperties_PublicNetworkAccess_STATUS
var accountProperties_PublicNetworkAccess_STATUS_Values = map[string]AccountProperties_PublicNetworkAccess_STATUS{
	"disabled": AccountProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  AccountProperties_PublicNetworkAccess_STATUS_Enabled,
}

// The api properties for special APIs.
type ApiProperties struct {
	// +kubebuilder:validation:MaxLength=500
	// AadClientId: (Metrics Advisor Only) The Azure AD Client Id (Application Id).
	AadClientId *string `json:"aadClientId,omitempty" optionalConfigMapPair:"AadClientId"`

	// AadClientIdFromConfig: (Metrics Advisor Only) The Azure AD Client Id (Application Id).
	AadClientIdFromConfig *genruntime.ConfigMapReference `json:"aadClientIdFromConfig,omitempty" optionalConfigMapPair:"AadClientId"`

	// +kubebuilder:validation:MaxLength=500
	// AadTenantId: (Metrics Advisor Only) The Azure AD Tenant Id.
	AadTenantId *string `json:"aadTenantId,omitempty" optionalConfigMapPair:"AadTenantId"`

	// AadTenantIdFromConfig: (Metrics Advisor Only) The Azure AD Tenant Id.
	AadTenantIdFromConfig *genruntime.ConfigMapReference `json:"aadTenantIdFromConfig,omitempty" optionalConfigMapPair:"AadTenantId"`
	AdditionalProperties  map[string]v1.JSON             `json:"additionalProperties,omitempty"`

	// EventHubConnectionString: (Personalization Only) The flag to enable statistics of Bing Search.
	EventHubConnectionString *genruntime.SecretReference `json:"eventHubConnectionString,omitempty"`

	// QnaAzureSearchEndpointId: (QnAMaker Only) The Azure Search endpoint id of QnAMaker.
	QnaAzureSearchEndpointId *string `json:"qnaAzureSearchEndpointId,omitempty" optionalConfigMapPair:"QnaAzureSearchEndpointId"`

	// QnaAzureSearchEndpointIdFromConfig: (QnAMaker Only) The Azure Search endpoint id of QnAMaker.
	QnaAzureSearchEndpointIdFromConfig *genruntime.ConfigMapReference `json:"qnaAzureSearchEndpointIdFromConfig,omitempty" optionalConfigMapPair:"QnaAzureSearchEndpointId"`

	// QnaAzureSearchEndpointKey: (QnAMaker Only) The Azure Search endpoint key of QnAMaker.
	QnaAzureSearchEndpointKey *genruntime.SecretReference `json:"qnaAzureSearchEndpointKey,omitempty"`

	// QnaRuntimeEndpoint: (QnAMaker Only) The runtime endpoint of QnAMaker.
	QnaRuntimeEndpoint *string `json:"qnaRuntimeEndpoint,omitempty" optionalConfigMapPair:"QnaRuntimeEndpoint"`

	// QnaRuntimeEndpointFromConfig: (QnAMaker Only) The runtime endpoint of QnAMaker.
	QnaRuntimeEndpointFromConfig *genruntime.ConfigMapReference `json:"qnaRuntimeEndpointFromConfig,omitempty" optionalConfigMapPair:"QnaRuntimeEndpoint"`

	// StatisticsEnabled: (Bing Search Only) The flag to enable statistics of Bing Search.
	StatisticsEnabled *bool `json:"statisticsEnabled,omitempty"`

	// StorageAccountConnectionString: (Personalization Only) The storage account connection string.
	StorageAccountConnectionString *genruntime.SecretReference `json:"storageAccountConnectionString,omitempty"`

	// +kubebuilder:validation:MaxLength=500
	// SuperUser: (Metrics Advisor Only) The super user of Metrics Advisor.
	SuperUser *string `json:"superUser,omitempty" optionalConfigMapPair:"SuperUser"`

	// SuperUserFromConfig: (Metrics Advisor Only) The super user of Metrics Advisor.
	SuperUserFromConfig *genruntime.ConfigMapReference `json:"superUserFromConfig,omitempty" optionalConfigMapPair:"SuperUser"`

	// +kubebuilder:validation:MaxLength=500
	// WebsiteName: (Metrics Advisor Only) The website name of Metrics Advisor.
	WebsiteName *string `json:"websiteName,omitempty" optionalConfigMapPair:"WebsiteName"`

	// WebsiteNameFromConfig: (Metrics Advisor Only) The website name of Metrics Advisor.
	WebsiteNameFromConfig *genruntime.ConfigMapReference `json:"websiteNameFromConfig,omitempty" optionalConfigMapPair:"WebsiteName"`
}

var _ genruntime.ARMTransformer = &ApiProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ApiProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ApiProperties{}

	// Set property "AadClientId":
	if properties.AadClientId != nil {
		aadClientId := *properties.AadClientId
		result.AadClientId = &aadClientId
	}
	if properties.AadClientIdFromConfig != nil {
		aadClientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.AadClientIdFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property AadClientId")
		}
		aadClientId := aadClientIdValue
		result.AadClientId = &aadClientId
	}

	// Set property "AadTenantId":
	if properties.AadTenantId != nil {
		aadTenantId := *properties.AadTenantId
		result.AadTenantId = &aadTenantId
	}
	if properties.AadTenantIdFromConfig != nil {
		aadTenantIdValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.AadTenantIdFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property AadTenantId")
		}
		aadTenantId := aadTenantIdValue
		result.AadTenantId = &aadTenantId
	}

	// Set property "AdditionalProperties":
	if properties.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(properties.AdditionalProperties))
		for key, value := range properties.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "EventHubConnectionString":
	if properties.EventHubConnectionString != nil {
		eventHubConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.EventHubConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property EventHubConnectionString")
		}
		eventHubConnectionString := eventHubConnectionStringSecret
		result.EventHubConnectionString = &eventHubConnectionString
	}

	// Set property "QnaAzureSearchEndpointId":
	if properties.QnaAzureSearchEndpointId != nil {
		qnaAzureSearchEndpointId := *properties.QnaAzureSearchEndpointId
		result.QnaAzureSearchEndpointId = &qnaAzureSearchEndpointId
	}
	if properties.QnaAzureSearchEndpointIdFromConfig != nil {
		qnaAzureSearchEndpointIdValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.QnaAzureSearchEndpointIdFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property QnaAzureSearchEndpointId")
		}
		qnaAzureSearchEndpointId := qnaAzureSearchEndpointIdValue
		result.QnaAzureSearchEndpointId = &qnaAzureSearchEndpointId
	}

	// Set property "QnaAzureSearchEndpointKey":
	if properties.QnaAzureSearchEndpointKey != nil {
		qnaAzureSearchEndpointKeySecret, err := resolved.ResolvedSecrets.Lookup(*properties.QnaAzureSearchEndpointKey)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property QnaAzureSearchEndpointKey")
		}
		qnaAzureSearchEndpointKey := qnaAzureSearchEndpointKeySecret
		result.QnaAzureSearchEndpointKey = &qnaAzureSearchEndpointKey
	}

	// Set property "QnaRuntimeEndpoint":
	if properties.QnaRuntimeEndpoint != nil {
		qnaRuntimeEndpoint := *properties.QnaRuntimeEndpoint
		result.QnaRuntimeEndpoint = &qnaRuntimeEndpoint
	}
	if properties.QnaRuntimeEndpointFromConfig != nil {
		qnaRuntimeEndpointValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.QnaRuntimeEndpointFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property QnaRuntimeEndpoint")
		}
		qnaRuntimeEndpoint := qnaRuntimeEndpointValue
		result.QnaRuntimeEndpoint = &qnaRuntimeEndpoint
	}

	// Set property "StatisticsEnabled":
	if properties.StatisticsEnabled != nil {
		statisticsEnabled := *properties.StatisticsEnabled
		result.StatisticsEnabled = &statisticsEnabled
	}

	// Set property "StorageAccountConnectionString":
	if properties.StorageAccountConnectionString != nil {
		storageAccountConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.StorageAccountConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property StorageAccountConnectionString")
		}
		storageAccountConnectionString := storageAccountConnectionStringSecret
		result.StorageAccountConnectionString = &storageAccountConnectionString
	}

	// Set property "SuperUser":
	if properties.SuperUser != nil {
		superUser := *properties.SuperUser
		result.SuperUser = &superUser
	}
	if properties.SuperUserFromConfig != nil {
		superUserValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.SuperUserFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property SuperUser")
		}
		superUser := superUserValue
		result.SuperUser = &superUser
	}

	// Set property "WebsiteName":
	if properties.WebsiteName != nil {
		websiteName := *properties.WebsiteName
		result.WebsiteName = &websiteName
	}
	if properties.WebsiteNameFromConfig != nil {
		websiteNameValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.WebsiteNameFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property WebsiteName")
		}
		websiteName := websiteNameValue
		result.WebsiteName = &websiteName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ApiProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ApiProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiProperties, got %T", armInput)
	}

	// Set property "AadClientId":
	if typedInput.AadClientId != nil {
		aadClientId := *typedInput.AadClientId
		properties.AadClientId = &aadClientId
	}

	// no assignment for property "AadClientIdFromConfig"

	// Set property "AadTenantId":
	if typedInput.AadTenantId != nil {
		aadTenantId := *typedInput.AadTenantId
		properties.AadTenantId = &aadTenantId
	}

	// no assignment for property "AadTenantIdFromConfig"

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		properties.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			properties.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// no assignment for property "EventHubConnectionString"

	// Set property "QnaAzureSearchEndpointId":
	if typedInput.QnaAzureSearchEndpointId != nil {
		qnaAzureSearchEndpointId := *typedInput.QnaAzureSearchEndpointId
		properties.QnaAzureSearchEndpointId = &qnaAzureSearchEndpointId
	}

	// no assignment for property "QnaAzureSearchEndpointIdFromConfig"

	// no assignment for property "QnaAzureSearchEndpointKey"

	// Set property "QnaRuntimeEndpoint":
	if typedInput.QnaRuntimeEndpoint != nil {
		qnaRuntimeEndpoint := *typedInput.QnaRuntimeEndpoint
		properties.QnaRuntimeEndpoint = &qnaRuntimeEndpoint
	}

	// no assignment for property "QnaRuntimeEndpointFromConfig"

	// Set property "StatisticsEnabled":
	if typedInput.StatisticsEnabled != nil {
		statisticsEnabled := *typedInput.StatisticsEnabled
		properties.StatisticsEnabled = &statisticsEnabled
	}

	// no assignment for property "StorageAccountConnectionString"

	// Set property "SuperUser":
	if typedInput.SuperUser != nil {
		superUser := *typedInput.SuperUser
		properties.SuperUser = &superUser
	}

	// no assignment for property "SuperUserFromConfig"

	// Set property "WebsiteName":
	if typedInput.WebsiteName != nil {
		websiteName := *typedInput.WebsiteName
		properties.WebsiteName = &websiteName
	}

	// no assignment for property "WebsiteNameFromConfig"

	// No error
	return nil
}

// AssignProperties_From_ApiProperties populates our ApiProperties from the provided source ApiProperties
func (properties *ApiProperties) AssignProperties_From_ApiProperties(source *storage.ApiProperties) error {

	// AadClientId
	properties.AadClientId = genruntime.ClonePointerToString(source.AadClientId)

	// AadClientIdFromConfig
	if source.AadClientIdFromConfig != nil {
		aadClientIdFromConfig := source.AadClientIdFromConfig.Copy()
		properties.AadClientIdFromConfig = &aadClientIdFromConfig
	} else {
		properties.AadClientIdFromConfig = nil
	}

	// AadTenantId
	properties.AadTenantId = genruntime.ClonePointerToString(source.AadTenantId)

	// AadTenantIdFromConfig
	if source.AadTenantIdFromConfig != nil {
		aadTenantIdFromConfig := source.AadTenantIdFromConfig.Copy()
		properties.AadTenantIdFromConfig = &aadTenantIdFromConfig
	} else {
		properties.AadTenantIdFromConfig = nil
	}

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		properties.AdditionalProperties = additionalPropertyMap
	} else {
		properties.AdditionalProperties = nil
	}

	// EventHubConnectionString
	if source.EventHubConnectionString != nil {
		eventHubConnectionString := source.EventHubConnectionString.Copy()
		properties.EventHubConnectionString = &eventHubConnectionString
	} else {
		properties.EventHubConnectionString = nil
	}

	// QnaAzureSearchEndpointId
	properties.QnaAzureSearchEndpointId = genruntime.ClonePointerToString(source.QnaAzureSearchEndpointId)

	// QnaAzureSearchEndpointIdFromConfig
	if source.QnaAzureSearchEndpointIdFromConfig != nil {
		qnaAzureSearchEndpointIdFromConfig := source.QnaAzureSearchEndpointIdFromConfig.Copy()
		properties.QnaAzureSearchEndpointIdFromConfig = &qnaAzureSearchEndpointIdFromConfig
	} else {
		properties.QnaAzureSearchEndpointIdFromConfig = nil
	}

	// QnaAzureSearchEndpointKey
	if source.QnaAzureSearchEndpointKey != nil {
		qnaAzureSearchEndpointKey := source.QnaAzureSearchEndpointKey.Copy()
		properties.QnaAzureSearchEndpointKey = &qnaAzureSearchEndpointKey
	} else {
		properties.QnaAzureSearchEndpointKey = nil
	}

	// QnaRuntimeEndpoint
	properties.QnaRuntimeEndpoint = genruntime.ClonePointerToString(source.QnaRuntimeEndpoint)

	// QnaRuntimeEndpointFromConfig
	if source.QnaRuntimeEndpointFromConfig != nil {
		qnaRuntimeEndpointFromConfig := source.QnaRuntimeEndpointFromConfig.Copy()
		properties.QnaRuntimeEndpointFromConfig = &qnaRuntimeEndpointFromConfig
	} else {
		properties.QnaRuntimeEndpointFromConfig = nil
	}

	// StatisticsEnabled
	if source.StatisticsEnabled != nil {
		statisticsEnabled := *source.StatisticsEnabled
		properties.StatisticsEnabled = &statisticsEnabled
	} else {
		properties.StatisticsEnabled = nil
	}

	// StorageAccountConnectionString
	if source.StorageAccountConnectionString != nil {
		storageAccountConnectionString := source.StorageAccountConnectionString.Copy()
		properties.StorageAccountConnectionString = &storageAccountConnectionString
	} else {
		properties.StorageAccountConnectionString = nil
	}

	// SuperUser
	properties.SuperUser = genruntime.ClonePointerToString(source.SuperUser)

	// SuperUserFromConfig
	if source.SuperUserFromConfig != nil {
		superUserFromConfig := source.SuperUserFromConfig.Copy()
		properties.SuperUserFromConfig = &superUserFromConfig
	} else {
		properties.SuperUserFromConfig = nil
	}

	// WebsiteName
	properties.WebsiteName = genruntime.ClonePointerToString(source.WebsiteName)

	// WebsiteNameFromConfig
	if source.WebsiteNameFromConfig != nil {
		websiteNameFromConfig := source.WebsiteNameFromConfig.Copy()
		properties.WebsiteNameFromConfig = &websiteNameFromConfig
	} else {
		properties.WebsiteNameFromConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiProperties populates the provided destination ApiProperties from our ApiProperties
func (properties *ApiProperties) AssignProperties_To_ApiProperties(destination *storage.ApiProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadClientId
	destination.AadClientId = genruntime.ClonePointerToString(properties.AadClientId)

	// AadClientIdFromConfig
	if properties.AadClientIdFromConfig != nil {
		aadClientIdFromConfig := properties.AadClientIdFromConfig.Copy()
		destination.AadClientIdFromConfig = &aadClientIdFromConfig
	} else {
		destination.AadClientIdFromConfig = nil
	}

	// AadTenantId
	destination.AadTenantId = genruntime.ClonePointerToString(properties.AadTenantId)

	// AadTenantIdFromConfig
	if properties.AadTenantIdFromConfig != nil {
		aadTenantIdFromConfig := properties.AadTenantIdFromConfig.Copy()
		destination.AadTenantIdFromConfig = &aadTenantIdFromConfig
	} else {
		destination.AadTenantIdFromConfig = nil
	}

	// AdditionalProperties
	if properties.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(properties.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range properties.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// EventHubConnectionString
	if properties.EventHubConnectionString != nil {
		eventHubConnectionString := properties.EventHubConnectionString.Copy()
		destination.EventHubConnectionString = &eventHubConnectionString
	} else {
		destination.EventHubConnectionString = nil
	}

	// QnaAzureSearchEndpointId
	destination.QnaAzureSearchEndpointId = genruntime.ClonePointerToString(properties.QnaAzureSearchEndpointId)

	// QnaAzureSearchEndpointIdFromConfig
	if properties.QnaAzureSearchEndpointIdFromConfig != nil {
		qnaAzureSearchEndpointIdFromConfig := properties.QnaAzureSearchEndpointIdFromConfig.Copy()
		destination.QnaAzureSearchEndpointIdFromConfig = &qnaAzureSearchEndpointIdFromConfig
	} else {
		destination.QnaAzureSearchEndpointIdFromConfig = nil
	}

	// QnaAzureSearchEndpointKey
	if properties.QnaAzureSearchEndpointKey != nil {
		qnaAzureSearchEndpointKey := properties.QnaAzureSearchEndpointKey.Copy()
		destination.QnaAzureSearchEndpointKey = &qnaAzureSearchEndpointKey
	} else {
		destination.QnaAzureSearchEndpointKey = nil
	}

	// QnaRuntimeEndpoint
	destination.QnaRuntimeEndpoint = genruntime.ClonePointerToString(properties.QnaRuntimeEndpoint)

	// QnaRuntimeEndpointFromConfig
	if properties.QnaRuntimeEndpointFromConfig != nil {
		qnaRuntimeEndpointFromConfig := properties.QnaRuntimeEndpointFromConfig.Copy()
		destination.QnaRuntimeEndpointFromConfig = &qnaRuntimeEndpointFromConfig
	} else {
		destination.QnaRuntimeEndpointFromConfig = nil
	}

	// StatisticsEnabled
	if properties.StatisticsEnabled != nil {
		statisticsEnabled := *properties.StatisticsEnabled
		destination.StatisticsEnabled = &statisticsEnabled
	} else {
		destination.StatisticsEnabled = nil
	}

	// StorageAccountConnectionString
	if properties.StorageAccountConnectionString != nil {
		storageAccountConnectionString := properties.StorageAccountConnectionString.Copy()
		destination.StorageAccountConnectionString = &storageAccountConnectionString
	} else {
		destination.StorageAccountConnectionString = nil
	}

	// SuperUser
	destination.SuperUser = genruntime.ClonePointerToString(properties.SuperUser)

	// SuperUserFromConfig
	if properties.SuperUserFromConfig != nil {
		superUserFromConfig := properties.SuperUserFromConfig.Copy()
		destination.SuperUserFromConfig = &superUserFromConfig
	} else {
		destination.SuperUserFromConfig = nil
	}

	// WebsiteName
	destination.WebsiteName = genruntime.ClonePointerToString(properties.WebsiteName)

	// WebsiteNameFromConfig
	if properties.WebsiteNameFromConfig != nil {
		websiteNameFromConfig := properties.WebsiteNameFromConfig.Copy()
		destination.WebsiteNameFromConfig = &websiteNameFromConfig
	} else {
		destination.WebsiteNameFromConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiProperties_STATUS populates our ApiProperties from the provided source ApiProperties_STATUS
func (properties *ApiProperties) Initialize_From_ApiProperties_STATUS(source *ApiProperties_STATUS) error {

	// AadClientId
	properties.AadClientId = genruntime.ClonePointerToString(source.AadClientId)

	// AadTenantId
	properties.AadTenantId = genruntime.ClonePointerToString(source.AadTenantId)

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		properties.AdditionalProperties = additionalPropertyMap
	} else {
		properties.AdditionalProperties = nil
	}

	// QnaAzureSearchEndpointId
	properties.QnaAzureSearchEndpointId = genruntime.ClonePointerToString(source.QnaAzureSearchEndpointId)

	// QnaRuntimeEndpoint
	properties.QnaRuntimeEndpoint = genruntime.ClonePointerToString(source.QnaRuntimeEndpoint)

	// StatisticsEnabled
	if source.StatisticsEnabled != nil {
		statisticsEnabled := *source.StatisticsEnabled
		properties.StatisticsEnabled = &statisticsEnabled
	} else {
		properties.StatisticsEnabled = nil
	}

	// SuperUser
	properties.SuperUser = genruntime.ClonePointerToString(source.SuperUser)

	// WebsiteName
	properties.WebsiteName = genruntime.ClonePointerToString(source.WebsiteName)

	// No error
	return nil
}

// The api properties for special APIs.
type ApiProperties_STATUS struct {
	// AadClientId: (Metrics Advisor Only) The Azure AD Client Id (Application Id).
	AadClientId *string `json:"aadClientId,omitempty"`

	// AadTenantId: (Metrics Advisor Only) The Azure AD Tenant Id.
	AadTenantId          *string            `json:"aadTenantId,omitempty"`
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// QnaAzureSearchEndpointId: (QnAMaker Only) The Azure Search endpoint id of QnAMaker.
	QnaAzureSearchEndpointId *string `json:"qnaAzureSearchEndpointId,omitempty"`

	// QnaRuntimeEndpoint: (QnAMaker Only) The runtime endpoint of QnAMaker.
	QnaRuntimeEndpoint *string `json:"qnaRuntimeEndpoint,omitempty"`

	// StatisticsEnabled: (Bing Search Only) The flag to enable statistics of Bing Search.
	StatisticsEnabled *bool `json:"statisticsEnabled,omitempty"`

	// SuperUser: (Metrics Advisor Only) The super user of Metrics Advisor.
	SuperUser *string `json:"superUser,omitempty"`

	// WebsiteName: (Metrics Advisor Only) The website name of Metrics Advisor.
	WebsiteName *string `json:"websiteName,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ApiProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ApiProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiProperties_STATUS, got %T", armInput)
	}

	// Set property "AadClientId":
	if typedInput.AadClientId != nil {
		aadClientId := *typedInput.AadClientId
		properties.AadClientId = &aadClientId
	}

	// Set property "AadTenantId":
	if typedInput.AadTenantId != nil {
		aadTenantId := *typedInput.AadTenantId
		properties.AadTenantId = &aadTenantId
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		properties.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			properties.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "QnaAzureSearchEndpointId":
	if typedInput.QnaAzureSearchEndpointId != nil {
		qnaAzureSearchEndpointId := *typedInput.QnaAzureSearchEndpointId
		properties.QnaAzureSearchEndpointId = &qnaAzureSearchEndpointId
	}

	// Set property "QnaRuntimeEndpoint":
	if typedInput.QnaRuntimeEndpoint != nil {
		qnaRuntimeEndpoint := *typedInput.QnaRuntimeEndpoint
		properties.QnaRuntimeEndpoint = &qnaRuntimeEndpoint
	}

	// Set property "StatisticsEnabled":
	if typedInput.StatisticsEnabled != nil {
		statisticsEnabled := *typedInput.StatisticsEnabled
		properties.StatisticsEnabled = &statisticsEnabled
	}

	// Set property "SuperUser":
	if typedInput.SuperUser != nil {
		superUser := *typedInput.SuperUser
		properties.SuperUser = &superUser
	}

	// Set property "WebsiteName":
	if typedInput.WebsiteName != nil {
		websiteName := *typedInput.WebsiteName
		properties.WebsiteName = &websiteName
	}

	// No error
	return nil
}

// AssignProperties_From_ApiProperties_STATUS populates our ApiProperties_STATUS from the provided source ApiProperties_STATUS
func (properties *ApiProperties_STATUS) AssignProperties_From_ApiProperties_STATUS(source *storage.ApiProperties_STATUS) error {

	// AadClientId
	properties.AadClientId = genruntime.ClonePointerToString(source.AadClientId)

	// AadTenantId
	properties.AadTenantId = genruntime.ClonePointerToString(source.AadTenantId)

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		properties.AdditionalProperties = additionalPropertyMap
	} else {
		properties.AdditionalProperties = nil
	}

	// QnaAzureSearchEndpointId
	properties.QnaAzureSearchEndpointId = genruntime.ClonePointerToString(source.QnaAzureSearchEndpointId)

	// QnaRuntimeEndpoint
	properties.QnaRuntimeEndpoint = genruntime.ClonePointerToString(source.QnaRuntimeEndpoint)

	// StatisticsEnabled
	if source.StatisticsEnabled != nil {
		statisticsEnabled := *source.StatisticsEnabled
		properties.StatisticsEnabled = &statisticsEnabled
	} else {
		properties.StatisticsEnabled = nil
	}

	// SuperUser
	properties.SuperUser = genruntime.ClonePointerToString(source.SuperUser)

	// WebsiteName
	properties.WebsiteName = genruntime.ClonePointerToString(source.WebsiteName)

	// No error
	return nil
}

// AssignProperties_To_ApiProperties_STATUS populates the provided destination ApiProperties_STATUS from our ApiProperties_STATUS
func (properties *ApiProperties_STATUS) AssignProperties_To_ApiProperties_STATUS(destination *storage.ApiProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadClientId
	destination.AadClientId = genruntime.ClonePointerToString(properties.AadClientId)

	// AadTenantId
	destination.AadTenantId = genruntime.ClonePointerToString(properties.AadTenantId)

	// AdditionalProperties
	if properties.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(properties.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range properties.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// QnaAzureSearchEndpointId
	destination.QnaAzureSearchEndpointId = genruntime.ClonePointerToString(properties.QnaAzureSearchEndpointId)

	// QnaRuntimeEndpoint
	destination.QnaRuntimeEndpoint = genruntime.ClonePointerToString(properties.QnaRuntimeEndpoint)

	// StatisticsEnabled
	if properties.StatisticsEnabled != nil {
		statisticsEnabled := *properties.StatisticsEnabled
		destination.StatisticsEnabled = &statisticsEnabled
	} else {
		destination.StatisticsEnabled = nil
	}

	// SuperUser
	destination.SuperUser = genruntime.ClonePointerToString(properties.SuperUser)

	// WebsiteName
	destination.WebsiteName = genruntime.ClonePointerToString(properties.WebsiteName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The call rate limit Cognitive Services account.
type CallRateLimit_STATUS struct {
	// Count: The count value of Call Rate Limit.
	Count *float64 `json:"count,omitempty"`

	// RenewalPeriod: The renewal period in seconds of Call Rate Limit.
	RenewalPeriod *float64                `json:"renewalPeriod,omitempty"`
	Rules         []ThrottlingRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &CallRateLimit_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limit *CallRateLimit_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CallRateLimit_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limit *CallRateLimit_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CallRateLimit_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CallRateLimit_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		limit.Count = &count
	}

	// Set property "RenewalPeriod":
	if typedInput.RenewalPeriod != nil {
		renewalPeriod := *typedInput.RenewalPeriod
		limit.RenewalPeriod = &renewalPeriod
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ThrottlingRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		limit.Rules = append(limit.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CallRateLimit_STATUS populates our CallRateLimit_STATUS from the provided source CallRateLimit_STATUS
func (limit *CallRateLimit_STATUS) AssignProperties_From_CallRateLimit_STATUS(source *storage.CallRateLimit_STATUS) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		limit.Count = &count
	} else {
		limit.Count = nil
	}

	// RenewalPeriod
	if source.RenewalPeriod != nil {
		renewalPeriod := *source.RenewalPeriod
		limit.RenewalPeriod = &renewalPeriod
	} else {
		limit.RenewalPeriod = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ThrottlingRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ThrottlingRule_STATUS
			err := rule.AssignProperties_From_ThrottlingRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ThrottlingRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		limit.Rules = ruleList
	} else {
		limit.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CallRateLimit_STATUS populates the provided destination CallRateLimit_STATUS from our CallRateLimit_STATUS
func (limit *CallRateLimit_STATUS) AssignProperties_To_CallRateLimit_STATUS(destination *storage.CallRateLimit_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if limit.Count != nil {
		count := *limit.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// RenewalPeriod
	if limit.RenewalPeriod != nil {
		renewalPeriod := *limit.RenewalPeriod
		destination.RenewalPeriod = &renewalPeriod
	} else {
		destination.RenewalPeriod = nil
	}

	// Rules
	if limit.Rules != nil {
		ruleList := make([]storage.ThrottlingRule_STATUS, len(limit.Rules))
		for ruleIndex, ruleItem := range limit.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ThrottlingRule_STATUS
			err := ruleItem.AssignProperties_To_ThrottlingRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ThrottlingRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The commitment plan association.
type CommitmentPlanAssociation_STATUS struct {
	// CommitmentPlanId: The Azure resource id of the commitment plan.
	CommitmentPlanId *string `json:"commitmentPlanId,omitempty"`

	// CommitmentPlanLocation: The location of of the commitment plan.
	CommitmentPlanLocation *string `json:"commitmentPlanLocation,omitempty"`
}

var _ genruntime.FromARMConverter = &CommitmentPlanAssociation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (association *CommitmentPlanAssociation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CommitmentPlanAssociation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (association *CommitmentPlanAssociation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CommitmentPlanAssociation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CommitmentPlanAssociation_STATUS, got %T", armInput)
	}

	// Set property "CommitmentPlanId":
	if typedInput.CommitmentPlanId != nil {
		commitmentPlanId := *typedInput.CommitmentPlanId
		association.CommitmentPlanId = &commitmentPlanId
	}

	// Set property "CommitmentPlanLocation":
	if typedInput.CommitmentPlanLocation != nil {
		commitmentPlanLocation := *typedInput.CommitmentPlanLocation
		association.CommitmentPlanLocation = &commitmentPlanLocation
	}

	// No error
	return nil
}

// AssignProperties_From_CommitmentPlanAssociation_STATUS populates our CommitmentPlanAssociation_STATUS from the provided source CommitmentPlanAssociation_STATUS
func (association *CommitmentPlanAssociation_STATUS) AssignProperties_From_CommitmentPlanAssociation_STATUS(source *storage.CommitmentPlanAssociation_STATUS) error {

	// CommitmentPlanId
	association.CommitmentPlanId = genruntime.ClonePointerToString(source.CommitmentPlanId)

	// CommitmentPlanLocation
	association.CommitmentPlanLocation = genruntime.ClonePointerToString(source.CommitmentPlanLocation)

	// No error
	return nil
}

// AssignProperties_To_CommitmentPlanAssociation_STATUS populates the provided destination CommitmentPlanAssociation_STATUS from our CommitmentPlanAssociation_STATUS
func (association *CommitmentPlanAssociation_STATUS) AssignProperties_To_CommitmentPlanAssociation_STATUS(destination *storage.CommitmentPlanAssociation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CommitmentPlanId
	destination.CommitmentPlanId = genruntime.ClonePointerToString(association.CommitmentPlanId)

	// CommitmentPlanLocation
	destination.CommitmentPlanLocation = genruntime.ClonePointerToString(association.CommitmentPlanLocation)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties to configure Encryption
type Encryption struct {
	// KeySource: Enumerates the possible value of keySource for Encryption
	KeySource *Encryption_KeySource `json:"keySource,omitempty"`

	// KeyVaultProperties: Properties of KeyVault
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &Encryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *Encryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.Encryption{}

	// Set property "KeySource":
	if encryption.KeySource != nil {
		var temp string
		temp = string(*encryption.KeySource)
		keySource := arm.Encryption_KeySource(temp)
		result.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if encryption.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := (*encryption.KeyVaultProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.KeyVaultProperties)
		result.KeyVaultProperties = &keyVaultProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *Encryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Encryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *Encryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Encryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Encryption, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := Encryption_KeySource(temp)
		encryption.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 KeyVaultProperties
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		encryption.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_Encryption populates our Encryption from the provided source Encryption
func (encryption *Encryption) AssignProperties_From_Encryption(source *storage.Encryption) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryption_KeySource_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Encryption populates the provided destination Encryption from our Encryption
func (encryption *Encryption) AssignProperties_To_Encryption(destination *storage.Encryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if encryption.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties
		err := encryption.KeyVaultProperties.AssignProperties_To_KeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Encryption_STATUS populates our Encryption from the provided source Encryption_STATUS
func (encryption *Encryption) Initialize_From_Encryption_STATUS(source *Encryption_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := genruntime.ToEnum(string(*source.KeySource), encryption_KeySource_Values)
		encryption.KeySource = &keySource
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.Initialize_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// Properties to configure Encryption
type Encryption_STATUS struct {
	// KeySource: Enumerates the possible value of keySource for Encryption
	KeySource *Encryption_KeySource_STATUS `json:"keySource,omitempty"`

	// KeyVaultProperties: Properties of KeyVault
	KeyVaultProperties *KeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &Encryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *Encryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Encryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *Encryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Encryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Encryption_STATUS, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := Encryption_KeySource_STATUS(temp)
		encryption.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 KeyVaultProperties_STATUS
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		encryption.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_Encryption_STATUS populates our Encryption_STATUS from the provided source Encryption_STATUS
func (encryption *Encryption_STATUS) AssignProperties_From_Encryption_STATUS(source *storage.Encryption_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryption_KeySource_STATUS_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Encryption_STATUS populates the provided destination Encryption_STATUS from our Encryption_STATUS
func (encryption *Encryption_STATUS) AssignProperties_To_Encryption_STATUS(destination *storage.Encryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if encryption.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties_STATUS
		err := encryption.KeyVaultProperties.AssignProperties_To_KeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type Identity_Type string

const (
	Identity_Type_None                       = Identity_Type("None")
	Identity_Type_SystemAssigned             = Identity_Type("SystemAssigned")
	Identity_Type_SystemAssignedUserAssigned = Identity_Type("SystemAssigned, UserAssigned")
	Identity_Type_UserAssigned               = Identity_Type("UserAssigned")
)

// Mapping from string to Identity_Type
var identity_Type_Values = map[string]Identity_Type{
	"none":                         Identity_Type_None,
	"systemassigned":               Identity_Type_SystemAssigned,
	"systemassigned, userassigned": Identity_Type_SystemAssignedUserAssigned,
	"userassigned":                 Identity_Type_UserAssigned,
}

type Identity_Type_STATUS string

const (
	Identity_Type_STATUS_None                       = Identity_Type_STATUS("None")
	Identity_Type_STATUS_SystemAssigned             = Identity_Type_STATUS("SystemAssigned")
	Identity_Type_STATUS_SystemAssignedUserAssigned = Identity_Type_STATUS("SystemAssigned, UserAssigned")
	Identity_Type_STATUS_UserAssigned               = Identity_Type_STATUS("UserAssigned")
)

// Mapping from string to Identity_Type_STATUS
var identity_Type_STATUS_Values = map[string]Identity_Type_STATUS{
	"none":                         Identity_Type_STATUS_None,
	"systemassigned":               Identity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": Identity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 Identity_Type_STATUS_UserAssigned,
}

// The multiregion settings Cognitive Services account.
type MultiRegionSettings struct {
	Regions []RegionSetting `json:"regions,omitempty"`

	// RoutingMethod: Multiregion routing methods.
	RoutingMethod *MultiRegionSettings_RoutingMethod `json:"routingMethod,omitempty"`
}

var _ genruntime.ARMTransformer = &MultiRegionSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *MultiRegionSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.MultiRegionSettings{}

	// Set property "Regions":
	for _, item := range settings.Regions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Regions = append(result.Regions, *item_ARM.(*arm.RegionSetting))
	}

	// Set property "RoutingMethod":
	if settings.RoutingMethod != nil {
		var temp string
		temp = string(*settings.RoutingMethod)
		routingMethod := arm.MultiRegionSettings_RoutingMethod(temp)
		result.RoutingMethod = &routingMethod
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MultiRegionSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MultiRegionSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MultiRegionSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MultiRegionSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MultiRegionSettings, got %T", armInput)
	}

	// Set property "Regions":
	for _, item := range typedInput.Regions {
		var item1 RegionSetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		settings.Regions = append(settings.Regions, item1)
	}

	// Set property "RoutingMethod":
	if typedInput.RoutingMethod != nil {
		var temp string
		temp = string(*typedInput.RoutingMethod)
		routingMethod := MultiRegionSettings_RoutingMethod(temp)
		settings.RoutingMethod = &routingMethod
	}

	// No error
	return nil
}

// AssignProperties_From_MultiRegionSettings populates our MultiRegionSettings from the provided source MultiRegionSettings
func (settings *MultiRegionSettings) AssignProperties_From_MultiRegionSettings(source *storage.MultiRegionSettings) error {

	// Regions
	if source.Regions != nil {
		regionList := make([]RegionSetting, len(source.Regions))
		for regionIndex, regionItem := range source.Regions {
			// Shadow the loop variable to avoid aliasing
			regionItem := regionItem
			var region RegionSetting
			err := region.AssignProperties_From_RegionSetting(&regionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegionSetting() to populate field Regions")
			}
			regionList[regionIndex] = region
		}
		settings.Regions = regionList
	} else {
		settings.Regions = nil
	}

	// RoutingMethod
	if source.RoutingMethod != nil {
		routingMethod := *source.RoutingMethod
		routingMethodTemp := genruntime.ToEnum(routingMethod, multiRegionSettings_RoutingMethod_Values)
		settings.RoutingMethod = &routingMethodTemp
	} else {
		settings.RoutingMethod = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MultiRegionSettings populates the provided destination MultiRegionSettings from our MultiRegionSettings
func (settings *MultiRegionSettings) AssignProperties_To_MultiRegionSettings(destination *storage.MultiRegionSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Regions
	if settings.Regions != nil {
		regionList := make([]storage.RegionSetting, len(settings.Regions))
		for regionIndex, regionItem := range settings.Regions {
			// Shadow the loop variable to avoid aliasing
			regionItem := regionItem
			var region storage.RegionSetting
			err := regionItem.AssignProperties_To_RegionSetting(&region)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegionSetting() to populate field Regions")
			}
			regionList[regionIndex] = region
		}
		destination.Regions = regionList
	} else {
		destination.Regions = nil
	}

	// RoutingMethod
	if settings.RoutingMethod != nil {
		routingMethod := string(*settings.RoutingMethod)
		destination.RoutingMethod = &routingMethod
	} else {
		destination.RoutingMethod = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MultiRegionSettings_STATUS populates our MultiRegionSettings from the provided source MultiRegionSettings_STATUS
func (settings *MultiRegionSettings) Initialize_From_MultiRegionSettings_STATUS(source *MultiRegionSettings_STATUS) error {

	// Regions
	if source.Regions != nil {
		regionList := make([]RegionSetting, len(source.Regions))
		for regionIndex, regionItem := range source.Regions {
			// Shadow the loop variable to avoid aliasing
			regionItem := regionItem
			var region RegionSetting
			err := region.Initialize_From_RegionSetting_STATUS(&regionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RegionSetting_STATUS() to populate field Regions")
			}
			regionList[regionIndex] = region
		}
		settings.Regions = regionList
	} else {
		settings.Regions = nil
	}

	// RoutingMethod
	if source.RoutingMethod != nil {
		routingMethod := genruntime.ToEnum(string(*source.RoutingMethod), multiRegionSettings_RoutingMethod_Values)
		settings.RoutingMethod = &routingMethod
	} else {
		settings.RoutingMethod = nil
	}

	// No error
	return nil
}

// The multiregion settings Cognitive Services account.
type MultiRegionSettings_STATUS struct {
	Regions []RegionSetting_STATUS `json:"regions,omitempty"`

	// RoutingMethod: Multiregion routing methods.
	RoutingMethod *MultiRegionSettings_RoutingMethod_STATUS `json:"routingMethod,omitempty"`
}

var _ genruntime.FromARMConverter = &MultiRegionSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MultiRegionSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MultiRegionSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MultiRegionSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MultiRegionSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MultiRegionSettings_STATUS, got %T", armInput)
	}

	// Set property "Regions":
	for _, item := range typedInput.Regions {
		var item1 RegionSetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		settings.Regions = append(settings.Regions, item1)
	}

	// Set property "RoutingMethod":
	if typedInput.RoutingMethod != nil {
		var temp string
		temp = string(*typedInput.RoutingMethod)
		routingMethod := MultiRegionSettings_RoutingMethod_STATUS(temp)
		settings.RoutingMethod = &routingMethod
	}

	// No error
	return nil
}

// AssignProperties_From_MultiRegionSettings_STATUS populates our MultiRegionSettings_STATUS from the provided source MultiRegionSettings_STATUS
func (settings *MultiRegionSettings_STATUS) AssignProperties_From_MultiRegionSettings_STATUS(source *storage.MultiRegionSettings_STATUS) error {

	// Regions
	if source.Regions != nil {
		regionList := make([]RegionSetting_STATUS, len(source.Regions))
		for regionIndex, regionItem := range source.Regions {
			// Shadow the loop variable to avoid aliasing
			regionItem := regionItem
			var region RegionSetting_STATUS
			err := region.AssignProperties_From_RegionSetting_STATUS(&regionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegionSetting_STATUS() to populate field Regions")
			}
			regionList[regionIndex] = region
		}
		settings.Regions = regionList
	} else {
		settings.Regions = nil
	}

	// RoutingMethod
	if source.RoutingMethod != nil {
		routingMethod := *source.RoutingMethod
		routingMethodTemp := genruntime.ToEnum(routingMethod, multiRegionSettings_RoutingMethod_STATUS_Values)
		settings.RoutingMethod = &routingMethodTemp
	} else {
		settings.RoutingMethod = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MultiRegionSettings_STATUS populates the provided destination MultiRegionSettings_STATUS from our MultiRegionSettings_STATUS
func (settings *MultiRegionSettings_STATUS) AssignProperties_To_MultiRegionSettings_STATUS(destination *storage.MultiRegionSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Regions
	if settings.Regions != nil {
		regionList := make([]storage.RegionSetting_STATUS, len(settings.Regions))
		for regionIndex, regionItem := range settings.Regions {
			// Shadow the loop variable to avoid aliasing
			regionItem := regionItem
			var region storage.RegionSetting_STATUS
			err := regionItem.AssignProperties_To_RegionSetting_STATUS(&region)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegionSetting_STATUS() to populate field Regions")
			}
			regionList[regionIndex] = region
		}
		destination.Regions = regionList
	} else {
		destination.Regions = nil
	}

	// RoutingMethod
	if settings.RoutingMethod != nil {
		routingMethod := string(*settings.RoutingMethod)
		destination.RoutingMethod = &routingMethod
	} else {
		destination.RoutingMethod = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies in AI Foundry where virtual network injection occurs to secure scenarios like Agents entirely within the
// user's private network, eliminating public internet exposure while maintaining control over network configurations and
// resources.
type NetworkInjections struct {
	// Scenario: Specifies what features in AI Foundry network injection applies to. Currently only supports 'agent' for agent
	// scenarios. 'none' means no network injection.
	Scenario *NetworkInjections_Scenario `json:"scenario,omitempty"`

	// SubnetArmReference: Specify the subnet for which your Agent Client is injected into.
	SubnetArmReference *genruntime.ResourceReference `armReference:"SubnetArmId" json:"subnetArmReference,omitempty"`

	// UseMicrosoftManagedNetwork: Boolean to enable Microsoft Managed Network for subnet delegation
	UseMicrosoftManagedNetwork *bool `json:"useMicrosoftManagedNetwork,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInjections{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (injections *NetworkInjections) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if injections == nil {
		return nil, nil
	}
	result := &arm.NetworkInjections{}

	// Set property "Scenario":
	if injections.Scenario != nil {
		var temp string
		temp = string(*injections.Scenario)
		scenario := arm.NetworkInjections_Scenario(temp)
		result.Scenario = &scenario
	}

	// Set property "SubnetArmId":
	if injections.SubnetArmReference != nil {
		subnetArmReferenceARMID, err := resolved.ResolvedReferences.Lookup(*injections.SubnetArmReference)
		if err != nil {
			return nil, err
		}
		subnetArmReference := subnetArmReferenceARMID
		result.SubnetArmId = &subnetArmReference
	}

	// Set property "UseMicrosoftManagedNetwork":
	if injections.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *injections.UseMicrosoftManagedNetwork
		result.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (injections *NetworkInjections) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkInjections{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (injections *NetworkInjections) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkInjections)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkInjections, got %T", armInput)
	}

	// Set property "Scenario":
	if typedInput.Scenario != nil {
		var temp string
		temp = string(*typedInput.Scenario)
		scenario := NetworkInjections_Scenario(temp)
		injections.Scenario = &scenario
	}

	// no assignment for property "SubnetArmReference"

	// Set property "UseMicrosoftManagedNetwork":
	if typedInput.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *typedInput.UseMicrosoftManagedNetwork
		injections.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInjections populates our NetworkInjections from the provided source NetworkInjections
func (injections *NetworkInjections) AssignProperties_From_NetworkInjections(source *storage.NetworkInjections) error {

	// Scenario
	if source.Scenario != nil {
		scenario := *source.Scenario
		scenarioTemp := genruntime.ToEnum(scenario, networkInjections_Scenario_Values)
		injections.Scenario = &scenarioTemp
	} else {
		injections.Scenario = nil
	}

	// SubnetArmReference
	if source.SubnetArmReference != nil {
		subnetArmReference := source.SubnetArmReference.Copy()
		injections.SubnetArmReference = &subnetArmReference
	} else {
		injections.SubnetArmReference = nil
	}

	// UseMicrosoftManagedNetwork
	if source.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *source.UseMicrosoftManagedNetwork
		injections.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	} else {
		injections.UseMicrosoftManagedNetwork = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInjections populates the provided destination NetworkInjections from our NetworkInjections
func (injections *NetworkInjections) AssignProperties_To_NetworkInjections(destination *storage.NetworkInjections) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scenario
	if injections.Scenario != nil {
		scenario := string(*injections.Scenario)
		destination.Scenario = &scenario
	} else {
		destination.Scenario = nil
	}

	// SubnetArmReference
	if injections.SubnetArmReference != nil {
		subnetArmReference := injections.SubnetArmReference.Copy()
		destination.SubnetArmReference = &subnetArmReference
	} else {
		destination.SubnetArmReference = nil
	}

	// UseMicrosoftManagedNetwork
	if injections.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *injections.UseMicrosoftManagedNetwork
		destination.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	} else {
		destination.UseMicrosoftManagedNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkInjections_STATUS populates our NetworkInjections from the provided source NetworkInjections_STATUS
func (injections *NetworkInjections) Initialize_From_NetworkInjections_STATUS(source *NetworkInjections_STATUS) error {

	// Scenario
	if source.Scenario != nil {
		scenario := genruntime.ToEnum(string(*source.Scenario), networkInjections_Scenario_Values)
		injections.Scenario = &scenario
	} else {
		injections.Scenario = nil
	}

	// SubnetArmReference
	if source.SubnetArmId != nil {
		subnetArmReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetArmId)
		injections.SubnetArmReference = &subnetArmReference
	} else {
		injections.SubnetArmReference = nil
	}

	// UseMicrosoftManagedNetwork
	if source.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *source.UseMicrosoftManagedNetwork
		injections.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	} else {
		injections.UseMicrosoftManagedNetwork = nil
	}

	// No error
	return nil
}

// Specifies in AI Foundry where virtual network injection occurs to secure scenarios like Agents entirely within the
// user's private network, eliminating public internet exposure while maintaining control over network configurations and
// resources.
type NetworkInjections_STATUS struct {
	// Scenario: Specifies what features in AI Foundry network injection applies to. Currently only supports 'agent' for agent
	// scenarios. 'none' means no network injection.
	Scenario *NetworkInjections_Scenario_STATUS `json:"scenario,omitempty"`

	// SubnetArmId: Specify the subnet for which your Agent Client is injected into.
	SubnetArmId *string `json:"subnetArmId,omitempty"`

	// UseMicrosoftManagedNetwork: Boolean to enable Microsoft Managed Network for subnet delegation
	UseMicrosoftManagedNetwork *bool `json:"useMicrosoftManagedNetwork,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInjections_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (injections *NetworkInjections_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkInjections_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (injections *NetworkInjections_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkInjections_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkInjections_STATUS, got %T", armInput)
	}

	// Set property "Scenario":
	if typedInput.Scenario != nil {
		var temp string
		temp = string(*typedInput.Scenario)
		scenario := NetworkInjections_Scenario_STATUS(temp)
		injections.Scenario = &scenario
	}

	// Set property "SubnetArmId":
	if typedInput.SubnetArmId != nil {
		subnetArmId := *typedInput.SubnetArmId
		injections.SubnetArmId = &subnetArmId
	}

	// Set property "UseMicrosoftManagedNetwork":
	if typedInput.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *typedInput.UseMicrosoftManagedNetwork
		injections.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInjections_STATUS populates our NetworkInjections_STATUS from the provided source NetworkInjections_STATUS
func (injections *NetworkInjections_STATUS) AssignProperties_From_NetworkInjections_STATUS(source *storage.NetworkInjections_STATUS) error {

	// Scenario
	if source.Scenario != nil {
		scenario := *source.Scenario
		scenarioTemp := genruntime.ToEnum(scenario, networkInjections_Scenario_STATUS_Values)
		injections.Scenario = &scenarioTemp
	} else {
		injections.Scenario = nil
	}

	// SubnetArmId
	injections.SubnetArmId = genruntime.ClonePointerToString(source.SubnetArmId)

	// UseMicrosoftManagedNetwork
	if source.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *source.UseMicrosoftManagedNetwork
		injections.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	} else {
		injections.UseMicrosoftManagedNetwork = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInjections_STATUS populates the provided destination NetworkInjections_STATUS from our NetworkInjections_STATUS
func (injections *NetworkInjections_STATUS) AssignProperties_To_NetworkInjections_STATUS(destination *storage.NetworkInjections_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scenario
	if injections.Scenario != nil {
		scenario := string(*injections.Scenario)
		destination.Scenario = &scenario
	} else {
		destination.Scenario = nil
	}

	// SubnetArmId
	destination.SubnetArmId = genruntime.ClonePointerToString(injections.SubnetArmId)

	// UseMicrosoftManagedNetwork
	if injections.UseMicrosoftManagedNetwork != nil {
		useMicrosoftManagedNetwork := *injections.UseMicrosoftManagedNetwork
		destination.UseMicrosoftManagedNetwork = &useMicrosoftManagedNetwork
	} else {
		destination.UseMicrosoftManagedNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A set of rules governing the network accessibility.
type NetworkRuleSet struct {
	// Bypass: Setting for trusted services.
	Bypass *NetworkRuleSet_Bypass `json:"bypass,omitempty"`

	// DefaultAction: The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after
	// the bypass property has been evaluated.
	DefaultAction *NetworkRuleSet_DefaultAction `json:"defaultAction,omitempty"`

	// IpRules: The list of IP address rules.
	IpRules []IpRule `json:"ipRules,omitempty"`

	// VirtualNetworkRules: The list of virtual network rules.
	VirtualNetworkRules []VirtualNetworkRule `json:"virtualNetworkRules,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *NetworkRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.NetworkRuleSet{}

	// Set property "Bypass":
	if ruleSet.Bypass != nil {
		var temp string
		temp = string(*ruleSet.Bypass)
		bypass := arm.NetworkRuleSet_Bypass(temp)
		result.Bypass = &bypass
	}

	// Set property "DefaultAction":
	if ruleSet.DefaultAction != nil {
		var temp string
		temp = string(*ruleSet.DefaultAction)
		defaultAction := arm.NetworkRuleSet_DefaultAction(temp)
		result.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range ruleSet.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*arm.IpRule))
	}

	// Set property "VirtualNetworkRules":
	for _, item := range ruleSet.VirtualNetworkRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualNetworkRules = append(result.VirtualNetworkRules, *item_ARM.(*arm.VirtualNetworkRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSet, got %T", armInput)
	}

	// Set property "Bypass":
	if typedInput.Bypass != nil {
		var temp string
		temp = string(*typedInput.Bypass)
		bypass := NetworkRuleSet_Bypass(temp)
		ruleSet.Bypass = &bypass
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := NetworkRuleSet_DefaultAction(temp)
		ruleSet.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// Set property "VirtualNetworkRules":
	for _, item := range typedInput.VirtualNetworkRules {
		var item1 VirtualNetworkRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.VirtualNetworkRules = append(ruleSet.VirtualNetworkRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet populates our NetworkRuleSet from the provided source NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_From_NetworkRuleSet(source *storage.NetworkRuleSet) error {

	// Bypass
	if source.Bypass != nil {
		bypass := *source.Bypass
		bypassTemp := genruntime.ToEnum(bypass, networkRuleSet_Bypass_Values)
		ruleSet.Bypass = &bypassTemp
	} else {
		ruleSet.Bypass = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, networkRuleSet_DefaultAction_Values)
		ruleSet.DefaultAction = &defaultActionTemp
	} else {
		ruleSet.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.AssignProperties_From_IpRule(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// VirtualNetworkRules
	if source.VirtualNetworkRules != nil {
		virtualNetworkRuleList := make([]VirtualNetworkRule, len(source.VirtualNetworkRules))
		for virtualNetworkRuleIndex, virtualNetworkRuleItem := range source.VirtualNetworkRules {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkRuleItem := virtualNetworkRuleItem
			var virtualNetworkRule VirtualNetworkRule
			err := virtualNetworkRule.AssignProperties_From_VirtualNetworkRule(&virtualNetworkRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualNetworkRule() to populate field VirtualNetworkRules")
			}
			virtualNetworkRuleList[virtualNetworkRuleIndex] = virtualNetworkRule
		}
		ruleSet.VirtualNetworkRules = virtualNetworkRuleList
	} else {
		ruleSet.VirtualNetworkRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet populates the provided destination NetworkRuleSet from our NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_To_NetworkRuleSet(destination *storage.NetworkRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Bypass
	if ruleSet.Bypass != nil {
		bypass := string(*ruleSet.Bypass)
		destination.Bypass = &bypass
	} else {
		destination.Bypass = nil
	}

	// DefaultAction
	if ruleSet.DefaultAction != nil {
		defaultAction := string(*ruleSet.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]storage.IpRule, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule
			err := ipRuleItem.AssignProperties_To_IpRule(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// VirtualNetworkRules
	if ruleSet.VirtualNetworkRules != nil {
		virtualNetworkRuleList := make([]storage.VirtualNetworkRule, len(ruleSet.VirtualNetworkRules))
		for virtualNetworkRuleIndex, virtualNetworkRuleItem := range ruleSet.VirtualNetworkRules {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkRuleItem := virtualNetworkRuleItem
			var virtualNetworkRule storage.VirtualNetworkRule
			err := virtualNetworkRuleItem.AssignProperties_To_VirtualNetworkRule(&virtualNetworkRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualNetworkRule() to populate field VirtualNetworkRules")
			}
			virtualNetworkRuleList[virtualNetworkRuleIndex] = virtualNetworkRule
		}
		destination.VirtualNetworkRules = virtualNetworkRuleList
	} else {
		destination.VirtualNetworkRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkRuleSet_STATUS populates our NetworkRuleSet from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet) Initialize_From_NetworkRuleSet_STATUS(source *NetworkRuleSet_STATUS) error {

	// Bypass
	if source.Bypass != nil {
		bypass := genruntime.ToEnum(string(*source.Bypass), networkRuleSet_Bypass_Values)
		ruleSet.Bypass = &bypass
	} else {
		ruleSet.Bypass = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := genruntime.ToEnum(string(*source.DefaultAction), networkRuleSet_DefaultAction_Values)
		ruleSet.DefaultAction = &defaultAction
	} else {
		ruleSet.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.Initialize_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// VirtualNetworkRules
	if source.VirtualNetworkRules != nil {
		virtualNetworkRuleList := make([]VirtualNetworkRule, len(source.VirtualNetworkRules))
		for virtualNetworkRuleIndex, virtualNetworkRuleItem := range source.VirtualNetworkRules {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkRuleItem := virtualNetworkRuleItem
			var virtualNetworkRule VirtualNetworkRule
			err := virtualNetworkRule.Initialize_From_VirtualNetworkRule_STATUS(&virtualNetworkRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualNetworkRule_STATUS() to populate field VirtualNetworkRules")
			}
			virtualNetworkRuleList[virtualNetworkRuleIndex] = virtualNetworkRule
		}
		ruleSet.VirtualNetworkRules = virtualNetworkRuleList
	} else {
		ruleSet.VirtualNetworkRules = nil
	}

	// No error
	return nil
}

// A set of rules governing the network accessibility.
type NetworkRuleSet_STATUS struct {
	// Bypass: Setting for trusted services.
	Bypass *NetworkRuleSet_Bypass_STATUS `json:"bypass,omitempty"`

	// DefaultAction: The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after
	// the bypass property has been evaluated.
	DefaultAction *NetworkRuleSet_DefaultAction_STATUS `json:"defaultAction,omitempty"`

	// IpRules: The list of IP address rules.
	IpRules []IpRule_STATUS `json:"ipRules,omitempty"`

	// VirtualNetworkRules: The list of virtual network rules.
	VirtualNetworkRules []VirtualNetworkRule_STATUS `json:"virtualNetworkRules,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSet_STATUS, got %T", armInput)
	}

	// Set property "Bypass":
	if typedInput.Bypass != nil {
		var temp string
		temp = string(*typedInput.Bypass)
		bypass := NetworkRuleSet_Bypass_STATUS(temp)
		ruleSet.Bypass = &bypass
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := NetworkRuleSet_DefaultAction_STATUS(temp)
		ruleSet.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// Set property "VirtualNetworkRules":
	for _, item := range typedInput.VirtualNetworkRules {
		var item1 VirtualNetworkRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.VirtualNetworkRules = append(ruleSet.VirtualNetworkRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet_STATUS populates our NetworkRuleSet_STATUS from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_From_NetworkRuleSet_STATUS(source *storage.NetworkRuleSet_STATUS) error {

	// Bypass
	if source.Bypass != nil {
		bypass := *source.Bypass
		bypassTemp := genruntime.ToEnum(bypass, networkRuleSet_Bypass_STATUS_Values)
		ruleSet.Bypass = &bypassTemp
	} else {
		ruleSet.Bypass = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, networkRuleSet_DefaultAction_STATUS_Values)
		ruleSet.DefaultAction = &defaultActionTemp
	} else {
		ruleSet.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule_STATUS
			err := ipRule.AssignProperties_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// VirtualNetworkRules
	if source.VirtualNetworkRules != nil {
		virtualNetworkRuleList := make([]VirtualNetworkRule_STATUS, len(source.VirtualNetworkRules))
		for virtualNetworkRuleIndex, virtualNetworkRuleItem := range source.VirtualNetworkRules {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkRuleItem := virtualNetworkRuleItem
			var virtualNetworkRule VirtualNetworkRule_STATUS
			err := virtualNetworkRule.AssignProperties_From_VirtualNetworkRule_STATUS(&virtualNetworkRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualNetworkRule_STATUS() to populate field VirtualNetworkRules")
			}
			virtualNetworkRuleList[virtualNetworkRuleIndex] = virtualNetworkRule
		}
		ruleSet.VirtualNetworkRules = virtualNetworkRuleList
	} else {
		ruleSet.VirtualNetworkRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet_STATUS populates the provided destination NetworkRuleSet_STATUS from our NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_To_NetworkRuleSet_STATUS(destination *storage.NetworkRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Bypass
	if ruleSet.Bypass != nil {
		bypass := string(*ruleSet.Bypass)
		destination.Bypass = &bypass
	} else {
		destination.Bypass = nil
	}

	// DefaultAction
	if ruleSet.DefaultAction != nil {
		defaultAction := string(*ruleSet.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]storage.IpRule_STATUS, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule_STATUS
			err := ipRuleItem.AssignProperties_To_IpRule_STATUS(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// VirtualNetworkRules
	if ruleSet.VirtualNetworkRules != nil {
		virtualNetworkRuleList := make([]storage.VirtualNetworkRule_STATUS, len(ruleSet.VirtualNetworkRules))
		for virtualNetworkRuleIndex, virtualNetworkRuleItem := range ruleSet.VirtualNetworkRules {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkRuleItem := virtualNetworkRuleItem
			var virtualNetworkRule storage.VirtualNetworkRule_STATUS
			err := virtualNetworkRuleItem.AssignProperties_To_VirtualNetworkRule_STATUS(&virtualNetworkRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualNetworkRule_STATUS() to populate field VirtualNetworkRules")
			}
			virtualNetworkRuleList[virtualNetworkRuleIndex] = virtualNetworkRule
		}
		destination.VirtualNetworkRules = virtualNetworkRuleList
	} else {
		destination.VirtualNetworkRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type QuotaLimit_STATUS struct {
	Count         *float64                `json:"count,omitempty"`
	RenewalPeriod *float64                `json:"renewalPeriod,omitempty"`
	Rules         []ThrottlingRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &QuotaLimit_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limit *QuotaLimit_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.QuotaLimit_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limit *QuotaLimit_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.QuotaLimit_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.QuotaLimit_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		limit.Count = &count
	}

	// Set property "RenewalPeriod":
	if typedInput.RenewalPeriod != nil {
		renewalPeriod := *typedInput.RenewalPeriod
		limit.RenewalPeriod = &renewalPeriod
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ThrottlingRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		limit.Rules = append(limit.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_QuotaLimit_STATUS populates our QuotaLimit_STATUS from the provided source QuotaLimit_STATUS
func (limit *QuotaLimit_STATUS) AssignProperties_From_QuotaLimit_STATUS(source *storage.QuotaLimit_STATUS) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		limit.Count = &count
	} else {
		limit.Count = nil
	}

	// RenewalPeriod
	if source.RenewalPeriod != nil {
		renewalPeriod := *source.RenewalPeriod
		limit.RenewalPeriod = &renewalPeriod
	} else {
		limit.RenewalPeriod = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ThrottlingRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ThrottlingRule_STATUS
			err := rule.AssignProperties_From_ThrottlingRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ThrottlingRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		limit.Rules = ruleList
	} else {
		limit.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_QuotaLimit_STATUS populates the provided destination QuotaLimit_STATUS from our QuotaLimit_STATUS
func (limit *QuotaLimit_STATUS) AssignProperties_To_QuotaLimit_STATUS(destination *storage.QuotaLimit_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if limit.Count != nil {
		count := *limit.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// RenewalPeriod
	if limit.RenewalPeriod != nil {
		renewalPeriod := *limit.RenewalPeriod
		destination.RenewalPeriod = &renewalPeriod
	} else {
		destination.RenewalPeriod = nil
	}

	// Rules
	if limit.Rules != nil {
		ruleList := make([]storage.ThrottlingRule_STATUS, len(limit.Rules))
		for ruleIndex, ruleItem := range limit.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ThrottlingRule_STATUS
			err := ruleItem.AssignProperties_To_ThrottlingRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ThrottlingRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Cognitive Services Rai Monitor Config.
type RaiMonitorConfig struct {
	// AdxStorageResourceReference: The storage resource Id.
	AdxStorageResourceReference *genruntime.ResourceReference `armReference:"AdxStorageResourceId" json:"adxStorageResourceReference,omitempty"`

	// IdentityClientId: The identity client Id to access the storage.
	IdentityClientId *string `json:"identityClientId,omitempty"`
}

var _ genruntime.ARMTransformer = &RaiMonitorConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *RaiMonitorConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.RaiMonitorConfig{}

	// Set property "AdxStorageResourceId":
	if config.AdxStorageResourceReference != nil {
		adxStorageResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*config.AdxStorageResourceReference)
		if err != nil {
			return nil, err
		}
		adxStorageResourceReference := adxStorageResourceReferenceARMID
		result.AdxStorageResourceId = &adxStorageResourceReference
	}

	// Set property "IdentityClientId":
	if config.IdentityClientId != nil {
		identityClientId := *config.IdentityClientId
		result.IdentityClientId = &identityClientId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *RaiMonitorConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RaiMonitorConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *RaiMonitorConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RaiMonitorConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RaiMonitorConfig, got %T", armInput)
	}

	// no assignment for property "AdxStorageResourceReference"

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		config.IdentityClientId = &identityClientId
	}

	// No error
	return nil
}

// AssignProperties_From_RaiMonitorConfig populates our RaiMonitorConfig from the provided source RaiMonitorConfig
func (config *RaiMonitorConfig) AssignProperties_From_RaiMonitorConfig(source *storage.RaiMonitorConfig) error {

	// AdxStorageResourceReference
	if source.AdxStorageResourceReference != nil {
		adxStorageResourceReference := source.AdxStorageResourceReference.Copy()
		config.AdxStorageResourceReference = &adxStorageResourceReference
	} else {
		config.AdxStorageResourceReference = nil
	}

	// IdentityClientId
	config.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// No error
	return nil
}

// AssignProperties_To_RaiMonitorConfig populates the provided destination RaiMonitorConfig from our RaiMonitorConfig
func (config *RaiMonitorConfig) AssignProperties_To_RaiMonitorConfig(destination *storage.RaiMonitorConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdxStorageResourceReference
	if config.AdxStorageResourceReference != nil {
		adxStorageResourceReference := config.AdxStorageResourceReference.Copy()
		destination.AdxStorageResourceReference = &adxStorageResourceReference
	} else {
		destination.AdxStorageResourceReference = nil
	}

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(config.IdentityClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RaiMonitorConfig_STATUS populates our RaiMonitorConfig from the provided source RaiMonitorConfig_STATUS
func (config *RaiMonitorConfig) Initialize_From_RaiMonitorConfig_STATUS(source *RaiMonitorConfig_STATUS) error {

	// AdxStorageResourceReference
	if source.AdxStorageResourceId != nil {
		adxStorageResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.AdxStorageResourceId)
		config.AdxStorageResourceReference = &adxStorageResourceReference
	} else {
		config.AdxStorageResourceReference = nil
	}

	// IdentityClientId
	config.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// No error
	return nil
}

// Cognitive Services Rai Monitor Config.
type RaiMonitorConfig_STATUS struct {
	// AdxStorageResourceId: The storage resource Id.
	AdxStorageResourceId *string `json:"adxStorageResourceId,omitempty"`

	// IdentityClientId: The identity client Id to access the storage.
	IdentityClientId *string `json:"identityClientId,omitempty"`
}

var _ genruntime.FromARMConverter = &RaiMonitorConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *RaiMonitorConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RaiMonitorConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *RaiMonitorConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RaiMonitorConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RaiMonitorConfig_STATUS, got %T", armInput)
	}

	// Set property "AdxStorageResourceId":
	if typedInput.AdxStorageResourceId != nil {
		adxStorageResourceId := *typedInput.AdxStorageResourceId
		config.AdxStorageResourceId = &adxStorageResourceId
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		config.IdentityClientId = &identityClientId
	}

	// No error
	return nil
}

// AssignProperties_From_RaiMonitorConfig_STATUS populates our RaiMonitorConfig_STATUS from the provided source RaiMonitorConfig_STATUS
func (config *RaiMonitorConfig_STATUS) AssignProperties_From_RaiMonitorConfig_STATUS(source *storage.RaiMonitorConfig_STATUS) error {

	// AdxStorageResourceId
	config.AdxStorageResourceId = genruntime.ClonePointerToString(source.AdxStorageResourceId)

	// IdentityClientId
	config.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// No error
	return nil
}

// AssignProperties_To_RaiMonitorConfig_STATUS populates the provided destination RaiMonitorConfig_STATUS from our RaiMonitorConfig_STATUS
func (config *RaiMonitorConfig_STATUS) AssignProperties_To_RaiMonitorConfig_STATUS(destination *storage.RaiMonitorConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdxStorageResourceId
	destination.AdxStorageResourceId = genruntime.ClonePointerToString(config.AdxStorageResourceId)

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(config.IdentityClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Basic","Enterprise","Free","Premium","Standard"}
type Sku_Tier string

const (
	Sku_Tier_Basic      = Sku_Tier("Basic")
	Sku_Tier_Enterprise = Sku_Tier("Enterprise")
	Sku_Tier_Free       = Sku_Tier("Free")
	Sku_Tier_Premium    = Sku_Tier("Premium")
	Sku_Tier_Standard   = Sku_Tier("Standard")
)

// Mapping from string to Sku_Tier
var sku_Tier_Values = map[string]Sku_Tier{
	"basic":      Sku_Tier_Basic,
	"enterprise": Sku_Tier_Enterprise,
	"free":       Sku_Tier_Free,
	"premium":    Sku_Tier_Premium,
	"standard":   Sku_Tier_Standard,
}

type Sku_Tier_STATUS string

const (
	Sku_Tier_STATUS_Basic      = Sku_Tier_STATUS("Basic")
	Sku_Tier_STATUS_Enterprise = Sku_Tier_STATUS("Enterprise")
	Sku_Tier_STATUS_Free       = Sku_Tier_STATUS("Free")
	Sku_Tier_STATUS_Premium    = Sku_Tier_STATUS("Premium")
	Sku_Tier_STATUS_Standard   = Sku_Tier_STATUS("Standard")
)

// Mapping from string to Sku_Tier_STATUS
var sku_Tier_STATUS_Values = map[string]Sku_Tier_STATUS{
	"basic":      Sku_Tier_STATUS_Basic,
	"enterprise": Sku_Tier_STATUS_Enterprise,
	"free":       Sku_Tier_STATUS_Free,
	"premium":    Sku_Tier_STATUS_Premium,
	"standard":   Sku_Tier_STATUS_Standard,
}

// SkuCapability indicates the capability of a certain feature.
type SkuCapability_STATUS struct {
	// Name: The name of the SkuCapability.
	Name *string `json:"name,omitempty"`

	// Value: The value of the SkuCapability.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &SkuCapability_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capability *SkuCapability_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SkuCapability_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capability *SkuCapability_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SkuCapability_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SkuCapability_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		capability.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		capability.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_SkuCapability_STATUS populates our SkuCapability_STATUS from the provided source SkuCapability_STATUS
func (capability *SkuCapability_STATUS) AssignProperties_From_SkuCapability_STATUS(source *storage.SkuCapability_STATUS) error {

	// Name
	capability.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	capability.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_SkuCapability_STATUS populates the provided destination SkuCapability_STATUS from our SkuCapability_STATUS
func (capability *SkuCapability_STATUS) AssignProperties_To_SkuCapability_STATUS(destination *storage.SkuCapability_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(capability.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(capability.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Sku change info of account.
type SkuChangeInfo_STATUS struct {
	// CountOfDowngrades: Gets the count of downgrades.
	CountOfDowngrades *float64 `json:"countOfDowngrades,omitempty"`

	// CountOfUpgradesAfterDowngrades: Gets the count of upgrades after downgrades.
	CountOfUpgradesAfterDowngrades *float64 `json:"countOfUpgradesAfterDowngrades,omitempty"`

	// LastChangeDate: Gets the last change date.
	LastChangeDate *string `json:"lastChangeDate,omitempty"`
}

var _ genruntime.FromARMConverter = &SkuChangeInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *SkuChangeInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SkuChangeInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *SkuChangeInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SkuChangeInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SkuChangeInfo_STATUS, got %T", armInput)
	}

	// Set property "CountOfDowngrades":
	if typedInput.CountOfDowngrades != nil {
		countOfDowngrades := *typedInput.CountOfDowngrades
		info.CountOfDowngrades = &countOfDowngrades
	}

	// Set property "CountOfUpgradesAfterDowngrades":
	if typedInput.CountOfUpgradesAfterDowngrades != nil {
		countOfUpgradesAfterDowngrades := *typedInput.CountOfUpgradesAfterDowngrades
		info.CountOfUpgradesAfterDowngrades = &countOfUpgradesAfterDowngrades
	}

	// Set property "LastChangeDate":
	if typedInput.LastChangeDate != nil {
		lastChangeDate := *typedInput.LastChangeDate
		info.LastChangeDate = &lastChangeDate
	}

	// No error
	return nil
}

// AssignProperties_From_SkuChangeInfo_STATUS populates our SkuChangeInfo_STATUS from the provided source SkuChangeInfo_STATUS
func (info *SkuChangeInfo_STATUS) AssignProperties_From_SkuChangeInfo_STATUS(source *storage.SkuChangeInfo_STATUS) error {

	// CountOfDowngrades
	if source.CountOfDowngrades != nil {
		countOfDowngrade := *source.CountOfDowngrades
		info.CountOfDowngrades = &countOfDowngrade
	} else {
		info.CountOfDowngrades = nil
	}

	// CountOfUpgradesAfterDowngrades
	if source.CountOfUpgradesAfterDowngrades != nil {
		countOfUpgradesAfterDowngrade := *source.CountOfUpgradesAfterDowngrades
		info.CountOfUpgradesAfterDowngrades = &countOfUpgradesAfterDowngrade
	} else {
		info.CountOfUpgradesAfterDowngrades = nil
	}

	// LastChangeDate
	info.LastChangeDate = genruntime.ClonePointerToString(source.LastChangeDate)

	// No error
	return nil
}

// AssignProperties_To_SkuChangeInfo_STATUS populates the provided destination SkuChangeInfo_STATUS from our SkuChangeInfo_STATUS
func (info *SkuChangeInfo_STATUS) AssignProperties_To_SkuChangeInfo_STATUS(destination *storage.SkuChangeInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CountOfDowngrades
	if info.CountOfDowngrades != nil {
		countOfDowngrade := *info.CountOfDowngrades
		destination.CountOfDowngrades = &countOfDowngrade
	} else {
		destination.CountOfDowngrades = nil
	}

	// CountOfUpgradesAfterDowngrades
	if info.CountOfUpgradesAfterDowngrades != nil {
		countOfUpgradesAfterDowngrade := *info.CountOfUpgradesAfterDowngrades
		destination.CountOfUpgradesAfterDowngrades = &countOfUpgradesAfterDowngrade
	} else {
		destination.CountOfUpgradesAfterDowngrades = nil
	}

	// LastChangeDate
	destination.LastChangeDate = genruntime.ClonePointerToString(info.LastChangeDate)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// User-assigned managed identity.
type UserAssignedIdentity_STATUS struct {
	// ClientId: Client App Id associated with this identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: Azure Active Directory principal ID associated with this Identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The user owned AML account for Cognitive Services account.
type UserOwnedAmlWorkspace struct {
	// IdentityClientId: Identity Client id of a AML account resource.
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// ResourceReference: Full resource id of a AML account resource.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserOwnedAmlWorkspace{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (workspace *UserOwnedAmlWorkspace) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if workspace == nil {
		return nil, nil
	}
	result := &arm.UserOwnedAmlWorkspace{}

	// Set property "IdentityClientId":
	if workspace.IdentityClientId != nil {
		identityClientId := *workspace.IdentityClientId
		result.IdentityClientId = &identityClientId
	}

	// Set property "ResourceId":
	if workspace.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*workspace.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *UserOwnedAmlWorkspace) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserOwnedAmlWorkspace{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *UserOwnedAmlWorkspace) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserOwnedAmlWorkspace)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserOwnedAmlWorkspace, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		workspace.IdentityClientId = &identityClientId
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_UserOwnedAmlWorkspace populates our UserOwnedAmlWorkspace from the provided source UserOwnedAmlWorkspace
func (workspace *UserOwnedAmlWorkspace) AssignProperties_From_UserOwnedAmlWorkspace(source *storage.UserOwnedAmlWorkspace) error {

	// IdentityClientId
	workspace.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		workspace.ResourceReference = &resourceReference
	} else {
		workspace.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserOwnedAmlWorkspace populates the provided destination UserOwnedAmlWorkspace from our UserOwnedAmlWorkspace
func (workspace *UserOwnedAmlWorkspace) AssignProperties_To_UserOwnedAmlWorkspace(destination *storage.UserOwnedAmlWorkspace) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(workspace.IdentityClientId)

	// ResourceReference
	if workspace.ResourceReference != nil {
		resourceReference := workspace.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserOwnedAmlWorkspace_STATUS populates our UserOwnedAmlWorkspace from the provided source UserOwnedAmlWorkspace_STATUS
func (workspace *UserOwnedAmlWorkspace) Initialize_From_UserOwnedAmlWorkspace_STATUS(source *UserOwnedAmlWorkspace_STATUS) error {

	// IdentityClientId
	workspace.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		workspace.ResourceReference = &resourceReference
	} else {
		workspace.ResourceReference = nil
	}

	// No error
	return nil
}

// The user owned AML account for Cognitive Services account.
type UserOwnedAmlWorkspace_STATUS struct {
	// IdentityClientId: Identity Client id of a AML account resource.
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// ResourceId: Full resource id of a AML account resource.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserOwnedAmlWorkspace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *UserOwnedAmlWorkspace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserOwnedAmlWorkspace_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *UserOwnedAmlWorkspace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserOwnedAmlWorkspace_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserOwnedAmlWorkspace_STATUS, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		workspace.IdentityClientId = &identityClientId
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		workspace.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserOwnedAmlWorkspace_STATUS populates our UserOwnedAmlWorkspace_STATUS from the provided source UserOwnedAmlWorkspace_STATUS
func (workspace *UserOwnedAmlWorkspace_STATUS) AssignProperties_From_UserOwnedAmlWorkspace_STATUS(source *storage.UserOwnedAmlWorkspace_STATUS) error {

	// IdentityClientId
	workspace.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceId
	workspace.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_UserOwnedAmlWorkspace_STATUS populates the provided destination UserOwnedAmlWorkspace_STATUS from our UserOwnedAmlWorkspace_STATUS
func (workspace *UserOwnedAmlWorkspace_STATUS) AssignProperties_To_UserOwnedAmlWorkspace_STATUS(destination *storage.UserOwnedAmlWorkspace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(workspace.IdentityClientId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(workspace.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The user owned storage for Cognitive Services account.
type UserOwnedStorage struct {
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// ResourceReference: Full resource id of a Microsoft.Storage resource.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserOwnedStorage{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (storage *UserOwnedStorage) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if storage == nil {
		return nil, nil
	}
	result := &arm.UserOwnedStorage{}

	// Set property "IdentityClientId":
	if storage.IdentityClientId != nil {
		identityClientId := *storage.IdentityClientId
		result.IdentityClientId = &identityClientId
	}

	// Set property "ResourceId":
	if storage.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*storage.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (storage *UserOwnedStorage) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserOwnedStorage{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (storage *UserOwnedStorage) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserOwnedStorage)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserOwnedStorage, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		storage.IdentityClientId = &identityClientId
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_UserOwnedStorage populates our UserOwnedStorage from the provided source UserOwnedStorage
func (storage *UserOwnedStorage) AssignProperties_From_UserOwnedStorage(source *storage.UserOwnedStorage) error {

	// IdentityClientId
	storage.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		storage.ResourceReference = &resourceReference
	} else {
		storage.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserOwnedStorage populates the provided destination UserOwnedStorage from our UserOwnedStorage
func (storage *UserOwnedStorage) AssignProperties_To_UserOwnedStorage(destination *storage.UserOwnedStorage) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(storage.IdentityClientId)

	// ResourceReference
	if storage.ResourceReference != nil {
		resourceReference := storage.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserOwnedStorage_STATUS populates our UserOwnedStorage from the provided source UserOwnedStorage_STATUS
func (storage *UserOwnedStorage) Initialize_From_UserOwnedStorage_STATUS(source *UserOwnedStorage_STATUS) error {

	// IdentityClientId
	storage.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		storage.ResourceReference = &resourceReference
	} else {
		storage.ResourceReference = nil
	}

	// No error
	return nil
}

// The user owned storage for Cognitive Services account.
type UserOwnedStorage_STATUS struct {
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// ResourceId: Full resource id of a Microsoft.Storage resource.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserOwnedStorage_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (storage *UserOwnedStorage_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserOwnedStorage_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (storage *UserOwnedStorage_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserOwnedStorage_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserOwnedStorage_STATUS, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		storage.IdentityClientId = &identityClientId
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		storage.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserOwnedStorage_STATUS populates our UserOwnedStorage_STATUS from the provided source UserOwnedStorage_STATUS
func (storage *UserOwnedStorage_STATUS) AssignProperties_From_UserOwnedStorage_STATUS(source *storage.UserOwnedStorage_STATUS) error {

	// IdentityClientId
	storage.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// ResourceId
	storage.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_UserOwnedStorage_STATUS populates the provided destination UserOwnedStorage_STATUS from our UserOwnedStorage_STATUS
func (storage *UserOwnedStorage_STATUS) AssignProperties_To_UserOwnedStorage_STATUS(destination *storage.UserOwnedStorage_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(storage.IdentityClientId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(storage.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AbusePenalty_Action_STATUS string

const (
	AbusePenalty_Action_STATUS_Block    = AbusePenalty_Action_STATUS("Block")
	AbusePenalty_Action_STATUS_Throttle = AbusePenalty_Action_STATUS("Throttle")
)

// Mapping from string to AbusePenalty_Action_STATUS
var abusePenalty_Action_STATUS_Values = map[string]AbusePenalty_Action_STATUS{
	"block":    AbusePenalty_Action_STATUS_Block,
	"throttle": AbusePenalty_Action_STATUS_Throttle,
}

// +kubebuilder:validation:Enum={"Microsoft.CognitiveServices","Microsoft.KeyVault"}
type Encryption_KeySource string

const (
	Encryption_KeySource_MicrosoftCognitiveServices = Encryption_KeySource("Microsoft.CognitiveServices")
	Encryption_KeySource_MicrosoftKeyVault          = Encryption_KeySource("Microsoft.KeyVault")
)

// Mapping from string to Encryption_KeySource
var encryption_KeySource_Values = map[string]Encryption_KeySource{
	"microsoft.cognitiveservices": Encryption_KeySource_MicrosoftCognitiveServices,
	"microsoft.keyvault":          Encryption_KeySource_MicrosoftKeyVault,
}

type Encryption_KeySource_STATUS string

const (
	Encryption_KeySource_STATUS_MicrosoftCognitiveServices = Encryption_KeySource_STATUS("Microsoft.CognitiveServices")
	Encryption_KeySource_STATUS_MicrosoftKeyVault          = Encryption_KeySource_STATUS("Microsoft.KeyVault")
)

// Mapping from string to Encryption_KeySource_STATUS
var encryption_KeySource_STATUS_Values = map[string]Encryption_KeySource_STATUS{
	"microsoft.cognitiveservices": Encryption_KeySource_STATUS_MicrosoftCognitiveServices,
	"microsoft.keyvault":          Encryption_KeySource_STATUS_MicrosoftKeyVault,
}

// A rule governing the accessibility from a specific ip address or ip range.
type IpRule struct {
	// +kubebuilder:validation:Required
	// Value: An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all
	// addresses that start with 124.56.78).
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &IpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IpRule{}

	// Set property "Value":
	if rule.Value != nil {
		value := *rule.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule populates our IpRule from the provided source IpRule
func (rule *IpRule) AssignProperties_From_IpRule(source *storage.IpRule) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule populates the provided destination IpRule from our IpRule
func (rule *IpRule) AssignProperties_To_IpRule(destination *storage.IpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpRule_STATUS populates our IpRule from the provided source IpRule_STATUS
func (rule *IpRule) Initialize_From_IpRule_STATUS(source *IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// A rule governing the accessibility from a specific ip address or ip range.
type IpRule_STATUS struct {
	// Value: An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all
	// addresses that start with 124.56.78).
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &IpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule_STATUS populates our IpRule_STATUS from the provided source IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_From_IpRule_STATUS(source *storage.IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule_STATUS populates the provided destination IpRule_STATUS from our IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_To_IpRule_STATUS(destination *storage.IpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties to configure keyVault Properties
type KeyVaultProperties struct {
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// KeyName: Name of the Key from KeyVault
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: Uri of KeyVault
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: Version of the Key from KeyVault
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KeyVaultProperties{}

	// Set property "IdentityClientId":
	if properties.IdentityClientId != nil {
		identityClientId := *properties.IdentityClientId
		result.IdentityClientId = &identityClientId
	}

	// Set property "KeyName":
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if properties.KeyVaultUri != nil {
		keyVaultUri := *properties.KeyVaultUri
		result.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		properties.IdentityClientId = &identityClientId
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties populates our KeyVaultProperties from the provided source KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_From_KeyVaultProperties(source *storage.KeyVaultProperties) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties populates the provided destination KeyVaultProperties from our KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_To_KeyVaultProperties(destination *storage.KeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(properties.IdentityClientId)

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultProperties_STATUS populates our KeyVaultProperties from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties) Initialize_From_KeyVaultProperties_STATUS(source *KeyVaultProperties_STATUS) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// Properties to configure keyVault Properties
type KeyVaultProperties_STATUS struct {
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// KeyName: Name of the Key from KeyVault
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: Uri of KeyVault
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: Version of the Key from KeyVault
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		properties.IdentityClientId = &identityClientId
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties_STATUS populates our KeyVaultProperties_STATUS from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_From_KeyVaultProperties_STATUS(source *storage.KeyVaultProperties_STATUS) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties_STATUS populates the provided destination KeyVaultProperties_STATUS from our KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_To_KeyVaultProperties_STATUS(destination *storage.KeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(properties.IdentityClientId)

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Performance","Priority","Weighted"}
type MultiRegionSettings_RoutingMethod string

const (
	MultiRegionSettings_RoutingMethod_Performance = MultiRegionSettings_RoutingMethod("Performance")
	MultiRegionSettings_RoutingMethod_Priority    = MultiRegionSettings_RoutingMethod("Priority")
	MultiRegionSettings_RoutingMethod_Weighted    = MultiRegionSettings_RoutingMethod("Weighted")
)

// Mapping from string to MultiRegionSettings_RoutingMethod
var multiRegionSettings_RoutingMethod_Values = map[string]MultiRegionSettings_RoutingMethod{
	"performance": MultiRegionSettings_RoutingMethod_Performance,
	"priority":    MultiRegionSettings_RoutingMethod_Priority,
	"weighted":    MultiRegionSettings_RoutingMethod_Weighted,
}

type MultiRegionSettings_RoutingMethod_STATUS string

const (
	MultiRegionSettings_RoutingMethod_STATUS_Performance = MultiRegionSettings_RoutingMethod_STATUS("Performance")
	MultiRegionSettings_RoutingMethod_STATUS_Priority    = MultiRegionSettings_RoutingMethod_STATUS("Priority")
	MultiRegionSettings_RoutingMethod_STATUS_Weighted    = MultiRegionSettings_RoutingMethod_STATUS("Weighted")
)

// Mapping from string to MultiRegionSettings_RoutingMethod_STATUS
var multiRegionSettings_RoutingMethod_STATUS_Values = map[string]MultiRegionSettings_RoutingMethod_STATUS{
	"performance": MultiRegionSettings_RoutingMethod_STATUS_Performance,
	"priority":    MultiRegionSettings_RoutingMethod_STATUS_Priority,
	"weighted":    MultiRegionSettings_RoutingMethod_STATUS_Weighted,
}

// +kubebuilder:validation:Enum={"agent","none"}
type NetworkInjections_Scenario string

const (
	NetworkInjections_Scenario_Agent = NetworkInjections_Scenario("agent")
	NetworkInjections_Scenario_None  = NetworkInjections_Scenario("none")
)

// Mapping from string to NetworkInjections_Scenario
var networkInjections_Scenario_Values = map[string]NetworkInjections_Scenario{
	"agent": NetworkInjections_Scenario_Agent,
	"none":  NetworkInjections_Scenario_None,
}

type NetworkInjections_Scenario_STATUS string

const (
	NetworkInjections_Scenario_STATUS_Agent = NetworkInjections_Scenario_STATUS("agent")
	NetworkInjections_Scenario_STATUS_None  = NetworkInjections_Scenario_STATUS("none")
)

// Mapping from string to NetworkInjections_Scenario_STATUS
var networkInjections_Scenario_STATUS_Values = map[string]NetworkInjections_Scenario_STATUS{
	"agent": NetworkInjections_Scenario_STATUS_Agent,
	"none":  NetworkInjections_Scenario_STATUS_None,
}

// +kubebuilder:validation:Enum={"AzureServices","None"}
type NetworkRuleSet_Bypass string

const (
	NetworkRuleSet_Bypass_AzureServices = NetworkRuleSet_Bypass("AzureServices")
	NetworkRuleSet_Bypass_None          = NetworkRuleSet_Bypass("None")
)

// Mapping from string to NetworkRuleSet_Bypass
var networkRuleSet_Bypass_Values = map[string]NetworkRuleSet_Bypass{
	"azureservices": NetworkRuleSet_Bypass_AzureServices,
	"none":          NetworkRuleSet_Bypass_None,
}

type NetworkRuleSet_Bypass_STATUS string

const (
	NetworkRuleSet_Bypass_STATUS_AzureServices = NetworkRuleSet_Bypass_STATUS("AzureServices")
	NetworkRuleSet_Bypass_STATUS_None          = NetworkRuleSet_Bypass_STATUS("None")
)

// Mapping from string to NetworkRuleSet_Bypass_STATUS
var networkRuleSet_Bypass_STATUS_Values = map[string]NetworkRuleSet_Bypass_STATUS{
	"azureservices": NetworkRuleSet_Bypass_STATUS_AzureServices,
	"none":          NetworkRuleSet_Bypass_STATUS_None,
}

// +kubebuilder:validation:Enum={"Allow","Deny"}
type NetworkRuleSet_DefaultAction string

const (
	NetworkRuleSet_DefaultAction_Allow = NetworkRuleSet_DefaultAction("Allow")
	NetworkRuleSet_DefaultAction_Deny  = NetworkRuleSet_DefaultAction("Deny")
)

// Mapping from string to NetworkRuleSet_DefaultAction
var networkRuleSet_DefaultAction_Values = map[string]NetworkRuleSet_DefaultAction{
	"allow": NetworkRuleSet_DefaultAction_Allow,
	"deny":  NetworkRuleSet_DefaultAction_Deny,
}

type NetworkRuleSet_DefaultAction_STATUS string

const (
	NetworkRuleSet_DefaultAction_STATUS_Allow = NetworkRuleSet_DefaultAction_STATUS("Allow")
	NetworkRuleSet_DefaultAction_STATUS_Deny  = NetworkRuleSet_DefaultAction_STATUS("Deny")
)

// Mapping from string to NetworkRuleSet_DefaultAction_STATUS
var networkRuleSet_DefaultAction_STATUS_Values = map[string]NetworkRuleSet_DefaultAction_STATUS{
	"allow": NetworkRuleSet_DefaultAction_STATUS_Allow,
	"deny":  NetworkRuleSet_DefaultAction_STATUS_Deny,
}

// The call rate limit Cognitive Services account.
type RegionSetting struct {
	// Customsubdomain: Maps the region to the regional custom subdomain.
	Customsubdomain *string `json:"customsubdomain,omitempty"`

	// Name: Name of the region.
	Name *string `json:"name,omitempty"`

	// Value: A value for priority or weighted routing methods.
	Value *float64 `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &RegionSetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *RegionSetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &arm.RegionSetting{}

	// Set property "Customsubdomain":
	if setting.Customsubdomain != nil {
		customsubdomain := *setting.Customsubdomain
		result.Customsubdomain = &customsubdomain
	}

	// Set property "Name":
	if setting.Name != nil {
		name := *setting.Name
		result.Name = &name
	}

	// Set property "Value":
	if setting.Value != nil {
		value := *setting.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *RegionSetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegionSetting{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *RegionSetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegionSetting)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegionSetting, got %T", armInput)
	}

	// Set property "Customsubdomain":
	if typedInput.Customsubdomain != nil {
		customsubdomain := *typedInput.Customsubdomain
		setting.Customsubdomain = &customsubdomain
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		setting.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		setting.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_RegionSetting populates our RegionSetting from the provided source RegionSetting
func (setting *RegionSetting) AssignProperties_From_RegionSetting(source *storage.RegionSetting) error {

	// Customsubdomain
	setting.Customsubdomain = genruntime.ClonePointerToString(source.Customsubdomain)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	if source.Value != nil {
		value := *source.Value
		setting.Value = &value
	} else {
		setting.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegionSetting populates the provided destination RegionSetting from our RegionSetting
func (setting *RegionSetting) AssignProperties_To_RegionSetting(destination *storage.RegionSetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Customsubdomain
	destination.Customsubdomain = genruntime.ClonePointerToString(setting.Customsubdomain)

	// Name
	destination.Name = genruntime.ClonePointerToString(setting.Name)

	// Value
	if setting.Value != nil {
		value := *setting.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegionSetting_STATUS populates our RegionSetting from the provided source RegionSetting_STATUS
func (setting *RegionSetting) Initialize_From_RegionSetting_STATUS(source *RegionSetting_STATUS) error {

	// Customsubdomain
	setting.Customsubdomain = genruntime.ClonePointerToString(source.Customsubdomain)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	if source.Value != nil {
		value := *source.Value
		setting.Value = &value
	} else {
		setting.Value = nil
	}

	// No error
	return nil
}

// The call rate limit Cognitive Services account.
type RegionSetting_STATUS struct {
	// Customsubdomain: Maps the region to the regional custom subdomain.
	Customsubdomain *string `json:"customsubdomain,omitempty"`

	// Name: Name of the region.
	Name *string `json:"name,omitempty"`

	// Value: A value for priority or weighted routing methods.
	Value *float64 `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &RegionSetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *RegionSetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegionSetting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *RegionSetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegionSetting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegionSetting_STATUS, got %T", armInput)
	}

	// Set property "Customsubdomain":
	if typedInput.Customsubdomain != nil {
		customsubdomain := *typedInput.Customsubdomain
		setting.Customsubdomain = &customsubdomain
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		setting.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		setting.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_RegionSetting_STATUS populates our RegionSetting_STATUS from the provided source RegionSetting_STATUS
func (setting *RegionSetting_STATUS) AssignProperties_From_RegionSetting_STATUS(source *storage.RegionSetting_STATUS) error {

	// Customsubdomain
	setting.Customsubdomain = genruntime.ClonePointerToString(source.Customsubdomain)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	if source.Value != nil {
		value := *source.Value
		setting.Value = &value
	} else {
		setting.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RegionSetting_STATUS populates the provided destination RegionSetting_STATUS from our RegionSetting_STATUS
func (setting *RegionSetting_STATUS) AssignProperties_To_RegionSetting_STATUS(destination *storage.RegionSetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Customsubdomain
	destination.Customsubdomain = genruntime.ClonePointerToString(setting.Customsubdomain)

	// Name
	destination.Name = genruntime.ClonePointerToString(setting.Name)

	// Value
	if setting.Value != nil {
		value := *setting.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A rule governing the accessibility from a specific virtual network.
type VirtualNetworkRule struct {
	// IgnoreMissingVnetServiceEndpoint: Ignore missing vnet service endpoint or not.
	IgnoreMissingVnetServiceEndpoint *bool `json:"ignoreMissingVnetServiceEndpoint,omitempty"`

	// +kubebuilder:validation:Required
	// Reference: Full resource id of a vnet subnet, such as
	// '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// State: Gets the state of virtual network rule.
	State *string `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworkRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *VirtualNetworkRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.VirtualNetworkRule{}

	// Set property "Id":
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "IgnoreMissingVnetServiceEndpoint":
	if rule.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *rule.IgnoreMissingVnetServiceEndpoint
		result.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	}

	// Set property "State":
	if rule.State != nil {
		state := *rule.State
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *VirtualNetworkRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualNetworkRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *VirtualNetworkRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualNetworkRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualNetworkRule, got %T", armInput)
	}

	// Set property "IgnoreMissingVnetServiceEndpoint":
	if typedInput.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *typedInput.IgnoreMissingVnetServiceEndpoint
		rule.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	}

	// no assignment for property "Reference"

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		rule.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkRule populates our VirtualNetworkRule from the provided source VirtualNetworkRule
func (rule *VirtualNetworkRule) AssignProperties_From_VirtualNetworkRule(source *storage.VirtualNetworkRule) error {

	// IgnoreMissingVnetServiceEndpoint
	if source.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *source.IgnoreMissingVnetServiceEndpoint
		rule.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	} else {
		rule.IgnoreMissingVnetServiceEndpoint = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// State
	rule.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkRule populates the provided destination VirtualNetworkRule from our VirtualNetworkRule
func (rule *VirtualNetworkRule) AssignProperties_To_VirtualNetworkRule(destination *storage.VirtualNetworkRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IgnoreMissingVnetServiceEndpoint
	if rule.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *rule.IgnoreMissingVnetServiceEndpoint
		destination.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	} else {
		destination.IgnoreMissingVnetServiceEndpoint = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(rule.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualNetworkRule_STATUS populates our VirtualNetworkRule from the provided source VirtualNetworkRule_STATUS
func (rule *VirtualNetworkRule) Initialize_From_VirtualNetworkRule_STATUS(source *VirtualNetworkRule_STATUS) error {

	// IgnoreMissingVnetServiceEndpoint
	if source.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *source.IgnoreMissingVnetServiceEndpoint
		rule.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	} else {
		rule.IgnoreMissingVnetServiceEndpoint = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// State
	rule.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// A rule governing the accessibility from a specific virtual network.
type VirtualNetworkRule_STATUS struct {
	// Id: Full resource id of a vnet subnet, such as
	// '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
	Id *string `json:"id,omitempty"`

	// IgnoreMissingVnetServiceEndpoint: Ignore missing vnet service endpoint or not.
	IgnoreMissingVnetServiceEndpoint *bool `json:"ignoreMissingVnetServiceEndpoint,omitempty"`

	// State: Gets the state of virtual network rule.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualNetworkRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *VirtualNetworkRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualNetworkRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *VirtualNetworkRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualNetworkRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualNetworkRule_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property "IgnoreMissingVnetServiceEndpoint":
	if typedInput.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *typedInput.IgnoreMissingVnetServiceEndpoint
		rule.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		rule.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkRule_STATUS populates our VirtualNetworkRule_STATUS from the provided source VirtualNetworkRule_STATUS
func (rule *VirtualNetworkRule_STATUS) AssignProperties_From_VirtualNetworkRule_STATUS(source *storage.VirtualNetworkRule_STATUS) error {

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IgnoreMissingVnetServiceEndpoint
	if source.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *source.IgnoreMissingVnetServiceEndpoint
		rule.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	} else {
		rule.IgnoreMissingVnetServiceEndpoint = nil
	}

	// State
	rule.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkRule_STATUS populates the provided destination VirtualNetworkRule_STATUS from our VirtualNetworkRule_STATUS
func (rule *VirtualNetworkRule_STATUS) AssignProperties_To_VirtualNetworkRule_STATUS(destination *storage.VirtualNetworkRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IgnoreMissingVnetServiceEndpoint
	if rule.IgnoreMissingVnetServiceEndpoint != nil {
		ignoreMissingVnetServiceEndpoint := *rule.IgnoreMissingVnetServiceEndpoint
		destination.IgnoreMissingVnetServiceEndpoint = &ignoreMissingVnetServiceEndpoint
	} else {
		destination.IgnoreMissingVnetServiceEndpoint = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(rule.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Account{}, &AccountList{})
}
