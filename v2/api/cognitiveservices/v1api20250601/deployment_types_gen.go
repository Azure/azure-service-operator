// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20250601

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/cognitiveservices/v1api20250601/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/cognitiveservices/v1api20250601/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,cognitiveservices}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /cognitiveservices/resource-manager/Microsoft.CognitiveServices/stable/2025-06-01/cognitiveservices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CognitiveServices/accounts/{accountName}/deployments/{deploymentName}
type Deployment struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Deployment_Spec   `json:"spec,omitempty"`
	Status            Deployment_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Deployment{}

// GetConditions returns the conditions of the resource
func (deployment *Deployment) GetConditions() conditions.Conditions {
	return deployment.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (deployment *Deployment) SetConditions(conditions conditions.Conditions) {
	deployment.Status.Conditions = conditions
}

var _ conversion.Convertible = &Deployment{}

// ConvertFrom populates our Deployment from the provided hub Deployment
func (deployment *Deployment) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Deployment)
	if !ok {
		return fmt.Errorf("expected cognitiveservices/v1api20250601/storage/Deployment but received %T instead", hub)
	}

	return deployment.AssignProperties_From_Deployment(source)
}

// ConvertTo populates the provided hub Deployment from our Deployment
func (deployment *Deployment) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Deployment)
	if !ok {
		return fmt.Errorf("expected cognitiveservices/v1api20250601/storage/Deployment but received %T instead", hub)
	}

	return deployment.AssignProperties_To_Deployment(destination)
}

var _ configmaps.Exporter = &Deployment{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (deployment *Deployment) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if deployment.Spec.OperatorSpec == nil {
		return nil
	}
	return deployment.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Deployment{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (deployment *Deployment) SecretDestinationExpressions() []*core.DestinationExpression {
	if deployment.Spec.OperatorSpec == nil {
		return nil
	}
	return deployment.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Deployment{}

// InitializeSpec initializes the spec for this resource from the given status
func (deployment *Deployment) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Deployment_STATUS); ok {
		return deployment.Spec.Initialize_From_Deployment_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Deployment_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Deployment{}

// AzureName returns the Azure name of the resource
func (deployment *Deployment) AzureName() string {
	return deployment.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2025-06-01"
func (deployment Deployment) GetAPIVersion() string {
	return "2025-06-01"
}

// GetResourceScope returns the scope of the resource
func (deployment *Deployment) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (deployment *Deployment) GetSpec() genruntime.ConvertibleSpec {
	return &deployment.Spec
}

// GetStatus returns the status of this resource
func (deployment *Deployment) GetStatus() genruntime.ConvertibleStatus {
	return &deployment.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (deployment *Deployment) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.CognitiveServices/accounts/deployments"
func (deployment *Deployment) GetType() string {
	return "Microsoft.CognitiveServices/accounts/deployments"
}

// NewEmptyStatus returns a new empty (blank) status
func (deployment *Deployment) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Deployment_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (deployment *Deployment) Owner() *genruntime.ResourceReference {
	if deployment.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(deployment.Spec)
	return deployment.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (deployment *Deployment) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Deployment_STATUS); ok {
		deployment.Status = *st
		return nil
	}

	// Convert status to required version
	var st Deployment_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	deployment.Status = st
	return nil
}

// AssignProperties_From_Deployment populates our Deployment from the provided source Deployment
func (deployment *Deployment) AssignProperties_From_Deployment(source *storage.Deployment) error {

	// ObjectMeta
	deployment.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Deployment_Spec
	err := spec.AssignProperties_From_Deployment_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Deployment_Spec() to populate field Spec")
	}
	deployment.Spec = spec

	// Status
	var status Deployment_STATUS
	err = status.AssignProperties_From_Deployment_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Deployment_STATUS() to populate field Status")
	}
	deployment.Status = status

	// No error
	return nil
}

// AssignProperties_To_Deployment populates the provided destination Deployment from our Deployment
func (deployment *Deployment) AssignProperties_To_Deployment(destination *storage.Deployment) error {

	// ObjectMeta
	destination.ObjectMeta = *deployment.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Deployment_Spec
	err := deployment.Spec.AssignProperties_To_Deployment_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Deployment_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Deployment_STATUS
	err = deployment.Status.AssignProperties_To_Deployment_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Deployment_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (deployment *Deployment) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: deployment.Spec.OriginalVersion(),
		Kind:    "Deployment",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /cognitiveservices/resource-manager/Microsoft.CognitiveServices/stable/2025-06-01/cognitiveservices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CognitiveServices/accounts/{accountName}/deployments/{deploymentName}
type DeploymentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Deployment `json:"items"`
}

type Deployment_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *DeploymentOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cognitiveservices.azure.com/Account resource
	Owner *genruntime.KnownResourceReference `group:"cognitiveservices.azure.com" json:"owner,omitempty" kind:"Account"`

	// Properties: Properties of Cognitive Services account deployment.
	Properties *DeploymentProperties `json:"properties,omitempty"`

	// Sku: The resource model definition representing SKU
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Deployment_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (deployment *Deployment_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if deployment == nil {
		return nil, nil
	}
	result := &arm.Deployment_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if deployment.Properties != nil {
		properties_ARM, err := (*deployment.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.DeploymentProperties)
		result.Properties = &properties
	}

	// Set property "Sku":
	if deployment.Sku != nil {
		sku_ARM, err := (*deployment.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if deployment.Tags != nil {
		result.Tags = make(map[string]string, len(deployment.Tags))
		for key, value := range deployment.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (deployment *Deployment_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Deployment_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (deployment *Deployment_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Deployment_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Deployment_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	deployment.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	deployment.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DeploymentProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		deployment.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		deployment.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		deployment.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			deployment.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Deployment_Spec{}

// ConvertSpecFrom populates our Deployment_Spec from the provided source
func (deployment *Deployment_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Deployment_Spec)
	if ok {
		// Populate our instance from source
		return deployment.AssignProperties_From_Deployment_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Deployment_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = deployment.AssignProperties_From_Deployment_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Deployment_Spec
func (deployment *Deployment_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Deployment_Spec)
	if ok {
		// Populate destination from our instance
		return deployment.AssignProperties_To_Deployment_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Deployment_Spec{}
	err := deployment.AssignProperties_To_Deployment_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Deployment_Spec populates our Deployment_Spec from the provided source Deployment_Spec
func (deployment *Deployment_Spec) AssignProperties_From_Deployment_Spec(source *storage.Deployment_Spec) error {

	// AzureName
	deployment.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec DeploymentOperatorSpec
		err := operatorSpec.AssignProperties_From_DeploymentOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentOperatorSpec() to populate field OperatorSpec")
		}
		deployment.OperatorSpec = &operatorSpec
	} else {
		deployment.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		deployment.Owner = &owner
	} else {
		deployment.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property DeploymentProperties
		err := property.AssignProperties_From_DeploymentProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentProperties() to populate field Properties")
		}
		deployment.Properties = &property
	} else {
		deployment.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		deployment.Sku = &sku
	} else {
		deployment.Sku = nil
	}

	// Tags
	deployment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Deployment_Spec populates the provided destination Deployment_Spec from our Deployment_Spec
func (deployment *Deployment_Spec) AssignProperties_To_Deployment_Spec(destination *storage.Deployment_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = deployment.AzureName

	// OperatorSpec
	if deployment.OperatorSpec != nil {
		var operatorSpec storage.DeploymentOperatorSpec
		err := deployment.OperatorSpec.AssignProperties_To_DeploymentOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = deployment.OriginalVersion()

	// Owner
	if deployment.Owner != nil {
		owner := deployment.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if deployment.Properties != nil {
		var property storage.DeploymentProperties
		err := deployment.Properties.AssignProperties_To_DeploymentProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if deployment.Sku != nil {
		var sku storage.Sku
		err := deployment.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(deployment.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Deployment_STATUS populates our Deployment_Spec from the provided source Deployment_STATUS
func (deployment *Deployment_Spec) Initialize_From_Deployment_STATUS(source *Deployment_STATUS) error {

	// Properties
	if source.Properties != nil {
		var property DeploymentProperties
		err := property.Initialize_From_DeploymentProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DeploymentProperties_STATUS() to populate field Properties")
		}
		deployment.Properties = &property
	} else {
		deployment.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		deployment.Sku = &sku
	} else {
		deployment.Sku = nil
	}

	// Tags
	deployment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (deployment *Deployment_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (deployment *Deployment_Spec) SetAzureName(azureName string) { deployment.AzureName = azureName }

type Deployment_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Etag: Resource Etag.
	Etag *string `json:"etag,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Properties of Cognitive Services account deployment.
	Properties *DeploymentProperties_STATUS `json:"properties,omitempty"`

	// Sku: The resource model definition representing SKU
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Deployment_STATUS{}

// ConvertStatusFrom populates our Deployment_STATUS from the provided source
func (deployment *Deployment_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Deployment_STATUS)
	if ok {
		// Populate our instance from source
		return deployment.AssignProperties_From_Deployment_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Deployment_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = deployment.AssignProperties_From_Deployment_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Deployment_STATUS
func (deployment *Deployment_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Deployment_STATUS)
	if ok {
		// Populate destination from our instance
		return deployment.AssignProperties_To_Deployment_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Deployment_STATUS{}
	err := deployment.AssignProperties_To_Deployment_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Deployment_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (deployment *Deployment_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Deployment_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (deployment *Deployment_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Deployment_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Deployment_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		deployment.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		deployment.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		deployment.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DeploymentProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		deployment.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		deployment.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		deployment.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		deployment.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			deployment.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		deployment.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Deployment_STATUS populates our Deployment_STATUS from the provided source Deployment_STATUS
func (deployment *Deployment_STATUS) AssignProperties_From_Deployment_STATUS(source *storage.Deployment_STATUS) error {

	// Conditions
	deployment.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	deployment.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	deployment.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	deployment.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property DeploymentProperties_STATUS
		err := property.AssignProperties_From_DeploymentProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentProperties_STATUS() to populate field Properties")
		}
		deployment.Properties = &property
	} else {
		deployment.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		deployment.Sku = &sku
	} else {
		deployment.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		deployment.SystemData = &systemDatum
	} else {
		deployment.SystemData = nil
	}

	// Tags
	deployment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	deployment.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Deployment_STATUS populates the provided destination Deployment_STATUS from our Deployment_STATUS
func (deployment *Deployment_STATUS) AssignProperties_To_Deployment_STATUS(destination *storage.Deployment_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(deployment.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(deployment.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(deployment.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(deployment.Name)

	// Properties
	if deployment.Properties != nil {
		var property storage.DeploymentProperties_STATUS
		err := deployment.Properties.AssignProperties_To_DeploymentProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if deployment.Sku != nil {
		var sku storage.Sku_STATUS
		err := deployment.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if deployment.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := deployment.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(deployment.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(deployment.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type DeploymentOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_DeploymentOperatorSpec populates our DeploymentOperatorSpec from the provided source DeploymentOperatorSpec
func (operator *DeploymentOperatorSpec) AssignProperties_From_DeploymentOperatorSpec(source *storage.DeploymentOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentOperatorSpec populates the provided destination DeploymentOperatorSpec from our DeploymentOperatorSpec
func (operator *DeploymentOperatorSpec) AssignProperties_To_DeploymentOperatorSpec(destination *storage.DeploymentOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account deployment.
type DeploymentProperties struct {
	// CapacitySettings: Internal use only.
	CapacitySettings *DeploymentCapacitySettings `json:"capacitySettings,omitempty"`

	// Model: Properties of Cognitive Services account deployment model.
	Model *DeploymentModel `json:"model,omitempty"`

	// ParentDeploymentName: The name of parent deployment.
	ParentDeploymentName *string `json:"parentDeploymentName,omitempty"`

	// RaiPolicyName: The name of RAI policy.
	RaiPolicyName *string `json:"raiPolicyName,omitempty"`

	// ScaleSettings: Properties of Cognitive Services account deployment model. (Deprecated, please use Deployment.sku
	// instead.)
	ScaleSettings *DeploymentScaleSettings `json:"scaleSettings,omitempty"`

	// SpilloverDeploymentName: Specifies the deployment name that should serve requests when the request would have otherwise
	// been throttled due to reaching current deployment throughput limit.
	SpilloverDeploymentName *string `json:"spilloverDeploymentName,omitempty"`

	// VersionUpgradeOption: Deployment model version upgrade option.
	VersionUpgradeOption *DeploymentProperties_VersionUpgradeOption `json:"versionUpgradeOption,omitempty"`
}

var _ genruntime.ARMTransformer = &DeploymentProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DeploymentProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DeploymentProperties{}

	// Set property "CapacitySettings":
	if properties.CapacitySettings != nil {
		capacitySettings_ARM, err := (*properties.CapacitySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		capacitySettings := *capacitySettings_ARM.(*arm.DeploymentCapacitySettings)
		result.CapacitySettings = &capacitySettings
	}

	// Set property "Model":
	if properties.Model != nil {
		model_ARM, err := (*properties.Model).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		model := *model_ARM.(*arm.DeploymentModel)
		result.Model = &model
	}

	// Set property "ParentDeploymentName":
	if properties.ParentDeploymentName != nil {
		parentDeploymentName := *properties.ParentDeploymentName
		result.ParentDeploymentName = &parentDeploymentName
	}

	// Set property "RaiPolicyName":
	if properties.RaiPolicyName != nil {
		raiPolicyName := *properties.RaiPolicyName
		result.RaiPolicyName = &raiPolicyName
	}

	// Set property "ScaleSettings":
	if properties.ScaleSettings != nil {
		scaleSettings_ARM, err := (*properties.ScaleSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleSettings := *scaleSettings_ARM.(*arm.DeploymentScaleSettings)
		result.ScaleSettings = &scaleSettings
	}

	// Set property "SpilloverDeploymentName":
	if properties.SpilloverDeploymentName != nil {
		spilloverDeploymentName := *properties.SpilloverDeploymentName
		result.SpilloverDeploymentName = &spilloverDeploymentName
	}

	// Set property "VersionUpgradeOption":
	if properties.VersionUpgradeOption != nil {
		var temp string
		temp = string(*properties.VersionUpgradeOption)
		versionUpgradeOption := arm.DeploymentProperties_VersionUpgradeOption(temp)
		result.VersionUpgradeOption = &versionUpgradeOption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DeploymentProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DeploymentProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentProperties, got %T", armInput)
	}

	// Set property "CapacitySettings":
	if typedInput.CapacitySettings != nil {
		var capacitySettings1 DeploymentCapacitySettings
		err := capacitySettings1.PopulateFromARM(owner, *typedInput.CapacitySettings)
		if err != nil {
			return err
		}
		capacitySettings := capacitySettings1
		properties.CapacitySettings = &capacitySettings
	}

	// Set property "Model":
	if typedInput.Model != nil {
		var model1 DeploymentModel
		err := model1.PopulateFromARM(owner, *typedInput.Model)
		if err != nil {
			return err
		}
		model := model1
		properties.Model = &model
	}

	// Set property "ParentDeploymentName":
	if typedInput.ParentDeploymentName != nil {
		parentDeploymentName := *typedInput.ParentDeploymentName
		properties.ParentDeploymentName = &parentDeploymentName
	}

	// Set property "RaiPolicyName":
	if typedInput.RaiPolicyName != nil {
		raiPolicyName := *typedInput.RaiPolicyName
		properties.RaiPolicyName = &raiPolicyName
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 DeploymentScaleSettings
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "SpilloverDeploymentName":
	if typedInput.SpilloverDeploymentName != nil {
		spilloverDeploymentName := *typedInput.SpilloverDeploymentName
		properties.SpilloverDeploymentName = &spilloverDeploymentName
	}

	// Set property "VersionUpgradeOption":
	if typedInput.VersionUpgradeOption != nil {
		var temp string
		temp = string(*typedInput.VersionUpgradeOption)
		versionUpgradeOption := DeploymentProperties_VersionUpgradeOption(temp)
		properties.VersionUpgradeOption = &versionUpgradeOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentProperties populates our DeploymentProperties from the provided source DeploymentProperties
func (properties *DeploymentProperties) AssignProperties_From_DeploymentProperties(source *storage.DeploymentProperties) error {

	// CapacitySettings
	if source.CapacitySettings != nil {
		var capacitySetting DeploymentCapacitySettings
		err := capacitySetting.AssignProperties_From_DeploymentCapacitySettings(source.CapacitySettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentCapacitySettings() to populate field CapacitySettings")
		}
		properties.CapacitySettings = &capacitySetting
	} else {
		properties.CapacitySettings = nil
	}

	// Model
	if source.Model != nil {
		var model DeploymentModel
		err := model.AssignProperties_From_DeploymentModel(source.Model)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentModel() to populate field Model")
		}
		properties.Model = &model
	} else {
		properties.Model = nil
	}

	// ParentDeploymentName
	properties.ParentDeploymentName = genruntime.ClonePointerToString(source.ParentDeploymentName)

	// RaiPolicyName
	properties.RaiPolicyName = genruntime.ClonePointerToString(source.RaiPolicyName)

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting DeploymentScaleSettings
		err := scaleSetting.AssignProperties_From_DeploymentScaleSettings(source.ScaleSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentScaleSettings() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// SpilloverDeploymentName
	properties.SpilloverDeploymentName = genruntime.ClonePointerToString(source.SpilloverDeploymentName)

	// VersionUpgradeOption
	if source.VersionUpgradeOption != nil {
		versionUpgradeOption := *source.VersionUpgradeOption
		versionUpgradeOptionTemp := genruntime.ToEnum(versionUpgradeOption, deploymentProperties_VersionUpgradeOption_Values)
		properties.VersionUpgradeOption = &versionUpgradeOptionTemp
	} else {
		properties.VersionUpgradeOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentProperties populates the provided destination DeploymentProperties from our DeploymentProperties
func (properties *DeploymentProperties) AssignProperties_To_DeploymentProperties(destination *storage.DeploymentProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CapacitySettings
	if properties.CapacitySettings != nil {
		var capacitySetting storage.DeploymentCapacitySettings
		err := properties.CapacitySettings.AssignProperties_To_DeploymentCapacitySettings(&capacitySetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentCapacitySettings() to populate field CapacitySettings")
		}
		destination.CapacitySettings = &capacitySetting
	} else {
		destination.CapacitySettings = nil
	}

	// Model
	if properties.Model != nil {
		var model storage.DeploymentModel
		err := properties.Model.AssignProperties_To_DeploymentModel(&model)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentModel() to populate field Model")
		}
		destination.Model = &model
	} else {
		destination.Model = nil
	}

	// ParentDeploymentName
	destination.ParentDeploymentName = genruntime.ClonePointerToString(properties.ParentDeploymentName)

	// RaiPolicyName
	destination.RaiPolicyName = genruntime.ClonePointerToString(properties.RaiPolicyName)

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.DeploymentScaleSettings
		err := properties.ScaleSettings.AssignProperties_To_DeploymentScaleSettings(&scaleSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentScaleSettings() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// SpilloverDeploymentName
	destination.SpilloverDeploymentName = genruntime.ClonePointerToString(properties.SpilloverDeploymentName)

	// VersionUpgradeOption
	if properties.VersionUpgradeOption != nil {
		versionUpgradeOption := string(*properties.VersionUpgradeOption)
		destination.VersionUpgradeOption = &versionUpgradeOption
	} else {
		destination.VersionUpgradeOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeploymentProperties_STATUS populates our DeploymentProperties from the provided source DeploymentProperties_STATUS
func (properties *DeploymentProperties) Initialize_From_DeploymentProperties_STATUS(source *DeploymentProperties_STATUS) error {

	// CapacitySettings
	if source.CapacitySettings != nil {
		var capacitySetting DeploymentCapacitySettings
		err := capacitySetting.Initialize_From_DeploymentCapacitySettings_STATUS(source.CapacitySettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DeploymentCapacitySettings_STATUS() to populate field CapacitySettings")
		}
		properties.CapacitySettings = &capacitySetting
	} else {
		properties.CapacitySettings = nil
	}

	// Model
	if source.Model != nil {
		var model DeploymentModel
		err := model.Initialize_From_DeploymentModel_STATUS(source.Model)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DeploymentModel_STATUS() to populate field Model")
		}
		properties.Model = &model
	} else {
		properties.Model = nil
	}

	// ParentDeploymentName
	properties.ParentDeploymentName = genruntime.ClonePointerToString(source.ParentDeploymentName)

	// RaiPolicyName
	properties.RaiPolicyName = genruntime.ClonePointerToString(source.RaiPolicyName)

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting DeploymentScaleSettings
		err := scaleSetting.Initialize_From_DeploymentScaleSettings_STATUS(source.ScaleSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DeploymentScaleSettings_STATUS() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// SpilloverDeploymentName
	properties.SpilloverDeploymentName = genruntime.ClonePointerToString(source.SpilloverDeploymentName)

	// VersionUpgradeOption
	if source.VersionUpgradeOption != nil {
		versionUpgradeOption := genruntime.ToEnum(string(*source.VersionUpgradeOption), deploymentProperties_VersionUpgradeOption_Values)
		properties.VersionUpgradeOption = &versionUpgradeOption
	} else {
		properties.VersionUpgradeOption = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account deployment.
type DeploymentProperties_STATUS struct {
	// CallRateLimit: The call rate limit Cognitive Services account.
	CallRateLimit *CallRateLimit_STATUS `json:"callRateLimit,omitempty"`

	// Capabilities: The capabilities.
	Capabilities map[string]string `json:"capabilities,omitempty"`

	// CapacitySettings: Internal use only.
	CapacitySettings *DeploymentCapacitySettings_STATUS `json:"capacitySettings,omitempty"`

	// CurrentCapacity: The current capacity.
	CurrentCapacity *int `json:"currentCapacity,omitempty"`

	// DynamicThrottlingEnabled: If the dynamic throttling is enabled.
	DynamicThrottlingEnabled *bool `json:"dynamicThrottlingEnabled,omitempty"`

	// Model: Properties of Cognitive Services account deployment model.
	Model *DeploymentModel_STATUS `json:"model,omitempty"`

	// ParentDeploymentName: The name of parent deployment.
	ParentDeploymentName *string `json:"parentDeploymentName,omitempty"`

	// ProvisioningState: Gets the status of the resource at the time the operation was called.
	ProvisioningState *DeploymentProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RaiPolicyName: The name of RAI policy.
	RaiPolicyName *string                 `json:"raiPolicyName,omitempty"`
	RateLimits    []ThrottlingRule_STATUS `json:"rateLimits,omitempty"`

	// ScaleSettings: Properties of Cognitive Services account deployment model. (Deprecated, please use Deployment.sku
	// instead.)
	ScaleSettings *DeploymentScaleSettings_STATUS `json:"scaleSettings,omitempty"`

	// SpilloverDeploymentName: Specifies the deployment name that should serve requests when the request would have otherwise
	// been throttled due to reaching current deployment throughput limit.
	SpilloverDeploymentName *string `json:"spilloverDeploymentName,omitempty"`

	// VersionUpgradeOption: Deployment model version upgrade option.
	VersionUpgradeOption *DeploymentProperties_VersionUpgradeOption_STATUS `json:"versionUpgradeOption,omitempty"`
}

var _ genruntime.FromARMConverter = &DeploymentProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DeploymentProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DeploymentProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentProperties_STATUS, got %T", armInput)
	}

	// Set property "CallRateLimit":
	if typedInput.CallRateLimit != nil {
		var callRateLimit1 CallRateLimit_STATUS
		err := callRateLimit1.PopulateFromARM(owner, *typedInput.CallRateLimit)
		if err != nil {
			return err
		}
		callRateLimit := callRateLimit1
		properties.CallRateLimit = &callRateLimit
	}

	// Set property "Capabilities":
	if typedInput.Capabilities != nil {
		properties.Capabilities = make(map[string]string, len(typedInput.Capabilities))
		for key, value := range typedInput.Capabilities {
			properties.Capabilities[key] = value
		}
	}

	// Set property "CapacitySettings":
	if typedInput.CapacitySettings != nil {
		var capacitySettings1 DeploymentCapacitySettings_STATUS
		err := capacitySettings1.PopulateFromARM(owner, *typedInput.CapacitySettings)
		if err != nil {
			return err
		}
		capacitySettings := capacitySettings1
		properties.CapacitySettings = &capacitySettings
	}

	// Set property "CurrentCapacity":
	if typedInput.CurrentCapacity != nil {
		currentCapacity := *typedInput.CurrentCapacity
		properties.CurrentCapacity = &currentCapacity
	}

	// Set property "DynamicThrottlingEnabled":
	if typedInput.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *typedInput.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	}

	// Set property "Model":
	if typedInput.Model != nil {
		var model1 DeploymentModel_STATUS
		err := model1.PopulateFromARM(owner, *typedInput.Model)
		if err != nil {
			return err
		}
		model := model1
		properties.Model = &model
	}

	// Set property "ParentDeploymentName":
	if typedInput.ParentDeploymentName != nil {
		parentDeploymentName := *typedInput.ParentDeploymentName
		properties.ParentDeploymentName = &parentDeploymentName
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := DeploymentProperties_ProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// Set property "RaiPolicyName":
	if typedInput.RaiPolicyName != nil {
		raiPolicyName := *typedInput.RaiPolicyName
		properties.RaiPolicyName = &raiPolicyName
	}

	// Set property "RateLimits":
	for _, item := range typedInput.RateLimits {
		var item1 ThrottlingRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.RateLimits = append(properties.RateLimits, item1)
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 DeploymentScaleSettings_STATUS
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "SpilloverDeploymentName":
	if typedInput.SpilloverDeploymentName != nil {
		spilloverDeploymentName := *typedInput.SpilloverDeploymentName
		properties.SpilloverDeploymentName = &spilloverDeploymentName
	}

	// Set property "VersionUpgradeOption":
	if typedInput.VersionUpgradeOption != nil {
		var temp string
		temp = string(*typedInput.VersionUpgradeOption)
		versionUpgradeOption := DeploymentProperties_VersionUpgradeOption_STATUS(temp)
		properties.VersionUpgradeOption = &versionUpgradeOption
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentProperties_STATUS populates our DeploymentProperties_STATUS from the provided source DeploymentProperties_STATUS
func (properties *DeploymentProperties_STATUS) AssignProperties_From_DeploymentProperties_STATUS(source *storage.DeploymentProperties_STATUS) error {

	// CallRateLimit
	if source.CallRateLimit != nil {
		var callRateLimit CallRateLimit_STATUS
		err := callRateLimit.AssignProperties_From_CallRateLimit_STATUS(source.CallRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		properties.CallRateLimit = &callRateLimit
	} else {
		properties.CallRateLimit = nil
	}

	// Capabilities
	properties.Capabilities = genruntime.CloneMapOfStringToString(source.Capabilities)

	// CapacitySettings
	if source.CapacitySettings != nil {
		var capacitySetting DeploymentCapacitySettings_STATUS
		err := capacitySetting.AssignProperties_From_DeploymentCapacitySettings_STATUS(source.CapacitySettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentCapacitySettings_STATUS() to populate field CapacitySettings")
		}
		properties.CapacitySettings = &capacitySetting
	} else {
		properties.CapacitySettings = nil
	}

	// CurrentCapacity
	properties.CurrentCapacity = genruntime.ClonePointerToInt(source.CurrentCapacity)

	// DynamicThrottlingEnabled
	if source.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *source.DynamicThrottlingEnabled
		properties.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		properties.DynamicThrottlingEnabled = nil
	}

	// Model
	if source.Model != nil {
		var model DeploymentModel_STATUS
		err := model.AssignProperties_From_DeploymentModel_STATUS(source.Model)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentModel_STATUS() to populate field Model")
		}
		properties.Model = &model
	} else {
		properties.Model = nil
	}

	// ParentDeploymentName
	properties.ParentDeploymentName = genruntime.ClonePointerToString(source.ParentDeploymentName)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, deploymentProperties_ProvisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// RaiPolicyName
	properties.RaiPolicyName = genruntime.ClonePointerToString(source.RaiPolicyName)

	// RateLimits
	if source.RateLimits != nil {
		rateLimitList := make([]ThrottlingRule_STATUS, len(source.RateLimits))
		for rateLimitIndex, rateLimitItem := range source.RateLimits {
			// Shadow the loop variable to avoid aliasing
			rateLimitItem := rateLimitItem
			var rateLimit ThrottlingRule_STATUS
			err := rateLimit.AssignProperties_From_ThrottlingRule_STATUS(&rateLimitItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ThrottlingRule_STATUS() to populate field RateLimits")
			}
			rateLimitList[rateLimitIndex] = rateLimit
		}
		properties.RateLimits = rateLimitList
	} else {
		properties.RateLimits = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting DeploymentScaleSettings_STATUS
		err := scaleSetting.AssignProperties_From_DeploymentScaleSettings_STATUS(source.ScaleSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DeploymentScaleSettings_STATUS() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// SpilloverDeploymentName
	properties.SpilloverDeploymentName = genruntime.ClonePointerToString(source.SpilloverDeploymentName)

	// VersionUpgradeOption
	if source.VersionUpgradeOption != nil {
		versionUpgradeOption := *source.VersionUpgradeOption
		versionUpgradeOptionTemp := genruntime.ToEnum(versionUpgradeOption, deploymentProperties_VersionUpgradeOption_STATUS_Values)
		properties.VersionUpgradeOption = &versionUpgradeOptionTemp
	} else {
		properties.VersionUpgradeOption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentProperties_STATUS populates the provided destination DeploymentProperties_STATUS from our DeploymentProperties_STATUS
func (properties *DeploymentProperties_STATUS) AssignProperties_To_DeploymentProperties_STATUS(destination *storage.DeploymentProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CallRateLimit
	if properties.CallRateLimit != nil {
		var callRateLimit storage.CallRateLimit_STATUS
		err := properties.CallRateLimit.AssignProperties_To_CallRateLimit_STATUS(&callRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		destination.CallRateLimit = &callRateLimit
	} else {
		destination.CallRateLimit = nil
	}

	// Capabilities
	destination.Capabilities = genruntime.CloneMapOfStringToString(properties.Capabilities)

	// CapacitySettings
	if properties.CapacitySettings != nil {
		var capacitySetting storage.DeploymentCapacitySettings_STATUS
		err := properties.CapacitySettings.AssignProperties_To_DeploymentCapacitySettings_STATUS(&capacitySetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentCapacitySettings_STATUS() to populate field CapacitySettings")
		}
		destination.CapacitySettings = &capacitySetting
	} else {
		destination.CapacitySettings = nil
	}

	// CurrentCapacity
	destination.CurrentCapacity = genruntime.ClonePointerToInt(properties.CurrentCapacity)

	// DynamicThrottlingEnabled
	if properties.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *properties.DynamicThrottlingEnabled
		destination.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		destination.DynamicThrottlingEnabled = nil
	}

	// Model
	if properties.Model != nil {
		var model storage.DeploymentModel_STATUS
		err := properties.Model.AssignProperties_To_DeploymentModel_STATUS(&model)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentModel_STATUS() to populate field Model")
		}
		destination.Model = &model
	} else {
		destination.Model = nil
	}

	// ParentDeploymentName
	destination.ParentDeploymentName = genruntime.ClonePointerToString(properties.ParentDeploymentName)

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RaiPolicyName
	destination.RaiPolicyName = genruntime.ClonePointerToString(properties.RaiPolicyName)

	// RateLimits
	if properties.RateLimits != nil {
		rateLimitList := make([]storage.ThrottlingRule_STATUS, len(properties.RateLimits))
		for rateLimitIndex, rateLimitItem := range properties.RateLimits {
			// Shadow the loop variable to avoid aliasing
			rateLimitItem := rateLimitItem
			var rateLimit storage.ThrottlingRule_STATUS
			err := rateLimitItem.AssignProperties_To_ThrottlingRule_STATUS(&rateLimit)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ThrottlingRule_STATUS() to populate field RateLimits")
			}
			rateLimitList[rateLimitIndex] = rateLimit
		}
		destination.RateLimits = rateLimitList
	} else {
		destination.RateLimits = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.DeploymentScaleSettings_STATUS
		err := properties.ScaleSettings.AssignProperties_To_DeploymentScaleSettings_STATUS(&scaleSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DeploymentScaleSettings_STATUS() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// SpilloverDeploymentName
	destination.SpilloverDeploymentName = genruntime.ClonePointerToString(properties.SpilloverDeploymentName)

	// VersionUpgradeOption
	if properties.VersionUpgradeOption != nil {
		versionUpgradeOption := string(*properties.VersionUpgradeOption)
		destination.VersionUpgradeOption = &versionUpgradeOption
	} else {
		destination.VersionUpgradeOption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Internal use only.
type DeploymentCapacitySettings struct {
	// +kubebuilder:validation:Minimum=0
	// DesignatedCapacity: The designated capacity.
	DesignatedCapacity *int `json:"designatedCapacity,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// Priority: The priority of this capacity setting.
	Priority *int `json:"priority,omitempty"`
}

var _ genruntime.ARMTransformer = &DeploymentCapacitySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DeploymentCapacitySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.DeploymentCapacitySettings{}

	// Set property "DesignatedCapacity":
	if settings.DesignatedCapacity != nil {
		designatedCapacity := *settings.DesignatedCapacity
		result.DesignatedCapacity = &designatedCapacity
	}

	// Set property "Priority":
	if settings.Priority != nil {
		priority := *settings.Priority
		result.Priority = &priority
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DeploymentCapacitySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentCapacitySettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DeploymentCapacitySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentCapacitySettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentCapacitySettings, got %T", armInput)
	}

	// Set property "DesignatedCapacity":
	if typedInput.DesignatedCapacity != nil {
		designatedCapacity := *typedInput.DesignatedCapacity
		settings.DesignatedCapacity = &designatedCapacity
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		settings.Priority = &priority
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentCapacitySettings populates our DeploymentCapacitySettings from the provided source DeploymentCapacitySettings
func (settings *DeploymentCapacitySettings) AssignProperties_From_DeploymentCapacitySettings(source *storage.DeploymentCapacitySettings) error {

	// DesignatedCapacity
	settings.DesignatedCapacity = genruntime.ClonePointerToInt(source.DesignatedCapacity)

	// Priority
	settings.Priority = genruntime.ClonePointerToInt(source.Priority)

	// No error
	return nil
}

// AssignProperties_To_DeploymentCapacitySettings populates the provided destination DeploymentCapacitySettings from our DeploymentCapacitySettings
func (settings *DeploymentCapacitySettings) AssignProperties_To_DeploymentCapacitySettings(destination *storage.DeploymentCapacitySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DesignatedCapacity
	destination.DesignatedCapacity = genruntime.ClonePointerToInt(settings.DesignatedCapacity)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(settings.Priority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeploymentCapacitySettings_STATUS populates our DeploymentCapacitySettings from the provided source DeploymentCapacitySettings_STATUS
func (settings *DeploymentCapacitySettings) Initialize_From_DeploymentCapacitySettings_STATUS(source *DeploymentCapacitySettings_STATUS) error {

	// DesignatedCapacity
	settings.DesignatedCapacity = genruntime.ClonePointerToInt(source.DesignatedCapacity)

	// Priority
	settings.Priority = genruntime.ClonePointerToInt(source.Priority)

	// No error
	return nil
}

// Internal use only.
type DeploymentCapacitySettings_STATUS struct {
	// DesignatedCapacity: The designated capacity.
	DesignatedCapacity *int `json:"designatedCapacity,omitempty"`

	// Priority: The priority of this capacity setting.
	Priority *int `json:"priority,omitempty"`
}

var _ genruntime.FromARMConverter = &DeploymentCapacitySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DeploymentCapacitySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentCapacitySettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DeploymentCapacitySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentCapacitySettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentCapacitySettings_STATUS, got %T", armInput)
	}

	// Set property "DesignatedCapacity":
	if typedInput.DesignatedCapacity != nil {
		designatedCapacity := *typedInput.DesignatedCapacity
		settings.DesignatedCapacity = &designatedCapacity
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		settings.Priority = &priority
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentCapacitySettings_STATUS populates our DeploymentCapacitySettings_STATUS from the provided source DeploymentCapacitySettings_STATUS
func (settings *DeploymentCapacitySettings_STATUS) AssignProperties_From_DeploymentCapacitySettings_STATUS(source *storage.DeploymentCapacitySettings_STATUS) error {

	// DesignatedCapacity
	settings.DesignatedCapacity = genruntime.ClonePointerToInt(source.DesignatedCapacity)

	// Priority
	settings.Priority = genruntime.ClonePointerToInt(source.Priority)

	// No error
	return nil
}

// AssignProperties_To_DeploymentCapacitySettings_STATUS populates the provided destination DeploymentCapacitySettings_STATUS from our DeploymentCapacitySettings_STATUS
func (settings *DeploymentCapacitySettings_STATUS) AssignProperties_To_DeploymentCapacitySettings_STATUS(destination *storage.DeploymentCapacitySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DesignatedCapacity
	destination.DesignatedCapacity = genruntime.ClonePointerToInt(settings.DesignatedCapacity)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(settings.Priority)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account deployment model.
type DeploymentModel struct {
	// Format: Deployment model format.
	Format *string `json:"format,omitempty" optionalConfigMapPair:"Format"`

	// FormatFromConfig: Deployment model format.
	FormatFromConfig *genruntime.ConfigMapReference `json:"formatFromConfig,omitempty" optionalConfigMapPair:"Format"`

	// Name: Deployment model name.
	Name *string `json:"name,omitempty" optionalConfigMapPair:"Name"`

	// NameFromConfig: Deployment model name.
	NameFromConfig *genruntime.ConfigMapReference `json:"nameFromConfig,omitempty" optionalConfigMapPair:"Name"`

	// Publisher: Deployment model publisher.
	Publisher *string `json:"publisher,omitempty" optionalConfigMapPair:"Publisher"`

	// PublisherFromConfig: Deployment model publisher.
	PublisherFromConfig *genruntime.ConfigMapReference `json:"publisherFromConfig,omitempty" optionalConfigMapPair:"Publisher"`

	// SourceAccountReference: Optional. Source of the model, another Microsoft.CognitiveServices accounts ARM resource ID.
	SourceAccountReference *genruntime.ResourceReference `armReference:"SourceAccount" json:"sourceAccountReference,omitempty"`

	// SourceReference: Optional. Deployment model source ARM resource ID.
	SourceReference *genruntime.ResourceReference `armReference:"Source" json:"sourceReference,omitempty"`

	// Version: Optional. Deployment model version. If version is not specified, a default version will be assigned. The
	// default version is different for different models and might change when there is new version available for a model.
	// Default version for a model could be found from list models API.
	Version *string `json:"version,omitempty" optionalConfigMapPair:"Version"`

	// VersionFromConfig: Optional. Deployment model version. If version is not specified, a default version will be assigned.
	// The default version is different for different models and might change when there is new version available for a model.
	// Default version for a model could be found from list models API.
	VersionFromConfig *genruntime.ConfigMapReference `json:"versionFromConfig,omitempty" optionalConfigMapPair:"Version"`
}

var _ genruntime.ARMTransformer = &DeploymentModel{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (model *DeploymentModel) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if model == nil {
		return nil, nil
	}
	result := &arm.DeploymentModel{}

	// Set property "Format":
	if model.Format != nil {
		format := *model.Format
		result.Format = &format
	}
	if model.FormatFromConfig != nil {
		formatValue, err := resolved.ResolvedConfigMaps.Lookup(*model.FormatFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property Format")
		}
		format := formatValue
		result.Format = &format
	}

	// Set property "Name":
	if model.Name != nil {
		name := *model.Name
		result.Name = &name
	}
	if model.NameFromConfig != nil {
		nameValue, err := resolved.ResolvedConfigMaps.Lookup(*model.NameFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property Name")
		}
		name := nameValue
		result.Name = &name
	}

	// Set property "Publisher":
	if model.Publisher != nil {
		publisher := *model.Publisher
		result.Publisher = &publisher
	}
	if model.PublisherFromConfig != nil {
		publisherValue, err := resolved.ResolvedConfigMaps.Lookup(*model.PublisherFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property Publisher")
		}
		publisher := publisherValue
		result.Publisher = &publisher
	}

	// Set property "Source":
	if model.SourceReference != nil {
		sourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*model.SourceReference)
		if err != nil {
			return nil, err
		}
		sourceReference := sourceReferenceARMID
		result.Source = &sourceReference
	}

	// Set property "SourceAccount":
	if model.SourceAccountReference != nil {
		sourceAccountReferenceARMID, err := resolved.ResolvedReferences.Lookup(*model.SourceAccountReference)
		if err != nil {
			return nil, err
		}
		sourceAccountReference := sourceAccountReferenceARMID
		result.SourceAccount = &sourceAccountReference
	}

	// Set property "Version":
	if model.Version != nil {
		version := *model.Version
		result.Version = &version
	}
	if model.VersionFromConfig != nil {
		versionValue, err := resolved.ResolvedConfigMaps.Lookup(*model.VersionFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property Version")
		}
		version := versionValue
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *DeploymentModel) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentModel{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *DeploymentModel) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentModel)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentModel, got %T", armInput)
	}

	// Set property "Format":
	if typedInput.Format != nil {
		format := *typedInput.Format
		model.Format = &format
	}

	// no assignment for property "FormatFromConfig"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		model.Name = &name
	}

	// no assignment for property "NameFromConfig"

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		model.Publisher = &publisher
	}

	// no assignment for property "PublisherFromConfig"

	// no assignment for property "SourceAccountReference"

	// no assignment for property "SourceReference"

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		model.Version = &version
	}

	// no assignment for property "VersionFromConfig"

	// No error
	return nil
}

// AssignProperties_From_DeploymentModel populates our DeploymentModel from the provided source DeploymentModel
func (model *DeploymentModel) AssignProperties_From_DeploymentModel(source *storage.DeploymentModel) error {

	// Format
	model.Format = genruntime.ClonePointerToString(source.Format)

	// FormatFromConfig
	if source.FormatFromConfig != nil {
		formatFromConfig := source.FormatFromConfig.Copy()
		model.FormatFromConfig = &formatFromConfig
	} else {
		model.FormatFromConfig = nil
	}

	// Name
	model.Name = genruntime.ClonePointerToString(source.Name)

	// NameFromConfig
	if source.NameFromConfig != nil {
		nameFromConfig := source.NameFromConfig.Copy()
		model.NameFromConfig = &nameFromConfig
	} else {
		model.NameFromConfig = nil
	}

	// Publisher
	model.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// PublisherFromConfig
	if source.PublisherFromConfig != nil {
		publisherFromConfig := source.PublisherFromConfig.Copy()
		model.PublisherFromConfig = &publisherFromConfig
	} else {
		model.PublisherFromConfig = nil
	}

	// SourceAccountReference
	if source.SourceAccountReference != nil {
		sourceAccountReference := source.SourceAccountReference.Copy()
		model.SourceAccountReference = &sourceAccountReference
	} else {
		model.SourceAccountReference = nil
	}

	// SourceReference
	if source.SourceReference != nil {
		sourceReference := source.SourceReference.Copy()
		model.SourceReference = &sourceReference
	} else {
		model.SourceReference = nil
	}

	// Version
	model.Version = genruntime.ClonePointerToString(source.Version)

	// VersionFromConfig
	if source.VersionFromConfig != nil {
		versionFromConfig := source.VersionFromConfig.Copy()
		model.VersionFromConfig = &versionFromConfig
	} else {
		model.VersionFromConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentModel populates the provided destination DeploymentModel from our DeploymentModel
func (model *DeploymentModel) AssignProperties_To_DeploymentModel(destination *storage.DeploymentModel) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Format
	destination.Format = genruntime.ClonePointerToString(model.Format)

	// FormatFromConfig
	if model.FormatFromConfig != nil {
		formatFromConfig := model.FormatFromConfig.Copy()
		destination.FormatFromConfig = &formatFromConfig
	} else {
		destination.FormatFromConfig = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(model.Name)

	// NameFromConfig
	if model.NameFromConfig != nil {
		nameFromConfig := model.NameFromConfig.Copy()
		destination.NameFromConfig = &nameFromConfig
	} else {
		destination.NameFromConfig = nil
	}

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(model.Publisher)

	// PublisherFromConfig
	if model.PublisherFromConfig != nil {
		publisherFromConfig := model.PublisherFromConfig.Copy()
		destination.PublisherFromConfig = &publisherFromConfig
	} else {
		destination.PublisherFromConfig = nil
	}

	// SourceAccountReference
	if model.SourceAccountReference != nil {
		sourceAccountReference := model.SourceAccountReference.Copy()
		destination.SourceAccountReference = &sourceAccountReference
	} else {
		destination.SourceAccountReference = nil
	}

	// SourceReference
	if model.SourceReference != nil {
		sourceReference := model.SourceReference.Copy()
		destination.SourceReference = &sourceReference
	} else {
		destination.SourceReference = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToString(model.Version)

	// VersionFromConfig
	if model.VersionFromConfig != nil {
		versionFromConfig := model.VersionFromConfig.Copy()
		destination.VersionFromConfig = &versionFromConfig
	} else {
		destination.VersionFromConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeploymentModel_STATUS populates our DeploymentModel from the provided source DeploymentModel_STATUS
func (model *DeploymentModel) Initialize_From_DeploymentModel_STATUS(source *DeploymentModel_STATUS) error {

	// Format
	model.Format = genruntime.ClonePointerToString(source.Format)

	// Name
	model.Name = genruntime.ClonePointerToString(source.Name)

	// Publisher
	model.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Version
	model.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// Properties of Cognitive Services account deployment model.
type DeploymentModel_STATUS struct {
	// CallRateLimit: The call rate limit Cognitive Services account.
	CallRateLimit *CallRateLimit_STATUS `json:"callRateLimit,omitempty"`

	// Format: Deployment model format.
	Format *string `json:"format,omitempty"`

	// Name: Deployment model name.
	Name *string `json:"name,omitempty"`

	// Publisher: Deployment model publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Source: Optional. Deployment model source ARM resource ID.
	Source *string `json:"source,omitempty"`

	// SourceAccount: Optional. Source of the model, another Microsoft.CognitiveServices accounts ARM resource ID.
	SourceAccount *string `json:"sourceAccount,omitempty"`

	// Version: Optional. Deployment model version. If version is not specified, a default version will be assigned. The
	// default version is different for different models and might change when there is new version available for a model.
	// Default version for a model could be found from list models API.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &DeploymentModel_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *DeploymentModel_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentModel_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *DeploymentModel_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentModel_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentModel_STATUS, got %T", armInput)
	}

	// Set property "CallRateLimit":
	if typedInput.CallRateLimit != nil {
		var callRateLimit1 CallRateLimit_STATUS
		err := callRateLimit1.PopulateFromARM(owner, *typedInput.CallRateLimit)
		if err != nil {
			return err
		}
		callRateLimit := callRateLimit1
		model.CallRateLimit = &callRateLimit
	}

	// Set property "Format":
	if typedInput.Format != nil {
		format := *typedInput.Format
		model.Format = &format
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		model.Name = &name
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		model.Publisher = &publisher
	}

	// Set property "Source":
	if typedInput.Source != nil {
		source := *typedInput.Source
		model.Source = &source
	}

	// Set property "SourceAccount":
	if typedInput.SourceAccount != nil {
		sourceAccount := *typedInput.SourceAccount
		model.SourceAccount = &sourceAccount
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		model.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentModel_STATUS populates our DeploymentModel_STATUS from the provided source DeploymentModel_STATUS
func (model *DeploymentModel_STATUS) AssignProperties_From_DeploymentModel_STATUS(source *storage.DeploymentModel_STATUS) error {

	// CallRateLimit
	if source.CallRateLimit != nil {
		var callRateLimit CallRateLimit_STATUS
		err := callRateLimit.AssignProperties_From_CallRateLimit_STATUS(source.CallRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		model.CallRateLimit = &callRateLimit
	} else {
		model.CallRateLimit = nil
	}

	// Format
	model.Format = genruntime.ClonePointerToString(source.Format)

	// Name
	model.Name = genruntime.ClonePointerToString(source.Name)

	// Publisher
	model.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Source
	model.Source = genruntime.ClonePointerToString(source.Source)

	// SourceAccount
	model.SourceAccount = genruntime.ClonePointerToString(source.SourceAccount)

	// Version
	model.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_DeploymentModel_STATUS populates the provided destination DeploymentModel_STATUS from our DeploymentModel_STATUS
func (model *DeploymentModel_STATUS) AssignProperties_To_DeploymentModel_STATUS(destination *storage.DeploymentModel_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CallRateLimit
	if model.CallRateLimit != nil {
		var callRateLimit storage.CallRateLimit_STATUS
		err := model.CallRateLimit.AssignProperties_To_CallRateLimit_STATUS(&callRateLimit)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CallRateLimit_STATUS() to populate field CallRateLimit")
		}
		destination.CallRateLimit = &callRateLimit
	} else {
		destination.CallRateLimit = nil
	}

	// Format
	destination.Format = genruntime.ClonePointerToString(model.Format)

	// Name
	destination.Name = genruntime.ClonePointerToString(model.Name)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(model.Publisher)

	// Source
	destination.Source = genruntime.ClonePointerToString(model.Source)

	// SourceAccount
	destination.SourceAccount = genruntime.ClonePointerToString(model.SourceAccount)

	// Version
	destination.Version = genruntime.ClonePointerToString(model.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeploymentProperties_ProvisioningState_STATUS string

const (
	DeploymentProperties_ProvisioningState_STATUS_Accepted  = DeploymentProperties_ProvisioningState_STATUS("Accepted")
	DeploymentProperties_ProvisioningState_STATUS_Canceled  = DeploymentProperties_ProvisioningState_STATUS("Canceled")
	DeploymentProperties_ProvisioningState_STATUS_Creating  = DeploymentProperties_ProvisioningState_STATUS("Creating")
	DeploymentProperties_ProvisioningState_STATUS_Deleting  = DeploymentProperties_ProvisioningState_STATUS("Deleting")
	DeploymentProperties_ProvisioningState_STATUS_Disabled  = DeploymentProperties_ProvisioningState_STATUS("Disabled")
	DeploymentProperties_ProvisioningState_STATUS_Failed    = DeploymentProperties_ProvisioningState_STATUS("Failed")
	DeploymentProperties_ProvisioningState_STATUS_Moving    = DeploymentProperties_ProvisioningState_STATUS("Moving")
	DeploymentProperties_ProvisioningState_STATUS_Succeeded = DeploymentProperties_ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to DeploymentProperties_ProvisioningState_STATUS
var deploymentProperties_ProvisioningState_STATUS_Values = map[string]DeploymentProperties_ProvisioningState_STATUS{
	"accepted":  DeploymentProperties_ProvisioningState_STATUS_Accepted,
	"canceled":  DeploymentProperties_ProvisioningState_STATUS_Canceled,
	"creating":  DeploymentProperties_ProvisioningState_STATUS_Creating,
	"deleting":  DeploymentProperties_ProvisioningState_STATUS_Deleting,
	"disabled":  DeploymentProperties_ProvisioningState_STATUS_Disabled,
	"failed":    DeploymentProperties_ProvisioningState_STATUS_Failed,
	"moving":    DeploymentProperties_ProvisioningState_STATUS_Moving,
	"succeeded": DeploymentProperties_ProvisioningState_STATUS_Succeeded,
}

// +kubebuilder:validation:Enum={"NoAutoUpgrade","OnceCurrentVersionExpired","OnceNewDefaultVersionAvailable"}
type DeploymentProperties_VersionUpgradeOption string

const (
	DeploymentProperties_VersionUpgradeOption_NoAutoUpgrade                  = DeploymentProperties_VersionUpgradeOption("NoAutoUpgrade")
	DeploymentProperties_VersionUpgradeOption_OnceCurrentVersionExpired      = DeploymentProperties_VersionUpgradeOption("OnceCurrentVersionExpired")
	DeploymentProperties_VersionUpgradeOption_OnceNewDefaultVersionAvailable = DeploymentProperties_VersionUpgradeOption("OnceNewDefaultVersionAvailable")
)

// Mapping from string to DeploymentProperties_VersionUpgradeOption
var deploymentProperties_VersionUpgradeOption_Values = map[string]DeploymentProperties_VersionUpgradeOption{
	"noautoupgrade":                  DeploymentProperties_VersionUpgradeOption_NoAutoUpgrade,
	"oncecurrentversionexpired":      DeploymentProperties_VersionUpgradeOption_OnceCurrentVersionExpired,
	"oncenewdefaultversionavailable": DeploymentProperties_VersionUpgradeOption_OnceNewDefaultVersionAvailable,
}

type DeploymentProperties_VersionUpgradeOption_STATUS string

const (
	DeploymentProperties_VersionUpgradeOption_STATUS_NoAutoUpgrade                  = DeploymentProperties_VersionUpgradeOption_STATUS("NoAutoUpgrade")
	DeploymentProperties_VersionUpgradeOption_STATUS_OnceCurrentVersionExpired      = DeploymentProperties_VersionUpgradeOption_STATUS("OnceCurrentVersionExpired")
	DeploymentProperties_VersionUpgradeOption_STATUS_OnceNewDefaultVersionAvailable = DeploymentProperties_VersionUpgradeOption_STATUS("OnceNewDefaultVersionAvailable")
)

// Mapping from string to DeploymentProperties_VersionUpgradeOption_STATUS
var deploymentProperties_VersionUpgradeOption_STATUS_Values = map[string]DeploymentProperties_VersionUpgradeOption_STATUS{
	"noautoupgrade":                  DeploymentProperties_VersionUpgradeOption_STATUS_NoAutoUpgrade,
	"oncecurrentversionexpired":      DeploymentProperties_VersionUpgradeOption_STATUS_OnceCurrentVersionExpired,
	"oncenewdefaultversionavailable": DeploymentProperties_VersionUpgradeOption_STATUS_OnceNewDefaultVersionAvailable,
}

// Properties of Cognitive Services account deployment model. (Deprecated, please use Deployment.sku instead.)
type DeploymentScaleSettings struct {
	// Capacity: Deployment capacity.
	Capacity *int `json:"capacity,omitempty"`

	// ScaleType: Deployment scale type.
	ScaleType *DeploymentScaleSettings_ScaleType `json:"scaleType,omitempty"`
}

var _ genruntime.ARMTransformer = &DeploymentScaleSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DeploymentScaleSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.DeploymentScaleSettings{}

	// Set property "Capacity":
	if settings.Capacity != nil {
		capacity := *settings.Capacity
		result.Capacity = &capacity
	}

	// Set property "ScaleType":
	if settings.ScaleType != nil {
		var temp string
		temp = string(*settings.ScaleType)
		scaleType := arm.DeploymentScaleSettings_ScaleType(temp)
		result.ScaleType = &scaleType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DeploymentScaleSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentScaleSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DeploymentScaleSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentScaleSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentScaleSettings, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		settings.Capacity = &capacity
	}

	// Set property "ScaleType":
	if typedInput.ScaleType != nil {
		var temp string
		temp = string(*typedInput.ScaleType)
		scaleType := DeploymentScaleSettings_ScaleType(temp)
		settings.ScaleType = &scaleType
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentScaleSettings populates our DeploymentScaleSettings from the provided source DeploymentScaleSettings
func (settings *DeploymentScaleSettings) AssignProperties_From_DeploymentScaleSettings(source *storage.DeploymentScaleSettings) error {

	// Capacity
	settings.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// ScaleType
	if source.ScaleType != nil {
		scaleType := *source.ScaleType
		scaleTypeTemp := genruntime.ToEnum(scaleType, deploymentScaleSettings_ScaleType_Values)
		settings.ScaleType = &scaleTypeTemp
	} else {
		settings.ScaleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentScaleSettings populates the provided destination DeploymentScaleSettings from our DeploymentScaleSettings
func (settings *DeploymentScaleSettings) AssignProperties_To_DeploymentScaleSettings(destination *storage.DeploymentScaleSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(settings.Capacity)

	// ScaleType
	if settings.ScaleType != nil {
		scaleType := string(*settings.ScaleType)
		destination.ScaleType = &scaleType
	} else {
		destination.ScaleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeploymentScaleSettings_STATUS populates our DeploymentScaleSettings from the provided source DeploymentScaleSettings_STATUS
func (settings *DeploymentScaleSettings) Initialize_From_DeploymentScaleSettings_STATUS(source *DeploymentScaleSettings_STATUS) error {

	// Capacity
	settings.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// ScaleType
	if source.ScaleType != nil {
		scaleType := genruntime.ToEnum(string(*source.ScaleType), deploymentScaleSettings_ScaleType_Values)
		settings.ScaleType = &scaleType
	} else {
		settings.ScaleType = nil
	}

	// No error
	return nil
}

// Properties of Cognitive Services account deployment model. (Deprecated, please use Deployment.sku instead.)
type DeploymentScaleSettings_STATUS struct {
	// ActiveCapacity: Deployment active capacity. This value might be different from `capacity` if customer recently updated
	// `capacity`.
	ActiveCapacity *int `json:"activeCapacity,omitempty"`

	// Capacity: Deployment capacity.
	Capacity *int `json:"capacity,omitempty"`

	// ScaleType: Deployment scale type.
	ScaleType *DeploymentScaleSettings_ScaleType_STATUS `json:"scaleType,omitempty"`
}

var _ genruntime.FromARMConverter = &DeploymentScaleSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DeploymentScaleSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeploymentScaleSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DeploymentScaleSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeploymentScaleSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeploymentScaleSettings_STATUS, got %T", armInput)
	}

	// Set property "ActiveCapacity":
	if typedInput.ActiveCapacity != nil {
		activeCapacity := *typedInput.ActiveCapacity
		settings.ActiveCapacity = &activeCapacity
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		settings.Capacity = &capacity
	}

	// Set property "ScaleType":
	if typedInput.ScaleType != nil {
		var temp string
		temp = string(*typedInput.ScaleType)
		scaleType := DeploymentScaleSettings_ScaleType_STATUS(temp)
		settings.ScaleType = &scaleType
	}

	// No error
	return nil
}

// AssignProperties_From_DeploymentScaleSettings_STATUS populates our DeploymentScaleSettings_STATUS from the provided source DeploymentScaleSettings_STATUS
func (settings *DeploymentScaleSettings_STATUS) AssignProperties_From_DeploymentScaleSettings_STATUS(source *storage.DeploymentScaleSettings_STATUS) error {

	// ActiveCapacity
	settings.ActiveCapacity = genruntime.ClonePointerToInt(source.ActiveCapacity)

	// Capacity
	settings.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// ScaleType
	if source.ScaleType != nil {
		scaleType := *source.ScaleType
		scaleTypeTemp := genruntime.ToEnum(scaleType, deploymentScaleSettings_ScaleType_STATUS_Values)
		settings.ScaleType = &scaleTypeTemp
	} else {
		settings.ScaleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeploymentScaleSettings_STATUS populates the provided destination DeploymentScaleSettings_STATUS from our DeploymentScaleSettings_STATUS
func (settings *DeploymentScaleSettings_STATUS) AssignProperties_To_DeploymentScaleSettings_STATUS(destination *storage.DeploymentScaleSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveCapacity
	destination.ActiveCapacity = genruntime.ClonePointerToInt(settings.ActiveCapacity)

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(settings.Capacity)

	// ScaleType
	if settings.ScaleType != nil {
		scaleType := string(*settings.ScaleType)
		destination.ScaleType = &scaleType
	} else {
		destination.ScaleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ThrottlingRule_STATUS struct {
	Count                    *float64                     `json:"count,omitempty"`
	DynamicThrottlingEnabled *bool                        `json:"dynamicThrottlingEnabled,omitempty"`
	Key                      *string                      `json:"key,omitempty"`
	MatchPatterns            []RequestMatchPattern_STATUS `json:"matchPatterns,omitempty"`
	MinCount                 *float64                     `json:"minCount,omitempty"`
	RenewalPeriod            *float64                     `json:"renewalPeriod,omitempty"`
}

var _ genruntime.FromARMConverter = &ThrottlingRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ThrottlingRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ThrottlingRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ThrottlingRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ThrottlingRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ThrottlingRule_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		rule.Count = &count
	}

	// Set property "DynamicThrottlingEnabled":
	if typedInput.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *typedInput.DynamicThrottlingEnabled
		rule.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		rule.Key = &key
	}

	// Set property "MatchPatterns":
	for _, item := range typedInput.MatchPatterns {
		var item1 RequestMatchPattern_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchPatterns = append(rule.MatchPatterns, item1)
	}

	// Set property "MinCount":
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		rule.MinCount = &minCount
	}

	// Set property "RenewalPeriod":
	if typedInput.RenewalPeriod != nil {
		renewalPeriod := *typedInput.RenewalPeriod
		rule.RenewalPeriod = &renewalPeriod
	}

	// No error
	return nil
}

// AssignProperties_From_ThrottlingRule_STATUS populates our ThrottlingRule_STATUS from the provided source ThrottlingRule_STATUS
func (rule *ThrottlingRule_STATUS) AssignProperties_From_ThrottlingRule_STATUS(source *storage.ThrottlingRule_STATUS) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		rule.Count = &count
	} else {
		rule.Count = nil
	}

	// DynamicThrottlingEnabled
	if source.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *source.DynamicThrottlingEnabled
		rule.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		rule.DynamicThrottlingEnabled = nil
	}

	// Key
	rule.Key = genruntime.ClonePointerToString(source.Key)

	// MatchPatterns
	if source.MatchPatterns != nil {
		matchPatternList := make([]RequestMatchPattern_STATUS, len(source.MatchPatterns))
		for matchPatternIndex, matchPatternItem := range source.MatchPatterns {
			// Shadow the loop variable to avoid aliasing
			matchPatternItem := matchPatternItem
			var matchPattern RequestMatchPattern_STATUS
			err := matchPattern.AssignProperties_From_RequestMatchPattern_STATUS(&matchPatternItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RequestMatchPattern_STATUS() to populate field MatchPatterns")
			}
			matchPatternList[matchPatternIndex] = matchPattern
		}
		rule.MatchPatterns = matchPatternList
	} else {
		rule.MatchPatterns = nil
	}

	// MinCount
	if source.MinCount != nil {
		minCount := *source.MinCount
		rule.MinCount = &minCount
	} else {
		rule.MinCount = nil
	}

	// RenewalPeriod
	if source.RenewalPeriod != nil {
		renewalPeriod := *source.RenewalPeriod
		rule.RenewalPeriod = &renewalPeriod
	} else {
		rule.RenewalPeriod = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ThrottlingRule_STATUS populates the provided destination ThrottlingRule_STATUS from our ThrottlingRule_STATUS
func (rule *ThrottlingRule_STATUS) AssignProperties_To_ThrottlingRule_STATUS(destination *storage.ThrottlingRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if rule.Count != nil {
		count := *rule.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// DynamicThrottlingEnabled
	if rule.DynamicThrottlingEnabled != nil {
		dynamicThrottlingEnabled := *rule.DynamicThrottlingEnabled
		destination.DynamicThrottlingEnabled = &dynamicThrottlingEnabled
	} else {
		destination.DynamicThrottlingEnabled = nil
	}

	// Key
	destination.Key = genruntime.ClonePointerToString(rule.Key)

	// MatchPatterns
	if rule.MatchPatterns != nil {
		matchPatternList := make([]storage.RequestMatchPattern_STATUS, len(rule.MatchPatterns))
		for matchPatternIndex, matchPatternItem := range rule.MatchPatterns {
			// Shadow the loop variable to avoid aliasing
			matchPatternItem := matchPatternItem
			var matchPattern storage.RequestMatchPattern_STATUS
			err := matchPatternItem.AssignProperties_To_RequestMatchPattern_STATUS(&matchPattern)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RequestMatchPattern_STATUS() to populate field MatchPatterns")
			}
			matchPatternList[matchPatternIndex] = matchPattern
		}
		destination.MatchPatterns = matchPatternList
	} else {
		destination.MatchPatterns = nil
	}

	// MinCount
	if rule.MinCount != nil {
		minCount := *rule.MinCount
		destination.MinCount = &minCount
	} else {
		destination.MinCount = nil
	}

	// RenewalPeriod
	if rule.RenewalPeriod != nil {
		renewalPeriod := *rule.RenewalPeriod
		destination.RenewalPeriod = &renewalPeriod
	} else {
		destination.RenewalPeriod = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Manual","Standard"}
type DeploymentScaleSettings_ScaleType string

const (
	DeploymentScaleSettings_ScaleType_Manual   = DeploymentScaleSettings_ScaleType("Manual")
	DeploymentScaleSettings_ScaleType_Standard = DeploymentScaleSettings_ScaleType("Standard")
)

// Mapping from string to DeploymentScaleSettings_ScaleType
var deploymentScaleSettings_ScaleType_Values = map[string]DeploymentScaleSettings_ScaleType{
	"manual":   DeploymentScaleSettings_ScaleType_Manual,
	"standard": DeploymentScaleSettings_ScaleType_Standard,
}

type DeploymentScaleSettings_ScaleType_STATUS string

const (
	DeploymentScaleSettings_ScaleType_STATUS_Manual   = DeploymentScaleSettings_ScaleType_STATUS("Manual")
	DeploymentScaleSettings_ScaleType_STATUS_Standard = DeploymentScaleSettings_ScaleType_STATUS("Standard")
)

// Mapping from string to DeploymentScaleSettings_ScaleType_STATUS
var deploymentScaleSettings_ScaleType_STATUS_Values = map[string]DeploymentScaleSettings_ScaleType_STATUS{
	"manual":   DeploymentScaleSettings_ScaleType_STATUS_Manual,
	"standard": DeploymentScaleSettings_ScaleType_STATUS_Standard,
}

type RequestMatchPattern_STATUS struct {
	Method *string `json:"method,omitempty"`
	Path   *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestMatchPattern_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pattern *RequestMatchPattern_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestMatchPattern_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pattern *RequestMatchPattern_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestMatchPattern_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestMatchPattern_STATUS, got %T", armInput)
	}

	// Set property "Method":
	if typedInput.Method != nil {
		method := *typedInput.Method
		pattern.Method = &method
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		pattern.Path = &path
	}

	// No error
	return nil
}

// AssignProperties_From_RequestMatchPattern_STATUS populates our RequestMatchPattern_STATUS from the provided source RequestMatchPattern_STATUS
func (pattern *RequestMatchPattern_STATUS) AssignProperties_From_RequestMatchPattern_STATUS(source *storage.RequestMatchPattern_STATUS) error {

	// Method
	pattern.Method = genruntime.ClonePointerToString(source.Method)

	// Path
	pattern.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignProperties_To_RequestMatchPattern_STATUS populates the provided destination RequestMatchPattern_STATUS from our RequestMatchPattern_STATUS
func (pattern *RequestMatchPattern_STATUS) AssignProperties_To_RequestMatchPattern_STATUS(destination *storage.RequestMatchPattern_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Method
	destination.Method = genruntime.ClonePointerToString(pattern.Method)

	// Path
	destination.Path = genruntime.ClonePointerToString(pattern.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Deployment{}, &DeploymentList{})
}
