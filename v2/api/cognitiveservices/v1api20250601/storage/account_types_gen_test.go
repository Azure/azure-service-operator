// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AbusePenalty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AbusePenalty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAbusePenalty_STATUS, AbusePenalty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAbusePenalty_STATUS runs a test to see if a specific instance of AbusePenalty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAbusePenalty_STATUS(subject AbusePenalty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AbusePenalty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AbusePenalty_STATUS instances for property testing - lazily instantiated by
// AbusePenalty_STATUSGenerator()
var abusePenalty_STATUSGenerator gopter.Gen

// AbusePenalty_STATUSGenerator returns a generator of AbusePenalty_STATUS instances for property testing.
func AbusePenalty_STATUSGenerator() gopter.Gen {
	if abusePenalty_STATUSGenerator != nil {
		return abusePenalty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAbusePenalty_STATUS(generators)
	abusePenalty_STATUSGenerator = gen.Struct(reflect.TypeOf(AbusePenalty_STATUS{}), generators)

	return abusePenalty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAbusePenalty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAbusePenalty_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Expiration"] = gen.PtrOf(gen.AlphaString())
	gens["RateLimitPercentage"] = gen.PtrOf(gen.Float64())
}

func Test_Account_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Account via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccount, AccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccount runs a test to see if a specific instance of Account round trips to JSON and back losslessly
func RunJSONSerializationTestForAccount(subject Account) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Account
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Account instances for property testing - lazily instantiated by AccountGenerator()
var accountGenerator gopter.Gen

// AccountGenerator returns a generator of Account instances for property testing.
func AccountGenerator() gopter.Gen {
	if accountGenerator != nil {
		return accountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAccount(generators)
	accountGenerator = gen.Struct(reflect.TypeOf(Account{}), generators)

	return accountGenerator
}

// AddRelatedPropertyGeneratorsForAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = Account_SpecGenerator()
	gens["Status"] = Account_STATUSGenerator()
}

func Test_AccountOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountOperatorSecrets, AccountOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountOperatorSecrets runs a test to see if a specific instance of AccountOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountOperatorSecrets(subject AccountOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountOperatorSecrets instances for property testing - lazily instantiated by
// AccountOperatorSecretsGenerator()
var accountOperatorSecretsGenerator gopter.Gen

// AccountOperatorSecretsGenerator returns a generator of AccountOperatorSecrets instances for property testing.
func AccountOperatorSecretsGenerator() gopter.Gen {
	if accountOperatorSecretsGenerator != nil {
		return accountOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	accountOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(AccountOperatorSecrets{}), generators)

	return accountOperatorSecretsGenerator
}

func Test_AccountOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountOperatorSpec, AccountOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountOperatorSpec runs a test to see if a specific instance of AccountOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountOperatorSpec(subject AccountOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountOperatorSpec instances for property testing - lazily instantiated by
// AccountOperatorSpecGenerator()
var accountOperatorSpecGenerator gopter.Gen

// AccountOperatorSpecGenerator returns a generator of AccountOperatorSpec instances for property testing.
func AccountOperatorSpecGenerator() gopter.Gen {
	if accountOperatorSpecGenerator != nil {
		return accountOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAccountOperatorSpec(generators)
	accountOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AccountOperatorSpec{}), generators)

	return accountOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForAccountOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(AccountOperatorSecretsGenerator())
}

func Test_AccountProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountProperties, AccountPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountProperties runs a test to see if a specific instance of AccountProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountProperties(subject AccountProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountProperties instances for property testing - lazily instantiated by AccountPropertiesGenerator()
var accountPropertiesGenerator gopter.Gen

// AccountPropertiesGenerator returns a generator of AccountProperties instances for property testing.
// We first initialize accountPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccountPropertiesGenerator() gopter.Gen {
	if accountPropertiesGenerator != nil {
		return accountPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties(generators)
	accountPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties(generators)
	AddRelatedPropertyGeneratorsForAccountProperties(generators)
	accountPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountProperties{}), generators)

	return accountPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAccountProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccountProperties(gens map[string]gopter.Gen) {
	gens["AllowProjectManagement"] = gen.PtrOf(gen.Bool())
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["AssociatedProjects"] = gen.SliceOf(gen.AlphaString())
	gens["CustomSubDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultProject"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DynamicThrottlingEnabled"] = gen.PtrOf(gen.Bool())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAccountProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountProperties(gens map[string]gopter.Gen) {
	gens["AmlWorkspace"] = gen.PtrOf(UserOwnedAmlWorkspaceGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionGenerator())
	gens["Locations"] = gen.PtrOf(MultiRegionSettingsGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["NetworkInjections"] = gen.PtrOf(NetworkInjectionsGenerator())
	gens["RaiMonitorConfig"] = gen.PtrOf(RaiMonitorConfigGenerator())
	gens["UserOwnedStorage"] = gen.SliceOf(UserOwnedStorageGenerator())
}

func Test_AccountProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountProperties_STATUS, AccountProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountProperties_STATUS runs a test to see if a specific instance of AccountProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountProperties_STATUS(subject AccountProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountProperties_STATUS instances for property testing - lazily instantiated by
// AccountProperties_STATUSGenerator()
var accountProperties_STATUSGenerator gopter.Gen

// AccountProperties_STATUSGenerator returns a generator of AccountProperties_STATUS instances for property testing.
// We first initialize accountProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccountProperties_STATUSGenerator() gopter.Gen {
	if accountProperties_STATUSGenerator != nil {
		return accountProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties_STATUS(generators)
	accountProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccountProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForAccountProperties_STATUS(generators)
	accountProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccountProperties_STATUS{}), generators)

	return accountProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAccountProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccountProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AllowProjectManagement"] = gen.PtrOf(gen.Bool())
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["AssociatedProjects"] = gen.SliceOf(gen.AlphaString())
	gens["CustomSubDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["DateCreated"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultProject"] = gen.PtrOf(gen.AlphaString())
	gens["DeletionDate"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DynamicThrottlingEnabled"] = gen.PtrOf(gen.Bool())
	gens["Endpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Endpoints"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["InternalId"] = gen.PtrOf(gen.AlphaString())
	gens["IsMigrated"] = gen.PtrOf(gen.Bool())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
	gens["ScheduledPurgeDate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccountProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AbusePenalty"] = gen.PtrOf(AbusePenalty_STATUSGenerator())
	gens["AmlWorkspace"] = gen.PtrOf(UserOwnedAmlWorkspace_STATUSGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_STATUSGenerator())
	gens["CallRateLimit"] = gen.PtrOf(CallRateLimit_STATUSGenerator())
	gens["Capabilities"] = gen.SliceOf(SkuCapability_STATUSGenerator())
	gens["CommitmentPlanAssociations"] = gen.SliceOf(CommitmentPlanAssociation_STATUSGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_STATUSGenerator())
	gens["Locations"] = gen.PtrOf(MultiRegionSettings_STATUSGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSet_STATUSGenerator())
	gens["NetworkInjections"] = gen.PtrOf(NetworkInjections_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["QuotaLimit"] = gen.PtrOf(QuotaLimit_STATUSGenerator())
	gens["RaiMonitorConfig"] = gen.PtrOf(RaiMonitorConfig_STATUSGenerator())
	gens["SkuChangeInfo"] = gen.PtrOf(SkuChangeInfo_STATUSGenerator())
	gens["UserOwnedStorage"] = gen.SliceOf(UserOwnedStorage_STATUSGenerator())
}

func Test_Account_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Account_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccount_STATUS, Account_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccount_STATUS runs a test to see if a specific instance of Account_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAccount_STATUS(subject Account_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Account_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Account_STATUS instances for property testing - lazily instantiated by Account_STATUSGenerator()
var account_STATUSGenerator gopter.Gen

// Account_STATUSGenerator returns a generator of Account_STATUS instances for property testing.
// We first initialize account_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Account_STATUSGenerator() gopter.Gen {
	if account_STATUSGenerator != nil {
		return account_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_STATUS(generators)
	account_STATUSGenerator = gen.Struct(reflect.TypeOf(Account_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_STATUS(generators)
	AddRelatedPropertyGeneratorsForAccount_STATUS(generators)
	account_STATUSGenerator = gen.Struct(reflect.TypeOf(Account_STATUS{}), generators)

	return account_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAccount_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccount_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccount_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccount_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(AccountProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Account_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Account_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccount_Spec, Account_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccount_Spec runs a test to see if a specific instance of Account_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAccount_Spec(subject Account_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Account_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Account_Spec instances for property testing - lazily instantiated by Account_SpecGenerator()
var account_SpecGenerator gopter.Gen

// Account_SpecGenerator returns a generator of Account_Spec instances for property testing.
// We first initialize account_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Account_SpecGenerator() gopter.Gen {
	if account_SpecGenerator != nil {
		return account_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_Spec(generators)
	account_SpecGenerator = gen.Struct(reflect.TypeOf(Account_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccount_Spec(generators)
	AddRelatedPropertyGeneratorsForAccount_Spec(generators)
	account_SpecGenerator = gen.Struct(reflect.TypeOf(Account_Spec{}), generators)

	return account_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAccount_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccount_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccount_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccount_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(AccountOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(AccountPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_ApiProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties, ApiPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties runs a test to see if a specific instance of ApiProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties(subject ApiProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties instances for property testing - lazily instantiated by ApiPropertiesGenerator()
var apiPropertiesGenerator gopter.Gen

// ApiPropertiesGenerator returns a generator of ApiProperties instances for property testing.
func ApiPropertiesGenerator() gopter.Gen {
	if apiPropertiesGenerator != nil {
		return apiPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties(generators)
	apiPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiProperties{}), generators)

	return apiPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties(gens map[string]gopter.Gen) {
	gens["AadClientId"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["QnaAzureSearchEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["QnaRuntimeEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["StatisticsEnabled"] = gen.PtrOf(gen.Bool())
	gens["SuperUser"] = gen.PtrOf(gen.AlphaString())
	gens["WebsiteName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_STATUS, ApiProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_STATUS runs a test to see if a specific instance of ApiProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_STATUS(subject ApiProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_STATUS instances for property testing - lazily instantiated by
// ApiProperties_STATUSGenerator()
var apiProperties_STATUSGenerator gopter.Gen

// ApiProperties_STATUSGenerator returns a generator of ApiProperties_STATUS instances for property testing.
func ApiProperties_STATUSGenerator() gopter.Gen {
	if apiProperties_STATUSGenerator != nil {
		return apiProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_STATUS(generators)
	apiProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiProperties_STATUS{}), generators)

	return apiProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AadClientId"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["QnaAzureSearchEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["QnaRuntimeEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["StatisticsEnabled"] = gen.PtrOf(gen.Bool())
	gens["SuperUser"] = gen.PtrOf(gen.AlphaString())
	gens["WebsiteName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CallRateLimit_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CallRateLimit_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCallRateLimit_STATUS, CallRateLimit_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCallRateLimit_STATUS runs a test to see if a specific instance of CallRateLimit_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCallRateLimit_STATUS(subject CallRateLimit_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CallRateLimit_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CallRateLimit_STATUS instances for property testing - lazily instantiated by
// CallRateLimit_STATUSGenerator()
var callRateLimit_STATUSGenerator gopter.Gen

// CallRateLimit_STATUSGenerator returns a generator of CallRateLimit_STATUS instances for property testing.
// We first initialize callRateLimit_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CallRateLimit_STATUSGenerator() gopter.Gen {
	if callRateLimit_STATUSGenerator != nil {
		return callRateLimit_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCallRateLimit_STATUS(generators)
	callRateLimit_STATUSGenerator = gen.Struct(reflect.TypeOf(CallRateLimit_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCallRateLimit_STATUS(generators)
	AddRelatedPropertyGeneratorsForCallRateLimit_STATUS(generators)
	callRateLimit_STATUSGenerator = gen.Struct(reflect.TypeOf(CallRateLimit_STATUS{}), generators)

	return callRateLimit_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCallRateLimit_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCallRateLimit_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Float64())
	gens["RenewalPeriod"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForCallRateLimit_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCallRateLimit_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ThrottlingRule_STATUSGenerator())
}

func Test_CommitmentPlanAssociation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CommitmentPlanAssociation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCommitmentPlanAssociation_STATUS, CommitmentPlanAssociation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCommitmentPlanAssociation_STATUS runs a test to see if a specific instance of CommitmentPlanAssociation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCommitmentPlanAssociation_STATUS(subject CommitmentPlanAssociation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CommitmentPlanAssociation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CommitmentPlanAssociation_STATUS instances for property testing - lazily instantiated by
// CommitmentPlanAssociation_STATUSGenerator()
var commitmentPlanAssociation_STATUSGenerator gopter.Gen

// CommitmentPlanAssociation_STATUSGenerator returns a generator of CommitmentPlanAssociation_STATUS instances for property testing.
func CommitmentPlanAssociation_STATUSGenerator() gopter.Gen {
	if commitmentPlanAssociation_STATUSGenerator != nil {
		return commitmentPlanAssociation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCommitmentPlanAssociation_STATUS(generators)
	commitmentPlanAssociation_STATUSGenerator = gen.Struct(reflect.TypeOf(CommitmentPlanAssociation_STATUS{}), generators)

	return commitmentPlanAssociation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCommitmentPlanAssociation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCommitmentPlanAssociation_STATUS(gens map[string]gopter.Gen) {
	gens["CommitmentPlanId"] = gen.PtrOf(gen.AlphaString())
	gens["CommitmentPlanLocation"] = gen.PtrOf(gen.AlphaString())
}

func Test_Encryption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption, EncryptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption runs a test to see if a specific instance of Encryption round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption(subject Encryption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption instances for property testing - lazily instantiated by EncryptionGenerator()
var encryptionGenerator gopter.Gen

// EncryptionGenerator returns a generator of Encryption instances for property testing.
// We first initialize encryptionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionGenerator() gopter.Gen {
	if encryptionGenerator != nil {
		return encryptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption(generators)
	AddRelatedPropertyGeneratorsForEncryption(generators)
	encryptionGenerator = gen.Struct(reflect.TypeOf(Encryption{}), generators)

	return encryptionGenerator
}

// AddIndependentPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryption is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesGenerator())
}

func Test_Encryption_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_STATUS, Encryption_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_STATUS runs a test to see if a specific instance of Encryption_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_STATUS(subject Encryption_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUS instances for property testing - lazily instantiated by Encryption_STATUSGenerator()
var encryption_STATUSGenerator gopter.Gen

// Encryption_STATUSGenerator returns a generator of Encryption_STATUS instances for property testing.
// We first initialize encryption_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_STATUSGenerator() gopter.Gen {
	if encryption_STATUSGenerator != nil {
		return encryption_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUS(generators)
	encryption_STATUSGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUS(generators)
	AddRelatedPropertyGeneratorsForEncryption_STATUS(generators)
	encryption_STATUSGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUS{}), generators)

	return encryption_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_STATUS(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryption_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_STATUSGenerator())
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
// We first initialize identityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	AddRelatedPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_Identity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUS(subject Identity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUS instances for property testing - lazily instantiated by Identity_STATUSGenerator()
var identity_STATUSGenerator gopter.Gen

// Identity_STATUSGenerator returns a generator of Identity_STATUS instances for property testing.
// We first initialize identity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_STATUSGenerator() gopter.Gen {
	if identity_STATUSGenerator != nil {
		return identity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_IpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule runs a test to see if a specific instance of IpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule(subject IpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule instances for property testing - lazily instantiated by IpRuleGenerator()
var ipRuleGenerator gopter.Gen

// IpRuleGenerator returns a generator of IpRule instances for property testing.
func IpRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IpRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule_STATUS, IpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule_STATUS runs a test to see if a specific instance of IpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule_STATUS(subject IpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule_STATUS instances for property testing - lazily instantiated by IpRule_STATUSGenerator()
var ipRule_STATUSGenerator gopter.Gen

// IpRule_STATUSGenerator returns a generator of IpRule_STATUS instances for property testing.
func IpRule_STATUSGenerator() gopter.Gen {
	if ipRule_STATUSGenerator != nil {
		return ipRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule_STATUS(generators)
	ipRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpRule_STATUS{}), generators)

	return ipRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule_STATUS(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties runs a test to see if a specific instance of KeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties instances for property testing - lazily instantiated by KeyVaultPropertiesGenerator()
var keyVaultPropertiesGenerator gopter.Gen

// KeyVaultPropertiesGenerator returns a generator of KeyVaultProperties instances for property testing.
func KeyVaultPropertiesGenerator() gopter.Gen {
	if keyVaultPropertiesGenerator != nil {
		return keyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties(generators)
	keyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties{}), generators)

	return keyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUS, KeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUS(subject KeyVaultProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUS instances for property testing - lazily instantiated by
// KeyVaultProperties_STATUSGenerator()
var keyVaultProperties_STATUSGenerator gopter.Gen

// KeyVaultProperties_STATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultProperties_STATUSGenerator() gopter.Gen {
	if keyVaultProperties_STATUSGenerator != nil {
		return keyVaultProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(generators)
	keyVaultProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_MultiRegionSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiRegionSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiRegionSettings, MultiRegionSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiRegionSettings runs a test to see if a specific instance of MultiRegionSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiRegionSettings(subject MultiRegionSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiRegionSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiRegionSettings instances for property testing - lazily instantiated by
// MultiRegionSettingsGenerator()
var multiRegionSettingsGenerator gopter.Gen

// MultiRegionSettingsGenerator returns a generator of MultiRegionSettings instances for property testing.
// We first initialize multiRegionSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MultiRegionSettingsGenerator() gopter.Gen {
	if multiRegionSettingsGenerator != nil {
		return multiRegionSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings(generators)
	multiRegionSettingsGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings(generators)
	AddRelatedPropertyGeneratorsForMultiRegionSettings(generators)
	multiRegionSettingsGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings{}), generators)

	return multiRegionSettingsGenerator
}

// AddIndependentPropertyGeneratorsForMultiRegionSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMultiRegionSettings(gens map[string]gopter.Gen) {
	gens["RoutingMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMultiRegionSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiRegionSettings(gens map[string]gopter.Gen) {
	gens["Regions"] = gen.SliceOf(RegionSettingGenerator())
}

func Test_MultiRegionSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiRegionSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiRegionSettings_STATUS, MultiRegionSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiRegionSettings_STATUS runs a test to see if a specific instance of MultiRegionSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiRegionSettings_STATUS(subject MultiRegionSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiRegionSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiRegionSettings_STATUS instances for property testing - lazily instantiated by
// MultiRegionSettings_STATUSGenerator()
var multiRegionSettings_STATUSGenerator gopter.Gen

// MultiRegionSettings_STATUSGenerator returns a generator of MultiRegionSettings_STATUS instances for property testing.
// We first initialize multiRegionSettings_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MultiRegionSettings_STATUSGenerator() gopter.Gen {
	if multiRegionSettings_STATUSGenerator != nil {
		return multiRegionSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings_STATUS(generators)
	multiRegionSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMultiRegionSettings_STATUS(generators)
	AddRelatedPropertyGeneratorsForMultiRegionSettings_STATUS(generators)
	multiRegionSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(MultiRegionSettings_STATUS{}), generators)

	return multiRegionSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMultiRegionSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMultiRegionSettings_STATUS(gens map[string]gopter.Gen) {
	gens["RoutingMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMultiRegionSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiRegionSettings_STATUS(gens map[string]gopter.Gen) {
	gens["Regions"] = gen.SliceOf(RegionSetting_STATUSGenerator())
}

func Test_NetworkInjections_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInjections via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInjections, NetworkInjectionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInjections runs a test to see if a specific instance of NetworkInjections round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInjections(subject NetworkInjections) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInjections
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInjections instances for property testing - lazily instantiated by NetworkInjectionsGenerator()
var networkInjectionsGenerator gopter.Gen

// NetworkInjectionsGenerator returns a generator of NetworkInjections instances for property testing.
func NetworkInjectionsGenerator() gopter.Gen {
	if networkInjectionsGenerator != nil {
		return networkInjectionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInjections(generators)
	networkInjectionsGenerator = gen.Struct(reflect.TypeOf(NetworkInjections{}), generators)

	return networkInjectionsGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInjections is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInjections(gens map[string]gopter.Gen) {
	gens["Scenario"] = gen.PtrOf(gen.AlphaString())
	gens["UseMicrosoftManagedNetwork"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkInjections_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInjections_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInjections_STATUS, NetworkInjections_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInjections_STATUS runs a test to see if a specific instance of NetworkInjections_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInjections_STATUS(subject NetworkInjections_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInjections_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInjections_STATUS instances for property testing - lazily instantiated by
// NetworkInjections_STATUSGenerator()
var networkInjections_STATUSGenerator gopter.Gen

// NetworkInjections_STATUSGenerator returns a generator of NetworkInjections_STATUS instances for property testing.
func NetworkInjections_STATUSGenerator() gopter.Gen {
	if networkInjections_STATUSGenerator != nil {
		return networkInjections_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInjections_STATUS(generators)
	networkInjections_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkInjections_STATUS{}), generators)

	return networkInjections_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInjections_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInjections_STATUS(gens map[string]gopter.Gen) {
	gens["Scenario"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetArmId"] = gen.PtrOf(gen.AlphaString())
	gens["UseMicrosoftManagedNetwork"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet runs a test to see if a specific instance of NetworkRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet instances for property testing - lazily instantiated by NetworkRuleSetGenerator()
var networkRuleSetGenerator gopter.Gen

// NetworkRuleSetGenerator returns a generator of NetworkRuleSet instances for property testing.
// We first initialize networkRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetGenerator() gopter.Gen {
	if networkRuleSetGenerator != nil {
		return networkRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	return networkRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRuleGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleGenerator())
}

func Test_NetworkRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_STATUS, NetworkRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_STATUS runs a test to see if a specific instance of NetworkRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_STATUS(subject NetworkRuleSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSet_STATUSGenerator()
var networkRuleSet_STATUSGenerator gopter.Gen

// NetworkRuleSet_STATUSGenerator returns a generator of NetworkRuleSet_STATUS instances for property testing.
// We first initialize networkRuleSet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_STATUSGenerator() gopter.Gen {
	if networkRuleSet_STATUSGenerator != nil {
		return networkRuleSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	networkRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	networkRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	return networkRuleSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRule_STATUSGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_STATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_QuotaLimit_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuotaLimit_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQuotaLimit_STATUS, QuotaLimit_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuotaLimit_STATUS runs a test to see if a specific instance of QuotaLimit_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForQuotaLimit_STATUS(subject QuotaLimit_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuotaLimit_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuotaLimit_STATUS instances for property testing - lazily instantiated by QuotaLimit_STATUSGenerator()
var quotaLimit_STATUSGenerator gopter.Gen

// QuotaLimit_STATUSGenerator returns a generator of QuotaLimit_STATUS instances for property testing.
// We first initialize quotaLimit_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func QuotaLimit_STATUSGenerator() gopter.Gen {
	if quotaLimit_STATUSGenerator != nil {
		return quotaLimit_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuotaLimit_STATUS(generators)
	quotaLimit_STATUSGenerator = gen.Struct(reflect.TypeOf(QuotaLimit_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuotaLimit_STATUS(generators)
	AddRelatedPropertyGeneratorsForQuotaLimit_STATUS(generators)
	quotaLimit_STATUSGenerator = gen.Struct(reflect.TypeOf(QuotaLimit_STATUS{}), generators)

	return quotaLimit_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForQuotaLimit_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuotaLimit_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Float64())
	gens["RenewalPeriod"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForQuotaLimit_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForQuotaLimit_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ThrottlingRule_STATUSGenerator())
}

func Test_RaiMonitorConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RaiMonitorConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRaiMonitorConfig, RaiMonitorConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRaiMonitorConfig runs a test to see if a specific instance of RaiMonitorConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForRaiMonitorConfig(subject RaiMonitorConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RaiMonitorConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RaiMonitorConfig instances for property testing - lazily instantiated by RaiMonitorConfigGenerator()
var raiMonitorConfigGenerator gopter.Gen

// RaiMonitorConfigGenerator returns a generator of RaiMonitorConfig instances for property testing.
func RaiMonitorConfigGenerator() gopter.Gen {
	if raiMonitorConfigGenerator != nil {
		return raiMonitorConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRaiMonitorConfig(generators)
	raiMonitorConfigGenerator = gen.Struct(reflect.TypeOf(RaiMonitorConfig{}), generators)

	return raiMonitorConfigGenerator
}

// AddIndependentPropertyGeneratorsForRaiMonitorConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRaiMonitorConfig(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_RaiMonitorConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RaiMonitorConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRaiMonitorConfig_STATUS, RaiMonitorConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRaiMonitorConfig_STATUS runs a test to see if a specific instance of RaiMonitorConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRaiMonitorConfig_STATUS(subject RaiMonitorConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RaiMonitorConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RaiMonitorConfig_STATUS instances for property testing - lazily instantiated by
// RaiMonitorConfig_STATUSGenerator()
var raiMonitorConfig_STATUSGenerator gopter.Gen

// RaiMonitorConfig_STATUSGenerator returns a generator of RaiMonitorConfig_STATUS instances for property testing.
func RaiMonitorConfig_STATUSGenerator() gopter.Gen {
	if raiMonitorConfig_STATUSGenerator != nil {
		return raiMonitorConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRaiMonitorConfig_STATUS(generators)
	raiMonitorConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(RaiMonitorConfig_STATUS{}), generators)

	return raiMonitorConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRaiMonitorConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRaiMonitorConfig_STATUS(gens map[string]gopter.Gen) {
	gens["AdxStorageResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_RegionSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegionSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegionSetting, RegionSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegionSetting runs a test to see if a specific instance of RegionSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForRegionSetting(subject RegionSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegionSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegionSetting instances for property testing - lazily instantiated by RegionSettingGenerator()
var regionSettingGenerator gopter.Gen

// RegionSettingGenerator returns a generator of RegionSetting instances for property testing.
func RegionSettingGenerator() gopter.Gen {
	if regionSettingGenerator != nil {
		return regionSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegionSetting(generators)
	regionSettingGenerator = gen.Struct(reflect.TypeOf(RegionSetting{}), generators)

	return regionSettingGenerator
}

// AddIndependentPropertyGeneratorsForRegionSetting is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegionSetting(gens map[string]gopter.Gen) {
	gens["Customsubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_RegionSetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegionSetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegionSetting_STATUS, RegionSetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegionSetting_STATUS runs a test to see if a specific instance of RegionSetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRegionSetting_STATUS(subject RegionSetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegionSetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegionSetting_STATUS instances for property testing - lazily instantiated by
// RegionSetting_STATUSGenerator()
var regionSetting_STATUSGenerator gopter.Gen

// RegionSetting_STATUSGenerator returns a generator of RegionSetting_STATUS instances for property testing.
func RegionSetting_STATUSGenerator() gopter.Gen {
	if regionSetting_STATUSGenerator != nil {
		return regionSetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegionSetting_STATUS(generators)
	regionSetting_STATUSGenerator = gen.Struct(reflect.TypeOf(RegionSetting_STATUS{}), generators)

	return regionSetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRegionSetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegionSetting_STATUS(gens map[string]gopter.Gen) {
	gens["Customsubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SkuCapability_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SkuCapability_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuCapability_STATUS, SkuCapability_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuCapability_STATUS runs a test to see if a specific instance of SkuCapability_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuCapability_STATUS(subject SkuCapability_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SkuCapability_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SkuCapability_STATUS instances for property testing - lazily instantiated by
// SkuCapability_STATUSGenerator()
var skuCapability_STATUSGenerator gopter.Gen

// SkuCapability_STATUSGenerator returns a generator of SkuCapability_STATUS instances for property testing.
func SkuCapability_STATUSGenerator() gopter.Gen {
	if skuCapability_STATUSGenerator != nil {
		return skuCapability_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuCapability_STATUS(generators)
	skuCapability_STATUSGenerator = gen.Struct(reflect.TypeOf(SkuCapability_STATUS{}), generators)

	return skuCapability_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSkuCapability_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuCapability_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SkuChangeInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SkuChangeInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuChangeInfo_STATUS, SkuChangeInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuChangeInfo_STATUS runs a test to see if a specific instance of SkuChangeInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuChangeInfo_STATUS(subject SkuChangeInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SkuChangeInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SkuChangeInfo_STATUS instances for property testing - lazily instantiated by
// SkuChangeInfo_STATUSGenerator()
var skuChangeInfo_STATUSGenerator gopter.Gen

// SkuChangeInfo_STATUSGenerator returns a generator of SkuChangeInfo_STATUS instances for property testing.
func SkuChangeInfo_STATUSGenerator() gopter.Gen {
	if skuChangeInfo_STATUSGenerator != nil {
		return skuChangeInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuChangeInfo_STATUS(generators)
	skuChangeInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(SkuChangeInfo_STATUS{}), generators)

	return skuChangeInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSkuChangeInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuChangeInfo_STATUS(gens map[string]gopter.Gen) {
	gens["CountOfDowngrades"] = gen.PtrOf(gen.Float64())
	gens["CountOfUpgradesAfterDowngrades"] = gen.PtrOf(gen.Float64())
	gens["LastChangeDate"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserOwnedAmlWorkspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedAmlWorkspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedAmlWorkspace, UserOwnedAmlWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedAmlWorkspace runs a test to see if a specific instance of UserOwnedAmlWorkspace round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedAmlWorkspace(subject UserOwnedAmlWorkspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedAmlWorkspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedAmlWorkspace instances for property testing - lazily instantiated by
// UserOwnedAmlWorkspaceGenerator()
var userOwnedAmlWorkspaceGenerator gopter.Gen

// UserOwnedAmlWorkspaceGenerator returns a generator of UserOwnedAmlWorkspace instances for property testing.
func UserOwnedAmlWorkspaceGenerator() gopter.Gen {
	if userOwnedAmlWorkspaceGenerator != nil {
		return userOwnedAmlWorkspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace(generators)
	userOwnedAmlWorkspaceGenerator = gen.Struct(reflect.TypeOf(UserOwnedAmlWorkspace{}), generators)

	return userOwnedAmlWorkspaceGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserOwnedAmlWorkspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedAmlWorkspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedAmlWorkspace_STATUS, UserOwnedAmlWorkspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedAmlWorkspace_STATUS runs a test to see if a specific instance of UserOwnedAmlWorkspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedAmlWorkspace_STATUS(subject UserOwnedAmlWorkspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedAmlWorkspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedAmlWorkspace_STATUS instances for property testing - lazily instantiated by
// UserOwnedAmlWorkspace_STATUSGenerator()
var userOwnedAmlWorkspace_STATUSGenerator gopter.Gen

// UserOwnedAmlWorkspace_STATUSGenerator returns a generator of UserOwnedAmlWorkspace_STATUS instances for property testing.
func UserOwnedAmlWorkspace_STATUSGenerator() gopter.Gen {
	if userOwnedAmlWorkspace_STATUSGenerator != nil {
		return userOwnedAmlWorkspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace_STATUS(generators)
	userOwnedAmlWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(UserOwnedAmlWorkspace_STATUS{}), generators)

	return userOwnedAmlWorkspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedAmlWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserOwnedStorage_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedStorage via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedStorage, UserOwnedStorageGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedStorage runs a test to see if a specific instance of UserOwnedStorage round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedStorage(subject UserOwnedStorage) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedStorage
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedStorage instances for property testing - lazily instantiated by UserOwnedStorageGenerator()
var userOwnedStorageGenerator gopter.Gen

// UserOwnedStorageGenerator returns a generator of UserOwnedStorage instances for property testing.
func UserOwnedStorageGenerator() gopter.Gen {
	if userOwnedStorageGenerator != nil {
		return userOwnedStorageGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedStorage(generators)
	userOwnedStorageGenerator = gen.Struct(reflect.TypeOf(UserOwnedStorage{}), generators)

	return userOwnedStorageGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedStorage is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedStorage(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserOwnedStorage_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserOwnedStorage_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserOwnedStorage_STATUS, UserOwnedStorage_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserOwnedStorage_STATUS runs a test to see if a specific instance of UserOwnedStorage_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserOwnedStorage_STATUS(subject UserOwnedStorage_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserOwnedStorage_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserOwnedStorage_STATUS instances for property testing - lazily instantiated by
// UserOwnedStorage_STATUSGenerator()
var userOwnedStorage_STATUSGenerator gopter.Gen

// UserOwnedStorage_STATUSGenerator returns a generator of UserOwnedStorage_STATUS instances for property testing.
func UserOwnedStorage_STATUSGenerator() gopter.Gen {
	if userOwnedStorage_STATUSGenerator != nil {
		return userOwnedStorage_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserOwnedStorage_STATUS(generators)
	userOwnedStorage_STATUSGenerator = gen.Struct(reflect.TypeOf(UserOwnedStorage_STATUS{}), generators)

	return userOwnedStorage_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserOwnedStorage_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserOwnedStorage_STATUS(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule runs a test to see if a specific instance of VirtualNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule instances for property testing - lazily instantiated by VirtualNetworkRuleGenerator()
var virtualNetworkRuleGenerator gopter.Gen

// VirtualNetworkRuleGenerator returns a generator of VirtualNetworkRule instances for property testing.
func VirtualNetworkRuleGenerator() gopter.Gen {
	if virtualNetworkRuleGenerator != nil {
		return virtualNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule(generators)
	virtualNetworkRuleGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule{}), generators)

	return virtualNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_STATUS, VirtualNetworkRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_STATUS runs a test to see if a specific instance of VirtualNetworkRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_STATUS(subject VirtualNetworkRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUS instances for property testing - lazily instantiated by
// VirtualNetworkRule_STATUSGenerator()
var virtualNetworkRule_STATUSGenerator gopter.Gen

// VirtualNetworkRule_STATUSGenerator returns a generator of VirtualNetworkRule_STATUS instances for property testing.
func VirtualNetworkRule_STATUSGenerator() gopter.Gen {
	if virtualNetworkRule_STATUSGenerator != nil {
		return virtualNetworkRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUS(generators)
	virtualNetworkRule_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUS{}), generators)

	return virtualNetworkRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}
