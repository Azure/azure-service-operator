// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.network/v1alpha1api20201101storage"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources=virtualnetworkssubnets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources={virtualnetworkssubnets/status,virtualnetworkssubnets/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/virtualNetworks_subnets
type VirtualNetworksSubnet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualNetworksSubnets_Spec                             `json:"spec,omitempty"`
	Status            Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualNetworksSubnet{}

// GetConditions returns the conditions of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) GetConditions() conditions.Conditions {
	return virtualNetworksSubnet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (virtualNetworksSubnet *VirtualNetworksSubnet) SetConditions(conditions conditions.Conditions) {
	virtualNetworksSubnet.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-network-azure-com-v1alpha1api20201101-virtualnetworkssubnet,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=virtualnetworkssubnets,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.virtualnetworkssubnets.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &VirtualNetworksSubnet{}

// Default applies defaults to the VirtualNetworksSubnet resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) Default() {
	virtualNetworksSubnet.defaultImpl()
	var temp interface{} = virtualNetworksSubnet
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (virtualNetworksSubnet *VirtualNetworksSubnet) defaultAzureName() {
	if virtualNetworksSubnet.Spec.AzureName == "" {
		virtualNetworksSubnet.Spec.AzureName = virtualNetworksSubnet.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualNetworksSubnet resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) defaultImpl() {
	virtualNetworksSubnet.defaultAzureName()
}

var _ genruntime.KubernetesResource = &VirtualNetworksSubnet{}

// AzureName returns the Azure name of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) AzureName() string {
	return virtualNetworksSubnet.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) GetSpec() genruntime.ConvertibleSpec {
	return &virtualNetworksSubnet.Spec
}

// GetStatus returns the status of this resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) GetStatus() genruntime.ConvertibleStatus {
	return &virtualNetworksSubnet.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/virtualNetworks/subnets"
func (virtualNetworksSubnet *VirtualNetworksSubnet) GetType() string {
	return "Microsoft.Network/virtualNetworks/subnets"
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (virtualNetworksSubnet *VirtualNetworksSubnet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(virtualNetworksSubnet.Spec)
	return &genruntime.ResourceReference{Group: group, Kind: kind, Namespace: virtualNetworksSubnet.Namespace, Name: virtualNetworksSubnet.Spec.Owner.Name}
}

// SetStatus sets the status of this resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded); ok {
		virtualNetworksSubnet.Status = *st
		return nil
	}

	// Convert status to required version
	var st Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	virtualNetworksSubnet.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-microsoft-network-azure-com-v1alpha1api20201101-virtualnetworkssubnet,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=virtualnetworkssubnets,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.virtualnetworkssubnets.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &VirtualNetworksSubnet{}

// ValidateCreate validates the creation of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) ValidateCreate() error {
	validations := virtualNetworksSubnet.createValidations()
	var temp interface{} = virtualNetworksSubnet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) ValidateDelete() error {
	validations := virtualNetworksSubnet.deleteValidations()
	var temp interface{} = virtualNetworksSubnet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) ValidateUpdate(old runtime.Object) error {
	validations := virtualNetworksSubnet.updateValidations()
	var temp interface{} = virtualNetworksSubnet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) createValidations() []func() error {
	return []func() error{virtualNetworksSubnet.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return virtualNetworksSubnet.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (virtualNetworksSubnet *VirtualNetworksSubnet) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&virtualNetworksSubnet.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromVirtualNetworksSubnet populates our VirtualNetworksSubnet from the provided source VirtualNetworksSubnet
func (virtualNetworksSubnet *VirtualNetworksSubnet) AssignPropertiesFromVirtualNetworksSubnet(source *v1alpha1api20201101storage.VirtualNetworksSubnet) error {

	// Spec
	var spec VirtualNetworksSubnets_Spec
	err := spec.AssignPropertiesFromVirtualNetworksSubnetsSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromVirtualNetworksSubnetsSpec()")
	}
	virtualNetworksSubnet.Spec = spec

	// Status
	var status Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
	err = status.AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded()")
	}
	virtualNetworksSubnet.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworksSubnet populates the provided destination VirtualNetworksSubnet from our VirtualNetworksSubnet
func (virtualNetworksSubnet *VirtualNetworksSubnet) AssignPropertiesToVirtualNetworksSubnet(destination *v1alpha1api20201101storage.VirtualNetworksSubnet) error {

	// Spec
	var spec v1alpha1api20201101storage.VirtualNetworksSubnets_Spec
	err := virtualNetworksSubnet.Spec.AssignPropertiesToVirtualNetworksSubnetsSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToVirtualNetworksSubnetsSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
	err = virtualNetworksSubnet.Status.AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (virtualNetworksSubnet *VirtualNetworksSubnet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: virtualNetworksSubnet.Spec.OriginalVersion(),
		Kind:    "VirtualNetworksSubnet",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/virtualNetworks_subnets
type VirtualNetworksSubnetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualNetworksSubnet `json:"items"`
}

//Generated from:
type Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//AddressPrefix: The address prefix for the subnet.
	AddressPrefix *string `json:"addressPrefix,omitempty"`

	//AddressPrefixes: List of address prefixes for the subnet.
	AddressPrefixes []string `json:"addressPrefixes,omitempty"`

	//ApplicationGatewayIpConfigurations: Application gateway IP configurations of
	//virtual network resource.
	ApplicationGatewayIpConfigurations []ApplicationGatewayIPConfiguration_Status `json:"applicationGatewayIpConfigurations,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//Delegations: An array of references to the delegations on the subnet.
	Delegations []Delegation_Status `json:"delegations,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IpAllocations: Array of IpAllocation which reference this subnet.
	IpAllocations []SubResource_Status `json:"ipAllocations,omitempty"`

	//IpConfigurationProfiles: Array of IP configuration profiles which reference this
	//subnet.
	IpConfigurationProfiles []IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"ipConfigurationProfiles,omitempty"`

	//IpConfigurations: An array of references to the network interface IP
	//configurations using subnet.
	IpConfigurations []IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	//Name: The name of the resource that is unique within a resource group. This name
	//can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//NatGateway: Nat gateway associated with this subnet.
	NatGateway *SubResource_Status `json:"natGateway,omitempty"`

	//NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"networkSecurityGroup,omitempty"`

	//PrivateEndpointNetworkPolicies: Enable or Disable apply network policies on
	//private end point in the subnet.
	PrivateEndpointNetworkPolicies *SubnetPropertiesFormatStatusPrivateEndpointNetworkPolicies `json:"privateEndpointNetworkPolicies,omitempty"`

	//PrivateEndpoints: An array of references to private endpoints.
	PrivateEndpoints []PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"privateEndpoints,omitempty"`

	//PrivateLinkServiceNetworkPolicies: Enable or Disable apply network policies on
	//private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *SubnetPropertiesFormatStatusPrivateLinkServiceNetworkPolicies `json:"privateLinkServiceNetworkPolicies,omitempty"`

	//ProvisioningState: The provisioning state of the subnet resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Purpose: A read-only string identifying the intention of use for this subnet
	//based on delegations and other user-defined properties.
	Purpose *string `json:"purpose,omitempty"`

	//ResourceNavigationLinks: An array of references to the external resources using
	//subnet.
	ResourceNavigationLinks []ResourceNavigationLink_Status `json:"resourceNavigationLinks,omitempty"`

	//RouteTable: The reference to the RouteTable resource.
	RouteTable *RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"routeTable,omitempty"`

	//ServiceAssociationLinks: An array of references to services injecting into this
	//subnet.
	ServiceAssociationLinks []ServiceAssociationLink_Status `json:"serviceAssociationLinks,omitempty"`

	//ServiceEndpointPolicies: An array of service endpoint policies.
	ServiceEndpointPolicies []ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"serviceEndpointPolicies,omitempty"`

	//ServiceEndpoints: An array of service endpoints.
	ServiceEndpoints []ServiceEndpointPropertiesFormat_Status `json:"serviceEndpoints,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// ConvertStatusFrom populates our Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded{}
	err := subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘AddressPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddressPrefix != nil {
			addressPrefix := *typedInput.Properties.AddressPrefix
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefix = &addressPrefix
		}
	}

	// Set property ‘AddressPrefixes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AddressPrefixes {
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefixes = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefixes, item)
		}
	}

	// Set property ‘ApplicationGatewayIpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayIpConfigurations {
			var item1 ApplicationGatewayIPConfiguration_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ApplicationGatewayIpConfigurations = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ApplicationGatewayIpConfigurations, item1)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Delegations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Delegations {
			var item1 Delegation_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Delegations = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Delegations, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// Set property ‘IpAllocations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpAllocations {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpAllocations = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpAllocations, item1)
		}
	}

	// Set property ‘IpConfigurationProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurationProfiles {
			var item1 IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurationProfiles = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurationProfiles, item1)
		}
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurations = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 SubResource_Status
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NatGateway = &natGateway
		}
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘PrivateEndpointNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointNetworkPolicies != nil {
			privateEndpointNetworkPolicies := *typedInput.Properties.PrivateEndpointNetworkPolicies
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
		}
	}

	// Set property ‘PrivateEndpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpoints {
			var item1 PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpoints = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpoints, item1)
		}
	}

	// Set property ‘PrivateLinkServiceNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkServiceNetworkPolicies != nil {
			privateLinkServiceNetworkPolicies := *typedInput.Properties.PrivateLinkServiceNetworkPolicies
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Purpose’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Purpose != nil {
			purpose := *typedInput.Properties.Purpose
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Purpose = &purpose
		}
	}

	// Set property ‘ResourceNavigationLinks’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ResourceNavigationLinks {
			var item1 ResourceNavigationLink_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ResourceNavigationLinks = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ResourceNavigationLinks, item1)
		}
	}

	// Set property ‘RouteTable’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RouteTable != nil {
			var routeTable1 RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := routeTable1.PopulateFromARM(owner, *typedInput.Properties.RouteTable)
			if err != nil {
				return err
			}
			routeTable := routeTable1
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.RouteTable = &routeTable
		}
	}

	// Set property ‘ServiceAssociationLinks’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceAssociationLinks {
			var item1 ServiceAssociationLink_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceAssociationLinks = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceAssociationLinks, item1)
		}
	}

	// Set property ‘ServiceEndpointPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpointPolicies {
			var item1 ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpointPolicies = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpointPolicies, item1)
		}
	}

	// Set property ‘ServiceEndpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpoints {
			var item1 ServiceEndpointPropertiesFormat_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpoints = append(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpoints, item1)
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded populates our Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// AddressPrefix
	if source.AddressPrefix != nil {
		addressPrefix := *source.AddressPrefix
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefix = &addressPrefix
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefix = nil
	}

	// AddressPrefixes
	addressPrefixList := make([]string, len(source.AddressPrefixes))
	for addressPrefixIndex, addressPrefixItem := range source.AddressPrefixes {
		// Shadow the loop variable to avoid aliasing
		addressPrefixItem := addressPrefixItem
		addressPrefixList[addressPrefixIndex] = addressPrefixItem
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefixes = addressPrefixList

	// ApplicationGatewayIpConfigurations
	applicationGatewayIpConfigurationList := make([]ApplicationGatewayIPConfiguration_Status, len(source.ApplicationGatewayIpConfigurations))
	for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range source.ApplicationGatewayIpConfigurations {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
		var applicationGatewayIpConfiguration ApplicationGatewayIPConfiguration_Status
		err := applicationGatewayIpConfiguration.AssignPropertiesFromApplicationGatewayIPConfigurationStatus(&applicationGatewayIpConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayIpConfigurations from ApplicationGatewayIpConfigurations, calling AssignPropertiesFromApplicationGatewayIPConfigurationStatus()")
		}
		applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Conditions = conditionList

	// Delegations
	delegationList := make([]Delegation_Status, len(source.Delegations))
	for delegationIndex, delegationItem := range source.Delegations {
		// Shadow the loop variable to avoid aliasing
		delegationItem := delegationItem
		var delegation Delegation_Status
		err := delegation.AssignPropertiesFromDelegationStatus(&delegationItem)
		if err != nil {
			return errors.Wrap(err, "populating Delegations from Delegations, calling AssignPropertiesFromDelegationStatus()")
		}
		delegationList[delegationIndex] = delegation
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Delegations = delegationList

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// IpAllocations
	ipAllocationList := make([]SubResource_Status, len(source.IpAllocations))
	for ipAllocationIndex, ipAllocationItem := range source.IpAllocations {
		// Shadow the loop variable to avoid aliasing
		ipAllocationItem := ipAllocationItem
		var ipAllocation SubResource_Status
		err := ipAllocation.AssignPropertiesFromSubResourceStatus(&ipAllocationItem)
		if err != nil {
			return errors.Wrap(err, "populating IpAllocations from IpAllocations, calling AssignPropertiesFromSubResourceStatus()")
		}
		ipAllocationList[ipAllocationIndex] = ipAllocation
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpAllocations = ipAllocationList

	// IpConfigurationProfiles
	ipConfigurationProfileList := make([]IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(source.IpConfigurationProfiles))
	for ipConfigurationProfileIndex, ipConfigurationProfileItem := range source.IpConfigurationProfiles {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationProfileItem := ipConfigurationProfileItem
		var ipConfigurationProfile IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := ipConfigurationProfile.AssignPropertiesFromIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded(&ipConfigurationProfileItem)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurationProfiles from IpConfigurationProfiles, calling AssignPropertiesFromIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		ipConfigurationProfileList[ipConfigurationProfileIndex] = ipConfigurationProfile
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurationProfiles = ipConfigurationProfileList

	// IpConfigurations
	ipConfigurationList := make([]IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(source.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := ipConfiguration.AssignPropertiesFromIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded(&ipConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesFromIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurations = ipConfigurationList

	// Name
	if source.Name != nil {
		name := *source.Name
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Name = nil
	}

	// NatGateway
	if source.NatGateway != nil {
		var natGateway SubResource_Status
		err := natGateway.AssignPropertiesFromSubResourceStatus(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "populating NatGateway from NatGateway, calling AssignPropertiesFromSubResourceStatus()")
		}
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NatGateway = &natGateway
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NatGateway = nil
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := networkSecurityGroup.AssignPropertiesFromNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesFromNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if source.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := SubnetPropertiesFormatStatusPrivateEndpointNetworkPolicies(*source.PrivateEndpointNetworkPolicies)
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateEndpoints
	privateEndpointList := make([]PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(source.PrivateEndpoints))
	for privateEndpointIndex, privateEndpointItem := range source.PrivateEndpoints {
		// Shadow the loop variable to avoid aliasing
		privateEndpointItem := privateEndpointItem
		var privateEndpoint PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := privateEndpoint.AssignPropertiesFromPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded(&privateEndpointItem)
		if err != nil {
			return errors.Wrap(err, "populating PrivateEndpoints from PrivateEndpoints, calling AssignPropertiesFromPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		privateEndpointList[privateEndpointIndex] = privateEndpoint
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpoints = privateEndpointList

	// PrivateLinkServiceNetworkPolicies
	if source.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := SubnetPropertiesFormatStatusPrivateLinkServiceNetworkPolicies(*source.PrivateLinkServiceNetworkPolicies)
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateLinkServiceNetworkPolicies = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = nil
	}

	// Purpose
	if source.Purpose != nil {
		purpose := *source.Purpose
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Purpose = &purpose
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Purpose = nil
	}

	// ResourceNavigationLinks
	resourceNavigationLinkList := make([]ResourceNavigationLink_Status, len(source.ResourceNavigationLinks))
	for resourceNavigationLinkIndex, resourceNavigationLinkItem := range source.ResourceNavigationLinks {
		// Shadow the loop variable to avoid aliasing
		resourceNavigationLinkItem := resourceNavigationLinkItem
		var resourceNavigationLink ResourceNavigationLink_Status
		err := resourceNavigationLink.AssignPropertiesFromResourceNavigationLinkStatus(&resourceNavigationLinkItem)
		if err != nil {
			return errors.Wrap(err, "populating ResourceNavigationLinks from ResourceNavigationLinks, calling AssignPropertiesFromResourceNavigationLinkStatus()")
		}
		resourceNavigationLinkList[resourceNavigationLinkIndex] = resourceNavigationLink
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ResourceNavigationLinks = resourceNavigationLinkList

	// RouteTable
	if source.RouteTable != nil {
		var routeTable RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := routeTable.AssignPropertiesFromRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded(source.RouteTable)
		if err != nil {
			return errors.Wrap(err, "populating RouteTable from RouteTable, calling AssignPropertiesFromRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.RouteTable = &routeTable
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.RouteTable = nil
	}

	// ServiceAssociationLinks
	serviceAssociationLinkList := make([]ServiceAssociationLink_Status, len(source.ServiceAssociationLinks))
	for serviceAssociationLinkIndex, serviceAssociationLinkItem := range source.ServiceAssociationLinks {
		// Shadow the loop variable to avoid aliasing
		serviceAssociationLinkItem := serviceAssociationLinkItem
		var serviceAssociationLink ServiceAssociationLink_Status
		err := serviceAssociationLink.AssignPropertiesFromServiceAssociationLinkStatus(&serviceAssociationLinkItem)
		if err != nil {
			return errors.Wrap(err, "populating ServiceAssociationLinks from ServiceAssociationLinks, calling AssignPropertiesFromServiceAssociationLinkStatus()")
		}
		serviceAssociationLinkList[serviceAssociationLinkIndex] = serviceAssociationLink
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceAssociationLinks = serviceAssociationLinkList

	// ServiceEndpointPolicies
	serviceEndpointPolicyList := make([]ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(source.ServiceEndpointPolicies))
	for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range source.ServiceEndpointPolicies {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointPolicyItem := serviceEndpointPolicyItem
		var serviceEndpointPolicy ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := serviceEndpointPolicy.AssignPropertiesFromServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded(&serviceEndpointPolicyItem)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpointPolicies from ServiceEndpointPolicies, calling AssignPropertiesFromServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpointPolicies = serviceEndpointPolicyList

	// ServiceEndpoints
	serviceEndpointList := make([]ServiceEndpointPropertiesFormat_Status, len(source.ServiceEndpoints))
	for serviceEndpointIndex, serviceEndpointItem := range source.ServiceEndpoints {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointItem := serviceEndpointItem
		var serviceEndpoint ServiceEndpointPropertiesFormat_Status
		err := serviceEndpoint.AssignPropertiesFromServiceEndpointPropertiesFormatStatus(&serviceEndpointItem)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpoints from ServiceEndpoints, calling AssignPropertiesFromServiceEndpointPropertiesFormatStatus()")
		}
		serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
	}
	subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpoints = serviceEndpointList

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Type = &typeVar
	} else {
		subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded from our Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (subnetStatusVirtualNetworksSubnetSubResourceEmbedded *Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToSubnetStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddressPrefix
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefix != nil {
		addressPrefix := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefix
		destination.AddressPrefix = &addressPrefix
	} else {
		destination.AddressPrefix = nil
	}

	// AddressPrefixes
	addressPrefixList := make([]string, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefixes))
	for addressPrefixIndex, addressPrefixItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.AddressPrefixes {
		// Shadow the loop variable to avoid aliasing
		addressPrefixItem := addressPrefixItem
		addressPrefixList[addressPrefixIndex] = addressPrefixItem
	}
	destination.AddressPrefixes = addressPrefixList

	// ApplicationGatewayIpConfigurations
	applicationGatewayIpConfigurationList := make([]v1alpha1api20201101storage.ApplicationGatewayIPConfiguration_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ApplicationGatewayIpConfigurations))
	for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ApplicationGatewayIpConfigurations {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
		var applicationGatewayIpConfiguration v1alpha1api20201101storage.ApplicationGatewayIPConfiguration_Status
		err := applicationGatewayIpConfigurationItem.AssignPropertiesToApplicationGatewayIPConfigurationStatus(&applicationGatewayIpConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayIpConfigurations from ApplicationGatewayIpConfigurations, calling AssignPropertiesToApplicationGatewayIPConfigurationStatus()")
		}
		applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
	}
	destination.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList

	// Conditions
	conditionList := make([]conditions.Condition, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Conditions))
	for conditionIndex, conditionItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// Delegations
	delegationList := make([]v1alpha1api20201101storage.Delegation_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Delegations))
	for delegationIndex, delegationItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Delegations {
		// Shadow the loop variable to avoid aliasing
		delegationItem := delegationItem
		var delegation v1alpha1api20201101storage.Delegation_Status
		err := delegationItem.AssignPropertiesToDelegationStatus(&delegation)
		if err != nil {
			return errors.Wrap(err, "populating Delegations from Delegations, calling AssignPropertiesToDelegationStatus()")
		}
		delegationList[delegationIndex] = delegation
	}
	destination.Delegations = delegationList

	// Etag
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Etag != nil {
		etag := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IpAllocations
	ipAllocationList := make([]v1alpha1api20201101storage.SubResource_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpAllocations))
	for ipAllocationIndex, ipAllocationItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpAllocations {
		// Shadow the loop variable to avoid aliasing
		ipAllocationItem := ipAllocationItem
		var ipAllocation v1alpha1api20201101storage.SubResource_Status
		err := ipAllocationItem.AssignPropertiesToSubResourceStatus(&ipAllocation)
		if err != nil {
			return errors.Wrap(err, "populating IpAllocations from IpAllocations, calling AssignPropertiesToSubResourceStatus()")
		}
		ipAllocationList[ipAllocationIndex] = ipAllocation
	}
	destination.IpAllocations = ipAllocationList

	// IpConfigurationProfiles
	ipConfigurationProfileList := make([]v1alpha1api20201101storage.IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurationProfiles))
	for ipConfigurationProfileIndex, ipConfigurationProfileItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurationProfiles {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationProfileItem := ipConfigurationProfileItem
		var ipConfigurationProfile v1alpha1api20201101storage.IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := ipConfigurationProfileItem.AssignPropertiesToIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded(&ipConfigurationProfile)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurationProfiles from IpConfigurationProfiles, calling AssignPropertiesToIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		ipConfigurationProfileList[ipConfigurationProfileIndex] = ipConfigurationProfile
	}
	destination.IpConfigurationProfiles = ipConfigurationProfileList

	// IpConfigurations
	ipConfigurationList := make([]v1alpha1api20201101storage.IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration v1alpha1api20201101storage.IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := ipConfigurationItem.AssignPropertiesToIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded(&ipConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesToIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	destination.IpConfigurations = ipConfigurationList

	// Name
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Name != nil {
		name := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NatGateway
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NatGateway != nil {
		var natGateway v1alpha1api20201101storage.SubResource_Status
		err := (*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NatGateway).AssignPropertiesToSubResourceStatus(&natGateway)
		if err != nil {
			return errors.Wrap(err, "populating NatGateway from NatGateway, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// NetworkSecurityGroup
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201101storage.NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := (*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.NetworkSecurityGroup).AssignPropertiesToNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesToNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := string(*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpointNetworkPolicies)
		destination.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		destination.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateEndpoints
	privateEndpointList := make([]v1alpha1api20201101storage.PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpoints))
	for privateEndpointIndex, privateEndpointItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateEndpoints {
		// Shadow the loop variable to avoid aliasing
		privateEndpointItem := privateEndpointItem
		var privateEndpoint v1alpha1api20201101storage.PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := privateEndpointItem.AssignPropertiesToPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "populating PrivateEndpoints from PrivateEndpoints, calling AssignPropertiesToPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		privateEndpointList[privateEndpointIndex] = privateEndpoint
	}
	destination.PrivateEndpoints = privateEndpointList

	// PrivateLinkServiceNetworkPolicies
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := string(*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateLinkServiceNetworkPolicies)
		destination.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		destination.PrivateLinkServiceNetworkPolicies = nil
	}

	// ProvisioningState
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Purpose
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Purpose != nil {
		purpose := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Purpose
		destination.Purpose = &purpose
	} else {
		destination.Purpose = nil
	}

	// ResourceNavigationLinks
	resourceNavigationLinkList := make([]v1alpha1api20201101storage.ResourceNavigationLink_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ResourceNavigationLinks))
	for resourceNavigationLinkIndex, resourceNavigationLinkItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ResourceNavigationLinks {
		// Shadow the loop variable to avoid aliasing
		resourceNavigationLinkItem := resourceNavigationLinkItem
		var resourceNavigationLink v1alpha1api20201101storage.ResourceNavigationLink_Status
		err := resourceNavigationLinkItem.AssignPropertiesToResourceNavigationLinkStatus(&resourceNavigationLink)
		if err != nil {
			return errors.Wrap(err, "populating ResourceNavigationLinks from ResourceNavigationLinks, calling AssignPropertiesToResourceNavigationLinkStatus()")
		}
		resourceNavigationLinkList[resourceNavigationLinkIndex] = resourceNavigationLink
	}
	destination.ResourceNavigationLinks = resourceNavigationLinkList

	// RouteTable
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.RouteTable != nil {
		var routeTable v1alpha1api20201101storage.RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := (*subnetStatusVirtualNetworksSubnetSubResourceEmbedded.RouteTable).AssignPropertiesToRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded(&routeTable)
		if err != nil {
			return errors.Wrap(err, "populating RouteTable from RouteTable, calling AssignPropertiesToRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		destination.RouteTable = &routeTable
	} else {
		destination.RouteTable = nil
	}

	// ServiceAssociationLinks
	serviceAssociationLinkList := make([]v1alpha1api20201101storage.ServiceAssociationLink_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceAssociationLinks))
	for serviceAssociationLinkIndex, serviceAssociationLinkItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceAssociationLinks {
		// Shadow the loop variable to avoid aliasing
		serviceAssociationLinkItem := serviceAssociationLinkItem
		var serviceAssociationLink v1alpha1api20201101storage.ServiceAssociationLink_Status
		err := serviceAssociationLinkItem.AssignPropertiesToServiceAssociationLinkStatus(&serviceAssociationLink)
		if err != nil {
			return errors.Wrap(err, "populating ServiceAssociationLinks from ServiceAssociationLinks, calling AssignPropertiesToServiceAssociationLinkStatus()")
		}
		serviceAssociationLinkList[serviceAssociationLinkIndex] = serviceAssociationLink
	}
	destination.ServiceAssociationLinks = serviceAssociationLinkList

	// ServiceEndpointPolicies
	serviceEndpointPolicyList := make([]v1alpha1api20201101storage.ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpointPolicies))
	for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpointPolicies {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointPolicyItem := serviceEndpointPolicyItem
		var serviceEndpointPolicy v1alpha1api20201101storage.ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := serviceEndpointPolicyItem.AssignPropertiesToServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded(&serviceEndpointPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpointPolicies from ServiceEndpointPolicies, calling AssignPropertiesToServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
	}
	destination.ServiceEndpointPolicies = serviceEndpointPolicyList

	// ServiceEndpoints
	serviceEndpointList := make([]v1alpha1api20201101storage.ServiceEndpointPropertiesFormat_Status, len(subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpoints))
	for serviceEndpointIndex, serviceEndpointItem := range subnetStatusVirtualNetworksSubnetSubResourceEmbedded.ServiceEndpoints {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointItem := serviceEndpointItem
		var serviceEndpoint v1alpha1api20201101storage.ServiceEndpointPropertiesFormat_Status
		err := serviceEndpointItem.AssignPropertiesToServiceEndpointPropertiesFormatStatus(&serviceEndpoint)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpoints from ServiceEndpoints, calling AssignPropertiesToServiceEndpointPropertiesFormatStatus()")
		}
		serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
	}
	destination.ServiceEndpoints = serviceEndpointList

	// Type
	if subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Type != nil {
		typeVar := *subnetStatusVirtualNetworksSubnetSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualNetworksSubnets_Spec struct {
	// +kubebuilder:validation:Required
	//AddressPrefix: The address prefix for the subnet.
	AddressPrefix string `json:"addressPrefix"`

	//AddressPrefixes: List of address prefixes for the subnet.
	AddressPrefixes []string `json:"addressPrefixes,omitempty"`

	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//Delegations: An array of references to the delegations on the subnet.
	Delegations []VirtualNetworksSubnets_Spec_Properties_Delegations `json:"delegations,omitempty"`

	//IpAllocations: Array of IpAllocation which reference this subnet.
	IpAllocations []SubResource `json:"ipAllocations,omitempty"`

	//Location: Location to deploy resource to
	Location *string `json:"location,omitempty"`

	//NatGateway: Nat gateway associated with this subnet.
	NatGateway *SubResource `json:"natGateway,omitempty"`

	//NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.network.azure.com" json:"owner" kind:"VirtualNetwork"`

	//PrivateEndpointNetworkPolicies: Enable or Disable apply network policies on
	//private end point in the subnet.
	PrivateEndpointNetworkPolicies *string `json:"privateEndpointNetworkPolicies,omitempty"`

	//PrivateLinkServiceNetworkPolicies: Enable or Disable apply network policies on
	//private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *string `json:"privateLinkServiceNetworkPolicies,omitempty"`

	//RouteTable: The reference to the RouteTable resource.
	RouteTable *SubResource `json:"routeTable,omitempty"`

	//ServiceEndpointPolicies: An array of service endpoint policies.
	ServiceEndpointPolicies []SubResource `json:"serviceEndpointPolicies,omitempty"`

	//ServiceEndpoints: An array of service endpoints.
	ServiceEndpoints []ServiceEndpointPropertiesFormat `json:"serviceEndpoints,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworksSubnets_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualNetworksSubnetsSpec == nil {
		return nil, nil
	}
	var result VirtualNetworksSubnets_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = VirtualNetworksSubnetsSpecAPIVersion20201101

	// Set property ‘Location’:
	if virtualNetworksSubnetsSpec.Location != nil {
		location := *virtualNetworksSubnetsSpec.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	result.Properties.AddressPrefix = virtualNetworksSubnetsSpec.AddressPrefix
	for _, item := range virtualNetworksSubnetsSpec.AddressPrefixes {
		result.Properties.AddressPrefixes = append(result.Properties.AddressPrefixes, item)
	}
	for _, item := range virtualNetworksSubnetsSpec.Delegations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Delegations = append(result.Properties.Delegations, itemARM.(VirtualNetworksSubnets_Spec_Properties_DelegationsARM))
	}
	for _, item := range virtualNetworksSubnetsSpec.IpAllocations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpAllocations = append(result.Properties.IpAllocations, itemARM.(SubResourceARM))
	}
	if virtualNetworksSubnetsSpec.NatGateway != nil {
		natGatewayARM, err := (*virtualNetworksSubnetsSpec.NatGateway).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGateway := natGatewayARM.(SubResourceARM)
		result.Properties.NatGateway = &natGateway
	}
	if virtualNetworksSubnetsSpec.NetworkSecurityGroup != nil {
		networkSecurityGroupARM, err := (*virtualNetworksSubnetsSpec.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := networkSecurityGroupARM.(SubResourceARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicies := *virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies
		result.Properties.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
	}
	if virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicies := *virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies
		result.Properties.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
	}
	if virtualNetworksSubnetsSpec.RouteTable != nil {
		routeTableARM, err := (*virtualNetworksSubnetsSpec.RouteTable).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routeTable := routeTableARM.(SubResourceARM)
		result.Properties.RouteTable = &routeTable
	}
	for _, item := range virtualNetworksSubnetsSpec.ServiceEndpointPolicies {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ServiceEndpointPolicies = append(result.Properties.ServiceEndpointPolicies, itemARM.(SubResourceARM))
	}
	for _, item := range virtualNetworksSubnetsSpec.ServiceEndpoints {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ServiceEndpoints = append(result.Properties.ServiceEndpoints, itemARM.(ServiceEndpointPropertiesFormatARM))
	}

	// Set property ‘Tags’:
	if virtualNetworksSubnetsSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range virtualNetworksSubnetsSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = VirtualNetworksSubnetsSpecTypeMicrosoftNetworkVirtualNetworksSubnets
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworksSubnets_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworksSubnets_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworksSubnets_SpecARM, got %T", armInput)
	}

	// Set property ‘AddressPrefix’:
	// copying flattened property:
	virtualNetworksSubnetsSpec.AddressPrefix = typedInput.Properties.AddressPrefix

	// Set property ‘AddressPrefixes’:
	// copying flattened property:
	for _, item := range typedInput.Properties.AddressPrefixes {
		virtualNetworksSubnetsSpec.AddressPrefixes = append(virtualNetworksSubnetsSpec.AddressPrefixes, item)
	}

	// Set property ‘AzureName’:
	virtualNetworksSubnetsSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Delegations’:
	// copying flattened property:
	for _, item := range typedInput.Properties.Delegations {
		var item1 VirtualNetworksSubnets_Spec_Properties_Delegations
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualNetworksSubnetsSpec.Delegations = append(virtualNetworksSubnetsSpec.Delegations, item1)
	}

	// Set property ‘IpAllocations’:
	// copying flattened property:
	for _, item := range typedInput.Properties.IpAllocations {
		var item1 SubResource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualNetworksSubnetsSpec.IpAllocations = append(virtualNetworksSubnetsSpec.IpAllocations, item1)
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		virtualNetworksSubnetsSpec.Location = &location
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties.NatGateway != nil {
		var natGateway1 SubResource
		err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
		if err != nil {
			return err
		}
		natGateway := natGateway1
		virtualNetworksSubnetsSpec.NatGateway = &natGateway
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties.NetworkSecurityGroup != nil {
		var networkSecurityGroup1 SubResource
		err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
		if err != nil {
			return err
		}
		networkSecurityGroup := networkSecurityGroup1
		virtualNetworksSubnetsSpec.NetworkSecurityGroup = &networkSecurityGroup
	}

	// Set property ‘Owner’:
	virtualNetworksSubnetsSpec.Owner = owner

	// Set property ‘PrivateEndpointNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicies := *typedInput.Properties.PrivateEndpointNetworkPolicies
		virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
	}

	// Set property ‘PrivateLinkServiceNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicies := *typedInput.Properties.PrivateLinkServiceNetworkPolicies
		virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
	}

	// Set property ‘RouteTable’:
	// copying flattened property:
	if typedInput.Properties.RouteTable != nil {
		var routeTable1 SubResource
		err := routeTable1.PopulateFromARM(owner, *typedInput.Properties.RouteTable)
		if err != nil {
			return err
		}
		routeTable := routeTable1
		virtualNetworksSubnetsSpec.RouteTable = &routeTable
	}

	// Set property ‘ServiceEndpointPolicies’:
	// copying flattened property:
	for _, item := range typedInput.Properties.ServiceEndpointPolicies {
		var item1 SubResource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualNetworksSubnetsSpec.ServiceEndpointPolicies = append(virtualNetworksSubnetsSpec.ServiceEndpointPolicies, item1)
	}

	// Set property ‘ServiceEndpoints’:
	// copying flattened property:
	for _, item := range typedInput.Properties.ServiceEndpoints {
		var item1 ServiceEndpointPropertiesFormat
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualNetworksSubnetsSpec.ServiceEndpoints = append(virtualNetworksSubnetsSpec.ServiceEndpoints, item1)
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualNetworksSubnetsSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualNetworksSubnetsSpec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualNetworksSubnets_Spec{}

// ConvertSpecFrom populates our VirtualNetworksSubnets_Spec from the provided source
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201101storage.VirtualNetworksSubnets_Spec)
	if ok {
		// Populate our instance from source
		return virtualNetworksSubnetsSpec.AssignPropertiesFromVirtualNetworksSubnetsSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.VirtualNetworksSubnets_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = virtualNetworksSubnetsSpec.AssignPropertiesFromVirtualNetworksSubnetsSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualNetworksSubnets_Spec
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201101storage.VirtualNetworksSubnets_Spec)
	if ok {
		// Populate destination from our instance
		return virtualNetworksSubnetsSpec.AssignPropertiesToVirtualNetworksSubnetsSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.VirtualNetworksSubnets_Spec{}
	err := virtualNetworksSubnetsSpec.AssignPropertiesToVirtualNetworksSubnetsSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualNetworksSubnetsSpec populates our VirtualNetworksSubnets_Spec from the provided source VirtualNetworksSubnets_Spec
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) AssignPropertiesFromVirtualNetworksSubnetsSpec(source *v1alpha1api20201101storage.VirtualNetworksSubnets_Spec) error {

	// AddressPrefix
	if source.AddressPrefix != nil {
		virtualNetworksSubnetsSpec.AddressPrefix = *source.AddressPrefix
	} else {
		virtualNetworksSubnetsSpec.AddressPrefix = ""
	}

	// AddressPrefixes
	addressPrefixList := make([]string, len(source.AddressPrefixes))
	for addressPrefixIndex, addressPrefixItem := range source.AddressPrefixes {
		// Shadow the loop variable to avoid aliasing
		addressPrefixItem := addressPrefixItem
		addressPrefixList[addressPrefixIndex] = addressPrefixItem
	}
	virtualNetworksSubnetsSpec.AddressPrefixes = addressPrefixList

	// AzureName
	virtualNetworksSubnetsSpec.AzureName = source.AzureName

	// Delegations
	delegationList := make([]VirtualNetworksSubnets_Spec_Properties_Delegations, len(source.Delegations))
	for delegationIndex, delegationItem := range source.Delegations {
		// Shadow the loop variable to avoid aliasing
		delegationItem := delegationItem
		var delegation VirtualNetworksSubnets_Spec_Properties_Delegations
		err := delegation.AssignPropertiesFromVirtualNetworksSubnetsSpecPropertiesDelegations(&delegationItem)
		if err != nil {
			return errors.Wrap(err, "populating Delegations from Delegations, calling AssignPropertiesFromVirtualNetworksSubnetsSpecPropertiesDelegations()")
		}
		delegationList[delegationIndex] = delegation
	}
	virtualNetworksSubnetsSpec.Delegations = delegationList

	// IpAllocations
	ipAllocationList := make([]SubResource, len(source.IpAllocations))
	for ipAllocationIndex, ipAllocationItem := range source.IpAllocations {
		// Shadow the loop variable to avoid aliasing
		ipAllocationItem := ipAllocationItem
		var ipAllocation SubResource
		err := ipAllocation.AssignPropertiesFromSubResource(&ipAllocationItem)
		if err != nil {
			return errors.Wrap(err, "populating IpAllocations from IpAllocations, calling AssignPropertiesFromSubResource()")
		}
		ipAllocationList[ipAllocationIndex] = ipAllocation
	}
	virtualNetworksSubnetsSpec.IpAllocations = ipAllocationList

	// Location
	if source.Location != nil {
		location := *source.Location
		virtualNetworksSubnetsSpec.Location = &location
	} else {
		virtualNetworksSubnetsSpec.Location = nil
	}

	// NatGateway
	if source.NatGateway != nil {
		var natGateway SubResource
		err := natGateway.AssignPropertiesFromSubResource(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "populating NatGateway from NatGateway, calling AssignPropertiesFromSubResource()")
		}
		virtualNetworksSubnetsSpec.NatGateway = &natGateway
	} else {
		virtualNetworksSubnetsSpec.NatGateway = nil
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignPropertiesFromSubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualNetworksSubnetsSpec.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		virtualNetworksSubnetsSpec.NetworkSecurityGroup = nil
	}

	// Owner
	virtualNetworksSubnetsSpec.Owner = source.Owner.Copy()

	// PrivateEndpointNetworkPolicies
	if source.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := *source.PrivateEndpointNetworkPolicies
		virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if source.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := *source.PrivateLinkServiceNetworkPolicies
		virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies = nil
	}

	// RouteTable
	if source.RouteTable != nil {
		var routeTable SubResource
		err := routeTable.AssignPropertiesFromSubResource(source.RouteTable)
		if err != nil {
			return errors.Wrap(err, "populating RouteTable from RouteTable, calling AssignPropertiesFromSubResource()")
		}
		virtualNetworksSubnetsSpec.RouteTable = &routeTable
	} else {
		virtualNetworksSubnetsSpec.RouteTable = nil
	}

	// ServiceEndpointPolicies
	serviceEndpointPolicyList := make([]SubResource, len(source.ServiceEndpointPolicies))
	for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range source.ServiceEndpointPolicies {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointPolicyItem := serviceEndpointPolicyItem
		var serviceEndpointPolicy SubResource
		err := serviceEndpointPolicy.AssignPropertiesFromSubResource(&serviceEndpointPolicyItem)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpointPolicies from ServiceEndpointPolicies, calling AssignPropertiesFromSubResource()")
		}
		serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
	}
	virtualNetworksSubnetsSpec.ServiceEndpointPolicies = serviceEndpointPolicyList

	// ServiceEndpoints
	serviceEndpointList := make([]ServiceEndpointPropertiesFormat, len(source.ServiceEndpoints))
	for serviceEndpointIndex, serviceEndpointItem := range source.ServiceEndpoints {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointItem := serviceEndpointItem
		var serviceEndpoint ServiceEndpointPropertiesFormat
		err := serviceEndpoint.AssignPropertiesFromServiceEndpointPropertiesFormat(&serviceEndpointItem)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpoints from ServiceEndpoints, calling AssignPropertiesFromServiceEndpointPropertiesFormat()")
		}
		serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
	}
	virtualNetworksSubnetsSpec.ServiceEndpoints = serviceEndpointList

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	virtualNetworksSubnetsSpec.Tags = tagMap

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworksSubnetsSpec populates the provided destination VirtualNetworksSubnets_Spec from our VirtualNetworksSubnets_Spec
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) AssignPropertiesToVirtualNetworksSubnetsSpec(destination *v1alpha1api20201101storage.VirtualNetworksSubnets_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddressPrefix
	addressPrefix := virtualNetworksSubnetsSpec.AddressPrefix
	destination.AddressPrefix = &addressPrefix

	// AddressPrefixes
	addressPrefixList := make([]string, len(virtualNetworksSubnetsSpec.AddressPrefixes))
	for addressPrefixIndex, addressPrefixItem := range virtualNetworksSubnetsSpec.AddressPrefixes {
		// Shadow the loop variable to avoid aliasing
		addressPrefixItem := addressPrefixItem
		addressPrefixList[addressPrefixIndex] = addressPrefixItem
	}
	destination.AddressPrefixes = addressPrefixList

	// AzureName
	destination.AzureName = virtualNetworksSubnetsSpec.AzureName

	// Delegations
	delegationList := make([]v1alpha1api20201101storage.VirtualNetworksSubnets_Spec_Properties_Delegations, len(virtualNetworksSubnetsSpec.Delegations))
	for delegationIndex, delegationItem := range virtualNetworksSubnetsSpec.Delegations {
		// Shadow the loop variable to avoid aliasing
		delegationItem := delegationItem
		var delegation v1alpha1api20201101storage.VirtualNetworksSubnets_Spec_Properties_Delegations
		err := delegationItem.AssignPropertiesToVirtualNetworksSubnetsSpecPropertiesDelegations(&delegation)
		if err != nil {
			return errors.Wrap(err, "populating Delegations from Delegations, calling AssignPropertiesToVirtualNetworksSubnetsSpecPropertiesDelegations()")
		}
		delegationList[delegationIndex] = delegation
	}
	destination.Delegations = delegationList

	// IpAllocations
	ipAllocationList := make([]v1alpha1api20201101storage.SubResource, len(virtualNetworksSubnetsSpec.IpAllocations))
	for ipAllocationIndex, ipAllocationItem := range virtualNetworksSubnetsSpec.IpAllocations {
		// Shadow the loop variable to avoid aliasing
		ipAllocationItem := ipAllocationItem
		var ipAllocation v1alpha1api20201101storage.SubResource
		err := ipAllocationItem.AssignPropertiesToSubResource(&ipAllocation)
		if err != nil {
			return errors.Wrap(err, "populating IpAllocations from IpAllocations, calling AssignPropertiesToSubResource()")
		}
		ipAllocationList[ipAllocationIndex] = ipAllocation
	}
	destination.IpAllocations = ipAllocationList

	// Location
	if virtualNetworksSubnetsSpec.Location != nil {
		location := *virtualNetworksSubnetsSpec.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// NatGateway
	if virtualNetworksSubnetsSpec.NatGateway != nil {
		var natGateway v1alpha1api20201101storage.SubResource
		err := (*virtualNetworksSubnetsSpec.NatGateway).AssignPropertiesToSubResource(&natGateway)
		if err != nil {
			return errors.Wrap(err, "populating NatGateway from NatGateway, calling AssignPropertiesToSubResource()")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// NetworkSecurityGroup
	if virtualNetworksSubnetsSpec.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201101storage.SubResource
		err := (*virtualNetworksSubnetsSpec.NetworkSecurityGroup).AssignPropertiesToSubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesToSubResource()")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// OriginalVersion
	destination.OriginalVersion = virtualNetworksSubnetsSpec.OriginalVersion()

	// Owner
	destination.Owner = virtualNetworksSubnetsSpec.Owner.Copy()

	// PrivateEndpointNetworkPolicies
	if virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := *virtualNetworksSubnetsSpec.PrivateEndpointNetworkPolicies
		destination.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		destination.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := *virtualNetworksSubnetsSpec.PrivateLinkServiceNetworkPolicies
		destination.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		destination.PrivateLinkServiceNetworkPolicies = nil
	}

	// RouteTable
	if virtualNetworksSubnetsSpec.RouteTable != nil {
		var routeTable v1alpha1api20201101storage.SubResource
		err := (*virtualNetworksSubnetsSpec.RouteTable).AssignPropertiesToSubResource(&routeTable)
		if err != nil {
			return errors.Wrap(err, "populating RouteTable from RouteTable, calling AssignPropertiesToSubResource()")
		}
		destination.RouteTable = &routeTable
	} else {
		destination.RouteTable = nil
	}

	// ServiceEndpointPolicies
	serviceEndpointPolicyList := make([]v1alpha1api20201101storage.SubResource, len(virtualNetworksSubnetsSpec.ServiceEndpointPolicies))
	for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range virtualNetworksSubnetsSpec.ServiceEndpointPolicies {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointPolicyItem := serviceEndpointPolicyItem
		var serviceEndpointPolicy v1alpha1api20201101storage.SubResource
		err := serviceEndpointPolicyItem.AssignPropertiesToSubResource(&serviceEndpointPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpointPolicies from ServiceEndpointPolicies, calling AssignPropertiesToSubResource()")
		}
		serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
	}
	destination.ServiceEndpointPolicies = serviceEndpointPolicyList

	// ServiceEndpoints
	serviceEndpointList := make([]v1alpha1api20201101storage.ServiceEndpointPropertiesFormat, len(virtualNetworksSubnetsSpec.ServiceEndpoints))
	for serviceEndpointIndex, serviceEndpointItem := range virtualNetworksSubnetsSpec.ServiceEndpoints {
		// Shadow the loop variable to avoid aliasing
		serviceEndpointItem := serviceEndpointItem
		var serviceEndpoint v1alpha1api20201101storage.ServiceEndpointPropertiesFormat
		err := serviceEndpointItem.AssignPropertiesToServiceEndpointPropertiesFormat(&serviceEndpoint)
		if err != nil {
			return errors.Wrap(err, "populating ServiceEndpoints from ServiceEndpoints, calling AssignPropertiesToServiceEndpointPropertiesFormat()")
		}
		serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
	}
	destination.ServiceEndpoints = serviceEndpointList

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range virtualNetworksSubnetsSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (virtualNetworksSubnetsSpec *VirtualNetworksSubnets_Spec) SetAzureName(azureName string) {
	virtualNetworksSubnetsSpec.AzureName = azureName
}

//Generated from:
type ApplicationGatewayIPConfiguration_Status struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: Name of the IP configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the application gateway IP
	//configuration resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Subnet: Reference to the subnet resource. A subnet from where application
	//gateway gets its private address.
	Subnet *SubResource_Status `json:"subnet,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayIPConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (applicationGatewayIPConfigurationStatus *ApplicationGatewayIPConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayIPConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (applicationGatewayIPConfigurationStatus *ApplicationGatewayIPConfiguration_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayIPConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayIPConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		applicationGatewayIPConfigurationStatus.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		applicationGatewayIPConfigurationStatus.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		applicationGatewayIPConfigurationStatus.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			applicationGatewayIPConfigurationStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource_Status
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			applicationGatewayIPConfigurationStatus.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		applicationGatewayIPConfigurationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayIPConfigurationStatus populates our ApplicationGatewayIPConfiguration_Status from the provided source ApplicationGatewayIPConfiguration_Status
func (applicationGatewayIPConfigurationStatus *ApplicationGatewayIPConfiguration_Status) AssignPropertiesFromApplicationGatewayIPConfigurationStatus(source *v1alpha1api20201101storage.ApplicationGatewayIPConfiguration_Status) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		applicationGatewayIPConfigurationStatus.Etag = &etag
	} else {
		applicationGatewayIPConfigurationStatus.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		applicationGatewayIPConfigurationStatus.Id = &id
	} else {
		applicationGatewayIPConfigurationStatus.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		applicationGatewayIPConfigurationStatus.Name = &name
	} else {
		applicationGatewayIPConfigurationStatus.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		applicationGatewayIPConfigurationStatus.ProvisioningState = &provisioningState
	} else {
		applicationGatewayIPConfigurationStatus.ProvisioningState = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource_Status
		err := subnet.AssignPropertiesFromSubResourceStatus(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubResourceStatus()")
		}
		applicationGatewayIPConfigurationStatus.Subnet = &subnet
	} else {
		applicationGatewayIPConfigurationStatus.Subnet = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		applicationGatewayIPConfigurationStatus.Type = &typeVar
	} else {
		applicationGatewayIPConfigurationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayIPConfigurationStatus populates the provided destination ApplicationGatewayIPConfiguration_Status from our ApplicationGatewayIPConfiguration_Status
func (applicationGatewayIPConfigurationStatus *ApplicationGatewayIPConfiguration_Status) AssignPropertiesToApplicationGatewayIPConfigurationStatus(destination *v1alpha1api20201101storage.ApplicationGatewayIPConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if applicationGatewayIPConfigurationStatus.Etag != nil {
		etag := *applicationGatewayIPConfigurationStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if applicationGatewayIPConfigurationStatus.Id != nil {
		id := *applicationGatewayIPConfigurationStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if applicationGatewayIPConfigurationStatus.Name != nil {
		name := *applicationGatewayIPConfigurationStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if applicationGatewayIPConfigurationStatus.ProvisioningState != nil {
		provisioningState := string(*applicationGatewayIPConfigurationStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Subnet
	if applicationGatewayIPConfigurationStatus.Subnet != nil {
		var subnet v1alpha1api20201101storage.SubResource_Status
		err := (*applicationGatewayIPConfigurationStatus.Subnet).AssignPropertiesToSubResourceStatus(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	if applicationGatewayIPConfigurationStatus.Type != nil {
		typeVar := *applicationGatewayIPConfigurationStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Delegation_Status struct {
	//Actions: The actions permitted to the service upon delegation.
	Actions []string `json:"actions,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: The name of the resource that is unique within a subnet. This name can be
	//used to access the resource.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the service delegation resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//ServiceName: The name of the service to whom the subnet should be delegated
	//(e.g. Microsoft.Sql/servers).
	ServiceName *string `json:"serviceName,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Delegation_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (delegationStatus *Delegation_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Delegation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (delegationStatus *Delegation_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(Delegation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Delegation_StatusARM, got %T", armInput)
	}

	// Set property ‘Actions’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Actions {
			delegationStatus.Actions = append(delegationStatus.Actions, item)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		delegationStatus.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		delegationStatus.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		delegationStatus.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			delegationStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ServiceName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceName != nil {
			serviceName := *typedInput.Properties.ServiceName
			delegationStatus.ServiceName = &serviceName
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		delegationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromDelegationStatus populates our Delegation_Status from the provided source Delegation_Status
func (delegationStatus *Delegation_Status) AssignPropertiesFromDelegationStatus(source *v1alpha1api20201101storage.Delegation_Status) error {

	// Actions
	actionList := make([]string, len(source.Actions))
	for actionIndex, actionItem := range source.Actions {
		// Shadow the loop variable to avoid aliasing
		actionItem := actionItem
		actionList[actionIndex] = actionItem
	}
	delegationStatus.Actions = actionList

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		delegationStatus.Etag = &etag
	} else {
		delegationStatus.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		delegationStatus.Id = &id
	} else {
		delegationStatus.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		delegationStatus.Name = &name
	} else {
		delegationStatus.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		delegationStatus.ProvisioningState = &provisioningState
	} else {
		delegationStatus.ProvisioningState = nil
	}

	// ServiceName
	if source.ServiceName != nil {
		serviceName := *source.ServiceName
		delegationStatus.ServiceName = &serviceName
	} else {
		delegationStatus.ServiceName = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		delegationStatus.Type = &typeVar
	} else {
		delegationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDelegationStatus populates the provided destination Delegation_Status from our Delegation_Status
func (delegationStatus *Delegation_Status) AssignPropertiesToDelegationStatus(destination *v1alpha1api20201101storage.Delegation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	actionList := make([]string, len(delegationStatus.Actions))
	for actionIndex, actionItem := range delegationStatus.Actions {
		// Shadow the loop variable to avoid aliasing
		actionItem := actionItem
		actionList[actionIndex] = actionItem
	}
	destination.Actions = actionList

	// Etag
	if delegationStatus.Etag != nil {
		etag := *delegationStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if delegationStatus.Id != nil {
		id := *delegationStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if delegationStatus.Name != nil {
		name := *delegationStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if delegationStatus.ProvisioningState != nil {
		provisioningState := string(*delegationStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ServiceName
	if delegationStatus.ServiceName != nil {
		serviceName := *delegationStatus.ServiceName
		destination.ServiceName = &serviceName
	} else {
		destination.ServiceName = nil
	}

	// Type
	if delegationStatus.Type != nil {
		typeVar := *delegationStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: The name of the resource. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the IP configuration profile
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Sub Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded populates our IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	} else {
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	} else {
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Type = &typeVar
	} else {
		ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded from our IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToIPConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.IPConfigurationProfile_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Etag != nil {
		etag := *ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Name != nil {
		name := *ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Type != nil {
		typeVar := *ipConfigurationProfileStatusVirtualNetworksSubnetSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: The name of the resource that is unique within a resource group. This name
	//can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//ProvisioningState: The provisioning state of the IP configuration resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: The reference to the public IP resource.
	PublicIPAddress *PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded `json:"publicIPAddress,omitempty"`
}

var _ genruntime.FromARMConverter = &IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PublicIPAddress = &publicIPAddress
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded populates our IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = &etag
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Name = &name
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Name = nil
	}

	// PrivateIPAddress
	if source.PrivateIPAddress != nil {
		privateIPAddress := *source.PrivateIPAddress
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAddress = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesFromPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PublicIPAddress = &publicIPAddress
	} else {
		ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PublicIPAddress = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded from our IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded *IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToIPConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.IPConfiguration_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Etag != nil {
		etag := *ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Name != nil {
		name := *ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// PrivateIPAddress
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAddress != nil {
		privateIPAddress := *ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAddress
		destination.PrivateIPAddress = &privateIPAddress
	} else {
		destination.PrivateIPAddress = nil
	}

	// PrivateIPAllocationMethod
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded
		err := (*ipConfigurationStatusVirtualNetworksSubnetSubResourceEmbedded.PublicIPAddress).AssignPropertiesToPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesToPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded()")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded *NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded *NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded populates our NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded *NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded from our NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded *NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToNetworkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkSecurityGroup_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *networkSecurityGroupStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded *PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded *PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded populates our PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded *PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = &extendedLocation
	} else {
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded from our PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded *PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToPrivateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.PrivateEndpoint_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := (*privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	if privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *privateEndpointStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ResourceNavigationLink_Status struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource navigation link identifier.
	Id *string `json:"id,omitempty"`

	//Link: Link to the external resource.
	Link *string `json:"link,omitempty"`

	//LinkedResourceType: Resource type of the linked resource.
	LinkedResourceType *string `json:"linkedResourceType,omitempty"`

	//Name: Name of the resource that is unique within a resource group. This name can
	//be used to access the resource.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the resource navigation link
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceNavigationLink_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceNavigationLinkStatus *ResourceNavigationLink_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceNavigationLink_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceNavigationLinkStatus *ResourceNavigationLink_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceNavigationLink_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceNavigationLink_StatusARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		resourceNavigationLinkStatus.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resourceNavigationLinkStatus.Id = &id
	}

	// Set property ‘Link’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Link != nil {
			link := *typedInput.Properties.Link
			resourceNavigationLinkStatus.Link = &link
		}
	}

	// Set property ‘LinkedResourceType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinkedResourceType != nil {
			linkedResourceType := *typedInput.Properties.LinkedResourceType
			resourceNavigationLinkStatus.LinkedResourceType = &linkedResourceType
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		resourceNavigationLinkStatus.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			resourceNavigationLinkStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resourceNavigationLinkStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceNavigationLinkStatus populates our ResourceNavigationLink_Status from the provided source ResourceNavigationLink_Status
func (resourceNavigationLinkStatus *ResourceNavigationLink_Status) AssignPropertiesFromResourceNavigationLinkStatus(source *v1alpha1api20201101storage.ResourceNavigationLink_Status) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		resourceNavigationLinkStatus.Etag = &etag
	} else {
		resourceNavigationLinkStatus.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		resourceNavigationLinkStatus.Id = &id
	} else {
		resourceNavigationLinkStatus.Id = nil
	}

	// Link
	if source.Link != nil {
		link := *source.Link
		resourceNavigationLinkStatus.Link = &link
	} else {
		resourceNavigationLinkStatus.Link = nil
	}

	// LinkedResourceType
	if source.LinkedResourceType != nil {
		linkedResourceType := *source.LinkedResourceType
		resourceNavigationLinkStatus.LinkedResourceType = &linkedResourceType
	} else {
		resourceNavigationLinkStatus.LinkedResourceType = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		resourceNavigationLinkStatus.Name = &name
	} else {
		resourceNavigationLinkStatus.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		resourceNavigationLinkStatus.ProvisioningState = &provisioningState
	} else {
		resourceNavigationLinkStatus.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		resourceNavigationLinkStatus.Type = &typeVar
	} else {
		resourceNavigationLinkStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceNavigationLinkStatus populates the provided destination ResourceNavigationLink_Status from our ResourceNavigationLink_Status
func (resourceNavigationLinkStatus *ResourceNavigationLink_Status) AssignPropertiesToResourceNavigationLinkStatus(destination *v1alpha1api20201101storage.ResourceNavigationLink_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if resourceNavigationLinkStatus.Etag != nil {
		etag := *resourceNavigationLinkStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if resourceNavigationLinkStatus.Id != nil {
		id := *resourceNavigationLinkStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Link
	if resourceNavigationLinkStatus.Link != nil {
		link := *resourceNavigationLinkStatus.Link
		destination.Link = &link
	} else {
		destination.Link = nil
	}

	// LinkedResourceType
	if resourceNavigationLinkStatus.LinkedResourceType != nil {
		linkedResourceType := *resourceNavigationLinkStatus.LinkedResourceType
		destination.LinkedResourceType = &linkedResourceType
	} else {
		destination.LinkedResourceType = nil
	}

	// Name
	if resourceNavigationLinkStatus.Name != nil {
		name := *resourceNavigationLinkStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if resourceNavigationLinkStatus.ProvisioningState != nil {
		provisioningState := string(*resourceNavigationLinkStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if resourceNavigationLinkStatus.Type != nil {
		typeVar := *resourceNavigationLinkStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routeTableStatusVirtualNetworksSubnetSubResourceEmbedded *RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routeTableStatusVirtualNetworksSubnetSubResourceEmbedded *RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		routeTableStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded populates our RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (routeTableStatusVirtualNetworksSubnetSubResourceEmbedded *RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		routeTableStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		routeTableStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded from our RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (routeTableStatusVirtualNetworksSubnetSubResourceEmbedded *RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToRouteTableStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.RouteTable_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if routeTableStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *routeTableStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ServiceAssociationLink_Status struct {
	//AllowDelete: If true, the resource can be deleted.
	AllowDelete *bool `json:"allowDelete,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Link: Link to the external resource.
	Link *string `json:"link,omitempty"`

	//LinkedResourceType: Resource type of the linked resource.
	LinkedResourceType *string `json:"linkedResourceType,omitempty"`

	//Locations: A list of locations.
	Locations []string `json:"locations,omitempty"`

	//Name: Name of the resource that is unique within a resource group. This name can
	//be used to access the resource.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the service association link
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceAssociationLink_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (serviceAssociationLinkStatus *ServiceAssociationLink_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServiceAssociationLink_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (serviceAssociationLinkStatus *ServiceAssociationLink_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServiceAssociationLink_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServiceAssociationLink_StatusARM, got %T", armInput)
	}

	// Set property ‘AllowDelete’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllowDelete != nil {
			allowDelete := *typedInput.Properties.AllowDelete
			serviceAssociationLinkStatus.AllowDelete = &allowDelete
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		serviceAssociationLinkStatus.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		serviceAssociationLinkStatus.Id = &id
	}

	// Set property ‘Link’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Link != nil {
			link := *typedInput.Properties.Link
			serviceAssociationLinkStatus.Link = &link
		}
	}

	// Set property ‘LinkedResourceType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinkedResourceType != nil {
			linkedResourceType := *typedInput.Properties.LinkedResourceType
			serviceAssociationLinkStatus.LinkedResourceType = &linkedResourceType
		}
	}

	// Set property ‘Locations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Locations {
			serviceAssociationLinkStatus.Locations = append(serviceAssociationLinkStatus.Locations, item)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		serviceAssociationLinkStatus.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			serviceAssociationLinkStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		serviceAssociationLinkStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromServiceAssociationLinkStatus populates our ServiceAssociationLink_Status from the provided source ServiceAssociationLink_Status
func (serviceAssociationLinkStatus *ServiceAssociationLink_Status) AssignPropertiesFromServiceAssociationLinkStatus(source *v1alpha1api20201101storage.ServiceAssociationLink_Status) error {

	// AllowDelete
	if source.AllowDelete != nil {
		allowDelete := *source.AllowDelete
		serviceAssociationLinkStatus.AllowDelete = &allowDelete
	} else {
		serviceAssociationLinkStatus.AllowDelete = nil
	}

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		serviceAssociationLinkStatus.Etag = &etag
	} else {
		serviceAssociationLinkStatus.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		serviceAssociationLinkStatus.Id = &id
	} else {
		serviceAssociationLinkStatus.Id = nil
	}

	// Link
	if source.Link != nil {
		link := *source.Link
		serviceAssociationLinkStatus.Link = &link
	} else {
		serviceAssociationLinkStatus.Link = nil
	}

	// LinkedResourceType
	if source.LinkedResourceType != nil {
		linkedResourceType := *source.LinkedResourceType
		serviceAssociationLinkStatus.LinkedResourceType = &linkedResourceType
	} else {
		serviceAssociationLinkStatus.LinkedResourceType = nil
	}

	// Locations
	locationList := make([]string, len(source.Locations))
	for locationIndex, locationItem := range source.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	serviceAssociationLinkStatus.Locations = locationList

	// Name
	if source.Name != nil {
		name := *source.Name
		serviceAssociationLinkStatus.Name = &name
	} else {
		serviceAssociationLinkStatus.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		serviceAssociationLinkStatus.ProvisioningState = &provisioningState
	} else {
		serviceAssociationLinkStatus.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		serviceAssociationLinkStatus.Type = &typeVar
	} else {
		serviceAssociationLinkStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServiceAssociationLinkStatus populates the provided destination ServiceAssociationLink_Status from our ServiceAssociationLink_Status
func (serviceAssociationLinkStatus *ServiceAssociationLink_Status) AssignPropertiesToServiceAssociationLinkStatus(destination *v1alpha1api20201101storage.ServiceAssociationLink_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowDelete
	if serviceAssociationLinkStatus.AllowDelete != nil {
		allowDelete := *serviceAssociationLinkStatus.AllowDelete
		destination.AllowDelete = &allowDelete
	} else {
		destination.AllowDelete = nil
	}

	// Etag
	if serviceAssociationLinkStatus.Etag != nil {
		etag := *serviceAssociationLinkStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if serviceAssociationLinkStatus.Id != nil {
		id := *serviceAssociationLinkStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Link
	if serviceAssociationLinkStatus.Link != nil {
		link := *serviceAssociationLinkStatus.Link
		destination.Link = &link
	} else {
		destination.Link = nil
	}

	// LinkedResourceType
	if serviceAssociationLinkStatus.LinkedResourceType != nil {
		linkedResourceType := *serviceAssociationLinkStatus.LinkedResourceType
		destination.LinkedResourceType = &linkedResourceType
	} else {
		destination.LinkedResourceType = nil
	}

	// Locations
	locationList := make([]string, len(serviceAssociationLinkStatus.Locations))
	for locationIndex, locationItem := range serviceAssociationLinkStatus.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	destination.Locations = locationList

	// Name
	if serviceAssociationLinkStatus.Name != nil {
		name := *serviceAssociationLinkStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if serviceAssociationLinkStatus.ProvisioningState != nil {
		provisioningState := string(*serviceAssociationLinkStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if serviceAssociationLinkStatus.Type != nil {
		typeVar := *serviceAssociationLinkStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Kind: Kind of service endpoint policy. This is metadata used for the Azure
	//portal experience.
	Kind *string `json:"kind,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded *ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded *ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Kind = &kind
	}

	// No error
	return nil
}

// AssignPropertiesFromServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded populates our ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded *ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Kind = &kind
	} else {
		serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Kind = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded from our ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded *ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToServiceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.ServiceEndpointPolicy_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Kind
	if serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Kind != nil {
		kind := *serviceEndpointPolicyStatusVirtualNetworksSubnetSubResourceEmbedded.Kind
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/definitions/ServiceEndpointPropertiesFormat
type ServiceEndpointPropertiesFormat struct {
	//Locations: A list of locations.
	Locations []string `json:"locations,omitempty"`

	//Service: The type of the endpoint service.
	Service *string `json:"service,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceEndpointPropertiesFormat{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (serviceEndpointPropertiesFormat *ServiceEndpointPropertiesFormat) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if serviceEndpointPropertiesFormat == nil {
		return nil, nil
	}
	var result ServiceEndpointPropertiesFormatARM

	// Set property ‘Locations’:
	for _, item := range serviceEndpointPropertiesFormat.Locations {
		result.Locations = append(result.Locations, item)
	}

	// Set property ‘Service’:
	if serviceEndpointPropertiesFormat.Service != nil {
		service := *serviceEndpointPropertiesFormat.Service
		result.Service = &service
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (serviceEndpointPropertiesFormat *ServiceEndpointPropertiesFormat) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServiceEndpointPropertiesFormatARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (serviceEndpointPropertiesFormat *ServiceEndpointPropertiesFormat) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServiceEndpointPropertiesFormatARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServiceEndpointPropertiesFormatARM, got %T", armInput)
	}

	// Set property ‘Locations’:
	for _, item := range typedInput.Locations {
		serviceEndpointPropertiesFormat.Locations = append(serviceEndpointPropertiesFormat.Locations, item)
	}

	// Set property ‘Service’:
	if typedInput.Service != nil {
		service := *typedInput.Service
		serviceEndpointPropertiesFormat.Service = &service
	}

	// No error
	return nil
}

// AssignPropertiesFromServiceEndpointPropertiesFormat populates our ServiceEndpointPropertiesFormat from the provided source ServiceEndpointPropertiesFormat
func (serviceEndpointPropertiesFormat *ServiceEndpointPropertiesFormat) AssignPropertiesFromServiceEndpointPropertiesFormat(source *v1alpha1api20201101storage.ServiceEndpointPropertiesFormat) error {

	// Locations
	locationList := make([]string, len(source.Locations))
	for locationIndex, locationItem := range source.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	serviceEndpointPropertiesFormat.Locations = locationList

	// Service
	if source.Service != nil {
		service := *source.Service
		serviceEndpointPropertiesFormat.Service = &service
	} else {
		serviceEndpointPropertiesFormat.Service = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServiceEndpointPropertiesFormat populates the provided destination ServiceEndpointPropertiesFormat from our ServiceEndpointPropertiesFormat
func (serviceEndpointPropertiesFormat *ServiceEndpointPropertiesFormat) AssignPropertiesToServiceEndpointPropertiesFormat(destination *v1alpha1api20201101storage.ServiceEndpointPropertiesFormat) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Locations
	locationList := make([]string, len(serviceEndpointPropertiesFormat.Locations))
	for locationIndex, locationItem := range serviceEndpointPropertiesFormat.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	destination.Locations = locationList

	// Service
	if serviceEndpointPropertiesFormat.Service != nil {
		service := *serviceEndpointPropertiesFormat.Service
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ServiceEndpointPropertiesFormat_Status struct {
	//Locations: A list of locations.
	Locations []string `json:"locations,omitempty"`

	//ProvisioningState: The provisioning state of the service endpoint resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Service: The type of the endpoint service.
	Service *string `json:"service,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceEndpointPropertiesFormat_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (serviceEndpointPropertiesFormatStatus *ServiceEndpointPropertiesFormat_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServiceEndpointPropertiesFormat_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (serviceEndpointPropertiesFormatStatus *ServiceEndpointPropertiesFormat_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServiceEndpointPropertiesFormat_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServiceEndpointPropertiesFormat_StatusARM, got %T", armInput)
	}

	// Set property ‘Locations’:
	for _, item := range typedInput.Locations {
		serviceEndpointPropertiesFormatStatus.Locations = append(serviceEndpointPropertiesFormatStatus.Locations, item)
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		serviceEndpointPropertiesFormatStatus.ProvisioningState = &provisioningState
	}

	// Set property ‘Service’:
	if typedInput.Service != nil {
		service := *typedInput.Service
		serviceEndpointPropertiesFormatStatus.Service = &service
	}

	// No error
	return nil
}

// AssignPropertiesFromServiceEndpointPropertiesFormatStatus populates our ServiceEndpointPropertiesFormat_Status from the provided source ServiceEndpointPropertiesFormat_Status
func (serviceEndpointPropertiesFormatStatus *ServiceEndpointPropertiesFormat_Status) AssignPropertiesFromServiceEndpointPropertiesFormatStatus(source *v1alpha1api20201101storage.ServiceEndpointPropertiesFormat_Status) error {

	// Locations
	locationList := make([]string, len(source.Locations))
	for locationIndex, locationItem := range source.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	serviceEndpointPropertiesFormatStatus.Locations = locationList

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		serviceEndpointPropertiesFormatStatus.ProvisioningState = &provisioningState
	} else {
		serviceEndpointPropertiesFormatStatus.ProvisioningState = nil
	}

	// Service
	if source.Service != nil {
		service := *source.Service
		serviceEndpointPropertiesFormatStatus.Service = &service
	} else {
		serviceEndpointPropertiesFormatStatus.Service = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServiceEndpointPropertiesFormatStatus populates the provided destination ServiceEndpointPropertiesFormat_Status from our ServiceEndpointPropertiesFormat_Status
func (serviceEndpointPropertiesFormatStatus *ServiceEndpointPropertiesFormat_Status) AssignPropertiesToServiceEndpointPropertiesFormatStatus(destination *v1alpha1api20201101storage.ServiceEndpointPropertiesFormat_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Locations
	locationList := make([]string, len(serviceEndpointPropertiesFormatStatus.Locations))
	for locationIndex, locationItem := range serviceEndpointPropertiesFormatStatus.Locations {
		// Shadow the loop variable to avoid aliasing
		locationItem := locationItem
		locationList[locationIndex] = locationItem
	}
	destination.Locations = locationList

	// ProvisioningState
	if serviceEndpointPropertiesFormatStatus.ProvisioningState != nil {
		provisioningState := string(*serviceEndpointPropertiesFormatStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Service
	if serviceEndpointPropertiesFormatStatus.Service != nil {
		service := *serviceEndpointPropertiesFormatStatus.Service
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualNetworksSubnets_Spec_Properties_Delegations struct {
	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within a subnet. This name can be
	//used to access the resource.
	Name string `json:"name"`

	//ServiceName: The name of the service to whom the subnet should be delegated
	//(e.g. Microsoft.Sql/servers).
	ServiceName *string `json:"serviceName,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworksSubnets_Spec_Properties_Delegations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualNetworksSubnetsSpecPropertiesDelegations *VirtualNetworksSubnets_Spec_Properties_Delegations) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualNetworksSubnetsSpecPropertiesDelegations == nil {
		return nil, nil
	}
	var result VirtualNetworksSubnets_Spec_Properties_DelegationsARM

	// Set property ‘Name’:
	result.Name = virtualNetworksSubnetsSpecPropertiesDelegations.Name

	// Set property ‘Properties’:
	if virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName != nil {
		result.Properties = &ServiceDelegationPropertiesFormatARM{}
	}
	if virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName != nil {
		serviceName := *virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName
		result.Properties.ServiceName = &serviceName
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualNetworksSubnetsSpecPropertiesDelegations *VirtualNetworksSubnets_Spec_Properties_Delegations) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworksSubnets_Spec_Properties_DelegationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualNetworksSubnetsSpecPropertiesDelegations *VirtualNetworksSubnets_Spec_Properties_Delegations) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworksSubnets_Spec_Properties_DelegationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworksSubnets_Spec_Properties_DelegationsARM, got %T", armInput)
	}

	// Set property ‘Name’:
	virtualNetworksSubnetsSpecPropertiesDelegations.Name = typedInput.Name

	// Set property ‘ServiceName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceName != nil {
			serviceName := *typedInput.Properties.ServiceName
			virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName = &serviceName
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualNetworksSubnetsSpecPropertiesDelegations populates our VirtualNetworksSubnets_Spec_Properties_Delegations from the provided source VirtualNetworksSubnets_Spec_Properties_Delegations
func (virtualNetworksSubnetsSpecPropertiesDelegations *VirtualNetworksSubnets_Spec_Properties_Delegations) AssignPropertiesFromVirtualNetworksSubnetsSpecPropertiesDelegations(source *v1alpha1api20201101storage.VirtualNetworksSubnets_Spec_Properties_Delegations) error {

	// Name
	if source.Name != nil {
		virtualNetworksSubnetsSpecPropertiesDelegations.Name = *source.Name
	} else {
		virtualNetworksSubnetsSpecPropertiesDelegations.Name = ""
	}

	// ServiceName
	if source.ServiceName != nil {
		serviceName := *source.ServiceName
		virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName = &serviceName
	} else {
		virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworksSubnetsSpecPropertiesDelegations populates the provided destination VirtualNetworksSubnets_Spec_Properties_Delegations from our VirtualNetworksSubnets_Spec_Properties_Delegations
func (virtualNetworksSubnetsSpecPropertiesDelegations *VirtualNetworksSubnets_Spec_Properties_Delegations) AssignPropertiesToVirtualNetworksSubnetsSpecPropertiesDelegations(destination *v1alpha1api20201101storage.VirtualNetworksSubnets_Spec_Properties_Delegations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := virtualNetworksSubnetsSpecPropertiesDelegations.Name
	destination.Name = &name

	// ServiceName
	if virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName != nil {
		serviceName := *virtualNetworksSubnetsSpecPropertiesDelegations.ServiceName
		destination.ServiceName = &serviceName
	} else {
		destination.ServiceName = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Status `json:"sku,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Zones = append(publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded populates our PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded from the provided source PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesFromPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded(source *v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = &extendedLocation
	} else {
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Id = &id
	} else {
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Id = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromPublicIPAddressSkuStatus()")
		}
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Sku = &sku
	} else {
		publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded populates the provided destination PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded from our PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded
func (publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) AssignPropertiesToPublicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded(destination *v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworksSubnet_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := (*publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	if publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Id != nil {
		id := *publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Sku
	if publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Status
		err := (*publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Sku).AssignPropertiesToPublicIPAddressSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToPublicIPAddressSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Zones))
	for zoneIndex, zoneItem := range publicIPAddressStatusVirtualNetworksSubnetSubResourceEmbedded.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&VirtualNetworksSubnet{}, &VirtualNetworksSubnetList{})
}
