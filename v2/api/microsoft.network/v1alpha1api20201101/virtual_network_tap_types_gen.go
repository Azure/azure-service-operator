// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.network/v1alpha1api20201101storage"
	"github.com/Azure/azure-service-operator/v2/internal/controller/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources=virtualnetworktaps,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources={virtualnetworktaps/status,virtualnetworktaps/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/virtualNetworkTaps
type VirtualNetworkTap struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualNetworkTaps_Spec                                        `json:"spec,omitempty"`
	Status            VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualNetworkTap{}

// GetConditions returns the conditions of the resource
func (virtualNetworkTap *VirtualNetworkTap) GetConditions() conditions.Conditions {
	return virtualNetworkTap.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (virtualNetworkTap *VirtualNetworkTap) SetConditions(conditions conditions.Conditions) {
	virtualNetworkTap.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-network-azure-com-v1alpha1api20201101-virtualnetworktap,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=virtualnetworktaps,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.virtualnetworktaps.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &VirtualNetworkTap{}

// Default applies defaults to the VirtualNetworkTap resource
func (virtualNetworkTap *VirtualNetworkTap) Default() {
	virtualNetworkTap.defaultImpl()
	var temp interface{} = virtualNetworkTap
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (virtualNetworkTap *VirtualNetworkTap) defaultAzureName() {
	if virtualNetworkTap.Spec.AzureName == "" {
		virtualNetworkTap.Spec.AzureName = virtualNetworkTap.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualNetworkTap resource
func (virtualNetworkTap *VirtualNetworkTap) defaultImpl() { virtualNetworkTap.defaultAzureName() }

var _ genruntime.KubernetesResource = &VirtualNetworkTap{}

// AzureName returns the Azure name of the resource
func (virtualNetworkTap *VirtualNetworkTap) AzureName() string {
	return virtualNetworkTap.Spec.AzureName
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (virtualNetworkTap *VirtualNetworkTap) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(virtualNetworkTap.Spec)
	return &genruntime.ResourceReference{Group: group, Kind: kind, Namespace: virtualNetworkTap.Namespace, Name: virtualNetworkTap.Spec.Owner.Name}
}

// +kubebuilder:webhook:path=/validate-microsoft-network-azure-com-v1alpha1api20201101-virtualnetworktap,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=virtualnetworktaps,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.virtualnetworktaps.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &VirtualNetworkTap{}

// ValidateCreate validates the creation of the resource
func (virtualNetworkTap *VirtualNetworkTap) ValidateCreate() error {
	validations := virtualNetworkTap.createValidations()
	var temp interface{} = virtualNetworkTap
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (virtualNetworkTap *VirtualNetworkTap) ValidateDelete() error {
	validations := virtualNetworkTap.deleteValidations()
	var temp interface{} = virtualNetworkTap
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (virtualNetworkTap *VirtualNetworkTap) ValidateUpdate(old runtime.Object) error {
	validations := virtualNetworkTap.updateValidations()
	var temp interface{} = virtualNetworkTap
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (virtualNetworkTap *VirtualNetworkTap) createValidations() []func() error {
	return []func() error{virtualNetworkTap.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (virtualNetworkTap *VirtualNetworkTap) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (virtualNetworkTap *VirtualNetworkTap) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return virtualNetworkTap.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (virtualNetworkTap *VirtualNetworkTap) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&virtualNetworkTap.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromVirtualNetworkTap populates our VirtualNetworkTap from the provided source VirtualNetworkTap
func (virtualNetworkTap *VirtualNetworkTap) AssignPropertiesFromVirtualNetworkTap(source *v1alpha1api20201101storage.VirtualNetworkTap) error {

	// Spec
	var spec VirtualNetworkTaps_Spec
	err := spec.AssignPropertiesFromVirtualNetworkTapsSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromVirtualNetworkTapsSpec()")
	}
	virtualNetworkTap.Spec = spec

	// Status
	var status VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded
	err = status.AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded()")
	}
	virtualNetworkTap.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTap populates the provided destination VirtualNetworkTap from our VirtualNetworkTap
func (virtualNetworkTap *VirtualNetworkTap) AssignPropertiesToVirtualNetworkTap(destination *v1alpha1api20201101storage.VirtualNetworkTap) error {

	// Spec
	var spec v1alpha1api20201101storage.VirtualNetworkTaps_Spec
	err := virtualNetworkTap.Spec.AssignPropertiesToVirtualNetworkTapsSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToVirtualNetworkTapsSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded
	err = virtualNetworkTap.Status.AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (virtualNetworkTap *VirtualNetworkTap) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: virtualNetworkTap.Spec.OriginalVersion(),
		Kind:    "VirtualNetworkTap",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/virtualNetworkTaps
type VirtualNetworkTapList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualNetworkTap `json:"items"`
}

//Generated from:
type VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DestinationLoadBalancerFrontEndIPConfiguration: The reference to the private IP
	//address on the internal Load Balancer that will receive the tap.
	DestinationLoadBalancerFrontEndIPConfiguration *FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded `json:"destinationLoadBalancerFrontEndIPConfiguration,omitempty"`

	//DestinationNetworkInterfaceIPConfiguration: The reference to the private IP
	//Address of the collector nic that will receive the tap.
	DestinationNetworkInterfaceIPConfiguration *NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded `json:"destinationNetworkInterfaceIPConfiguration,omitempty"`

	//DestinationPort: The VXLAN destination port that will receive the tapped traffic.
	DestinationPort *int `json:"destinationPort,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Name: Resource name.
	Name *string `json:"name,omitempty"`

	//NetworkInterfaceTapConfigurations: Specifies the list of resource IDs for the
	//network interface IP configuration that needs to be tapped.
	NetworkInterfaceTapConfigurations []NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded `json:"networkInterfaceTapConfigurations,omitempty"`

	//ProvisioningState: The provisioning state of the virtual network tap resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//ResourceGuid: The resource GUID property of the virtual network tap resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded{}

// ConvertStatusFrom populates our VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded{}
	err := virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DestinationLoadBalancerFrontEndIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration != nil {
			var destinationLoadBalancerFrontEndIPConfiguration1 FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
			err := destinationLoadBalancerFrontEndIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration)
			if err != nil {
				return err
			}
			destinationLoadBalancerFrontEndIPConfiguration := destinationLoadBalancerFrontEndIPConfiguration1
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
		}
	}

	// Set property ‘DestinationNetworkInterfaceIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DestinationNetworkInterfaceIPConfiguration != nil {
			var destinationNetworkInterfaceIPConfiguration1 NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
			err := destinationNetworkInterfaceIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DestinationNetworkInterfaceIPConfiguration)
			if err != nil {
				return err
			}
			destinationNetworkInterfaceIPConfiguration := destinationNetworkInterfaceIPConfiguration1
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
		}
	}

	// Set property ‘DestinationPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DestinationPort != nil {
			destinationPort := *typedInput.Properties.DestinationPort
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationPort = &destinationPort
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	}

	// Set property ‘NetworkInterfaceTapConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.NetworkInterfaceTapConfigurations {
			var item1 NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.NetworkInterfaceTapConfigurations = append(virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.NetworkInterfaceTapConfigurations, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded populates our VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Conditions = conditionList

	// DestinationLoadBalancerFrontEndIPConfiguration
	if source.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := destinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesFromFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(source.DestinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationLoadBalancerFrontEndIPConfiguration from DestinationLoadBalancerFrontEndIPConfiguration, calling AssignPropertiesFromFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationNetworkInterfaceIPConfiguration
	if source.DestinationNetworkInterfaceIPConfiguration != nil {
		var destinationNetworkInterfaceIPConfiguration NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := destinationNetworkInterfaceIPConfiguration.AssignPropertiesFromNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(source.DestinationNetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationNetworkInterfaceIPConfiguration from DestinationNetworkInterfaceIPConfiguration, calling AssignPropertiesFromNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationNetworkInterfaceIPConfiguration = nil
	}

	// DestinationPort
	if source.DestinationPort != nil {
		destinationPort := *source.DestinationPort
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationPort = &destinationPort
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationPort = nil
	}

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// Location
	if source.Location != nil {
		location := *source.Location
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Location = &location
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Location = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Name = nil
	}

	// NetworkInterfaceTapConfigurations
	networkInterfaceTapConfigurationList := make([]NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded, len(source.NetworkInterfaceTapConfigurations))
	for networkInterfaceTapConfigurationIndex, networkInterfaceTapConfigurationItem := range source.NetworkInterfaceTapConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceTapConfigurationItem := networkInterfaceTapConfigurationItem
		var networkInterfaceTapConfiguration NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := networkInterfaceTapConfiguration.AssignPropertiesFromNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded(&networkInterfaceTapConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceTapConfigurations from NetworkInterfaceTapConfigurations, calling AssignPropertiesFromNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		networkInterfaceTapConfigurationList[networkInterfaceTapConfigurationIndex] = networkInterfaceTapConfiguration
	}
	virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.NetworkInterfaceTapConfigurations = networkInterfaceTapConfigurationList

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = nil
	}

	// ResourceGuid
	if source.ResourceGuid != nil {
		resourceGuid := *source.ResourceGuid
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ResourceGuid = &resourceGuid
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ResourceGuid = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	} else {
		virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded from our VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded
func (virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded *VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToVirtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.VirtualNetworkTap_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	conditionList := make([]conditions.Condition, len(virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Conditions))
	for conditionIndex, conditionItem := range virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// DestinationLoadBalancerFrontEndIPConfiguration
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationLoadBalancerFrontEndIPConfiguration).AssignPropertiesToFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(&destinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationLoadBalancerFrontEndIPConfiguration from DestinationLoadBalancerFrontEndIPConfiguration, calling AssignPropertiesToFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		destination.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationNetworkInterfaceIPConfiguration
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationNetworkInterfaceIPConfiguration != nil {
		var destinationNetworkInterfaceIPConfiguration v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationNetworkInterfaceIPConfiguration).AssignPropertiesToNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(&destinationNetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationNetworkInterfaceIPConfiguration from DestinationNetworkInterfaceIPConfiguration, calling AssignPropertiesToNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	} else {
		destination.DestinationNetworkInterfaceIPConfiguration = nil
	}

	// DestinationPort
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationPort != nil {
		destinationPort := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.DestinationPort
		destination.DestinationPort = &destinationPort
	} else {
		destination.DestinationPort = nil
	}

	// Etag
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Etag != nil {
		etag := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Location
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Location != nil {
		location := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Name != nil {
		name := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NetworkInterfaceTapConfigurations
	networkInterfaceTapConfigurationList := make([]v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded, len(virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.NetworkInterfaceTapConfigurations))
	for networkInterfaceTapConfigurationIndex, networkInterfaceTapConfigurationItem := range virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.NetworkInterfaceTapConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceTapConfigurationItem := networkInterfaceTapConfigurationItem
		var networkInterfaceTapConfiguration v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
		err := networkInterfaceTapConfigurationItem.AssignPropertiesToNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded(&networkInterfaceTapConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceTapConfigurations from NetworkInterfaceTapConfigurations, calling AssignPropertiesToNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		networkInterfaceTapConfigurationList[networkInterfaceTapConfigurationIndex] = networkInterfaceTapConfiguration
	}
	destination.NetworkInterfaceTapConfigurations = networkInterfaceTapConfigurationList

	// ProvisioningState
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ResourceGuid != nil {
		resourceGuid := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.ResourceGuid
		destination.ResourceGuid = &resourceGuid
	} else {
		destination.ResourceGuid = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Type != nil {
		typeVar := *virtualNetworkTapStatusVirtualNetworkTapSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualNetworkTaps_Spec struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DestinationLoadBalancerFrontEndIPConfiguration: The reference to the private IP
	//address on the internal Load Balancer that will receive the tap.
	DestinationLoadBalancerFrontEndIPConfiguration *SubResource `json:"destinationLoadBalancerFrontEndIPConfiguration,omitempty"`

	//DestinationNetworkInterfaceIPConfiguration: The reference to the private IP
	//Address of the collector nic that will receive the tap.
	DestinationNetworkInterfaceIPConfiguration *SubResource `json:"destinationNetworkInterfaceIPConfiguration,omitempty"`

	//DestinationPort: The VXLAN destination port that will receive the tapped traffic.
	DestinationPort *int `json:"destinationPort,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworkTaps_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if virtualNetworkTapsSpec == nil {
		return nil, nil
	}
	var result VirtualNetworkTaps_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = VirtualNetworkTapsSpecAPIVersion20201101

	// Set property ‘Location’:
	result.Location = virtualNetworkTapsSpec.Location

	// Set property ‘Name’:
	result.Name = name

	// Set property ‘Properties’:
	if virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		destinationLoadBalancerFrontEndIPConfigurationARM, err := (*virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		destinationLoadBalancerFrontEndIPConfiguration := destinationLoadBalancerFrontEndIPConfigurationARM.(SubResourceARM)
		result.Properties.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	}
	if virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration != nil {
		destinationNetworkInterfaceIPConfigurationARM, err := (*virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		destinationNetworkInterfaceIPConfiguration := destinationNetworkInterfaceIPConfigurationARM.(SubResourceARM)
		result.Properties.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	}
	if virtualNetworkTapsSpec.DestinationPort != nil {
		destinationPort := *virtualNetworkTapsSpec.DestinationPort
		result.Properties.DestinationPort = &destinationPort
	}

	// Set property ‘Tags’:
	if virtualNetworkTapsSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range virtualNetworkTapsSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = VirtualNetworkTapsSpecTypeMicrosoftNetworkVirtualNetworkTaps
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) CreateEmptyARMValue() interface{} {
	return VirtualNetworkTaps_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworkTaps_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTaps_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	virtualNetworkTapsSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DestinationLoadBalancerFrontEndIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration1 SubResource
		err := destinationLoadBalancerFrontEndIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return err
		}
		destinationLoadBalancerFrontEndIPConfiguration := destinationLoadBalancerFrontEndIPConfiguration1
		virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	}

	// Set property ‘DestinationNetworkInterfaceIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties.DestinationNetworkInterfaceIPConfiguration != nil {
		var destinationNetworkInterfaceIPConfiguration1 SubResource
		err := destinationNetworkInterfaceIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DestinationNetworkInterfaceIPConfiguration)
		if err != nil {
			return err
		}
		destinationNetworkInterfaceIPConfiguration := destinationNetworkInterfaceIPConfiguration1
		virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	}

	// Set property ‘DestinationPort’:
	// copying flattened property:
	if typedInput.Properties.DestinationPort != nil {
		destinationPort := *typedInput.Properties.DestinationPort
		virtualNetworkTapsSpec.DestinationPort = &destinationPort
	}

	// Set property ‘Location’:
	virtualNetworkTapsSpec.Location = typedInput.Location

	// Set property ‘Owner’:
	virtualNetworkTapsSpec.Owner = owner

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualNetworkTapsSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualNetworkTapsSpec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualNetworkTaps_Spec{}

// ConvertSpecFrom populates our VirtualNetworkTaps_Spec from the provided source
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201101storage.VirtualNetworkTaps_Spec)
	if ok {
		// Populate our instance from source
		return virtualNetworkTapsSpec.AssignPropertiesFromVirtualNetworkTapsSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.VirtualNetworkTaps_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = virtualNetworkTapsSpec.AssignPropertiesFromVirtualNetworkTapsSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualNetworkTaps_Spec
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201101storage.VirtualNetworkTaps_Spec)
	if ok {
		// Populate destination from our instance
		return virtualNetworkTapsSpec.AssignPropertiesToVirtualNetworkTapsSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.VirtualNetworkTaps_Spec{}
	err := virtualNetworkTapsSpec.AssignPropertiesToVirtualNetworkTapsSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualNetworkTapsSpec populates our VirtualNetworkTaps_Spec from the provided source VirtualNetworkTaps_Spec
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) AssignPropertiesFromVirtualNetworkTapsSpec(source *v1alpha1api20201101storage.VirtualNetworkTaps_Spec) error {

	// AzureName
	virtualNetworkTapsSpec.AzureName = source.AzureName

	// DestinationLoadBalancerFrontEndIPConfiguration
	if source.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration SubResource
		err := destinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesFromSubResource(source.DestinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationLoadBalancerFrontEndIPConfiguration from DestinationLoadBalancerFrontEndIPConfiguration, calling AssignPropertiesFromSubResource()")
		}
		virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationNetworkInterfaceIPConfiguration
	if source.DestinationNetworkInterfaceIPConfiguration != nil {
		var destinationNetworkInterfaceIPConfiguration SubResource
		err := destinationNetworkInterfaceIPConfiguration.AssignPropertiesFromSubResource(source.DestinationNetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationNetworkInterfaceIPConfiguration from DestinationNetworkInterfaceIPConfiguration, calling AssignPropertiesFromSubResource()")
		}
		virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	} else {
		virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration = nil
	}

	// DestinationPort
	if source.DestinationPort != nil {
		destinationPort := *source.DestinationPort
		virtualNetworkTapsSpec.DestinationPort = &destinationPort
	} else {
		virtualNetworkTapsSpec.DestinationPort = nil
	}

	// Location
	if source.Location != nil {
		virtualNetworkTapsSpec.Location = *source.Location
	} else {
		virtualNetworkTapsSpec.Location = ""
	}

	// Owner
	virtualNetworkTapsSpec.Owner = source.Owner.Copy()

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	virtualNetworkTapsSpec.Tags = tagMap

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTapsSpec populates the provided destination VirtualNetworkTaps_Spec from our VirtualNetworkTaps_Spec
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) AssignPropertiesToVirtualNetworkTapsSpec(destination *v1alpha1api20201101storage.VirtualNetworkTaps_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = virtualNetworkTapsSpec.AzureName

	// DestinationLoadBalancerFrontEndIPConfiguration
	if virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration v1alpha1api20201101storage.SubResource
		err := (*virtualNetworkTapsSpec.DestinationLoadBalancerFrontEndIPConfiguration).AssignPropertiesToSubResource(&destinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationLoadBalancerFrontEndIPConfiguration from DestinationLoadBalancerFrontEndIPConfiguration, calling AssignPropertiesToSubResource()")
		}
		destination.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		destination.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationNetworkInterfaceIPConfiguration
	if virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration != nil {
		var destinationNetworkInterfaceIPConfiguration v1alpha1api20201101storage.SubResource
		err := (*virtualNetworkTapsSpec.DestinationNetworkInterfaceIPConfiguration).AssignPropertiesToSubResource(&destinationNetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating DestinationNetworkInterfaceIPConfiguration from DestinationNetworkInterfaceIPConfiguration, calling AssignPropertiesToSubResource()")
		}
		destination.DestinationNetworkInterfaceIPConfiguration = &destinationNetworkInterfaceIPConfiguration
	} else {
		destination.DestinationNetworkInterfaceIPConfiguration = nil
	}

	// DestinationPort
	if virtualNetworkTapsSpec.DestinationPort != nil {
		destinationPort := *virtualNetworkTapsSpec.DestinationPort
		destination.DestinationPort = &destinationPort
	} else {
		destination.DestinationPort = nil
	}

	// Location
	location := virtualNetworkTapsSpec.Location
	destination.Location = &location

	// OriginalVersion
	destination.OriginalVersion = virtualNetworkTapsSpec.OriginalVersion()

	// Owner
	destination.Owner = virtualNetworkTapsSpec.Owner.Copy()

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range virtualNetworkTapsSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (virtualNetworkTapsSpec *VirtualNetworkTaps_Spec) SetAzureName(azureName string) {
	virtualNetworkTapsSpec.AzureName = azureName
}

//Generated from:
type FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//InboundNatPools: An array of references to inbound pools that use this frontend
	//IP.
	InboundNatPools []SubResource_Status `json:"inboundNatPools,omitempty"`

	//InboundNatRules: An array of references to inbound rules that use this frontend
	//IP.
	InboundNatRules []SubResource_Status `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: An array of references to load balancing rules that use this
	//frontend IP.
	LoadBalancingRules []SubResource_Status `json:"loadBalancingRules,omitempty"`

	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name *string `json:"name,omitempty"`

	//OutboundRules: An array of references to outbound rules that use this frontend
	//IP.
	OutboundRules []SubResource_Status `json:"outboundRules,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_Status `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//ProvisioningState: The provisioning state of the frontend IP configuration
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_Status `json:"publicIPPrefix,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatPools = append(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatRules = append(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancingRules = append(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.OutboundRules = append(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.OutboundRules, item1)
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Zones = append(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates our FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]SubResource_Status, len(source.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool SubResource_Status
		err := inboundNatPool.AssignPropertiesFromSubResourceStatus(&inboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesFromSubResourceStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]SubResource_Status, len(source.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule SubResource_Status
		err := inboundNatRule.AssignPropertiesFromSubResourceStatus(&inboundNatRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule SubResource_Status
		err := loadBalancingRule.AssignPropertiesFromSubResourceStatus(&loadBalancingRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancingRules = loadBalancingRuleList

	// Name
	if source.Name != nil {
		name := *source.Name
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]SubResource_Status, len(source.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule SubResource_Status
		err := outboundRule.AssignPropertiesFromSubResourceStatus(&outboundRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.OutboundRules = outboundRuleList

	// PrivateIPAddress
	if source.PrivateIPAddress != nil {
		privateIPAddress := *source.PrivateIPAddress
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = &publicIPAddress
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResourceStatus(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesFromSubResourceStatus()")
		}
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPPrefix = &publicIPPrefix
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = &subnet
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	} else {
		frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from our FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToFrontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.FrontendIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag != nil {
		etag := *frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool v1alpha1api20201101storage.SubResource_Status
		err := inboundNatPoolItem.AssignPropertiesToSubResourceStatus(&inboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesToSubResourceStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	destination.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule v1alpha1api20201101storage.SubResource_Status
		err := inboundNatRuleItem.AssignPropertiesToSubResourceStatus(&inboundNatRule)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesToSubResourceStatus()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	destination.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule v1alpha1api20201101storage.SubResource_Status
		err := loadBalancingRuleItem.AssignPropertiesToSubResourceStatus(&loadBalancingRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesToSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	destination.LoadBalancingRules = loadBalancingRuleList

	// Name
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name != nil {
		name := *frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule v1alpha1api20201101storage.SubResource_Status
		err := outboundRuleItem.AssignPropertiesToSubResourceStatus(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesToSubResourceStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	destination.OutboundRules = outboundRuleList

	// PrivateIPAddress
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress != nil {
		privateIPAddress := *frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress
		destination.PrivateIPAddress = &privateIPAddress
	} else {
		destination.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress).AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Status
		err := (*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPPrefix).AssignPropertiesToSubResourceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet).AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	if frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type != nil {
		typeVar := *frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Zones
	zoneList := make([]string, len(frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Zones))
	for zoneIndex, zoneItem := range frontendIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//ApplicationGatewayBackendAddressPools: The reference to
	//ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Application security groups in which the IP
	//configuration is included.
	ApplicationSecurityGroups []ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded `json:"applicationSecurityGroups,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//LoadBalancerBackendAddressPools: The reference to LoadBalancerBackendAddressPool
	//resource.
	LoadBalancerBackendAddressPools []BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatRules: A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules []InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded `json:"loadBalancerInboundNatRules,omitempty"`

	//Name: The name of the resource that is unique within a resource group. This name
	//can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Primary: Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddress: Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6.
	//Default is IPv4.
	PrivateIPAddressVersion *IPVersion_Status `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//PrivateLinkConnectionProperties: PrivateLinkConnection properties for the
	//network interface.
	PrivateLinkConnectionProperties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status `json:"privateLinkConnectionProperties,omitempty"`

	//ProvisioningState: The provisioning state of the network interface IP
	//configuration.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	//Subnet: Subnet bound to the IP configuration.
	Subnet *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationGatewayBackendAddressPools = append(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationSecurityGroups = append(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerBackendAddressPools = append(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatRules {
			var item1 InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerInboundNatRules = append(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerInboundNatRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PrivateLinkConnectionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkConnectionProperties != nil {
			var privateLinkConnectionProperties1 NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
			err := privateLinkConnectionProperties1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkConnectionProperties)
			if err != nil {
				return err
			}
			privateLinkConnectionProperties := privateLinkConnectionProperties1
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperties
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates our NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
		err := applicationGatewayBackendAddressPool.AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded
		err := applicationSecurityGroup.AssignPropertiesFromApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded(&applicationSecurityGroupItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesFromApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationSecurityGroups = applicationSecurityGroupList

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
		err := loadBalancerBackendAddressPool.AssignPropertiesFromBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesFromBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatRules
	loadBalancerInboundNatRuleList := make([]InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
	for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
		var loadBalancerInboundNatRule InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded
		err := loadBalancerInboundNatRule.AssignPropertiesFromInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded(&loadBalancerInboundNatRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatRules from LoadBalancerInboundNatRules, calling AssignPropertiesFromInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
	}
	networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList

	// Name
	if source.Name != nil {
		name := *source.Name
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Primary = &primary
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Primary = nil
	}

	// PrivateIPAddress
	if source.PrivateIPAddress != nil {
		privateIPAddress := *source.PrivateIPAddress
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if source.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
		err := privateLinkConnectionProperty.AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(source.PrivateLinkConnectionProperties)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkConnectionProperties from PrivateLinkConnectionProperties, calling AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus()")
		}
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = &publicIPAddress
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = &subnet
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	} else {
		networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded, len(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
		err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(&applicationGatewayBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesToApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]v1alpha1api20201101storage.ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded, len(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup v1alpha1api20201101storage.ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded
		err := applicationSecurityGroupItem.AssignPropertiesToApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded(&applicationSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesToApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	destination.ApplicationSecurityGroups = applicationSecurityGroupList

	// Etag
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag != nil {
		etag := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded, len(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool v1alpha1api20201101storage.BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
		err := loadBalancerBackendAddressPoolItem.AssignPropertiesToBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(&loadBalancerBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesToBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatRules
	loadBalancerInboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded, len(networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerInboundNatRules))
	for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.LoadBalancerInboundNatRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
		var loadBalancerInboundNatRule v1alpha1api20201101storage.InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded
		err := loadBalancerInboundNatRuleItem.AssignPropertiesToInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded(&loadBalancerInboundNatRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatRules from LoadBalancerInboundNatRules, calling AssignPropertiesToInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
	}
	destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList

	// Name
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name != nil {
		name := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Primary
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Primary != nil {
		primary := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress != nil {
		privateIPAddress := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddress
		destination.PrivateIPAddress = &privateIPAddress
	} else {
		destination.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
		err := (*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PrivateLinkConnectionProperties).AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(&privateLinkConnectionProperty)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkConnectionProperties from PrivateLinkConnectionProperties, calling AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus()")
		}
		destination.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		destination.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.PublicIPAddress).AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
		err := (*networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Subnet).AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	if networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type != nil {
		typeVar := *networkInterfaceIPConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates our NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded from our NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded
func (networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded *NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *networkInterfaceTapConfigurationStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//BackendAddresses: Backend addresses.
	BackendAddresses []ApplicationGatewayBackendAddress_Status `json:"backendAddresses,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: Name of the backend address pool that is unique within an Application
	//Gateway.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the backend address pool resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘BackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddresses {
			var item1 ApplicationGatewayBackendAddress_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.BackendAddresses = append(applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.BackendAddresses, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
func (applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// BackendAddresses
	backendAddressList := make([]ApplicationGatewayBackendAddress_Status, len(source.BackendAddresses))
	for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
		// Shadow the loop variable to avoid aliasing
		backendAddressItem := backendAddressItem
		var backendAddress ApplicationGatewayBackendAddress_Status
		err := backendAddress.AssignPropertiesFromApplicationGatewayBackendAddressStatus(&backendAddressItem)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddresses from BackendAddresses, calling AssignPropertiesFromApplicationGatewayBackendAddressStatus()")
		}
		backendAddressList[backendAddressIndex] = backendAddress
	}
	applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.BackendAddresses = backendAddressList

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Etag = &etag
	} else {
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Name = &name
	} else {
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Name = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Type = &typeVar
	} else {
		applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded from our ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
func (applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToApplicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddresses
	backendAddressList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status, len(applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.BackendAddresses))
	for backendAddressIndex, backendAddressItem := range applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.BackendAddresses {
		// Shadow the loop variable to avoid aliasing
		backendAddressItem := backendAddressItem
		var backendAddress v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status
		err := backendAddressItem.AssignPropertiesToApplicationGatewayBackendAddressStatus(&backendAddress)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddresses from BackendAddresses, calling AssignPropertiesToApplicationGatewayBackendAddressStatus()")
		}
		backendAddressList[backendAddressIndex] = backendAddress
	}
	destination.BackendAddresses = backendAddressList

	// Etag
	if applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Etag != nil {
		etag := *applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Name != nil {
		name := *applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// ProvisioningState
	if applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Type != nil {
		typeVar := *applicationGatewayBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded *ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded *ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded populates our ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded
func (applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded *ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded from our ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded
func (applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded *ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToApplicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.ApplicationSecurityGroup_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *applicationSecurityGroupStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded populates our BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
func (backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded from our BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded
func (backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded *BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToBackendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *backendAddressPoolStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded *InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded *InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded populates our InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded
func (inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded *InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded from our InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded
func (inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded *InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToInboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *inboundNatRuleStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status struct {
	//Fqdns: List of FQDNs for current private link connection.
	Fqdns []string `json:"fqdns,omitempty"`

	//GroupId: The group ID for current private link connection.
	GroupId *string `json:"groupId,omitempty"`

	//RequiredMemberName: The required member name for current private link connection.
	RequiredMemberName *string `json:"requiredMemberName,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) CreateEmptyARMValue() interface{} {
	return NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM, got %T", armInput)
	}

	// Set property ‘Fqdns’:
	for _, item := range typedInput.Fqdns {
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.Fqdns = append(networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.Fqdns, item)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.GroupId = &groupId
	}

	// Set property ‘RequiredMemberName’:
	if typedInput.RequiredMemberName != nil {
		requiredMemberName := *typedInput.RequiredMemberName
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.RequiredMemberName = &requiredMemberName
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus populates our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status from the provided source NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
func (networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(source *v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) error {

	// Fqdns
	fqdnList := make([]string, len(source.Fqdns))
	for fqdnIndex, fqdnItem := range source.Fqdns {
		// Shadow the loop variable to avoid aliasing
		fqdnItem := fqdnItem
		fqdnList[fqdnIndex] = fqdnItem
	}
	networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.Fqdns = fqdnList

	// GroupId
	if source.GroupId != nil {
		groupId := *source.GroupId
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.GroupId = &groupId
	} else {
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.GroupId = nil
	}

	// RequiredMemberName
	if source.RequiredMemberName != nil {
		requiredMemberName := *source.RequiredMemberName
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.RequiredMemberName = &requiredMemberName
	} else {
		networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.RequiredMemberName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus populates the provided destination NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status from our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
func (networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(destination *v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdns
	fqdnList := make([]string, len(networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.Fqdns))
	for fqdnIndex, fqdnItem := range networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.Fqdns {
		// Shadow the loop variable to avoid aliasing
		fqdnItem := fqdnItem
		fqdnList[fqdnIndex] = fqdnItem
	}
	destination.Fqdns = fqdnList

	// GroupId
	if networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.GroupId != nil {
		groupId := *networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.GroupId
		destination.GroupId = &groupId
	} else {
		destination.GroupId = nil
	}

	// RequiredMemberName
	if networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.RequiredMemberName != nil {
		requiredMemberName := *networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus.RequiredMemberName
		destination.RequiredMemberName = &requiredMemberName
	} else {
		destination.RequiredMemberName = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Status `json:"sku,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Zones = append(publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded populates our PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
func (publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.ExtendedLocation = &extendedLocation
	} else {
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.ExtendedLocation = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromPublicIPAddressSkuStatus()")
		}
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Sku = &sku
	} else {
		publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded from our PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded
func (publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded *PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToPublicIPAddressStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.PublicIPAddress_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := (*publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	if publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Sku
	if publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Status
		err := (*publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Sku).AssignPropertiesToPublicIPAddressSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToPublicIPAddressSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Zones))
	for zoneIndex, zoneItem := range publicIPAddressStatusVirtualNetworkTapSubResourceEmbedded.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Subnet_Status_VirtualNetworkTap_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_Status_VirtualNetworkTap_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetStatusVirtualNetworkTapSubResourceEmbedded *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) CreateEmptyARMValue() interface{} {
	return Subnet_Status_VirtualNetworkTap_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetStatusVirtualNetworkTapSubResourceEmbedded *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_VirtualNetworkTap_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_VirtualNetworkTap_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded populates our Subnet_Status_VirtualNetworkTap_SubResourceEmbedded from the provided source Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
func (subnetStatusVirtualNetworkTapSubResourceEmbedded *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesFromSubnetStatusVirtualNetworkTapSubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		subnetStatusVirtualNetworkTapSubResourceEmbedded.Id = &id
	} else {
		subnetStatusVirtualNetworkTapSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded populates the provided destination Subnet_Status_VirtualNetworkTap_SubResourceEmbedded from our Subnet_Status_VirtualNetworkTap_SubResourceEmbedded
func (subnetStatusVirtualNetworkTapSubResourceEmbedded *Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) AssignPropertiesToSubnetStatusVirtualNetworkTapSubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Status_VirtualNetworkTap_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if subnetStatusVirtualNetworkTapSubResourceEmbedded.Id != nil {
		id := *subnetStatusVirtualNetworkTapSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ApplicationGatewayBackendAddress_Status struct {
	//Fqdn: Fully qualified domain name (FQDN).
	Fqdn *string `json:"fqdn,omitempty"`

	//IpAddress: IP address.
	IpAddress *string `json:"ipAddress,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddress_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (applicationGatewayBackendAddressStatus *ApplicationGatewayBackendAddress_Status) CreateEmptyARMValue() interface{} {
	return ApplicationGatewayBackendAddress_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (applicationGatewayBackendAddressStatus *ApplicationGatewayBackendAddress_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddress_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddress_StatusARM, got %T", armInput)
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		applicationGatewayBackendAddressStatus.Fqdn = &fqdn
	}

	// Set property ‘IpAddress’:
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		applicationGatewayBackendAddressStatus.IpAddress = &ipAddress
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddressStatus populates our ApplicationGatewayBackendAddress_Status from the provided source ApplicationGatewayBackendAddress_Status
func (applicationGatewayBackendAddressStatus *ApplicationGatewayBackendAddress_Status) AssignPropertiesFromApplicationGatewayBackendAddressStatus(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status) error {

	// Fqdn
	if source.Fqdn != nil {
		fqdn := *source.Fqdn
		applicationGatewayBackendAddressStatus.Fqdn = &fqdn
	} else {
		applicationGatewayBackendAddressStatus.Fqdn = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		ipAddress := *source.IpAddress
		applicationGatewayBackendAddressStatus.IpAddress = &ipAddress
	} else {
		applicationGatewayBackendAddressStatus.IpAddress = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressStatus populates the provided destination ApplicationGatewayBackendAddress_Status from our ApplicationGatewayBackendAddress_Status
func (applicationGatewayBackendAddressStatus *ApplicationGatewayBackendAddress_Status) AssignPropertiesToApplicationGatewayBackendAddressStatus(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	if applicationGatewayBackendAddressStatus.Fqdn != nil {
		fqdn := *applicationGatewayBackendAddressStatus.Fqdn
		destination.Fqdn = &fqdn
	} else {
		destination.Fqdn = nil
	}

	// IpAddress
	if applicationGatewayBackendAddressStatus.IpAddress != nil {
		ipAddress := *applicationGatewayBackendAddressStatus.IpAddress
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&VirtualNetworkTap{}, &VirtualNetworkTapList{})
}
