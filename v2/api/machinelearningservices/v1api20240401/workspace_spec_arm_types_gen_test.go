// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ComputeRuntimeDto_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeRuntimeDto_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeRuntimeDto_ARM, ComputeRuntimeDto_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeRuntimeDto_ARM runs a test to see if a specific instance of ComputeRuntimeDto_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeRuntimeDto_ARM(subject ComputeRuntimeDto_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeRuntimeDto_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeRuntimeDto_ARM instances for property testing - lazily instantiated by
// ComputeRuntimeDto_ARMGenerator()
var computeRuntimeDto_ARMGenerator gopter.Gen

// ComputeRuntimeDto_ARMGenerator returns a generator of ComputeRuntimeDto_ARM instances for property testing.
func ComputeRuntimeDto_ARMGenerator() gopter.Gen {
	if computeRuntimeDto_ARMGenerator != nil {
		return computeRuntimeDto_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeRuntimeDto_ARM(generators)
	computeRuntimeDto_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeRuntimeDto_ARM{}), generators)

	return computeRuntimeDto_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeRuntimeDto_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeRuntimeDto_ARM(gens map[string]gopter.Gen) {
	gens["SparkRuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CosmosDbSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings_ARM, CosmosDbSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings_ARM runs a test to see if a specific instance of CosmosDbSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings_ARM(subject CosmosDbSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings_ARM instances for property testing - lazily instantiated by
// CosmosDbSettings_ARMGenerator()
var cosmosDbSettings_ARMGenerator gopter.Gen

// CosmosDbSettings_ARMGenerator returns a generator of CosmosDbSettings_ARM instances for property testing.
func CosmosDbSettings_ARMGenerator() gopter.Gen {
	if cosmosDbSettings_ARMGenerator != nil {
		return cosmosDbSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings_ARM(generators)
	cosmosDbSettings_ARMGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings_ARM{}), generators)

	return cosmosDbSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings_ARM(gens map[string]gopter.Gen) {
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_EncryptionKeyVaultProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionKeyVaultProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionKeyVaultProperties_ARM, EncryptionKeyVaultProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionKeyVaultProperties_ARM runs a test to see if a specific instance of EncryptionKeyVaultProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionKeyVaultProperties_ARM(subject EncryptionKeyVaultProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionKeyVaultProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionKeyVaultProperties_ARM instances for property testing - lazily instantiated by
// EncryptionKeyVaultProperties_ARMGenerator()
var encryptionKeyVaultProperties_ARMGenerator gopter.Gen

// EncryptionKeyVaultProperties_ARMGenerator returns a generator of EncryptionKeyVaultProperties_ARM instances for property testing.
func EncryptionKeyVaultProperties_ARMGenerator() gopter.Gen {
	if encryptionKeyVaultProperties_ARMGenerator != nil {
		return encryptionKeyVaultProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_ARM(generators)
	encryptionKeyVaultProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionKeyVaultProperties_ARM{}), generators)

	return encryptionKeyVaultProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_ARM(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperty_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty_ARM, EncryptionProperty_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty_ARM runs a test to see if a specific instance of EncryptionProperty_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty_ARM(subject EncryptionProperty_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_ARM instances for property testing - lazily instantiated by
// EncryptionProperty_ARMGenerator()
var encryptionProperty_ARMGenerator gopter.Gen

// EncryptionProperty_ARMGenerator returns a generator of EncryptionProperty_ARM instances for property testing.
func EncryptionProperty_ARMGenerator() gopter.Gen {
	if encryptionProperty_ARMGenerator != nil {
		return encryptionProperty_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionProperty_ARM(generators)
	encryptionProperty_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_ARM{}), generators)

	return encryptionProperty_ARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionProperty_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmk_ARMGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(EncryptionKeyVaultProperties_ARMGenerator())
}

func Test_FeatureStoreSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeatureStoreSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeatureStoreSettings_ARM, FeatureStoreSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeatureStoreSettings_ARM runs a test to see if a specific instance of FeatureStoreSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFeatureStoreSettings_ARM(subject FeatureStoreSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeatureStoreSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeatureStoreSettings_ARM instances for property testing - lazily instantiated by
// FeatureStoreSettings_ARMGenerator()
var featureStoreSettings_ARMGenerator gopter.Gen

// FeatureStoreSettings_ARMGenerator returns a generator of FeatureStoreSettings_ARM instances for property testing.
// We first initialize featureStoreSettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FeatureStoreSettings_ARMGenerator() gopter.Gen {
	if featureStoreSettings_ARMGenerator != nil {
		return featureStoreSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings_ARM(generators)
	featureStoreSettings_ARMGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings_ARM(generators)
	AddRelatedPropertyGeneratorsForFeatureStoreSettings_ARM(generators)
	featureStoreSettings_ARMGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings_ARM{}), generators)

	return featureStoreSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFeatureStoreSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeatureStoreSettings_ARM(gens map[string]gopter.Gen) {
	gens["OfflineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
	gens["OnlineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFeatureStoreSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFeatureStoreSettings_ARM(gens map[string]gopter.Gen) {
	gens["ComputeRuntime"] = gen.PtrOf(ComputeRuntimeDto_ARMGenerator())
}

func Test_FqdnOutboundRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FqdnOutboundRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFqdnOutboundRule_ARM, FqdnOutboundRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFqdnOutboundRule_ARM runs a test to see if a specific instance of FqdnOutboundRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFqdnOutboundRule_ARM(subject FqdnOutboundRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FqdnOutboundRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FqdnOutboundRule_ARM instances for property testing - lazily instantiated by
// FqdnOutboundRule_ARMGenerator()
var fqdnOutboundRule_ARMGenerator gopter.Gen

// FqdnOutboundRule_ARMGenerator returns a generator of FqdnOutboundRule_ARM instances for property testing.
func FqdnOutboundRule_ARMGenerator() gopter.Gen {
	if fqdnOutboundRule_ARMGenerator != nil {
		return fqdnOutboundRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFqdnOutboundRule_ARM(generators)
	fqdnOutboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(FqdnOutboundRule_ARM{}), generators)

	return fqdnOutboundRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFqdnOutboundRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFqdnOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_ARM_Dependency,
		RuleCategory_ARM_Recommended,
		RuleCategory_ARM_Required,
		RuleCategory_ARM_UserDefined))
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_ARM_Active, RuleStatus_ARM_Inactive))
	gens["Type"] = gen.OneConstOf(FqdnOutboundRule_Type_ARM_FQDN)
}

func Test_IdentityForCmk_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk_ARM, IdentityForCmk_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk_ARM runs a test to see if a specific instance of IdentityForCmk_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk_ARM(subject IdentityForCmk_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk_ARM instances for property testing - lazily instantiated by IdentityForCmk_ARMGenerator()
var identityForCmk_ARMGenerator gopter.Gen

// IdentityForCmk_ARMGenerator returns a generator of IdentityForCmk_ARM instances for property testing.
func IdentityForCmk_ARMGenerator() gopter.Gen {
	if identityForCmk_ARMGenerator != nil {
		return identityForCmk_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmk_ARM(generators)
	identityForCmk_ARMGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk_ARM{}), generators)

	return identityForCmk_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmk_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmk_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedNetworkProvisionStatus_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkProvisionStatus_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkProvisionStatus_ARM, ManagedNetworkProvisionStatus_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkProvisionStatus_ARM runs a test to see if a specific instance of ManagedNetworkProvisionStatus_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkProvisionStatus_ARM(subject ManagedNetworkProvisionStatus_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkProvisionStatus_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkProvisionStatus_ARM instances for property testing - lazily instantiated by
// ManagedNetworkProvisionStatus_ARMGenerator()
var managedNetworkProvisionStatus_ARMGenerator gopter.Gen

// ManagedNetworkProvisionStatus_ARMGenerator returns a generator of ManagedNetworkProvisionStatus_ARM instances for property testing.
func ManagedNetworkProvisionStatus_ARMGenerator() gopter.Gen {
	if managedNetworkProvisionStatus_ARMGenerator != nil {
		return managedNetworkProvisionStatus_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_ARM(generators)
	managedNetworkProvisionStatus_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkProvisionStatus_ARM{}), generators)

	return managedNetworkProvisionStatus_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_ARM(gens map[string]gopter.Gen) {
	gens["SparkReady"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ManagedNetworkStatus_ARM_Active, ManagedNetworkStatus_ARM_Inactive))
}

func Test_ManagedNetworkSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkSettings_ARM, ManagedNetworkSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkSettings_ARM runs a test to see if a specific instance of ManagedNetworkSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkSettings_ARM(subject ManagedNetworkSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkSettings_ARM instances for property testing - lazily instantiated by
// ManagedNetworkSettings_ARMGenerator()
var managedNetworkSettings_ARMGenerator gopter.Gen

// ManagedNetworkSettings_ARMGenerator returns a generator of ManagedNetworkSettings_ARM instances for property testing.
// We first initialize managedNetworkSettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedNetworkSettings_ARMGenerator() gopter.Gen {
	if managedNetworkSettings_ARMGenerator != nil {
		return managedNetworkSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings_ARM(generators)
	managedNetworkSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedNetworkSettings_ARM(generators)
	managedNetworkSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings_ARM{}), generators)

	return managedNetworkSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkSettings_ARM(gens map[string]gopter.Gen) {
	gens["IsolationMode"] = gen.PtrOf(gen.OneConstOf(IsolationMode_ARM_AllowInternetOutbound, IsolationMode_ARM_AllowOnlyApprovedOutbound, IsolationMode_ARM_Disabled))
}

// AddRelatedPropertyGeneratorsForManagedNetworkSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedNetworkSettings_ARM(gens map[string]gopter.Gen) {
	gens["OutboundRules"] = gen.MapOf(
		gen.AlphaString(),
		OutboundRule_ARMGenerator())
	gens["Status"] = gen.PtrOf(ManagedNetworkProvisionStatus_ARMGenerator())
}

func Test_ManagedServiceIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_ARM, ManagedServiceIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_ARM runs a test to see if a specific instance of ManagedServiceIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_ARM(subject ManagedServiceIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_ARM instances for property testing - lazily instantiated by
// ManagedServiceIdentity_ARMGenerator()
var managedServiceIdentity_ARMGenerator gopter.Gen

// ManagedServiceIdentity_ARMGenerator returns a generator of ManagedServiceIdentity_ARM instances for property testing.
// We first initialize managedServiceIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_ARMGenerator() gopter.Gen {
	if managedServiceIdentity_ARMGenerator != nil {
		return managedServiceIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	managedServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	managedServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_ARM{}), generators)

	return managedServiceIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_ARM_None,
		ManagedServiceIdentityType_ARM_SystemAssigned,
		ManagedServiceIdentityType_ARM_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_ARM_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetails_ARMGenerator())
}

func Test_OutboundRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_ARM, OutboundRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_ARM runs a test to see if a specific instance of OutboundRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_ARM(subject OutboundRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_ARM instances for property testing - lazily instantiated by OutboundRule_ARMGenerator()
var outboundRule_ARMGenerator gopter.Gen

// OutboundRule_ARMGenerator returns a generator of OutboundRule_ARM instances for property testing.
func OutboundRule_ARMGenerator() gopter.Gen {
	if outboundRule_ARMGenerator != nil {
		return outboundRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOutboundRule_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(OutboundRule_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	outboundRule_ARMGenerator = gen.OneGenOf(gens...)

	return outboundRule_ARMGenerator
}

// AddRelatedPropertyGeneratorsForOutboundRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["FQDN"] = FqdnOutboundRule_ARMGenerator().Map(func(it FqdnOutboundRule_ARM) *FqdnOutboundRule_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["PrivateEndpoint"] = PrivateEndpointOutboundRule_ARMGenerator().Map(func(it PrivateEndpointOutboundRule_ARM) *PrivateEndpointOutboundRule_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceTag"] = ServiceTagOutboundRule_ARMGenerator().Map(func(it ServiceTagOutboundRule_ARM) *ServiceTagOutboundRule_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_PrivateEndpointDestination_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointDestination_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointDestination_ARM, PrivateEndpointDestination_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointDestination_ARM runs a test to see if a specific instance of PrivateEndpointDestination_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointDestination_ARM(subject PrivateEndpointDestination_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointDestination_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointDestination_ARM instances for property testing - lazily instantiated by
// PrivateEndpointDestination_ARMGenerator()
var privateEndpointDestination_ARMGenerator gopter.Gen

// PrivateEndpointDestination_ARMGenerator returns a generator of PrivateEndpointDestination_ARM instances for property testing.
func PrivateEndpointDestination_ARMGenerator() gopter.Gen {
	if privateEndpointDestination_ARMGenerator != nil {
		return privateEndpointDestination_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointDestination_ARM(generators)
	privateEndpointDestination_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointDestination_ARM{}), generators)

	return privateEndpointDestination_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointDestination_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointDestination_ARM(gens map[string]gopter.Gen) {
	gens["ServiceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SparkEnabled"] = gen.PtrOf(gen.Bool())
	gens["SparkStatus"] = gen.PtrOf(gen.OneConstOf(RuleStatus_ARM_Active, RuleStatus_ARM_Inactive))
	gens["SubresourceTarget"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointOutboundRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointOutboundRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointOutboundRule_ARM, PrivateEndpointOutboundRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointOutboundRule_ARM runs a test to see if a specific instance of PrivateEndpointOutboundRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointOutboundRule_ARM(subject PrivateEndpointOutboundRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointOutboundRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointOutboundRule_ARM instances for property testing - lazily instantiated by
// PrivateEndpointOutboundRule_ARMGenerator()
var privateEndpointOutboundRule_ARMGenerator gopter.Gen

// PrivateEndpointOutboundRule_ARMGenerator returns a generator of PrivateEndpointOutboundRule_ARM instances for property testing.
// We first initialize privateEndpointOutboundRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointOutboundRule_ARMGenerator() gopter.Gen {
	if privateEndpointOutboundRule_ARMGenerator != nil {
		return privateEndpointOutboundRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_ARM(generators)
	privateEndpointOutboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_ARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_ARM(generators)
	privateEndpointOutboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule_ARM{}), generators)

	return privateEndpointOutboundRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_ARM_Dependency,
		RuleCategory_ARM_Recommended,
		RuleCategory_ARM_Required,
		RuleCategory_ARM_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_ARM_Active, RuleStatus_ARM_Inactive))
	gens["Type"] = gen.OneConstOf(PrivateEndpointOutboundRule_Type_ARM_PrivateEndpoint)
}

// AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(PrivateEndpointDestination_ARMGenerator())
}

func Test_ServerlessComputeSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessComputeSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessComputeSettings_ARM, ServerlessComputeSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessComputeSettings_ARM runs a test to see if a specific instance of ServerlessComputeSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessComputeSettings_ARM(subject ServerlessComputeSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessComputeSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessComputeSettings_ARM instances for property testing - lazily instantiated by
// ServerlessComputeSettings_ARMGenerator()
var serverlessComputeSettings_ARMGenerator gopter.Gen

// ServerlessComputeSettings_ARMGenerator returns a generator of ServerlessComputeSettings_ARM instances for property testing.
func ServerlessComputeSettings_ARMGenerator() gopter.Gen {
	if serverlessComputeSettings_ARMGenerator != nil {
		return serverlessComputeSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerlessComputeSettings_ARM(generators)
	serverlessComputeSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ServerlessComputeSettings_ARM{}), generators)

	return serverlessComputeSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForServerlessComputeSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerlessComputeSettings_ARM(gens map[string]gopter.Gen) {
	gens["ServerlessComputeCustomSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["ServerlessComputeNoPublicIP"] = gen.PtrOf(gen.Bool())
}

func Test_ServiceManagedResourcesSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings_ARM, ServiceManagedResourcesSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings_ARM runs a test to see if a specific instance of ServiceManagedResourcesSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings_ARM(subject ServiceManagedResourcesSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings_ARM instances for property testing - lazily instantiated by
// ServiceManagedResourcesSettings_ARMGenerator()
var serviceManagedResourcesSettings_ARMGenerator gopter.Gen

// ServiceManagedResourcesSettings_ARMGenerator returns a generator of ServiceManagedResourcesSettings_ARM instances for property testing.
func ServiceManagedResourcesSettings_ARMGenerator() gopter.Gen {
	if serviceManagedResourcesSettings_ARMGenerator != nil {
		return serviceManagedResourcesSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_ARM(generators)
	serviceManagedResourcesSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings_ARM{}), generators)

	return serviceManagedResourcesSettings_ARMGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_ARM(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettings_ARMGenerator())
}

func Test_ServiceTagDestination_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagDestination_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagDestination_ARM, ServiceTagDestination_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagDestination_ARM runs a test to see if a specific instance of ServiceTagDestination_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagDestination_ARM(subject ServiceTagDestination_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagDestination_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagDestination_ARM instances for property testing - lazily instantiated by
// ServiceTagDestination_ARMGenerator()
var serviceTagDestination_ARMGenerator gopter.Gen

// ServiceTagDestination_ARMGenerator returns a generator of ServiceTagDestination_ARM instances for property testing.
func ServiceTagDestination_ARMGenerator() gopter.Gen {
	if serviceTagDestination_ARMGenerator != nil {
		return serviceTagDestination_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagDestination_ARM(generators)
	serviceTagDestination_ARMGenerator = gen.Struct(reflect.TypeOf(ServiceTagDestination_ARM{}), generators)

	return serviceTagDestination_ARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagDestination_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagDestination_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(RuleAction_ARM_Allow, RuleAction_ARM_Deny))
	gens["PortRanges"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceTag"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceTagOutboundRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagOutboundRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagOutboundRule_ARM, ServiceTagOutboundRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagOutboundRule_ARM runs a test to see if a specific instance of ServiceTagOutboundRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagOutboundRule_ARM(subject ServiceTagOutboundRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagOutboundRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagOutboundRule_ARM instances for property testing - lazily instantiated by
// ServiceTagOutboundRule_ARMGenerator()
var serviceTagOutboundRule_ARMGenerator gopter.Gen

// ServiceTagOutboundRule_ARMGenerator returns a generator of ServiceTagOutboundRule_ARM instances for property testing.
// We first initialize serviceTagOutboundRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceTagOutboundRule_ARMGenerator() gopter.Gen {
	if serviceTagOutboundRule_ARMGenerator != nil {
		return serviceTagOutboundRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule_ARM(generators)
	serviceTagOutboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule_ARM(generators)
	AddRelatedPropertyGeneratorsForServiceTagOutboundRule_ARM(generators)
	serviceTagOutboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule_ARM{}), generators)

	return serviceTagOutboundRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagOutboundRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_ARM_Dependency,
		RuleCategory_ARM_Recommended,
		RuleCategory_ARM_Required,
		RuleCategory_ARM_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_ARM_Active, RuleStatus_ARM_Inactive))
	gens["Type"] = gen.OneConstOf(ServiceTagOutboundRule_Type_ARM_ServiceTag)
}

// AddRelatedPropertyGeneratorsForServiceTagOutboundRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceTagOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(ServiceTagDestination_ARMGenerator())
}

func Test_SharedPrivateLinkResourceProperty_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResourceProperty_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceProperty_ARM, SharedPrivateLinkResourceProperty_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceProperty_ARM runs a test to see if a specific instance of SharedPrivateLinkResourceProperty_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceProperty_ARM(subject SharedPrivateLinkResourceProperty_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResourceProperty_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResourceProperty_ARM instances for property testing - lazily instantiated by
// SharedPrivateLinkResourceProperty_ARMGenerator()
var sharedPrivateLinkResourceProperty_ARMGenerator gopter.Gen

// SharedPrivateLinkResourceProperty_ARMGenerator returns a generator of SharedPrivateLinkResourceProperty_ARM instances for property testing.
func SharedPrivateLinkResourceProperty_ARMGenerator() gopter.Gen {
	if sharedPrivateLinkResourceProperty_ARMGenerator != nil {
		return sharedPrivateLinkResourceProperty_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty_ARM(generators)
	sharedPrivateLinkResourceProperty_ARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResourceProperty_ARM{}), generators)

	return sharedPrivateLinkResourceProperty_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty_ARM(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_ARM_Approved,
		PrivateEndpointServiceConnectionStatus_ARM_Disconnected,
		PrivateEndpointServiceConnectionStatus_ARM_Pending,
		PrivateEndpointServiceConnectionStatus_ARM_Rejected,
		PrivateEndpointServiceConnectionStatus_ARM_Timeout))
}

func Test_SharedPrivateLinkResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource_ARM, SharedPrivateLinkResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource_ARM runs a test to see if a specific instance of SharedPrivateLinkResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource_ARM(subject SharedPrivateLinkResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_ARM instances for property testing - lazily instantiated by
// SharedPrivateLinkResource_ARMGenerator()
var sharedPrivateLinkResource_ARMGenerator gopter.Gen

// SharedPrivateLinkResource_ARMGenerator returns a generator of SharedPrivateLinkResource_ARM instances for property testing.
// We first initialize sharedPrivateLinkResource_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResource_ARMGenerator() gopter.Gen {
	if sharedPrivateLinkResource_ARMGenerator != nil {
		return sharedPrivateLinkResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_ARM(generators)
	sharedPrivateLinkResource_ARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_ARM(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_ARM(generators)
	sharedPrivateLinkResource_ARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_ARM{}), generators)

	return sharedPrivateLinkResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SharedPrivateLinkResourceProperty_ARMGenerator())
}

func Test_Sku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_ARM, Sku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_ARM runs a test to see if a specific instance of Sku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_ARM(subject Sku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_ARM instances for property testing - lazily instantiated by Sku_ARMGenerator()
var sku_ARMGenerator gopter.Gen

// Sku_ARMGenerator returns a generator of Sku_ARM instances for property testing.
func Sku_ARMGenerator() gopter.Gen {
	if sku_ARMGenerator != nil {
		return sku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_ARM(generators)
	sku_ARMGenerator = gen.Struct(reflect.TypeOf(Sku_ARM{}), generators)

	return sku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuTier_ARM_Basic,
		SkuTier_ARM_Free,
		SkuTier_ARM_Premium,
		SkuTier_ARM_Standard))
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}

func Test_WorkspaceHubConfig_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceHubConfig_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceHubConfig_ARM, WorkspaceHubConfig_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceHubConfig_ARM runs a test to see if a specific instance of WorkspaceHubConfig_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceHubConfig_ARM(subject WorkspaceHubConfig_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceHubConfig_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceHubConfig_ARM instances for property testing - lazily instantiated by
// WorkspaceHubConfig_ARMGenerator()
var workspaceHubConfig_ARMGenerator gopter.Gen

// WorkspaceHubConfig_ARMGenerator returns a generator of WorkspaceHubConfig_ARM instances for property testing.
func WorkspaceHubConfig_ARMGenerator() gopter.Gen {
	if workspaceHubConfig_ARMGenerator != nil {
		return workspaceHubConfig_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceHubConfig_ARM(generators)
	workspaceHubConfig_ARMGenerator = gen.Struct(reflect.TypeOf(WorkspaceHubConfig_ARM{}), generators)

	return workspaceHubConfig_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceHubConfig_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceHubConfig_ARM(gens map[string]gopter.Gen) {
	gens["AdditionalWorkspaceStorageAccounts"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultWorkspaceResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceProperties_ARM, WorkspaceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceProperties_ARM runs a test to see if a specific instance of WorkspaceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceProperties_ARM(subject WorkspaceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceProperties_ARM instances for property testing - lazily instantiated by
// WorkspaceProperties_ARMGenerator()
var workspaceProperties_ARMGenerator gopter.Gen

// WorkspaceProperties_ARMGenerator returns a generator of WorkspaceProperties_ARM instances for property testing.
// We first initialize workspaceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WorkspaceProperties_ARMGenerator() gopter.Gen {
	if workspaceProperties_ARMGenerator != nil {
		return workspaceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceProperties_ARM(generators)
	workspaceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(WorkspaceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForWorkspaceProperties_ARM(generators)
	workspaceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(WorkspaceProperties_ARM{}), generators)

	return workspaceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceProperties_ARM(gens map[string]gopter.Gen) {
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["ApplicationInsights"] = gen.PtrOf(gen.AlphaString())
	gens["AssociatedWorkspaces"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerRegistry"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["EnableDataIsolation"] = gen.PtrOf(gen.Bool())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["HubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVault"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_ARM_Disabled, WorkspaceProperties_PublicNetworkAccess_ARM_Enabled))
	gens["StorageAccount"] = gen.PtrOf(gen.AlphaString())
	gens["V1LegacyMode"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWorkspaceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceProperties_ARM(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionProperty_ARMGenerator())
	gens["FeatureStoreSettings"] = gen.PtrOf(FeatureStoreSettings_ARMGenerator())
	gens["ManagedNetwork"] = gen.PtrOf(ManagedNetworkSettings_ARMGenerator())
	gens["ServerlessComputeSettings"] = gen.PtrOf(ServerlessComputeSettings_ARMGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettings_ARMGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResource_ARMGenerator())
	gens["WorkspaceHubConfig"] = gen.PtrOf(WorkspaceHubConfig_ARMGenerator())
}

func Test_Workspace_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_Spec_ARM, Workspace_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_Spec_ARM runs a test to see if a specific instance of Workspace_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_Spec_ARM(subject Workspace_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_Spec_ARM instances for property testing - lazily instantiated by Workspace_Spec_ARMGenerator()
var workspace_Spec_ARMGenerator gopter.Gen

// Workspace_Spec_ARMGenerator returns a generator of Workspace_Spec_ARM instances for property testing.
// We first initialize workspace_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_Spec_ARMGenerator() gopter.Gen {
	if workspace_Spec_ARMGenerator != nil {
		return workspace_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec_ARM(generators)
	workspace_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForWorkspace_Spec_ARM(generators)
	workspace_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec_ARM{}), generators)

	return workspace_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspace_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(WorkspaceProperties_ARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_ARMGenerator())
}
