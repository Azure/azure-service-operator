// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ComputeRuntimeDto_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ComputeRuntimeDto to ComputeRuntimeDto via AssignProperties_To_ComputeRuntimeDto & AssignProperties_From_ComputeRuntimeDto returns original",
		prop.ForAll(RunPropertyAssignmentTestForComputeRuntimeDto, ComputeRuntimeDtoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForComputeRuntimeDto tests if a specific instance of ComputeRuntimeDto can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForComputeRuntimeDto(subject ComputeRuntimeDto) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ComputeRuntimeDto
	err := copied.AssignProperties_To_ComputeRuntimeDto(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ComputeRuntimeDto
	err = actual.AssignProperties_From_ComputeRuntimeDto(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ComputeRuntimeDto_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeRuntimeDto via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeRuntimeDto, ComputeRuntimeDtoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeRuntimeDto runs a test to see if a specific instance of ComputeRuntimeDto round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeRuntimeDto(subject ComputeRuntimeDto) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeRuntimeDto
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeRuntimeDto instances for property testing - lazily instantiated by ComputeRuntimeDtoGenerator()
var computeRuntimeDtoGenerator gopter.Gen

// ComputeRuntimeDtoGenerator returns a generator of ComputeRuntimeDto instances for property testing.
func ComputeRuntimeDtoGenerator() gopter.Gen {
	if computeRuntimeDtoGenerator != nil {
		return computeRuntimeDtoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeRuntimeDto(generators)
	computeRuntimeDtoGenerator = gen.Struct(reflect.TypeOf(ComputeRuntimeDto{}), generators)

	return computeRuntimeDtoGenerator
}

// AddIndependentPropertyGeneratorsForComputeRuntimeDto is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeRuntimeDto(gens map[string]gopter.Gen) {
	gens["SparkRuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ComputeRuntimeDto_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ComputeRuntimeDto_STATUS to ComputeRuntimeDto_STATUS via AssignProperties_To_ComputeRuntimeDto_STATUS & AssignProperties_From_ComputeRuntimeDto_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForComputeRuntimeDto_STATUS, ComputeRuntimeDto_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForComputeRuntimeDto_STATUS tests if a specific instance of ComputeRuntimeDto_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForComputeRuntimeDto_STATUS(subject ComputeRuntimeDto_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ComputeRuntimeDto_STATUS
	err := copied.AssignProperties_To_ComputeRuntimeDto_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ComputeRuntimeDto_STATUS
	err = actual.AssignProperties_From_ComputeRuntimeDto_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ComputeRuntimeDto_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeRuntimeDto_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeRuntimeDto_STATUS, ComputeRuntimeDto_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeRuntimeDto_STATUS runs a test to see if a specific instance of ComputeRuntimeDto_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeRuntimeDto_STATUS(subject ComputeRuntimeDto_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeRuntimeDto_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeRuntimeDto_STATUS instances for property testing - lazily instantiated by
// ComputeRuntimeDto_STATUSGenerator()
var computeRuntimeDto_STATUSGenerator gopter.Gen

// ComputeRuntimeDto_STATUSGenerator returns a generator of ComputeRuntimeDto_STATUS instances for property testing.
func ComputeRuntimeDto_STATUSGenerator() gopter.Gen {
	if computeRuntimeDto_STATUSGenerator != nil {
		return computeRuntimeDto_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeRuntimeDto_STATUS(generators)
	computeRuntimeDto_STATUSGenerator = gen.Struct(reflect.TypeOf(ComputeRuntimeDto_STATUS{}), generators)

	return computeRuntimeDto_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForComputeRuntimeDto_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeRuntimeDto_STATUS(gens map[string]gopter.Gen) {
	gens["SparkRuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CosmosDbSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CosmosDbSettings to CosmosDbSettings via AssignProperties_To_CosmosDbSettings & AssignProperties_From_CosmosDbSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbSettings, CosmosDbSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbSettings tests if a specific instance of CosmosDbSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbSettings(subject CosmosDbSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CosmosDbSettings
	err := copied.AssignProperties_To_CosmosDbSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbSettings
	err = actual.AssignProperties_From_CosmosDbSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings, CosmosDbSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings runs a test to see if a specific instance of CosmosDbSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings(subject CosmosDbSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings instances for property testing - lazily instantiated by CosmosDbSettingsGenerator()
var cosmosDbSettingsGenerator gopter.Gen

// CosmosDbSettingsGenerator returns a generator of CosmosDbSettings instances for property testing.
func CosmosDbSettingsGenerator() gopter.Gen {
	if cosmosDbSettingsGenerator != nil {
		return cosmosDbSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings(generators)
	cosmosDbSettingsGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings{}), generators)

	return cosmosDbSettingsGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings(gens map[string]gopter.Gen) {
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_CosmosDbSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CosmosDbSettings_STATUS to CosmosDbSettings_STATUS via AssignProperties_To_CosmosDbSettings_STATUS & AssignProperties_From_CosmosDbSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbSettings_STATUS, CosmosDbSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbSettings_STATUS tests if a specific instance of CosmosDbSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbSettings_STATUS(subject CosmosDbSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CosmosDbSettings_STATUS
	err := copied.AssignProperties_To_CosmosDbSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbSettings_STATUS
	err = actual.AssignProperties_From_CosmosDbSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings_STATUS, CosmosDbSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings_STATUS runs a test to see if a specific instance of CosmosDbSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings_STATUS(subject CosmosDbSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings_STATUS instances for property testing - lazily instantiated by
// CosmosDbSettings_STATUSGenerator()
var cosmosDbSettings_STATUSGenerator gopter.Gen

// CosmosDbSettings_STATUSGenerator returns a generator of CosmosDbSettings_STATUS instances for property testing.
func CosmosDbSettings_STATUSGenerator() gopter.Gen {
	if cosmosDbSettings_STATUSGenerator != nil {
		return cosmosDbSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS(generators)
	cosmosDbSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings_STATUS{}), generators)

	return cosmosDbSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS(gens map[string]gopter.Gen) {
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_EncryptionKeyVaultProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionKeyVaultProperties to EncryptionKeyVaultProperties via AssignProperties_To_EncryptionKeyVaultProperties & AssignProperties_From_EncryptionKeyVaultProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionKeyVaultProperties, EncryptionKeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionKeyVaultProperties tests if a specific instance of EncryptionKeyVaultProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEncryptionKeyVaultProperties(subject EncryptionKeyVaultProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EncryptionKeyVaultProperties
	err := copied.AssignProperties_To_EncryptionKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionKeyVaultProperties
	err = actual.AssignProperties_From_EncryptionKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionKeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionKeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionKeyVaultProperties, EncryptionKeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionKeyVaultProperties runs a test to see if a specific instance of EncryptionKeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionKeyVaultProperties(subject EncryptionKeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionKeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionKeyVaultProperties instances for property testing - lazily instantiated by
// EncryptionKeyVaultPropertiesGenerator()
var encryptionKeyVaultPropertiesGenerator gopter.Gen

// EncryptionKeyVaultPropertiesGenerator returns a generator of EncryptionKeyVaultProperties instances for property testing.
func EncryptionKeyVaultPropertiesGenerator() gopter.Gen {
	if encryptionKeyVaultPropertiesGenerator != nil {
		return encryptionKeyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties(generators)
	encryptionKeyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionKeyVaultProperties{}), generators)

	return encryptionKeyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionKeyVaultProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionKeyVaultProperties_STATUS to EncryptionKeyVaultProperties_STATUS via AssignProperties_To_EncryptionKeyVaultProperties_STATUS & AssignProperties_From_EncryptionKeyVaultProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionKeyVaultProperties_STATUS, EncryptionKeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionKeyVaultProperties_STATUS tests if a specific instance of EncryptionKeyVaultProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEncryptionKeyVaultProperties_STATUS(subject EncryptionKeyVaultProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EncryptionKeyVaultProperties_STATUS
	err := copied.AssignProperties_To_EncryptionKeyVaultProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionKeyVaultProperties_STATUS
	err = actual.AssignProperties_From_EncryptionKeyVaultProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionKeyVaultProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionKeyVaultProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionKeyVaultProperties_STATUS, EncryptionKeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionKeyVaultProperties_STATUS runs a test to see if a specific instance of EncryptionKeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionKeyVaultProperties_STATUS(subject EncryptionKeyVaultProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionKeyVaultProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionKeyVaultProperties_STATUS instances for property testing - lazily instantiated by
// EncryptionKeyVaultProperties_STATUSGenerator()
var encryptionKeyVaultProperties_STATUSGenerator gopter.Gen

// EncryptionKeyVaultProperties_STATUSGenerator returns a generator of EncryptionKeyVaultProperties_STATUS instances for property testing.
func EncryptionKeyVaultProperties_STATUSGenerator() gopter.Gen {
	if encryptionKeyVaultProperties_STATUSGenerator != nil {
		return encryptionKeyVaultProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_STATUS(generators)
	encryptionKeyVaultProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionKeyVaultProperties_STATUS{}), generators)

	return encryptionKeyVaultProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties_STATUS(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperty_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperty to EncryptionProperty via AssignProperties_To_EncryptionProperty & AssignProperties_From_EncryptionProperty returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty tests if a specific instance of EncryptionProperty can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty(subject EncryptionProperty) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EncryptionProperty
	err := copied.AssignProperties_To_EncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty
	err = actual.AssignProperties_From_EncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty runs a test to see if a specific instance of EncryptionProperty round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty(subject EncryptionProperty) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty instances for property testing - lazily instantiated by EncryptionPropertyGenerator()
var encryptionPropertyGenerator gopter.Gen

// EncryptionPropertyGenerator returns a generator of EncryptionProperty instances for property testing.
func EncryptionPropertyGenerator() gopter.Gen {
	if encryptionPropertyGenerator != nil {
		return encryptionPropertyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	return encryptionPropertyGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmkGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(EncryptionKeyVaultPropertiesGenerator())
}

func Test_EncryptionProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperty_STATUS to EncryptionProperty_STATUS via AssignProperties_To_EncryptionProperty_STATUS & AssignProperties_From_EncryptionProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty_STATUS tests if a specific instance of EncryptionProperty_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EncryptionProperty_STATUS
	err := copied.AssignProperties_To_EncryptionProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty_STATUS
	err = actual.AssignProperties_From_EncryptionProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty_STATUS runs a test to see if a specific instance of EncryptionProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_STATUS instances for property testing - lazily instantiated by
// EncryptionProperty_STATUSGenerator()
var encryptionProperty_STATUSGenerator gopter.Gen

// EncryptionProperty_STATUSGenerator returns a generator of EncryptionProperty_STATUS instances for property testing.
// We first initialize encryptionProperty_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperty_STATUSGenerator() gopter.Gen {
	if encryptionProperty_STATUSGenerator != nil {
		return encryptionProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	return encryptionProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_Status_STATUS_Disabled, EncryptionProperty_Status_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmk_STATUSGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(EncryptionKeyVaultProperties_STATUSGenerator())
}

func Test_FeatureStoreSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FeatureStoreSettings to FeatureStoreSettings via AssignProperties_To_FeatureStoreSettings & AssignProperties_From_FeatureStoreSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForFeatureStoreSettings, FeatureStoreSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFeatureStoreSettings tests if a specific instance of FeatureStoreSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFeatureStoreSettings(subject FeatureStoreSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FeatureStoreSettings
	err := copied.AssignProperties_To_FeatureStoreSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FeatureStoreSettings
	err = actual.AssignProperties_From_FeatureStoreSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FeatureStoreSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeatureStoreSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeatureStoreSettings, FeatureStoreSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeatureStoreSettings runs a test to see if a specific instance of FeatureStoreSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForFeatureStoreSettings(subject FeatureStoreSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeatureStoreSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeatureStoreSettings instances for property testing - lazily instantiated by
// FeatureStoreSettingsGenerator()
var featureStoreSettingsGenerator gopter.Gen

// FeatureStoreSettingsGenerator returns a generator of FeatureStoreSettings instances for property testing.
// We first initialize featureStoreSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FeatureStoreSettingsGenerator() gopter.Gen {
	if featureStoreSettingsGenerator != nil {
		return featureStoreSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings(generators)
	featureStoreSettingsGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings(generators)
	AddRelatedPropertyGeneratorsForFeatureStoreSettings(generators)
	featureStoreSettingsGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings{}), generators)

	return featureStoreSettingsGenerator
}

// AddIndependentPropertyGeneratorsForFeatureStoreSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeatureStoreSettings(gens map[string]gopter.Gen) {
	gens["OfflineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
	gens["OnlineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFeatureStoreSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFeatureStoreSettings(gens map[string]gopter.Gen) {
	gens["ComputeRuntime"] = gen.PtrOf(ComputeRuntimeDtoGenerator())
}

func Test_FeatureStoreSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FeatureStoreSettings_STATUS to FeatureStoreSettings_STATUS via AssignProperties_To_FeatureStoreSettings_STATUS & AssignProperties_From_FeatureStoreSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFeatureStoreSettings_STATUS, FeatureStoreSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFeatureStoreSettings_STATUS tests if a specific instance of FeatureStoreSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFeatureStoreSettings_STATUS(subject FeatureStoreSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FeatureStoreSettings_STATUS
	err := copied.AssignProperties_To_FeatureStoreSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FeatureStoreSettings_STATUS
	err = actual.AssignProperties_From_FeatureStoreSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FeatureStoreSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeatureStoreSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeatureStoreSettings_STATUS, FeatureStoreSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeatureStoreSettings_STATUS runs a test to see if a specific instance of FeatureStoreSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFeatureStoreSettings_STATUS(subject FeatureStoreSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeatureStoreSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeatureStoreSettings_STATUS instances for property testing - lazily instantiated by
// FeatureStoreSettings_STATUSGenerator()
var featureStoreSettings_STATUSGenerator gopter.Gen

// FeatureStoreSettings_STATUSGenerator returns a generator of FeatureStoreSettings_STATUS instances for property testing.
// We first initialize featureStoreSettings_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FeatureStoreSettings_STATUSGenerator() gopter.Gen {
	if featureStoreSettings_STATUSGenerator != nil {
		return featureStoreSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings_STATUS(generators)
	featureStoreSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings_STATUS(generators)
	AddRelatedPropertyGeneratorsForFeatureStoreSettings_STATUS(generators)
	featureStoreSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings_STATUS{}), generators)

	return featureStoreSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFeatureStoreSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeatureStoreSettings_STATUS(gens map[string]gopter.Gen) {
	gens["OfflineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
	gens["OnlineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFeatureStoreSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFeatureStoreSettings_STATUS(gens map[string]gopter.Gen) {
	gens["ComputeRuntime"] = gen.PtrOf(ComputeRuntimeDto_STATUSGenerator())
}

func Test_FqdnOutboundRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FqdnOutboundRule to FqdnOutboundRule via AssignProperties_To_FqdnOutboundRule & AssignProperties_From_FqdnOutboundRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForFqdnOutboundRule, FqdnOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFqdnOutboundRule tests if a specific instance of FqdnOutboundRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFqdnOutboundRule(subject FqdnOutboundRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FqdnOutboundRule
	err := copied.AssignProperties_To_FqdnOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FqdnOutboundRule
	err = actual.AssignProperties_From_FqdnOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FqdnOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FqdnOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFqdnOutboundRule, FqdnOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFqdnOutboundRule runs a test to see if a specific instance of FqdnOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForFqdnOutboundRule(subject FqdnOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FqdnOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FqdnOutboundRule instances for property testing - lazily instantiated by FqdnOutboundRuleGenerator()
var fqdnOutboundRuleGenerator gopter.Gen

// FqdnOutboundRuleGenerator returns a generator of FqdnOutboundRule instances for property testing.
func FqdnOutboundRuleGenerator() gopter.Gen {
	if fqdnOutboundRuleGenerator != nil {
		return fqdnOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFqdnOutboundRule(generators)
	fqdnOutboundRuleGenerator = gen.Struct(reflect.TypeOf(FqdnOutboundRule{}), generators)

	return fqdnOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForFqdnOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFqdnOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FqdnOutboundRule_Type_FQDN))
}

func Test_FqdnOutboundRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FqdnOutboundRule_STATUS to FqdnOutboundRule_STATUS via AssignProperties_To_FqdnOutboundRule_STATUS & AssignProperties_From_FqdnOutboundRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFqdnOutboundRule_STATUS, FqdnOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFqdnOutboundRule_STATUS tests if a specific instance of FqdnOutboundRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFqdnOutboundRule_STATUS(subject FqdnOutboundRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FqdnOutboundRule_STATUS
	err := copied.AssignProperties_To_FqdnOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FqdnOutboundRule_STATUS
	err = actual.AssignProperties_From_FqdnOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FqdnOutboundRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FqdnOutboundRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFqdnOutboundRule_STATUS, FqdnOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFqdnOutboundRule_STATUS runs a test to see if a specific instance of FqdnOutboundRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFqdnOutboundRule_STATUS(subject FqdnOutboundRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FqdnOutboundRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FqdnOutboundRule_STATUS instances for property testing - lazily instantiated by
// FqdnOutboundRule_STATUSGenerator()
var fqdnOutboundRule_STATUSGenerator gopter.Gen

// FqdnOutboundRule_STATUSGenerator returns a generator of FqdnOutboundRule_STATUS instances for property testing.
func FqdnOutboundRule_STATUSGenerator() gopter.Gen {
	if fqdnOutboundRule_STATUSGenerator != nil {
		return fqdnOutboundRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFqdnOutboundRule_STATUS(generators)
	fqdnOutboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(FqdnOutboundRule_STATUS{}), generators)

	return fqdnOutboundRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFqdnOutboundRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFqdnOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_STATUS_Dependency,
		RuleCategory_STATUS_Recommended,
		RuleCategory_STATUS_Required,
		RuleCategory_STATUS_UserDefined))
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_STATUS_Active, RuleStatus_STATUS_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FqdnOutboundRule_Type_STATUS_FQDN))
}

func Test_IdentityForCmk_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IdentityForCmk to IdentityForCmk via AssignProperties_To_IdentityForCmk & AssignProperties_From_IdentityForCmk returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityForCmk, IdentityForCmkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityForCmk tests if a specific instance of IdentityForCmk can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIdentityForCmk(subject IdentityForCmk) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IdentityForCmk
	err := copied.AssignProperties_To_IdentityForCmk(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityForCmk
	err = actual.AssignProperties_From_IdentityForCmk(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityForCmk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk, IdentityForCmkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk runs a test to see if a specific instance of IdentityForCmk round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk(subject IdentityForCmk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk instances for property testing - lazily instantiated by IdentityForCmkGenerator()
var identityForCmkGenerator gopter.Gen

// IdentityForCmkGenerator returns a generator of IdentityForCmk instances for property testing.
func IdentityForCmkGenerator() gopter.Gen {
	if identityForCmkGenerator != nil {
		return identityForCmkGenerator
	}

	generators := make(map[string]gopter.Gen)
	identityForCmkGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk{}), generators)

	return identityForCmkGenerator
}

func Test_IdentityForCmk_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IdentityForCmk_STATUS to IdentityForCmk_STATUS via AssignProperties_To_IdentityForCmk_STATUS & AssignProperties_From_IdentityForCmk_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityForCmk_STATUS, IdentityForCmk_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityForCmk_STATUS tests if a specific instance of IdentityForCmk_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIdentityForCmk_STATUS(subject IdentityForCmk_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IdentityForCmk_STATUS
	err := copied.AssignProperties_To_IdentityForCmk_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityForCmk_STATUS
	err = actual.AssignProperties_From_IdentityForCmk_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityForCmk_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk_STATUS, IdentityForCmk_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk_STATUS runs a test to see if a specific instance of IdentityForCmk_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk_STATUS(subject IdentityForCmk_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk_STATUS instances for property testing - lazily instantiated by
// IdentityForCmk_STATUSGenerator()
var identityForCmk_STATUSGenerator gopter.Gen

// IdentityForCmk_STATUSGenerator returns a generator of IdentityForCmk_STATUS instances for property testing.
func IdentityForCmk_STATUSGenerator() gopter.Gen {
	if identityForCmk_STATUSGenerator != nil {
		return identityForCmk_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS(generators)
	identityForCmk_STATUSGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk_STATUS{}), generators)

	return identityForCmk_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedNetworkProvisionStatus_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedNetworkProvisionStatus to ManagedNetworkProvisionStatus via AssignProperties_To_ManagedNetworkProvisionStatus & AssignProperties_From_ManagedNetworkProvisionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedNetworkProvisionStatus, ManagedNetworkProvisionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedNetworkProvisionStatus tests if a specific instance of ManagedNetworkProvisionStatus can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedNetworkProvisionStatus(subject ManagedNetworkProvisionStatus) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedNetworkProvisionStatus
	err := copied.AssignProperties_To_ManagedNetworkProvisionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedNetworkProvisionStatus
	err = actual.AssignProperties_From_ManagedNetworkProvisionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedNetworkProvisionStatus_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkProvisionStatus via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkProvisionStatus, ManagedNetworkProvisionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkProvisionStatus runs a test to see if a specific instance of ManagedNetworkProvisionStatus round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkProvisionStatus(subject ManagedNetworkProvisionStatus) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkProvisionStatus
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkProvisionStatus instances for property testing - lazily instantiated by
// ManagedNetworkProvisionStatusGenerator()
var managedNetworkProvisionStatusGenerator gopter.Gen

// ManagedNetworkProvisionStatusGenerator returns a generator of ManagedNetworkProvisionStatus instances for property testing.
func ManagedNetworkProvisionStatusGenerator() gopter.Gen {
	if managedNetworkProvisionStatusGenerator != nil {
		return managedNetworkProvisionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus(generators)
	managedNetworkProvisionStatusGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkProvisionStatus{}), generators)

	return managedNetworkProvisionStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus(gens map[string]gopter.Gen) {
	gens["SparkReady"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ManagedNetworkStatus_Active, ManagedNetworkStatus_Inactive))
}

func Test_ManagedNetworkProvisionStatus_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedNetworkProvisionStatus_STATUS to ManagedNetworkProvisionStatus_STATUS via AssignProperties_To_ManagedNetworkProvisionStatus_STATUS & AssignProperties_From_ManagedNetworkProvisionStatus_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedNetworkProvisionStatus_STATUS, ManagedNetworkProvisionStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedNetworkProvisionStatus_STATUS tests if a specific instance of ManagedNetworkProvisionStatus_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedNetworkProvisionStatus_STATUS(subject ManagedNetworkProvisionStatus_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedNetworkProvisionStatus_STATUS
	err := copied.AssignProperties_To_ManagedNetworkProvisionStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedNetworkProvisionStatus_STATUS
	err = actual.AssignProperties_From_ManagedNetworkProvisionStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedNetworkProvisionStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkProvisionStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkProvisionStatus_STATUS, ManagedNetworkProvisionStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkProvisionStatus_STATUS runs a test to see if a specific instance of ManagedNetworkProvisionStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkProvisionStatus_STATUS(subject ManagedNetworkProvisionStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkProvisionStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkProvisionStatus_STATUS instances for property testing - lazily instantiated by
// ManagedNetworkProvisionStatus_STATUSGenerator()
var managedNetworkProvisionStatus_STATUSGenerator gopter.Gen

// ManagedNetworkProvisionStatus_STATUSGenerator returns a generator of ManagedNetworkProvisionStatus_STATUS instances for property testing.
func ManagedNetworkProvisionStatus_STATUSGenerator() gopter.Gen {
	if managedNetworkProvisionStatus_STATUSGenerator != nil {
		return managedNetworkProvisionStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_STATUS(generators)
	managedNetworkProvisionStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkProvisionStatus_STATUS{}), generators)

	return managedNetworkProvisionStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus_STATUS(gens map[string]gopter.Gen) {
	gens["SparkReady"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ManagedNetworkStatus_STATUS_Active, ManagedNetworkStatus_STATUS_Inactive))
}

func Test_ManagedNetworkSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedNetworkSettings to ManagedNetworkSettings via AssignProperties_To_ManagedNetworkSettings & AssignProperties_From_ManagedNetworkSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedNetworkSettings, ManagedNetworkSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedNetworkSettings tests if a specific instance of ManagedNetworkSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedNetworkSettings(subject ManagedNetworkSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedNetworkSettings
	err := copied.AssignProperties_To_ManagedNetworkSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedNetworkSettings
	err = actual.AssignProperties_From_ManagedNetworkSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedNetworkSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkSettings, ManagedNetworkSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkSettings runs a test to see if a specific instance of ManagedNetworkSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkSettings(subject ManagedNetworkSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkSettings instances for property testing - lazily instantiated by
// ManagedNetworkSettingsGenerator()
var managedNetworkSettingsGenerator gopter.Gen

// ManagedNetworkSettingsGenerator returns a generator of ManagedNetworkSettings instances for property testing.
// We first initialize managedNetworkSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedNetworkSettingsGenerator() gopter.Gen {
	if managedNetworkSettingsGenerator != nil {
		return managedNetworkSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings(generators)
	managedNetworkSettingsGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings(generators)
	AddRelatedPropertyGeneratorsForManagedNetworkSettings(generators)
	managedNetworkSettingsGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings{}), generators)

	return managedNetworkSettingsGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkSettings(gens map[string]gopter.Gen) {
	gens["IsolationMode"] = gen.PtrOf(gen.OneConstOf(IsolationMode_AllowInternetOutbound, IsolationMode_AllowOnlyApprovedOutbound, IsolationMode_Disabled))
}

// AddRelatedPropertyGeneratorsForManagedNetworkSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedNetworkSettings(gens map[string]gopter.Gen) {
	gens["OutboundRules"] = gen.MapOf(
		gen.AlphaString(),
		OutboundRuleGenerator())
	gens["Status"] = gen.PtrOf(ManagedNetworkProvisionStatusGenerator())
}

func Test_ManagedNetworkSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedNetworkSettings_STATUS to ManagedNetworkSettings_STATUS via AssignProperties_To_ManagedNetworkSettings_STATUS & AssignProperties_From_ManagedNetworkSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedNetworkSettings_STATUS, ManagedNetworkSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedNetworkSettings_STATUS tests if a specific instance of ManagedNetworkSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedNetworkSettings_STATUS(subject ManagedNetworkSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedNetworkSettings_STATUS
	err := copied.AssignProperties_To_ManagedNetworkSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedNetworkSettings_STATUS
	err = actual.AssignProperties_From_ManagedNetworkSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedNetworkSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkSettings_STATUS, ManagedNetworkSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkSettings_STATUS runs a test to see if a specific instance of ManagedNetworkSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkSettings_STATUS(subject ManagedNetworkSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkSettings_STATUS instances for property testing - lazily instantiated by
// ManagedNetworkSettings_STATUSGenerator()
var managedNetworkSettings_STATUSGenerator gopter.Gen

// ManagedNetworkSettings_STATUSGenerator returns a generator of ManagedNetworkSettings_STATUS instances for property testing.
// We first initialize managedNetworkSettings_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedNetworkSettings_STATUSGenerator() gopter.Gen {
	if managedNetworkSettings_STATUSGenerator != nil {
		return managedNetworkSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings_STATUS(generators)
	managedNetworkSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedNetworkSettings_STATUS(generators)
	managedNetworkSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings_STATUS{}), generators)

	return managedNetworkSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkSettings_STATUS(gens map[string]gopter.Gen) {
	gens["IsolationMode"] = gen.PtrOf(gen.OneConstOf(IsolationMode_STATUS_AllowInternetOutbound, IsolationMode_STATUS_AllowOnlyApprovedOutbound, IsolationMode_STATUS_Disabled))
	gens["NetworkId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedNetworkSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedNetworkSettings_STATUS(gens map[string]gopter.Gen) {
	gens["OutboundRules"] = gen.MapOf(
		gen.AlphaString(),
		OutboundRule_STATUSGenerator())
	gens["Status"] = gen.PtrOf(ManagedNetworkProvisionStatus_STATUSGenerator())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_STATUS_None,
		ManagedServiceIdentityType_STATUS_SystemAssigned,
		ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_NotebookPreparationError_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotebookPreparationError_STATUS to NotebookPreparationError_STATUS via AssignProperties_To_NotebookPreparationError_STATUS & AssignProperties_From_NotebookPreparationError_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookPreparationError_STATUS, NotebookPreparationError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookPreparationError_STATUS tests if a specific instance of NotebookPreparationError_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotebookPreparationError_STATUS(subject NotebookPreparationError_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotebookPreparationError_STATUS
	err := copied.AssignProperties_To_NotebookPreparationError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotebookPreparationError_STATUS
	err = actual.AssignProperties_From_NotebookPreparationError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotebookPreparationError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotebookPreparationError_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotebookPreparationError_STATUS, NotebookPreparationError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookPreparationError_STATUS runs a test to see if a specific instance of NotebookPreparationError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookPreparationError_STATUS(subject NotebookPreparationError_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotebookPreparationError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotebookPreparationError_STATUS instances for property testing - lazily instantiated by
// NotebookPreparationError_STATUSGenerator()
var notebookPreparationError_STATUSGenerator gopter.Gen

// NotebookPreparationError_STATUSGenerator returns a generator of NotebookPreparationError_STATUS instances for property testing.
func NotebookPreparationError_STATUSGenerator() gopter.Gen {
	if notebookPreparationError_STATUSGenerator != nil {
		return notebookPreparationError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS(generators)
	notebookPreparationError_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookPreparationError_STATUS{}), generators)

	return notebookPreparationError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS(gens map[string]gopter.Gen) {
	gens["ErrorMessage"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCode"] = gen.PtrOf(gen.Int())
}

func Test_NotebookResourceInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotebookResourceInfo_STATUS to NotebookResourceInfo_STATUS via AssignProperties_To_NotebookResourceInfo_STATUS & AssignProperties_From_NotebookResourceInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookResourceInfo_STATUS, NotebookResourceInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookResourceInfo_STATUS tests if a specific instance of NotebookResourceInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotebookResourceInfo_STATUS(subject NotebookResourceInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotebookResourceInfo_STATUS
	err := copied.AssignProperties_To_NotebookResourceInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotebookResourceInfo_STATUS
	err = actual.AssignProperties_From_NotebookResourceInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotebookResourceInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotebookResourceInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotebookResourceInfo_STATUS, NotebookResourceInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookResourceInfo_STATUS runs a test to see if a specific instance of NotebookResourceInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookResourceInfo_STATUS(subject NotebookResourceInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotebookResourceInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotebookResourceInfo_STATUS instances for property testing - lazily instantiated by
// NotebookResourceInfo_STATUSGenerator()
var notebookResourceInfo_STATUSGenerator gopter.Gen

// NotebookResourceInfo_STATUSGenerator returns a generator of NotebookResourceInfo_STATUS instances for property testing.
// We first initialize notebookResourceInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotebookResourceInfo_STATUSGenerator() gopter.Gen {
	if notebookResourceInfo_STATUSGenerator != nil {
		return notebookResourceInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	notebookResourceInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	notebookResourceInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	return notebookResourceInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS(gens map[string]gopter.Gen) {
	gens["NotebookPreparationError"] = gen.PtrOf(NotebookPreparationError_STATUSGenerator())
}

func Test_OutboundRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule to OutboundRule via AssignProperties_To_OutboundRule & AssignProperties_From_OutboundRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule, OutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule tests if a specific instance of OutboundRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule(subject OutboundRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OutboundRule
	err := copied.AssignProperties_To_OutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule
	err = actual.AssignProperties_From_OutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule, OutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule runs a test to see if a specific instance of OutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule(subject OutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule instances for property testing - lazily instantiated by OutboundRuleGenerator()
var outboundRuleGenerator gopter.Gen

// OutboundRuleGenerator returns a generator of OutboundRule instances for property testing.
func OutboundRuleGenerator() gopter.Gen {
	if outboundRuleGenerator != nil {
		return outboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOutboundRule(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(OutboundRule{}), map[string]gopter.Gen{propName: propGen}))
	}
	outboundRuleGenerator = gen.OneGenOf(gens...)

	return outboundRuleGenerator
}

// AddRelatedPropertyGeneratorsForOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule(gens map[string]gopter.Gen) {
	gens["FQDN"] = FqdnOutboundRuleGenerator().Map(func(it FqdnOutboundRule) *FqdnOutboundRule {
		return &it
	}) // generate one case for OneOf type
	gens["PrivateEndpoint"] = PrivateEndpointOutboundRuleGenerator().Map(func(it PrivateEndpointOutboundRule) *PrivateEndpointOutboundRule {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceTag"] = ServiceTagOutboundRuleGenerator().Map(func(it ServiceTagOutboundRule) *ServiceTagOutboundRule {
		return &it
	}) // generate one case for OneOf type
}

func Test_OutboundRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_STATUS to OutboundRule_STATUS via AssignProperties_To_OutboundRule_STATUS & AssignProperties_From_OutboundRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule_STATUS, OutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule_STATUS tests if a specific instance of OutboundRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule_STATUS(subject OutboundRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OutboundRule_STATUS
	err := copied.AssignProperties_To_OutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_STATUS
	err = actual.AssignProperties_From_OutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_STATUS, OutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_STATUS runs a test to see if a specific instance of OutboundRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_STATUS(subject OutboundRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_STATUS instances for property testing - lazily instantiated by
// OutboundRule_STATUSGenerator()
var outboundRule_STATUSGenerator gopter.Gen

// OutboundRule_STATUSGenerator returns a generator of OutboundRule_STATUS instances for property testing.
func OutboundRule_STATUSGenerator() gopter.Gen {
	if outboundRule_STATUSGenerator != nil {
		return outboundRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOutboundRule_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(OutboundRule_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	outboundRule_STATUSGenerator = gen.OneGenOf(gens...)

	return outboundRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForOutboundRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["FQDN"] = FqdnOutboundRule_STATUSGenerator().Map(func(it FqdnOutboundRule_STATUS) *FqdnOutboundRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["PrivateEndpoint"] = PrivateEndpointOutboundRule_STATUSGenerator().Map(func(it PrivateEndpointOutboundRule_STATUS) *PrivateEndpointOutboundRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceTag"] = ServiceTagOutboundRule_STATUSGenerator().Map(func(it ServiceTagOutboundRule_STATUS) *ServiceTagOutboundRule_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignProperties_To_PrivateEndpointConnection_STATUS & AssignProperties_From_PrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointConnection_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointDestination to PrivateEndpointDestination via AssignProperties_To_PrivateEndpointDestination & AssignProperties_From_PrivateEndpointDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointDestination, PrivateEndpointDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointDestination tests if a specific instance of PrivateEndpointDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointDestination(subject PrivateEndpointDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointDestination
	err := copied.AssignProperties_To_PrivateEndpointDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointDestination
	err = actual.AssignProperties_From_PrivateEndpointDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointDestination, PrivateEndpointDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointDestination runs a test to see if a specific instance of PrivateEndpointDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointDestination(subject PrivateEndpointDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointDestination instances for property testing - lazily instantiated by
// PrivateEndpointDestinationGenerator()
var privateEndpointDestinationGenerator gopter.Gen

// PrivateEndpointDestinationGenerator returns a generator of PrivateEndpointDestination instances for property testing.
func PrivateEndpointDestinationGenerator() gopter.Gen {
	if privateEndpointDestinationGenerator != nil {
		return privateEndpointDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointDestination(generators)
	privateEndpointDestinationGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointDestination{}), generators)

	return privateEndpointDestinationGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointDestination(gens map[string]gopter.Gen) {
	gens["SparkEnabled"] = gen.PtrOf(gen.Bool())
	gens["SparkStatus"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
}

func Test_PrivateEndpointDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointDestination_STATUS to PrivateEndpointDestination_STATUS via AssignProperties_To_PrivateEndpointDestination_STATUS & AssignProperties_From_PrivateEndpointDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointDestination_STATUS, PrivateEndpointDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointDestination_STATUS tests if a specific instance of PrivateEndpointDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointDestination_STATUS(subject PrivateEndpointDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointDestination_STATUS
	err := copied.AssignProperties_To_PrivateEndpointDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointDestination_STATUS
	err = actual.AssignProperties_From_PrivateEndpointDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointDestination_STATUS, PrivateEndpointDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointDestination_STATUS runs a test to see if a specific instance of PrivateEndpointDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointDestination_STATUS(subject PrivateEndpointDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointDestination_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointDestination_STATUSGenerator()
var privateEndpointDestination_STATUSGenerator gopter.Gen

// PrivateEndpointDestination_STATUSGenerator returns a generator of PrivateEndpointDestination_STATUS instances for property testing.
func PrivateEndpointDestination_STATUSGenerator() gopter.Gen {
	if privateEndpointDestination_STATUSGenerator != nil {
		return privateEndpointDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointDestination_STATUS(generators)
	privateEndpointDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointDestination_STATUS{}), generators)

	return privateEndpointDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointDestination_STATUS(gens map[string]gopter.Gen) {
	gens["ServiceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SparkEnabled"] = gen.PtrOf(gen.Bool())
	gens["SparkStatus"] = gen.PtrOf(gen.OneConstOf(RuleStatus_STATUS_Active, RuleStatus_STATUS_Inactive))
	gens["SubresourceTarget"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointOutboundRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointOutboundRule to PrivateEndpointOutboundRule via AssignProperties_To_PrivateEndpointOutboundRule & AssignProperties_From_PrivateEndpointOutboundRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointOutboundRule, PrivateEndpointOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointOutboundRule tests if a specific instance of PrivateEndpointOutboundRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointOutboundRule(subject PrivateEndpointOutboundRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointOutboundRule
	err := copied.AssignProperties_To_PrivateEndpointOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointOutboundRule
	err = actual.AssignProperties_From_PrivateEndpointOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointOutboundRule, PrivateEndpointOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointOutboundRule runs a test to see if a specific instance of PrivateEndpointOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointOutboundRule(subject PrivateEndpointOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointOutboundRule instances for property testing - lazily instantiated by
// PrivateEndpointOutboundRuleGenerator()
var privateEndpointOutboundRuleGenerator gopter.Gen

// PrivateEndpointOutboundRuleGenerator returns a generator of PrivateEndpointOutboundRule instances for property testing.
// We first initialize privateEndpointOutboundRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointOutboundRuleGenerator() gopter.Gen {
	if privateEndpointOutboundRuleGenerator != nil {
		return privateEndpointOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	privateEndpointOutboundRuleGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	privateEndpointOutboundRuleGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule{}), generators)

	return privateEndpointOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointOutboundRule_Type_PrivateEndpoint))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(PrivateEndpointDestinationGenerator())
}

func Test_PrivateEndpointOutboundRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointOutboundRule_STATUS to PrivateEndpointOutboundRule_STATUS via AssignProperties_To_PrivateEndpointOutboundRule_STATUS & AssignProperties_From_PrivateEndpointOutboundRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointOutboundRule_STATUS, PrivateEndpointOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointOutboundRule_STATUS tests if a specific instance of PrivateEndpointOutboundRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointOutboundRule_STATUS(subject PrivateEndpointOutboundRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointOutboundRule_STATUS
	err := copied.AssignProperties_To_PrivateEndpointOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointOutboundRule_STATUS
	err = actual.AssignProperties_From_PrivateEndpointOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointOutboundRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointOutboundRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointOutboundRule_STATUS, PrivateEndpointOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointOutboundRule_STATUS runs a test to see if a specific instance of PrivateEndpointOutboundRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointOutboundRule_STATUS(subject PrivateEndpointOutboundRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointOutboundRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointOutboundRule_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointOutboundRule_STATUSGenerator()
var privateEndpointOutboundRule_STATUSGenerator gopter.Gen

// PrivateEndpointOutboundRule_STATUSGenerator returns a generator of PrivateEndpointOutboundRule_STATUS instances for property testing.
// We first initialize privateEndpointOutboundRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointOutboundRule_STATUSGenerator() gopter.Gen {
	if privateEndpointOutboundRule_STATUSGenerator != nil {
		return privateEndpointOutboundRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS(generators)
	privateEndpointOutboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS(generators)
	privateEndpointOutboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule_STATUS{}), generators)

	return privateEndpointOutboundRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_STATUS_Dependency,
		RuleCategory_STATUS_Recommended,
		RuleCategory_STATUS_Required,
		RuleCategory_STATUS_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_STATUS_Active, RuleStatus_STATUS_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointOutboundRule_Type_STATUS_PrivateEndpoint))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(PrivateEndpointDestination_STATUSGenerator())
}

func Test_ServerlessComputeSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessComputeSettings to ServerlessComputeSettings via AssignProperties_To_ServerlessComputeSettings & AssignProperties_From_ServerlessComputeSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessComputeSettings, ServerlessComputeSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessComputeSettings tests if a specific instance of ServerlessComputeSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServerlessComputeSettings(subject ServerlessComputeSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServerlessComputeSettings
	err := copied.AssignProperties_To_ServerlessComputeSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessComputeSettings
	err = actual.AssignProperties_From_ServerlessComputeSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessComputeSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessComputeSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessComputeSettings, ServerlessComputeSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessComputeSettings runs a test to see if a specific instance of ServerlessComputeSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessComputeSettings(subject ServerlessComputeSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessComputeSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessComputeSettings instances for property testing - lazily instantiated by
// ServerlessComputeSettingsGenerator()
var serverlessComputeSettingsGenerator gopter.Gen

// ServerlessComputeSettingsGenerator returns a generator of ServerlessComputeSettings instances for property testing.
func ServerlessComputeSettingsGenerator() gopter.Gen {
	if serverlessComputeSettingsGenerator != nil {
		return serverlessComputeSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerlessComputeSettings(generators)
	serverlessComputeSettingsGenerator = gen.Struct(reflect.TypeOf(ServerlessComputeSettings{}), generators)

	return serverlessComputeSettingsGenerator
}

// AddIndependentPropertyGeneratorsForServerlessComputeSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerlessComputeSettings(gens map[string]gopter.Gen) {
	gens["ServerlessComputeNoPublicIP"] = gen.PtrOf(gen.Bool())
}

func Test_ServerlessComputeSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessComputeSettings_STATUS to ServerlessComputeSettings_STATUS via AssignProperties_To_ServerlessComputeSettings_STATUS & AssignProperties_From_ServerlessComputeSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessComputeSettings_STATUS, ServerlessComputeSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessComputeSettings_STATUS tests if a specific instance of ServerlessComputeSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServerlessComputeSettings_STATUS(subject ServerlessComputeSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServerlessComputeSettings_STATUS
	err := copied.AssignProperties_To_ServerlessComputeSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessComputeSettings_STATUS
	err = actual.AssignProperties_From_ServerlessComputeSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessComputeSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessComputeSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessComputeSettings_STATUS, ServerlessComputeSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessComputeSettings_STATUS runs a test to see if a specific instance of ServerlessComputeSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessComputeSettings_STATUS(subject ServerlessComputeSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessComputeSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessComputeSettings_STATUS instances for property testing - lazily instantiated by
// ServerlessComputeSettings_STATUSGenerator()
var serverlessComputeSettings_STATUSGenerator gopter.Gen

// ServerlessComputeSettings_STATUSGenerator returns a generator of ServerlessComputeSettings_STATUS instances for property testing.
func ServerlessComputeSettings_STATUSGenerator() gopter.Gen {
	if serverlessComputeSettings_STATUSGenerator != nil {
		return serverlessComputeSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerlessComputeSettings_STATUS(generators)
	serverlessComputeSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ServerlessComputeSettings_STATUS{}), generators)

	return serverlessComputeSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServerlessComputeSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerlessComputeSettings_STATUS(gens map[string]gopter.Gen) {
	gens["ServerlessComputeCustomSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["ServerlessComputeNoPublicIP"] = gen.PtrOf(gen.Bool())
}

func Test_ServiceManagedResourcesSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceManagedResourcesSettings to ServiceManagedResourcesSettings via AssignProperties_To_ServiceManagedResourcesSettings & AssignProperties_From_ServiceManagedResourcesSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceManagedResourcesSettings, ServiceManagedResourcesSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceManagedResourcesSettings tests if a specific instance of ServiceManagedResourcesSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceManagedResourcesSettings(subject ServiceManagedResourcesSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceManagedResourcesSettings
	err := copied.AssignProperties_To_ServiceManagedResourcesSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceManagedResourcesSettings
	err = actual.AssignProperties_From_ServiceManagedResourcesSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceManagedResourcesSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings, ServiceManagedResourcesSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings runs a test to see if a specific instance of ServiceManagedResourcesSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings(subject ServiceManagedResourcesSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings instances for property testing - lazily instantiated by
// ServiceManagedResourcesSettingsGenerator()
var serviceManagedResourcesSettingsGenerator gopter.Gen

// ServiceManagedResourcesSettingsGenerator returns a generator of ServiceManagedResourcesSettings instances for property testing.
func ServiceManagedResourcesSettingsGenerator() gopter.Gen {
	if serviceManagedResourcesSettingsGenerator != nil {
		return serviceManagedResourcesSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(generators)
	serviceManagedResourcesSettingsGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings{}), generators)

	return serviceManagedResourcesSettingsGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettingsGenerator())
}

func Test_ServiceManagedResourcesSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceManagedResourcesSettings_STATUS to ServiceManagedResourcesSettings_STATUS via AssignProperties_To_ServiceManagedResourcesSettings_STATUS & AssignProperties_From_ServiceManagedResourcesSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS, ServiceManagedResourcesSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS tests if a specific instance of ServiceManagedResourcesSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS(subject ServiceManagedResourcesSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceManagedResourcesSettings_STATUS
	err := copied.AssignProperties_To_ServiceManagedResourcesSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceManagedResourcesSettings_STATUS
	err = actual.AssignProperties_From_ServiceManagedResourcesSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceManagedResourcesSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS, ServiceManagedResourcesSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS runs a test to see if a specific instance of ServiceManagedResourcesSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS(subject ServiceManagedResourcesSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings_STATUS instances for property testing - lazily instantiated by
// ServiceManagedResourcesSettings_STATUSGenerator()
var serviceManagedResourcesSettings_STATUSGenerator gopter.Gen

// ServiceManagedResourcesSettings_STATUSGenerator returns a generator of ServiceManagedResourcesSettings_STATUS instances for property testing.
func ServiceManagedResourcesSettings_STATUSGenerator() gopter.Gen {
	if serviceManagedResourcesSettings_STATUSGenerator != nil {
		return serviceManagedResourcesSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS(generators)
	serviceManagedResourcesSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings_STATUS{}), generators)

	return serviceManagedResourcesSettings_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettings_STATUSGenerator())
}

func Test_ServiceTagDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceTagDestination to ServiceTagDestination via AssignProperties_To_ServiceTagDestination & AssignProperties_From_ServiceTagDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceTagDestination, ServiceTagDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceTagDestination tests if a specific instance of ServiceTagDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceTagDestination(subject ServiceTagDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceTagDestination
	err := copied.AssignProperties_To_ServiceTagDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceTagDestination
	err = actual.AssignProperties_From_ServiceTagDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceTagDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagDestination, ServiceTagDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagDestination runs a test to see if a specific instance of ServiceTagDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagDestination(subject ServiceTagDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagDestination instances for property testing - lazily instantiated by
// ServiceTagDestinationGenerator()
var serviceTagDestinationGenerator gopter.Gen

// ServiceTagDestinationGenerator returns a generator of ServiceTagDestination instances for property testing.
func ServiceTagDestinationGenerator() gopter.Gen {
	if serviceTagDestinationGenerator != nil {
		return serviceTagDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagDestination(generators)
	serviceTagDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceTagDestination{}), generators)

	return serviceTagDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagDestination(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(RuleAction_Allow, RuleAction_Deny))
	gens["PortRanges"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceTag"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceTagDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceTagDestination_STATUS to ServiceTagDestination_STATUS via AssignProperties_To_ServiceTagDestination_STATUS & AssignProperties_From_ServiceTagDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceTagDestination_STATUS, ServiceTagDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceTagDestination_STATUS tests if a specific instance of ServiceTagDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceTagDestination_STATUS(subject ServiceTagDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceTagDestination_STATUS
	err := copied.AssignProperties_To_ServiceTagDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceTagDestination_STATUS
	err = actual.AssignProperties_From_ServiceTagDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceTagDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagDestination_STATUS, ServiceTagDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagDestination_STATUS runs a test to see if a specific instance of ServiceTagDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagDestination_STATUS(subject ServiceTagDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagDestination_STATUS instances for property testing - lazily instantiated by
// ServiceTagDestination_STATUSGenerator()
var serviceTagDestination_STATUSGenerator gopter.Gen

// ServiceTagDestination_STATUSGenerator returns a generator of ServiceTagDestination_STATUS instances for property testing.
func ServiceTagDestination_STATUSGenerator() gopter.Gen {
	if serviceTagDestination_STATUSGenerator != nil {
		return serviceTagDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagDestination_STATUS(generators)
	serviceTagDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceTagDestination_STATUS{}), generators)

	return serviceTagDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(RuleAction_STATUS_Allow, RuleAction_STATUS_Deny))
	gens["AddressPrefixes"] = gen.SliceOf(gen.AlphaString())
	gens["PortRanges"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceTag"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceTagOutboundRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceTagOutboundRule to ServiceTagOutboundRule via AssignProperties_To_ServiceTagOutboundRule & AssignProperties_From_ServiceTagOutboundRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceTagOutboundRule, ServiceTagOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceTagOutboundRule tests if a specific instance of ServiceTagOutboundRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceTagOutboundRule(subject ServiceTagOutboundRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceTagOutboundRule
	err := copied.AssignProperties_To_ServiceTagOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceTagOutboundRule
	err = actual.AssignProperties_From_ServiceTagOutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceTagOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagOutboundRule, ServiceTagOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagOutboundRule runs a test to see if a specific instance of ServiceTagOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagOutboundRule(subject ServiceTagOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagOutboundRule instances for property testing - lazily instantiated by
// ServiceTagOutboundRuleGenerator()
var serviceTagOutboundRuleGenerator gopter.Gen

// ServiceTagOutboundRuleGenerator returns a generator of ServiceTagOutboundRule instances for property testing.
// We first initialize serviceTagOutboundRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceTagOutboundRuleGenerator() gopter.Gen {
	if serviceTagOutboundRuleGenerator != nil {
		return serviceTagOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule(generators)
	serviceTagOutboundRuleGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule(generators)
	AddRelatedPropertyGeneratorsForServiceTagOutboundRule(generators)
	serviceTagOutboundRuleGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule{}), generators)

	return serviceTagOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ServiceTagOutboundRule_Type_ServiceTag))
}

// AddRelatedPropertyGeneratorsForServiceTagOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceTagOutboundRule(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(ServiceTagDestinationGenerator())
}

func Test_ServiceTagOutboundRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceTagOutboundRule_STATUS to ServiceTagOutboundRule_STATUS via AssignProperties_To_ServiceTagOutboundRule_STATUS & AssignProperties_From_ServiceTagOutboundRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceTagOutboundRule_STATUS, ServiceTagOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceTagOutboundRule_STATUS tests if a specific instance of ServiceTagOutboundRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceTagOutboundRule_STATUS(subject ServiceTagOutboundRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceTagOutboundRule_STATUS
	err := copied.AssignProperties_To_ServiceTagOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceTagOutboundRule_STATUS
	err = actual.AssignProperties_From_ServiceTagOutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceTagOutboundRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagOutboundRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagOutboundRule_STATUS, ServiceTagOutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagOutboundRule_STATUS runs a test to see if a specific instance of ServiceTagOutboundRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagOutboundRule_STATUS(subject ServiceTagOutboundRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagOutboundRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagOutboundRule_STATUS instances for property testing - lazily instantiated by
// ServiceTagOutboundRule_STATUSGenerator()
var serviceTagOutboundRule_STATUSGenerator gopter.Gen

// ServiceTagOutboundRule_STATUSGenerator returns a generator of ServiceTagOutboundRule_STATUS instances for property testing.
// We first initialize serviceTagOutboundRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceTagOutboundRule_STATUSGenerator() gopter.Gen {
	if serviceTagOutboundRule_STATUSGenerator != nil {
		return serviceTagOutboundRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule_STATUS(generators)
	serviceTagOutboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForServiceTagOutboundRule_STATUS(generators)
	serviceTagOutboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule_STATUS{}), generators)

	return serviceTagOutboundRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagOutboundRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_STATUS_Dependency,
		RuleCategory_STATUS_Recommended,
		RuleCategory_STATUS_Required,
		RuleCategory_STATUS_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_STATUS_Active, RuleStatus_STATUS_Inactive))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ServiceTagOutboundRule_Type_STATUS_ServiceTag))
}

// AddRelatedPropertyGeneratorsForServiceTagOutboundRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceTagOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(ServiceTagDestination_STATUSGenerator())
}

func Test_SharedPrivateLinkResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource to SharedPrivateLinkResource via AssignProperties_To_SharedPrivateLinkResource & AssignProperties_From_SharedPrivateLinkResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResource, SharedPrivateLinkResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResource tests if a specific instance of SharedPrivateLinkResource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResource(subject SharedPrivateLinkResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SharedPrivateLinkResource
	err := copied.AssignProperties_To_SharedPrivateLinkResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource
	err = actual.AssignProperties_From_SharedPrivateLinkResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource, SharedPrivateLinkResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource runs a test to see if a specific instance of SharedPrivateLinkResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource(subject SharedPrivateLinkResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource instances for property testing - lazily instantiated by
// SharedPrivateLinkResourceGenerator()
var sharedPrivateLinkResourceGenerator gopter.Gen

// SharedPrivateLinkResourceGenerator returns a generator of SharedPrivateLinkResource instances for property testing.
func SharedPrivateLinkResourceGenerator() gopter.Gen {
	if sharedPrivateLinkResourceGenerator != nil {
		return sharedPrivateLinkResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(generators)
	sharedPrivateLinkResourceGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource{}), generators)

	return sharedPrivateLinkResourceGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_Approved,
		PrivateEndpointServiceConnectionStatus_Disconnected,
		PrivateEndpointServiceConnectionStatus_Pending,
		PrivateEndpointServiceConnectionStatus_Rejected,
		PrivateEndpointServiceConnectionStatus_Timeout))
}

func Test_SharedPrivateLinkResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource_STATUS to SharedPrivateLinkResource_STATUS via AssignProperties_To_SharedPrivateLinkResource_STATUS & AssignProperties_From_SharedPrivateLinkResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS, SharedPrivateLinkResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS tests if a specific instance of SharedPrivateLinkResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS(subject SharedPrivateLinkResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SharedPrivateLinkResource_STATUS
	err := copied.AssignProperties_To_SharedPrivateLinkResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource_STATUS
	err = actual.AssignProperties_From_SharedPrivateLinkResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource_STATUS, SharedPrivateLinkResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource_STATUS runs a test to see if a specific instance of SharedPrivateLinkResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource_STATUS(subject SharedPrivateLinkResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_STATUS instances for property testing - lazily instantiated by
// SharedPrivateLinkResource_STATUSGenerator()
var sharedPrivateLinkResource_STATUSGenerator gopter.Gen

// SharedPrivateLinkResource_STATUSGenerator returns a generator of SharedPrivateLinkResource_STATUS instances for property testing.
func SharedPrivateLinkResource_STATUSGenerator() gopter.Gen {
	if sharedPrivateLinkResource_STATUSGenerator != nil {
		return sharedPrivateLinkResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS(generators)
	sharedPrivateLinkResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS{}), generators)

	return sharedPrivateLinkResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_STATUS_Approved,
		PrivateEndpointServiceConnectionStatus_STATUS_Disconnected,
		PrivateEndpointServiceConnectionStatus_STATUS_Pending,
		PrivateEndpointServiceConnectionStatus_STATUS_Rejected,
		PrivateEndpointServiceConnectionStatus_STATUS_Timeout))
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignProperties_To_Sku & AssignProperties_From_Sku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku
	err := copied.AssignProperties_To_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignProperties_From_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuTier_Basic,
		SkuTier_Free,
		SkuTier_Premium,
		SkuTier_Standard))
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_STATUS to Sku_STATUS via AssignProperties_To_Sku_STATUS & AssignProperties_From_Sku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku_STATUS
	err := copied.AssignProperties_To_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
	err = actual.AssignProperties_From_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuTier_STATUS_Basic,
		SkuTier_STATUS_Free,
		SkuTier_STATUS_Premium,
		SkuTier_STATUS_Standard))
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignProperties_To_UserAssignedIdentity_STATUS & AssignProperties_From_UserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Workspace_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to hub returns original",
		prop.ForAll(RunResourceConversionTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWorkspace tests if a specific instance of Workspace round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.Workspace
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Workspace
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to Workspace via AssignProperties_To_Workspace & AssignProperties_From_Workspace returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace tests if a specific instance of Workspace can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Workspace
	err := copied.AssignProperties_To_Workspace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace
	err = actual.AssignProperties_From_Workspace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace runs a test to see if a specific instance of Workspace round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace(subject Workspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace instances for property testing - lazily instantiated by WorkspaceGenerator()
var workspaceGenerator gopter.Gen

// WorkspaceGenerator returns a generator of Workspace instances for property testing.
func WorkspaceGenerator() gopter.Gen {
	if workspaceGenerator != nil {
		return workspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspace(generators)
	workspaceGenerator = gen.Struct(reflect.TypeOf(Workspace{}), generators)

	return workspaceGenerator
}

// AddRelatedPropertyGeneratorsForWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace(gens map[string]gopter.Gen) {
	gens["Spec"] = Workspace_SpecGenerator()
	gens["Status"] = Workspace_STATUSGenerator()
}

func Test_WorkspaceHubConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceHubConfig to WorkspaceHubConfig via AssignProperties_To_WorkspaceHubConfig & AssignProperties_From_WorkspaceHubConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceHubConfig, WorkspaceHubConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceHubConfig tests if a specific instance of WorkspaceHubConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceHubConfig(subject WorkspaceHubConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceHubConfig
	err := copied.AssignProperties_To_WorkspaceHubConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceHubConfig
	err = actual.AssignProperties_From_WorkspaceHubConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceHubConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceHubConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceHubConfig, WorkspaceHubConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceHubConfig runs a test to see if a specific instance of WorkspaceHubConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceHubConfig(subject WorkspaceHubConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceHubConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceHubConfig instances for property testing - lazily instantiated by WorkspaceHubConfigGenerator()
var workspaceHubConfigGenerator gopter.Gen

// WorkspaceHubConfigGenerator returns a generator of WorkspaceHubConfig instances for property testing.
func WorkspaceHubConfigGenerator() gopter.Gen {
	if workspaceHubConfigGenerator != nil {
		return workspaceHubConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceHubConfig(generators)
	workspaceHubConfigGenerator = gen.Struct(reflect.TypeOf(WorkspaceHubConfig{}), generators)

	return workspaceHubConfigGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceHubConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceHubConfig(gens map[string]gopter.Gen) {
	gens["AdditionalWorkspaceStorageAccounts"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultWorkspaceResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceHubConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceHubConfig_STATUS to WorkspaceHubConfig_STATUS via AssignProperties_To_WorkspaceHubConfig_STATUS & AssignProperties_From_WorkspaceHubConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceHubConfig_STATUS, WorkspaceHubConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceHubConfig_STATUS tests if a specific instance of WorkspaceHubConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceHubConfig_STATUS(subject WorkspaceHubConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceHubConfig_STATUS
	err := copied.AssignProperties_To_WorkspaceHubConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceHubConfig_STATUS
	err = actual.AssignProperties_From_WorkspaceHubConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceHubConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceHubConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceHubConfig_STATUS, WorkspaceHubConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceHubConfig_STATUS runs a test to see if a specific instance of WorkspaceHubConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceHubConfig_STATUS(subject WorkspaceHubConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceHubConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceHubConfig_STATUS instances for property testing - lazily instantiated by
// WorkspaceHubConfig_STATUSGenerator()
var workspaceHubConfig_STATUSGenerator gopter.Gen

// WorkspaceHubConfig_STATUSGenerator returns a generator of WorkspaceHubConfig_STATUS instances for property testing.
func WorkspaceHubConfig_STATUSGenerator() gopter.Gen {
	if workspaceHubConfig_STATUSGenerator != nil {
		return workspaceHubConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceHubConfig_STATUS(generators)
	workspaceHubConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceHubConfig_STATUS{}), generators)

	return workspaceHubConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceHubConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceHubConfig_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalWorkspaceStorageAccounts"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultWorkspaceResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceOperatorSecrets to WorkspaceOperatorSecrets via AssignProperties_To_WorkspaceOperatorSecrets & AssignProperties_From_WorkspaceOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceOperatorSecrets, WorkspaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceOperatorSecrets tests if a specific instance of WorkspaceOperatorSecrets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceOperatorSecrets(subject WorkspaceOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceOperatorSecrets
	err := copied.AssignProperties_To_WorkspaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceOperatorSecrets
	err = actual.AssignProperties_From_WorkspaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceOperatorSecrets, WorkspaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceOperatorSecrets runs a test to see if a specific instance of WorkspaceOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceOperatorSecrets(subject WorkspaceOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceOperatorSecrets instances for property testing - lazily instantiated by
// WorkspaceOperatorSecretsGenerator()
var workspaceOperatorSecretsGenerator gopter.Gen

// WorkspaceOperatorSecretsGenerator returns a generator of WorkspaceOperatorSecrets instances for property testing.
func WorkspaceOperatorSecretsGenerator() gopter.Gen {
	if workspaceOperatorSecretsGenerator != nil {
		return workspaceOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(WorkspaceOperatorSecrets{}), generators)

	return workspaceOperatorSecretsGenerator
}

func Test_WorkspaceOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceOperatorSpec to WorkspaceOperatorSpec via AssignProperties_To_WorkspaceOperatorSpec & AssignProperties_From_WorkspaceOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceOperatorSpec, WorkspaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceOperatorSpec tests if a specific instance of WorkspaceOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceOperatorSpec(subject WorkspaceOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceOperatorSpec
	err := copied.AssignProperties_To_WorkspaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceOperatorSpec
	err = actual.AssignProperties_From_WorkspaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceOperatorSpec, WorkspaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceOperatorSpec runs a test to see if a specific instance of WorkspaceOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceOperatorSpec(subject WorkspaceOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceOperatorSpec instances for property testing - lazily instantiated by
// WorkspaceOperatorSpecGenerator()
var workspaceOperatorSpecGenerator gopter.Gen

// WorkspaceOperatorSpecGenerator returns a generator of WorkspaceOperatorSpec instances for property testing.
func WorkspaceOperatorSpecGenerator() gopter.Gen {
	if workspaceOperatorSpecGenerator != nil {
		return workspaceOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec(generators)
	workspaceOperatorSpecGenerator = gen.Struct(reflect.TypeOf(WorkspaceOperatorSpec{}), generators)

	return workspaceOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(WorkspaceOperatorSecretsGenerator())
}

func Test_Workspace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace_STATUS to Workspace_STATUS via AssignProperties_To_Workspace_STATUS & AssignProperties_From_Workspace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_STATUS tests if a specific instance of Workspace_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_STATUS(subject Workspace_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Workspace_STATUS
	err := copied.AssignProperties_To_Workspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_STATUS
	err = actual.AssignProperties_From_Workspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_STATUS runs a test to see if a specific instance of Workspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_STATUS(subject Workspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_STATUS instances for property testing - lazily instantiated by Workspace_STATUSGenerator()
var workspace_STATUSGenerator gopter.Gen

// Workspace_STATUSGenerator returns a generator of Workspace_STATUS instances for property testing.
// We first initialize workspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_STATUSGenerator() gopter.Gen {
	if workspace_STATUSGenerator != nil {
		return workspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	return workspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["ApplicationInsights"] = gen.PtrOf(gen.AlphaString())
	gens["AssociatedWorkspaces"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerRegistry"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["EnableDataIsolation"] = gen.PtrOf(gen.Bool())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["HubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVault"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MlFlowTrackingUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkCount"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		WorkspaceProperties_ProvisioningState_STATUS_Canceled,
		WorkspaceProperties_ProvisioningState_STATUS_Creating,
		WorkspaceProperties_ProvisioningState_STATUS_Deleting,
		WorkspaceProperties_ProvisioningState_STATUS_Failed,
		WorkspaceProperties_ProvisioningState_STATUS_Succeeded,
		WorkspaceProperties_ProvisioningState_STATUS_Unknown,
		WorkspaceProperties_ProvisioningState_STATUS_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled, WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled))
	gens["ServiceProvisionedResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccount"] = gen.PtrOf(gen.AlphaString())
	gens["StorageHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["V1LegacyMode"] = gen.PtrOf(gen.Bool())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionProperty_STATUSGenerator())
	gens["FeatureStoreSettings"] = gen.PtrOf(FeatureStoreSettings_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["ManagedNetwork"] = gen.PtrOf(ManagedNetworkSettings_STATUSGenerator())
	gens["NotebookInfo"] = gen.PtrOf(NotebookResourceInfo_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["ServerlessComputeSettings"] = gen.PtrOf(ServerlessComputeSettings_STATUSGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettings_STATUSGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["WorkspaceHubConfig"] = gen.PtrOf(WorkspaceHubConfig_STATUSGenerator())
}

func Test_Workspace_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace_Spec to Workspace_Spec via AssignProperties_To_Workspace_Spec & AssignProperties_From_Workspace_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_Spec tests if a specific instance of Workspace_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Workspace_Spec
	err := copied.AssignProperties_To_Workspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_Spec
	err = actual.AssignProperties_From_Workspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_Spec runs a test to see if a specific instance of Workspace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_Spec instances for property testing - lazily instantiated by Workspace_SpecGenerator()
var workspace_SpecGenerator gopter.Gen

// Workspace_SpecGenerator returns a generator of Workspace_Spec instances for property testing.
// We first initialize workspace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_SpecGenerator() gopter.Gen {
	if workspace_SpecGenerator != nil {
		return workspace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	return workspace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["AssociatedWorkspaces"] = gen.SliceOf(gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["EnableDataIsolation"] = gen.PtrOf(gen.Bool())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_Disabled, WorkspaceProperties_PublicNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["V1LegacyMode"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyGenerator())
	gens["FeatureStoreSettings"] = gen.PtrOf(FeatureStoreSettingsGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["ManagedNetwork"] = gen.PtrOf(ManagedNetworkSettingsGenerator())
	gens["OperatorSpec"] = gen.PtrOf(WorkspaceOperatorSpecGenerator())
	gens["ServerlessComputeSettings"] = gen.PtrOf(ServerlessComputeSettingsGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettingsGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
	gens["WorkspaceHubConfig"] = gen.PtrOf(WorkspaceHubConfigGenerator())
}
