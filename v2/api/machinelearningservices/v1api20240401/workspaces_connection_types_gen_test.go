// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AADAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AADAuthTypeWorkspaceConnectionProperties to AADAuthTypeWorkspaceConnectionProperties via AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties & AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties, AADAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties tests if a specific instance of AADAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties(subject AADAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AADAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AADAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AADAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AADAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties, AADAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of AADAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties(subject AADAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AADAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AADAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// AADAuthTypeWorkspaceConnectionPropertiesGenerator()
var aadAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// AADAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of AADAuthTypeWorkspaceConnectionProperties instances for property testing.
func AADAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if aadAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return aadAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties(generators)
	aadAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AADAuthTypeWorkspaceConnectionProperties{}), generators)

	return aadAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AADAuthTypeWorkspaceConnectionProperties_AuthType_AAD))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AADAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

func Test_AADAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AADAuthTypeWorkspaceConnectionProperties_STATUS to AADAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties_STATUS, AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of AADAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAADAuthTypeWorkspaceConnectionProperties_STATUS(subject AADAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AADAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AADAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AADAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AADAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties_STATUS, AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of AADAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAADAuthTypeWorkspaceConnectionProperties_STATUS(subject AADAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AADAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AADAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var aadAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of AADAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
func AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if aadAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return aadAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	aadAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AADAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return aadAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAADAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AAD))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

func Test_AccessKeyAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccessKeyAuthTypeWorkspaceConnectionProperties to AccessKeyAuthTypeWorkspaceConnectionProperties via AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties & AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties, AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties tests if a specific instance of AccessKeyAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties(subject AccessKeyAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AccessKeyAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccessKeyAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccessKeyAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccessKeyAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties, AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of AccessKeyAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties(subject AccessKeyAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccessKeyAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccessKeyAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator()
var accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of AccessKeyAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties(generators)
	accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AccessKeyAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties(generators)
	accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AccessKeyAuthTypeWorkspaceConnectionProperties{}), generators)

	return accessKeyAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccessKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionAccessKeyGenerator())
}

func Test_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS to AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS, AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(subject AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS, AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(subject AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily
// instantiated by AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return accessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccessKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionAccessKey_STATUSGenerator())
}

func Test_AccountKeyAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccountKeyAuthTypeWorkspaceConnectionProperties to AccountKeyAuthTypeWorkspaceConnectionProperties via AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties & AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties, AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties tests if a specific instance of AccountKeyAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties(subject AccountKeyAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AccountKeyAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccountKeyAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccountKeyAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountKeyAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties, AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of AccountKeyAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties(subject AccountKeyAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountKeyAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountKeyAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator()
var accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of AccountKeyAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties(generators)
	accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountKeyAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties(generators)
	accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AccountKeyAuthTypeWorkspaceConnectionProperties{}), generators)

	return accountKeyAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccountKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionAccountKeyGenerator())
}

func Test_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS to AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS, AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(subject AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS, AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(subject AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily
// instantiated by AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return accountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccountKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionAccountKey_STATUSGenerator())
}

func Test_ApiKeyAuthWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiKeyAuthWorkspaceConnectionProperties to ApiKeyAuthWorkspaceConnectionProperties via AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties & AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties, ApiKeyAuthWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties tests if a specific instance of ApiKeyAuthWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties(subject ApiKeyAuthWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApiKeyAuthWorkspaceConnectionProperties
	err := copied.AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiKeyAuthWorkspaceConnectionProperties
	err = actual.AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiKeyAuthWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiKeyAuthWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties, ApiKeyAuthWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties runs a test to see if a specific instance of ApiKeyAuthWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties(subject ApiKeyAuthWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiKeyAuthWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiKeyAuthWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// ApiKeyAuthWorkspaceConnectionPropertiesGenerator()
var apiKeyAuthWorkspaceConnectionPropertiesGenerator gopter.Gen

// ApiKeyAuthWorkspaceConnectionPropertiesGenerator returns a generator of ApiKeyAuthWorkspaceConnectionProperties instances for property testing.
// We first initialize apiKeyAuthWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiKeyAuthWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if apiKeyAuthWorkspaceConnectionPropertiesGenerator != nil {
		return apiKeyAuthWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties(generators)
	apiKeyAuthWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiKeyAuthWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties(generators)
	apiKeyAuthWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiKeyAuthWorkspaceConnectionProperties{}), generators)

	return apiKeyAuthWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ApiKeyAuthWorkspaceConnectionProperties_AuthType_ApiKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionApiKeyGenerator())
}

func Test_ApiKeyAuthWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiKeyAuthWorkspaceConnectionProperties_STATUS to ApiKeyAuthWorkspaceConnectionProperties_STATUS via AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS & AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties_STATUS, ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties_STATUS tests if a specific instance of ApiKeyAuthWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiKeyAuthWorkspaceConnectionProperties_STATUS(subject ApiKeyAuthWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApiKeyAuthWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiKeyAuthWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiKeyAuthWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiKeyAuthWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties_STATUS, ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of ApiKeyAuthWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiKeyAuthWorkspaceConnectionProperties_STATUS(subject ApiKeyAuthWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiKeyAuthWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiKeyAuthWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator()
var apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator returns a generator of ApiKeyAuthWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator != nil {
		return apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS(generators)
	apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiKeyAuthWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS(generators)
	apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiKeyAuthWorkspaceConnectionProperties_STATUS{}), generators)

	return apiKeyAuthWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS_ApiKey))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiKeyAuthWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionApiKey_STATUSGenerator())
}

func Test_CustomKeys_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomKeys to CustomKeys via AssignProperties_To_CustomKeys & AssignProperties_From_CustomKeys returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomKeys, CustomKeysGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomKeys tests if a specific instance of CustomKeys can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomKeys(subject CustomKeys) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomKeys
	err := copied.AssignProperties_To_CustomKeys(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomKeys
	err = actual.AssignProperties_From_CustomKeys(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomKeys_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomKeys via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomKeys, CustomKeysGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomKeys runs a test to see if a specific instance of CustomKeys round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomKeys(subject CustomKeys) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomKeys
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomKeys instances for property testing - lazily instantiated by CustomKeysGenerator()
var customKeysGenerator gopter.Gen

// CustomKeysGenerator returns a generator of CustomKeys instances for property testing.
func CustomKeysGenerator() gopter.Gen {
	if customKeysGenerator != nil {
		return customKeysGenerator
	}

	generators := make(map[string]gopter.Gen)
	customKeysGenerator = gen.Struct(reflect.TypeOf(CustomKeys{}), generators)

	return customKeysGenerator
}

func Test_CustomKeysWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomKeysWorkspaceConnectionProperties to CustomKeysWorkspaceConnectionProperties via AssignProperties_To_CustomKeysWorkspaceConnectionProperties & AssignProperties_From_CustomKeysWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties, CustomKeysWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties tests if a specific instance of CustomKeysWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties(subject CustomKeysWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomKeysWorkspaceConnectionProperties
	err := copied.AssignProperties_To_CustomKeysWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomKeysWorkspaceConnectionProperties
	err = actual.AssignProperties_From_CustomKeysWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomKeysWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomKeysWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties, CustomKeysWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties runs a test to see if a specific instance of CustomKeysWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties(subject CustomKeysWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomKeysWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomKeysWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// CustomKeysWorkspaceConnectionPropertiesGenerator()
var customKeysWorkspaceConnectionPropertiesGenerator gopter.Gen

// CustomKeysWorkspaceConnectionPropertiesGenerator returns a generator of CustomKeysWorkspaceConnectionProperties instances for property testing.
// We first initialize customKeysWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomKeysWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if customKeysWorkspaceConnectionPropertiesGenerator != nil {
		return customKeysWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties(generators)
	customKeysWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(CustomKeysWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties(generators)
	customKeysWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(CustomKeysWorkspaceConnectionProperties{}), generators)

	return customKeysWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(CustomKeysWorkspaceConnectionProperties_AuthType_CustomKeys))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(CustomKeysWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(CustomKeysGenerator())
}

func Test_CustomKeysWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomKeysWorkspaceConnectionProperties_STATUS to CustomKeysWorkspaceConnectionProperties_STATUS via AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS & AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties_STATUS, CustomKeysWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties_STATUS tests if a specific instance of CustomKeysWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomKeysWorkspaceConnectionProperties_STATUS(subject CustomKeysWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomKeysWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomKeysWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomKeysWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomKeysWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties_STATUS, CustomKeysWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of CustomKeysWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomKeysWorkspaceConnectionProperties_STATUS(subject CustomKeysWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomKeysWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomKeysWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// CustomKeysWorkspaceConnectionProperties_STATUSGenerator()
var customKeysWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// CustomKeysWorkspaceConnectionProperties_STATUSGenerator returns a generator of CustomKeysWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize customKeysWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomKeysWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if customKeysWorkspaceConnectionProperties_STATUSGenerator != nil {
		return customKeysWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS(generators)
	customKeysWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomKeysWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS(generators)
	customKeysWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomKeysWorkspaceConnectionProperties_STATUS{}), generators)

	return customKeysWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(CustomKeysWorkspaceConnectionProperties_AuthType_STATUS_CustomKeys))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomKeysWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(CustomKeys_STATUSGenerator())
}

func Test_CustomKeys_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomKeys_STATUS to CustomKeys_STATUS via AssignProperties_To_CustomKeys_STATUS & AssignProperties_From_CustomKeys_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomKeys_STATUS, CustomKeys_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomKeys_STATUS tests if a specific instance of CustomKeys_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomKeys_STATUS(subject CustomKeys_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomKeys_STATUS
	err := copied.AssignProperties_To_CustomKeys_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomKeys_STATUS
	err = actual.AssignProperties_From_CustomKeys_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomKeys_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomKeys_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomKeys_STATUS, CustomKeys_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomKeys_STATUS runs a test to see if a specific instance of CustomKeys_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomKeys_STATUS(subject CustomKeys_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomKeys_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomKeys_STATUS instances for property testing - lazily instantiated by CustomKeys_STATUSGenerator()
var customKeys_STATUSGenerator gopter.Gen

// CustomKeys_STATUSGenerator returns a generator of CustomKeys_STATUS instances for property testing.
func CustomKeys_STATUSGenerator() gopter.Gen {
	if customKeys_STATUSGenerator != nil {
		return customKeys_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomKeys_STATUS(generators)
	customKeys_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomKeys_STATUS{}), generators)

	return customKeys_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomKeys_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomKeys_STATUS(gens map[string]gopter.Gen) {
	gens["Keys"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_ManagedIdentityAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentityAuthTypeWorkspaceConnectionProperties to ManagedIdentityAuthTypeWorkspaceConnectionProperties via AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties & AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties, ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties tests if a specific instance of ManagedIdentityAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties(subject ManagedIdentityAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentityAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentityAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties, ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of ManagedIdentityAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties(subject ManagedIdentityAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityAuthTypeWorkspaceConnectionProperties instances for property testing - lazily
// instantiated by ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator()
var managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of ManagedIdentityAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties(generators)
	managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties(generators)
	managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties{}), generators)

	return managedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_ManagedIdentity))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionManagedIdentityGenerator())
}

func Test_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS to ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS, ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(subject ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS, ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(subject ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily
// instantiated by ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return managedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ManagedIdentity))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionManagedIdentity_STATUSGenerator())
}

func Test_NoneAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NoneAuthTypeWorkspaceConnectionProperties to NoneAuthTypeWorkspaceConnectionProperties via AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties & AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties, NoneAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties tests if a specific instance of NoneAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties(subject NoneAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NoneAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NoneAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NoneAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NoneAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties, NoneAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of NoneAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties(subject NoneAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NoneAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NoneAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// NoneAuthTypeWorkspaceConnectionPropertiesGenerator()
var noneAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// NoneAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of NoneAuthTypeWorkspaceConnectionProperties instances for property testing.
func NoneAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if noneAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return noneAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties(generators)
	noneAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(NoneAuthTypeWorkspaceConnectionProperties{}), generators)

	return noneAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(NoneAuthTypeWorkspaceConnectionProperties_AuthType_None))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

func Test_NoneAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NoneAuthTypeWorkspaceConnectionProperties_STATUS to NoneAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS, NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of NoneAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS(subject NoneAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NoneAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NoneAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NoneAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NoneAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS, NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of NoneAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNoneAuthTypeWorkspaceConnectionProperties_STATUS(subject NoneAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NoneAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NoneAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var noneAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of NoneAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
func NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if noneAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return noneAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	noneAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NoneAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return noneAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNoneAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_None))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

func Test_OAuth2AuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OAuth2AuthTypeWorkspaceConnectionProperties to OAuth2AuthTypeWorkspaceConnectionProperties via AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties & AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties, OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties tests if a specific instance of OAuth2AuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties(subject OAuth2AuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OAuth2AuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OAuth2AuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OAuth2AuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OAuth2AuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties, OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of OAuth2AuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties(subject OAuth2AuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OAuth2AuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OAuth2AuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator()
var oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of OAuth2AuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties(generators)
	oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(OAuth2AuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties(generators)
	oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(OAuth2AuthTypeWorkspaceConnectionProperties{}), generators)

	return oAuth2AuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_OAuth2))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionOAuth2Generator())
}

func Test_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OAuth2AuthTypeWorkspaceConnectionProperties_STATUS to OAuth2AuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS, OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of OAuth2AuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(subject OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OAuth2AuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS, OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of OAuth2AuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(subject OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OAuth2AuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated
// by OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of OAuth2AuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(generators)
	oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(OAuth2AuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(generators)
	oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(OAuth2AuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return oAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS_OAuth2))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOAuth2AuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionOAuth2_STATUSGenerator())
}

func Test_PATAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PATAuthTypeWorkspaceConnectionProperties to PATAuthTypeWorkspaceConnectionProperties via AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties & AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties, PATAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties tests if a specific instance of PATAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties(subject PATAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PATAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PATAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PATAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PATAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties, PATAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of PATAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties(subject PATAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PATAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PATAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// PATAuthTypeWorkspaceConnectionPropertiesGenerator()
var patAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// PATAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of PATAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize patAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PATAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if patAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return patAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties(generators)
	patAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(PATAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties(generators)
	patAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(PATAuthTypeWorkspaceConnectionProperties{}), generators)

	return patAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(PATAuthTypeWorkspaceConnectionProperties_AuthType_PAT))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(PATAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionPersonalAccessTokenGenerator())
}

func Test_PATAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PATAuthTypeWorkspaceConnectionProperties_STATUS to PATAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties_STATUS, PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of PATAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPATAuthTypeWorkspaceConnectionProperties_STATUS(subject PATAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PATAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PATAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PATAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PATAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties_STATUS, PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of PATAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPATAuthTypeWorkspaceConnectionProperties_STATUS(subject PATAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PATAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PATAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var patAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of PATAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize patAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if patAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return patAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	patAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(PATAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	patAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(PATAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return patAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_PAT))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPATAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionPersonalAccessToken_STATUSGenerator())
}

func Test_SASAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SASAuthTypeWorkspaceConnectionProperties to SASAuthTypeWorkspaceConnectionProperties via AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties & AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties, SASAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties tests if a specific instance of SASAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties(subject SASAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SASAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SASAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SASAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SASAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties, SASAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of SASAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties(subject SASAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SASAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SASAuthTypeWorkspaceConnectionProperties instances for property testing - lazily instantiated by
// SASAuthTypeWorkspaceConnectionPropertiesGenerator()
var sasAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// SASAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of SASAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize sasAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SASAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if sasAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return sasAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties(generators)
	sasAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(SASAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties(generators)
	sasAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(SASAuthTypeWorkspaceConnectionProperties{}), generators)

	return sasAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(SASAuthTypeWorkspaceConnectionProperties_AuthType_SAS))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(SASAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionSharedAccessSignatureGenerator())
}

func Test_SASAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SASAuthTypeWorkspaceConnectionProperties_STATUS to SASAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties_STATUS, SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of SASAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSASAuthTypeWorkspaceConnectionProperties_STATUS(subject SASAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SASAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SASAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SASAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SASAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties_STATUS, SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of SASAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSASAuthTypeWorkspaceConnectionProperties_STATUS(subject SASAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SASAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SASAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily instantiated by
// SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of SASAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(SASAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(SASAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return sasAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_SAS))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSASAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionSharedAccessSignature_STATUSGenerator())
}

func Test_ServicePrincipalAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalAuthTypeWorkspaceConnectionProperties to ServicePrincipalAuthTypeWorkspaceConnectionProperties via AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties & AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties, ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties tests if a specific instance of ServicePrincipalAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties(subject ServicePrincipalAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties, ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of ServicePrincipalAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties(subject ServicePrincipalAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalAuthTypeWorkspaceConnectionProperties instances for property testing - lazily
// instantiated by ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator()
var servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of ServicePrincipalAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties(generators)
	servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties(generators)
	servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties{}), generators)

	return servicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_ServicePrincipal))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionServicePrincipalGenerator())
}

func Test_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS to ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS, ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(subject ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS, ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(subject ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily
// instantiated by ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return servicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ServicePrincipal))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionServicePrincipal_STATUSGenerator())
}

func Test_UsernamePasswordAuthTypeWorkspaceConnectionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UsernamePasswordAuthTypeWorkspaceConnectionProperties to UsernamePasswordAuthTypeWorkspaceConnectionProperties via AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties & AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties, UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties tests if a specific instance of UsernamePasswordAuthTypeWorkspaceConnectionProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties(subject UsernamePasswordAuthTypeWorkspaceConnectionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties
	err := copied.AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UsernamePasswordAuthTypeWorkspaceConnectionProperties
	err = actual.AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UsernamePasswordAuthTypeWorkspaceConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UsernamePasswordAuthTypeWorkspaceConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties, UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties runs a test to see if a specific instance of UsernamePasswordAuthTypeWorkspaceConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties(subject UsernamePasswordAuthTypeWorkspaceConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UsernamePasswordAuthTypeWorkspaceConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UsernamePasswordAuthTypeWorkspaceConnectionProperties instances for property testing - lazily
// instantiated by UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator()
var usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator gopter.Gen

// UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator returns a generator of UsernamePasswordAuthTypeWorkspaceConnectionProperties instances for property testing.
// We first initialize usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator() gopter.Gen {
	if usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator != nil {
		return usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties(generators)
	usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties(generators)
	AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties(generators)
	usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties{}), generators)

	return usernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_UsernamePassword))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_ADLSGen2,
		ConnectionCategory_AIServices,
		ConnectionCategory_AmazonMws,
		ConnectionCategory_AmazonRdsForOracle,
		ConnectionCategory_AmazonRdsForSqlServer,
		ConnectionCategory_AmazonRedshift,
		ConnectionCategory_AmazonS3Compatible,
		ConnectionCategory_ApiKey,
		ConnectionCategory_AzureBlob,
		ConnectionCategory_AzureDataExplorer,
		ConnectionCategory_AzureDatabricksDeltaLake,
		ConnectionCategory_AzureMariaDb,
		ConnectionCategory_AzureMySqlDb,
		ConnectionCategory_AzureOneLake,
		ConnectionCategory_AzureOpenAI,
		ConnectionCategory_AzurePostgresDb,
		ConnectionCategory_AzureSqlDb,
		ConnectionCategory_AzureSqlMi,
		ConnectionCategory_AzureSynapseAnalytics,
		ConnectionCategory_AzureTableStorage,
		ConnectionCategory_BingLLMSearch,
		ConnectionCategory_Cassandra,
		ConnectionCategory_CognitiveSearch,
		ConnectionCategory_CognitiveService,
		ConnectionCategory_Concur,
		ConnectionCategory_ContainerRegistry,
		ConnectionCategory_CosmosDb,
		ConnectionCategory_CosmosDbMongoDbApi,
		ConnectionCategory_Couchbase,
		ConnectionCategory_CustomKeys,
		ConnectionCategory_Db2,
		ConnectionCategory_Drill,
		ConnectionCategory_Dynamics,
		ConnectionCategory_DynamicsAx,
		ConnectionCategory_DynamicsCrm,
		ConnectionCategory_Eloqua,
		ConnectionCategory_FileServer,
		ConnectionCategory_FtpServer,
		ConnectionCategory_GenericContainerRegistry,
		ConnectionCategory_GenericHttp,
		ConnectionCategory_GenericRest,
		ConnectionCategory_Git,
		ConnectionCategory_GoogleAdWords,
		ConnectionCategory_GoogleBigQuery,
		ConnectionCategory_GoogleCloudStorage,
		ConnectionCategory_Greenplum,
		ConnectionCategory_Hbase,
		ConnectionCategory_Hdfs,
		ConnectionCategory_Hive,
		ConnectionCategory_Hubspot,
		ConnectionCategory_Impala,
		ConnectionCategory_Informix,
		ConnectionCategory_Jira,
		ConnectionCategory_Magento,
		ConnectionCategory_MariaDb,
		ConnectionCategory_Marketo,
		ConnectionCategory_MicrosoftAccess,
		ConnectionCategory_MongoDbAtlas,
		ConnectionCategory_MongoDbV2,
		ConnectionCategory_MySql,
		ConnectionCategory_Netezza,
		ConnectionCategory_ODataRest,
		ConnectionCategory_Odbc,
		ConnectionCategory_Office365,
		ConnectionCategory_OpenAI,
		ConnectionCategory_Oracle,
		ConnectionCategory_OracleCloudStorage,
		ConnectionCategory_OracleServiceCloud,
		ConnectionCategory_PayPal,
		ConnectionCategory_Phoenix,
		ConnectionCategory_PostgreSql,
		ConnectionCategory_Presto,
		ConnectionCategory_PythonFeed,
		ConnectionCategory_QuickBooks,
		ConnectionCategory_Redis,
		ConnectionCategory_Responsys,
		ConnectionCategory_S3,
		ConnectionCategory_Salesforce,
		ConnectionCategory_SalesforceMarketingCloud,
		ConnectionCategory_SalesforceServiceCloud,
		ConnectionCategory_SapBw,
		ConnectionCategory_SapCloudForCustomer,
		ConnectionCategory_SapEcc,
		ConnectionCategory_SapHana,
		ConnectionCategory_SapOpenHub,
		ConnectionCategory_SapTable,
		ConnectionCategory_Serp,
		ConnectionCategory_Serverless,
		ConnectionCategory_ServiceNow,
		ConnectionCategory_Sftp,
		ConnectionCategory_SharePointOnlineList,
		ConnectionCategory_Shopify,
		ConnectionCategory_Snowflake,
		ConnectionCategory_Spark,
		ConnectionCategory_SqlServer,
		ConnectionCategory_Square,
		ConnectionCategory_Sybase,
		ConnectionCategory_Teradata,
		ConnectionCategory_Vertica,
		ConnectionCategory_WebTable,
		ConnectionCategory_Xero,
		ConnectionCategory_Zoho))
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON))
}

// AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionUsernamePasswordGenerator())
}

func Test_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS to UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS via AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS & AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS, UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS tests if a specific instance of UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(subject UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
	err := copied.AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
	err = actual.AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS, UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS runs a test to see if a specific instance of UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(subject UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing - lazily
// instantiated by UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator()
var usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator gopter.Gen

// UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator returns a generator of UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS instances for property testing.
// We first initialize usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator() gopter.Gen {
	if usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator != nil {
		return usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(generators)
	usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS{}), generators)

	return usernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthType"] = gen.PtrOf(gen.OneConstOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_UsernamePassword))
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		ConnectionCategory_STATUS_ADLSGen2,
		ConnectionCategory_STATUS_AIServices,
		ConnectionCategory_STATUS_AmazonMws,
		ConnectionCategory_STATUS_AmazonRdsForOracle,
		ConnectionCategory_STATUS_AmazonRdsForSqlServer,
		ConnectionCategory_STATUS_AmazonRedshift,
		ConnectionCategory_STATUS_AmazonS3Compatible,
		ConnectionCategory_STATUS_ApiKey,
		ConnectionCategory_STATUS_AzureBlob,
		ConnectionCategory_STATUS_AzureDataExplorer,
		ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
		ConnectionCategory_STATUS_AzureMariaDb,
		ConnectionCategory_STATUS_AzureMySqlDb,
		ConnectionCategory_STATUS_AzureOneLake,
		ConnectionCategory_STATUS_AzureOpenAI,
		ConnectionCategory_STATUS_AzurePostgresDb,
		ConnectionCategory_STATUS_AzureSqlDb,
		ConnectionCategory_STATUS_AzureSqlMi,
		ConnectionCategory_STATUS_AzureSynapseAnalytics,
		ConnectionCategory_STATUS_AzureTableStorage,
		ConnectionCategory_STATUS_BingLLMSearch,
		ConnectionCategory_STATUS_Cassandra,
		ConnectionCategory_STATUS_CognitiveSearch,
		ConnectionCategory_STATUS_CognitiveService,
		ConnectionCategory_STATUS_Concur,
		ConnectionCategory_STATUS_ContainerRegistry,
		ConnectionCategory_STATUS_CosmosDb,
		ConnectionCategory_STATUS_CosmosDbMongoDbApi,
		ConnectionCategory_STATUS_Couchbase,
		ConnectionCategory_STATUS_CustomKeys,
		ConnectionCategory_STATUS_Db2,
		ConnectionCategory_STATUS_Drill,
		ConnectionCategory_STATUS_Dynamics,
		ConnectionCategory_STATUS_DynamicsAx,
		ConnectionCategory_STATUS_DynamicsCrm,
		ConnectionCategory_STATUS_Eloqua,
		ConnectionCategory_STATUS_FileServer,
		ConnectionCategory_STATUS_FtpServer,
		ConnectionCategory_STATUS_GenericContainerRegistry,
		ConnectionCategory_STATUS_GenericHttp,
		ConnectionCategory_STATUS_GenericRest,
		ConnectionCategory_STATUS_Git,
		ConnectionCategory_STATUS_GoogleAdWords,
		ConnectionCategory_STATUS_GoogleBigQuery,
		ConnectionCategory_STATUS_GoogleCloudStorage,
		ConnectionCategory_STATUS_Greenplum,
		ConnectionCategory_STATUS_Hbase,
		ConnectionCategory_STATUS_Hdfs,
		ConnectionCategory_STATUS_Hive,
		ConnectionCategory_STATUS_Hubspot,
		ConnectionCategory_STATUS_Impala,
		ConnectionCategory_STATUS_Informix,
		ConnectionCategory_STATUS_Jira,
		ConnectionCategory_STATUS_Magento,
		ConnectionCategory_STATUS_MariaDb,
		ConnectionCategory_STATUS_Marketo,
		ConnectionCategory_STATUS_MicrosoftAccess,
		ConnectionCategory_STATUS_MongoDbAtlas,
		ConnectionCategory_STATUS_MongoDbV2,
		ConnectionCategory_STATUS_MySql,
		ConnectionCategory_STATUS_Netezza,
		ConnectionCategory_STATUS_ODataRest,
		ConnectionCategory_STATUS_Odbc,
		ConnectionCategory_STATUS_Office365,
		ConnectionCategory_STATUS_OpenAI,
		ConnectionCategory_STATUS_Oracle,
		ConnectionCategory_STATUS_OracleCloudStorage,
		ConnectionCategory_STATUS_OracleServiceCloud,
		ConnectionCategory_STATUS_PayPal,
		ConnectionCategory_STATUS_Phoenix,
		ConnectionCategory_STATUS_PostgreSql,
		ConnectionCategory_STATUS_Presto,
		ConnectionCategory_STATUS_PythonFeed,
		ConnectionCategory_STATUS_QuickBooks,
		ConnectionCategory_STATUS_Redis,
		ConnectionCategory_STATUS_Responsys,
		ConnectionCategory_STATUS_S3,
		ConnectionCategory_STATUS_Salesforce,
		ConnectionCategory_STATUS_SalesforceMarketingCloud,
		ConnectionCategory_STATUS_SalesforceServiceCloud,
		ConnectionCategory_STATUS_SapBw,
		ConnectionCategory_STATUS_SapCloudForCustomer,
		ConnectionCategory_STATUS_SapEcc,
		ConnectionCategory_STATUS_SapHana,
		ConnectionCategory_STATUS_SapOpenHub,
		ConnectionCategory_STATUS_SapTable,
		ConnectionCategory_STATUS_Serp,
		ConnectionCategory_STATUS_Serverless,
		ConnectionCategory_STATUS_ServiceNow,
		ConnectionCategory_STATUS_Sftp,
		ConnectionCategory_STATUS_SharePointOnlineList,
		ConnectionCategory_STATUS_Shopify,
		ConnectionCategory_STATUS_Snowflake,
		ConnectionCategory_STATUS_Spark,
		ConnectionCategory_STATUS_SqlServer,
		ConnectionCategory_STATUS_Square,
		ConnectionCategory_STATUS_Sybase,
		ConnectionCategory_STATUS_Teradata,
		ConnectionCategory_STATUS_Vertica,
		ConnectionCategory_STATUS_WebTable,
		ConnectionCategory_STATUS_Xero,
		ConnectionCategory_STATUS_Zoho))
	gens["CreatedByWorkspaceArmId"] = gen.PtrOf(gen.AlphaString())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Group"] = gen.PtrOf(gen.OneConstOf(
		ConnectionGroup_STATUS_Azure,
		ConnectionGroup_STATUS_AzureAI,
		ConnectionGroup_STATUS_Database,
		ConnectionGroup_STATUS_File,
		ConnectionGroup_STATUS_GenericProtocol,
		ConnectionGroup_STATUS_NoSQL,
		ConnectionGroup_STATUS_ServicesAndApps))
	gens["IsSharedToAll"] = gen.PtrOf(gen.Bool())
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["SharedUserList"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
	gens["ValueFormat"] = gen.PtrOf(gen.OneConstOf(UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON))
}

// AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Credentials"] = gen.PtrOf(WorkspaceConnectionUsernamePassword_STATUSGenerator())
}

func Test_WorkspaceConnectionAccessKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionAccessKey to WorkspaceConnectionAccessKey via AssignProperties_To_WorkspaceConnectionAccessKey & AssignProperties_From_WorkspaceConnectionAccessKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionAccessKey, WorkspaceConnectionAccessKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionAccessKey tests if a specific instance of WorkspaceConnectionAccessKey can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionAccessKey(subject WorkspaceConnectionAccessKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionAccessKey
	err := copied.AssignProperties_To_WorkspaceConnectionAccessKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionAccessKey
	err = actual.AssignProperties_From_WorkspaceConnectionAccessKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionAccessKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionAccessKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionAccessKey, WorkspaceConnectionAccessKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionAccessKey runs a test to see if a specific instance of WorkspaceConnectionAccessKey round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionAccessKey(subject WorkspaceConnectionAccessKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionAccessKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionAccessKey instances for property testing - lazily instantiated by
// WorkspaceConnectionAccessKeyGenerator()
var workspaceConnectionAccessKeyGenerator gopter.Gen

// WorkspaceConnectionAccessKeyGenerator returns a generator of WorkspaceConnectionAccessKey instances for property testing.
func WorkspaceConnectionAccessKeyGenerator() gopter.Gen {
	if workspaceConnectionAccessKeyGenerator != nil {
		return workspaceConnectionAccessKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey(generators)
	workspaceConnectionAccessKeyGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionAccessKey{}), generators)

	return workspaceConnectionAccessKeyGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey(gens map[string]gopter.Gen) {
	gens["AccessKeyId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionAccessKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionAccessKey_STATUS to WorkspaceConnectionAccessKey_STATUS via AssignProperties_To_WorkspaceConnectionAccessKey_STATUS & AssignProperties_From_WorkspaceConnectionAccessKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionAccessKey_STATUS, WorkspaceConnectionAccessKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionAccessKey_STATUS tests if a specific instance of WorkspaceConnectionAccessKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionAccessKey_STATUS(subject WorkspaceConnectionAccessKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionAccessKey_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionAccessKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionAccessKey_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionAccessKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionAccessKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionAccessKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionAccessKey_STATUS, WorkspaceConnectionAccessKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionAccessKey_STATUS runs a test to see if a specific instance of WorkspaceConnectionAccessKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionAccessKey_STATUS(subject WorkspaceConnectionAccessKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionAccessKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionAccessKey_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionAccessKey_STATUSGenerator()
var workspaceConnectionAccessKey_STATUSGenerator gopter.Gen

// WorkspaceConnectionAccessKey_STATUSGenerator returns a generator of WorkspaceConnectionAccessKey_STATUS instances for property testing.
func WorkspaceConnectionAccessKey_STATUSGenerator() gopter.Gen {
	if workspaceConnectionAccessKey_STATUSGenerator != nil {
		return workspaceConnectionAccessKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey_STATUS(generators)
	workspaceConnectionAccessKey_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionAccessKey_STATUS{}), generators)

	return workspaceConnectionAccessKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionAccessKey_STATUS(gens map[string]gopter.Gen) {
	gens["AccessKeyId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionAccountKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionAccountKey to WorkspaceConnectionAccountKey via AssignProperties_To_WorkspaceConnectionAccountKey & AssignProperties_From_WorkspaceConnectionAccountKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionAccountKey, WorkspaceConnectionAccountKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionAccountKey tests if a specific instance of WorkspaceConnectionAccountKey can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionAccountKey(subject WorkspaceConnectionAccountKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionAccountKey
	err := copied.AssignProperties_To_WorkspaceConnectionAccountKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionAccountKey
	err = actual.AssignProperties_From_WorkspaceConnectionAccountKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionAccountKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionAccountKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionAccountKey, WorkspaceConnectionAccountKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionAccountKey runs a test to see if a specific instance of WorkspaceConnectionAccountKey round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionAccountKey(subject WorkspaceConnectionAccountKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionAccountKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionAccountKey instances for property testing - lazily instantiated by
// WorkspaceConnectionAccountKeyGenerator()
var workspaceConnectionAccountKeyGenerator gopter.Gen

// WorkspaceConnectionAccountKeyGenerator returns a generator of WorkspaceConnectionAccountKey instances for property testing.
func WorkspaceConnectionAccountKeyGenerator() gopter.Gen {
	if workspaceConnectionAccountKeyGenerator != nil {
		return workspaceConnectionAccountKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionAccountKeyGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionAccountKey{}), generators)

	return workspaceConnectionAccountKeyGenerator
}

func Test_WorkspaceConnectionAccountKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionAccountKey_STATUS to WorkspaceConnectionAccountKey_STATUS via AssignProperties_To_WorkspaceConnectionAccountKey_STATUS & AssignProperties_From_WorkspaceConnectionAccountKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionAccountKey_STATUS, WorkspaceConnectionAccountKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionAccountKey_STATUS tests if a specific instance of WorkspaceConnectionAccountKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionAccountKey_STATUS(subject WorkspaceConnectionAccountKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionAccountKey_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionAccountKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionAccountKey_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionAccountKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionAccountKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionAccountKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionAccountKey_STATUS, WorkspaceConnectionAccountKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionAccountKey_STATUS runs a test to see if a specific instance of WorkspaceConnectionAccountKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionAccountKey_STATUS(subject WorkspaceConnectionAccountKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionAccountKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionAccountKey_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionAccountKey_STATUSGenerator()
var workspaceConnectionAccountKey_STATUSGenerator gopter.Gen

// WorkspaceConnectionAccountKey_STATUSGenerator returns a generator of WorkspaceConnectionAccountKey_STATUS instances for property testing.
func WorkspaceConnectionAccountKey_STATUSGenerator() gopter.Gen {
	if workspaceConnectionAccountKey_STATUSGenerator != nil {
		return workspaceConnectionAccountKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionAccountKey_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionAccountKey_STATUS{}), generators)

	return workspaceConnectionAccountKey_STATUSGenerator
}

func Test_WorkspaceConnectionApiKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionApiKey to WorkspaceConnectionApiKey via AssignProperties_To_WorkspaceConnectionApiKey & AssignProperties_From_WorkspaceConnectionApiKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionApiKey, WorkspaceConnectionApiKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionApiKey tests if a specific instance of WorkspaceConnectionApiKey can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionApiKey(subject WorkspaceConnectionApiKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionApiKey
	err := copied.AssignProperties_To_WorkspaceConnectionApiKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionApiKey
	err = actual.AssignProperties_From_WorkspaceConnectionApiKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionApiKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionApiKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionApiKey, WorkspaceConnectionApiKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionApiKey runs a test to see if a specific instance of WorkspaceConnectionApiKey round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionApiKey(subject WorkspaceConnectionApiKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionApiKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionApiKey instances for property testing - lazily instantiated by
// WorkspaceConnectionApiKeyGenerator()
var workspaceConnectionApiKeyGenerator gopter.Gen

// WorkspaceConnectionApiKeyGenerator returns a generator of WorkspaceConnectionApiKey instances for property testing.
func WorkspaceConnectionApiKeyGenerator() gopter.Gen {
	if workspaceConnectionApiKeyGenerator != nil {
		return workspaceConnectionApiKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionApiKeyGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionApiKey{}), generators)

	return workspaceConnectionApiKeyGenerator
}

func Test_WorkspaceConnectionApiKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionApiKey_STATUS to WorkspaceConnectionApiKey_STATUS via AssignProperties_To_WorkspaceConnectionApiKey_STATUS & AssignProperties_From_WorkspaceConnectionApiKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionApiKey_STATUS, WorkspaceConnectionApiKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionApiKey_STATUS tests if a specific instance of WorkspaceConnectionApiKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionApiKey_STATUS(subject WorkspaceConnectionApiKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionApiKey_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionApiKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionApiKey_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionApiKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionApiKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionApiKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionApiKey_STATUS, WorkspaceConnectionApiKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionApiKey_STATUS runs a test to see if a specific instance of WorkspaceConnectionApiKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionApiKey_STATUS(subject WorkspaceConnectionApiKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionApiKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionApiKey_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionApiKey_STATUSGenerator()
var workspaceConnectionApiKey_STATUSGenerator gopter.Gen

// WorkspaceConnectionApiKey_STATUSGenerator returns a generator of WorkspaceConnectionApiKey_STATUS instances for property testing.
func WorkspaceConnectionApiKey_STATUSGenerator() gopter.Gen {
	if workspaceConnectionApiKey_STATUSGenerator != nil {
		return workspaceConnectionApiKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionApiKey_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionApiKey_STATUS{}), generators)

	return workspaceConnectionApiKey_STATUSGenerator
}

func Test_WorkspaceConnectionManagedIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionManagedIdentity to WorkspaceConnectionManagedIdentity via AssignProperties_To_WorkspaceConnectionManagedIdentity & AssignProperties_From_WorkspaceConnectionManagedIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity, WorkspaceConnectionManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity tests if a specific instance of WorkspaceConnectionManagedIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity(subject WorkspaceConnectionManagedIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionManagedIdentity
	err := copied.AssignProperties_To_WorkspaceConnectionManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionManagedIdentity
	err = actual.AssignProperties_From_WorkspaceConnectionManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionManagedIdentity, WorkspaceConnectionManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionManagedIdentity runs a test to see if a specific instance of WorkspaceConnectionManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionManagedIdentity(subject WorkspaceConnectionManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionManagedIdentity instances for property testing - lazily instantiated by
// WorkspaceConnectionManagedIdentityGenerator()
var workspaceConnectionManagedIdentityGenerator gopter.Gen

// WorkspaceConnectionManagedIdentityGenerator returns a generator of WorkspaceConnectionManagedIdentity instances for property testing.
func WorkspaceConnectionManagedIdentityGenerator() gopter.Gen {
	if workspaceConnectionManagedIdentityGenerator != nil {
		return workspaceConnectionManagedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity(generators)
	workspaceConnectionManagedIdentityGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionManagedIdentity{}), generators)

	return workspaceConnectionManagedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionManagedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionManagedIdentity_STATUS to WorkspaceConnectionManagedIdentity_STATUS via AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS & AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity_STATUS, WorkspaceConnectionManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity_STATUS tests if a specific instance of WorkspaceConnectionManagedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionManagedIdentity_STATUS(subject WorkspaceConnectionManagedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionManagedIdentity_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionManagedIdentity_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionManagedIdentity_STATUS, WorkspaceConnectionManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionManagedIdentity_STATUS runs a test to see if a specific instance of WorkspaceConnectionManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionManagedIdentity_STATUS(subject WorkspaceConnectionManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionManagedIdentity_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionManagedIdentity_STATUSGenerator()
var workspaceConnectionManagedIdentity_STATUSGenerator gopter.Gen

// WorkspaceConnectionManagedIdentity_STATUSGenerator returns a generator of WorkspaceConnectionManagedIdentity_STATUS instances for property testing.
func WorkspaceConnectionManagedIdentity_STATUSGenerator() gopter.Gen {
	if workspaceConnectionManagedIdentity_STATUSGenerator != nil {
		return workspaceConnectionManagedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity_STATUS(generators)
	workspaceConnectionManagedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionManagedIdentity_STATUS{}), generators)

	return workspaceConnectionManagedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionOAuth2_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionOAuth2 to WorkspaceConnectionOAuth2 via AssignProperties_To_WorkspaceConnectionOAuth2 & AssignProperties_From_WorkspaceConnectionOAuth2 returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionOAuth2, WorkspaceConnectionOAuth2Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionOAuth2 tests if a specific instance of WorkspaceConnectionOAuth2 can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionOAuth2(subject WorkspaceConnectionOAuth2) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionOAuth2
	err := copied.AssignProperties_To_WorkspaceConnectionOAuth2(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionOAuth2
	err = actual.AssignProperties_From_WorkspaceConnectionOAuth2(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionOAuth2_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionOAuth2 via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionOAuth2, WorkspaceConnectionOAuth2Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionOAuth2 runs a test to see if a specific instance of WorkspaceConnectionOAuth2 round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionOAuth2(subject WorkspaceConnectionOAuth2) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionOAuth2
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionOAuth2 instances for property testing - lazily instantiated by
// WorkspaceConnectionOAuth2Generator()
var workspaceConnectionOAuth2Generator gopter.Gen

// WorkspaceConnectionOAuth2Generator returns a generator of WorkspaceConnectionOAuth2 instances for property testing.
func WorkspaceConnectionOAuth2Generator() gopter.Gen {
	if workspaceConnectionOAuth2Generator != nil {
		return workspaceConnectionOAuth2Generator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2(generators)
	workspaceConnectionOAuth2Generator = gen.Struct(reflect.TypeOf(WorkspaceConnectionOAuth2{}), generators)

	return workspaceConnectionOAuth2Generator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2 is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2(gens map[string]gopter.Gen) {
	gens["AuthUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionOAuth2_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionOAuth2_STATUS to WorkspaceConnectionOAuth2_STATUS via AssignProperties_To_WorkspaceConnectionOAuth2_STATUS & AssignProperties_From_WorkspaceConnectionOAuth2_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionOAuth2_STATUS, WorkspaceConnectionOAuth2_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionOAuth2_STATUS tests if a specific instance of WorkspaceConnectionOAuth2_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionOAuth2_STATUS(subject WorkspaceConnectionOAuth2_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionOAuth2_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionOAuth2_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionOAuth2_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionOAuth2_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionOAuth2_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionOAuth2_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionOAuth2_STATUS, WorkspaceConnectionOAuth2_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionOAuth2_STATUS runs a test to see if a specific instance of WorkspaceConnectionOAuth2_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionOAuth2_STATUS(subject WorkspaceConnectionOAuth2_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionOAuth2_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionOAuth2_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionOAuth2_STATUSGenerator()
var workspaceConnectionOAuth2_STATUSGenerator gopter.Gen

// WorkspaceConnectionOAuth2_STATUSGenerator returns a generator of WorkspaceConnectionOAuth2_STATUS instances for property testing.
func WorkspaceConnectionOAuth2_STATUSGenerator() gopter.Gen {
	if workspaceConnectionOAuth2_STATUSGenerator != nil {
		return workspaceConnectionOAuth2_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2_STATUS(generators)
	workspaceConnectionOAuth2_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionOAuth2_STATUS{}), generators)

	return workspaceConnectionOAuth2_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionOAuth2_STATUS(gens map[string]gopter.Gen) {
	gens["AuthUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionPersonalAccessToken_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionPersonalAccessToken to WorkspaceConnectionPersonalAccessToken via AssignProperties_To_WorkspaceConnectionPersonalAccessToken & AssignProperties_From_WorkspaceConnectionPersonalAccessToken returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken, WorkspaceConnectionPersonalAccessTokenGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken tests if a specific instance of WorkspaceConnectionPersonalAccessToken can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken(subject WorkspaceConnectionPersonalAccessToken) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionPersonalAccessToken
	err := copied.AssignProperties_To_WorkspaceConnectionPersonalAccessToken(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionPersonalAccessToken
	err = actual.AssignProperties_From_WorkspaceConnectionPersonalAccessToken(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionPersonalAccessToken_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionPersonalAccessToken via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken, WorkspaceConnectionPersonalAccessTokenGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken runs a test to see if a specific instance of WorkspaceConnectionPersonalAccessToken round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken(subject WorkspaceConnectionPersonalAccessToken) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionPersonalAccessToken
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionPersonalAccessToken instances for property testing - lazily instantiated by
// WorkspaceConnectionPersonalAccessTokenGenerator()
var workspaceConnectionPersonalAccessTokenGenerator gopter.Gen

// WorkspaceConnectionPersonalAccessTokenGenerator returns a generator of WorkspaceConnectionPersonalAccessToken instances for property testing.
func WorkspaceConnectionPersonalAccessTokenGenerator() gopter.Gen {
	if workspaceConnectionPersonalAccessTokenGenerator != nil {
		return workspaceConnectionPersonalAccessTokenGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionPersonalAccessTokenGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionPersonalAccessToken{}), generators)

	return workspaceConnectionPersonalAccessTokenGenerator
}

func Test_WorkspaceConnectionPersonalAccessToken_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionPersonalAccessToken_STATUS to WorkspaceConnectionPersonalAccessToken_STATUS via AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS & AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken_STATUS, WorkspaceConnectionPersonalAccessToken_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken_STATUS tests if a specific instance of WorkspaceConnectionPersonalAccessToken_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionPersonalAccessToken_STATUS(subject WorkspaceConnectionPersonalAccessToken_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionPersonalAccessToken_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionPersonalAccessToken_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionPersonalAccessToken_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionPersonalAccessToken_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken_STATUS, WorkspaceConnectionPersonalAccessToken_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken_STATUS runs a test to see if a specific instance of WorkspaceConnectionPersonalAccessToken_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionPersonalAccessToken_STATUS(subject WorkspaceConnectionPersonalAccessToken_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionPersonalAccessToken_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionPersonalAccessToken_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionPersonalAccessToken_STATUSGenerator()
var workspaceConnectionPersonalAccessToken_STATUSGenerator gopter.Gen

// WorkspaceConnectionPersonalAccessToken_STATUSGenerator returns a generator of WorkspaceConnectionPersonalAccessToken_STATUS instances for property testing.
func WorkspaceConnectionPersonalAccessToken_STATUSGenerator() gopter.Gen {
	if workspaceConnectionPersonalAccessToken_STATUSGenerator != nil {
		return workspaceConnectionPersonalAccessToken_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionPersonalAccessToken_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionPersonalAccessToken_STATUS{}), generators)

	return workspaceConnectionPersonalAccessToken_STATUSGenerator
}

func Test_WorkspaceConnectionPropertiesV2_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionPropertiesV2 to WorkspaceConnectionPropertiesV2 via AssignProperties_To_WorkspaceConnectionPropertiesV2 & AssignProperties_From_WorkspaceConnectionPropertiesV2 returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2, WorkspaceConnectionPropertiesV2Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2 tests if a specific instance of WorkspaceConnectionPropertiesV2 can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2(subject WorkspaceConnectionPropertiesV2) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionPropertiesV2
	err := copied.AssignProperties_To_WorkspaceConnectionPropertiesV2(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionPropertiesV2
	err = actual.AssignProperties_From_WorkspaceConnectionPropertiesV2(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionPropertiesV2_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionPropertiesV2 via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionPropertiesV2, WorkspaceConnectionPropertiesV2Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionPropertiesV2 runs a test to see if a specific instance of WorkspaceConnectionPropertiesV2 round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionPropertiesV2(subject WorkspaceConnectionPropertiesV2) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionPropertiesV2
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionPropertiesV2 instances for property testing - lazily instantiated by
// WorkspaceConnectionPropertiesV2Generator()
var workspaceConnectionPropertiesV2Generator gopter.Gen

// WorkspaceConnectionPropertiesV2Generator returns a generator of WorkspaceConnectionPropertiesV2 instances for property testing.
func WorkspaceConnectionPropertiesV2Generator() gopter.Gen {
	if workspaceConnectionPropertiesV2Generator != nil {
		return workspaceConnectionPropertiesV2Generator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(WorkspaceConnectionPropertiesV2{}), map[string]gopter.Gen{propName: propGen}))
	}
	workspaceConnectionPropertiesV2Generator = gen.OneGenOf(gens...)

	return workspaceConnectionPropertiesV2Generator
}

// AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2 is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2(gens map[string]gopter.Gen) {
	gens["AAD"] = AADAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it AADAuthTypeWorkspaceConnectionProperties) *AADAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["AccessKey"] = AccessKeyAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it AccessKeyAuthTypeWorkspaceConnectionProperties) *AccessKeyAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["AccountKey"] = AccountKeyAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it AccountKeyAuthTypeWorkspaceConnectionProperties) *AccountKeyAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["ApiKey"] = ApiKeyAuthWorkspaceConnectionPropertiesGenerator().Map(func(it ApiKeyAuthWorkspaceConnectionProperties) *ApiKeyAuthWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["CustomKeys"] = CustomKeysWorkspaceConnectionPropertiesGenerator().Map(func(it CustomKeysWorkspaceConnectionProperties) *CustomKeysWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["ManagedIdentity"] = ManagedIdentityAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it ManagedIdentityAuthTypeWorkspaceConnectionProperties) *ManagedIdentityAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["None"] = NoneAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it NoneAuthTypeWorkspaceConnectionProperties) *NoneAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["OAuth2"] = OAuth2AuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it OAuth2AuthTypeWorkspaceConnectionProperties) *OAuth2AuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["PAT"] = PATAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it PATAuthTypeWorkspaceConnectionProperties) *PATAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["SAS"] = SASAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it SASAuthTypeWorkspaceConnectionProperties) *SASAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["ServicePrincipal"] = ServicePrincipalAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it ServicePrincipalAuthTypeWorkspaceConnectionProperties) *ServicePrincipalAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
	gens["UsernamePassword"] = UsernamePasswordAuthTypeWorkspaceConnectionPropertiesGenerator().Map(func(it UsernamePasswordAuthTypeWorkspaceConnectionProperties) *UsernamePasswordAuthTypeWorkspaceConnectionProperties {
		return &it
	}) // generate one case for OneOf type
}

func Test_WorkspaceConnectionPropertiesV2_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionPropertiesV2_STATUS to WorkspaceConnectionPropertiesV2_STATUS via AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS & AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2_STATUS, WorkspaceConnectionPropertiesV2_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2_STATUS tests if a specific instance of WorkspaceConnectionPropertiesV2_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionPropertiesV2_STATUS(subject WorkspaceConnectionPropertiesV2_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionPropertiesV2_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionPropertiesV2_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionPropertiesV2_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionPropertiesV2_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionPropertiesV2_STATUS, WorkspaceConnectionPropertiesV2_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionPropertiesV2_STATUS runs a test to see if a specific instance of WorkspaceConnectionPropertiesV2_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionPropertiesV2_STATUS(subject WorkspaceConnectionPropertiesV2_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionPropertiesV2_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionPropertiesV2_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionPropertiesV2_STATUSGenerator()
var workspaceConnectionPropertiesV2_STATUSGenerator gopter.Gen

// WorkspaceConnectionPropertiesV2_STATUSGenerator returns a generator of WorkspaceConnectionPropertiesV2_STATUS instances for property testing.
func WorkspaceConnectionPropertiesV2_STATUSGenerator() gopter.Gen {
	if workspaceConnectionPropertiesV2_STATUSGenerator != nil {
		return workspaceConnectionPropertiesV2_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(WorkspaceConnectionPropertiesV2_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	workspaceConnectionPropertiesV2_STATUSGenerator = gen.OneGenOf(gens...)

	return workspaceConnectionPropertiesV2_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceConnectionPropertiesV2_STATUS(gens map[string]gopter.Gen) {
	gens["AAD"] = AADAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it AADAuthTypeWorkspaceConnectionProperties_STATUS) *AADAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["AccessKey"] = AccessKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["AccountKey"] = AccountKeyAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ApiKey"] = ApiKeyAuthWorkspaceConnectionProperties_STATUSGenerator().Map(func(it ApiKeyAuthWorkspaceConnectionProperties_STATUS) *ApiKeyAuthWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["CustomKeys"] = CustomKeysWorkspaceConnectionProperties_STATUSGenerator().Map(func(it CustomKeysWorkspaceConnectionProperties_STATUS) *CustomKeysWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ManagedIdentity"] = ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["None"] = NoneAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it NoneAuthTypeWorkspaceConnectionProperties_STATUS) *NoneAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["OAuth2"] = OAuth2AuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["PAT"] = PATAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it PATAuthTypeWorkspaceConnectionProperties_STATUS) *PATAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["SAS"] = SASAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it SASAuthTypeWorkspaceConnectionProperties_STATUS) *SASAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ServicePrincipal"] = ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["UsernamePassword"] = UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUSGenerator().Map(func(it UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_WorkspaceConnectionServicePrincipal_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionServicePrincipal to WorkspaceConnectionServicePrincipal via AssignProperties_To_WorkspaceConnectionServicePrincipal & AssignProperties_From_WorkspaceConnectionServicePrincipal returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal, WorkspaceConnectionServicePrincipalGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal tests if a specific instance of WorkspaceConnectionServicePrincipal can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal(subject WorkspaceConnectionServicePrincipal) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionServicePrincipal
	err := copied.AssignProperties_To_WorkspaceConnectionServicePrincipal(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionServicePrincipal
	err = actual.AssignProperties_From_WorkspaceConnectionServicePrincipal(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionServicePrincipal_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionServicePrincipal via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionServicePrincipal, WorkspaceConnectionServicePrincipalGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionServicePrincipal runs a test to see if a specific instance of WorkspaceConnectionServicePrincipal round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionServicePrincipal(subject WorkspaceConnectionServicePrincipal) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionServicePrincipal
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionServicePrincipal instances for property testing - lazily instantiated by
// WorkspaceConnectionServicePrincipalGenerator()
var workspaceConnectionServicePrincipalGenerator gopter.Gen

// WorkspaceConnectionServicePrincipalGenerator returns a generator of WorkspaceConnectionServicePrincipal instances for property testing.
func WorkspaceConnectionServicePrincipalGenerator() gopter.Gen {
	if workspaceConnectionServicePrincipalGenerator != nil {
		return workspaceConnectionServicePrincipalGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal(generators)
	workspaceConnectionServicePrincipalGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionServicePrincipal{}), generators)

	return workspaceConnectionServicePrincipalGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionServicePrincipal_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionServicePrincipal_STATUS to WorkspaceConnectionServicePrincipal_STATUS via AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS & AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal_STATUS, WorkspaceConnectionServicePrincipal_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal_STATUS tests if a specific instance of WorkspaceConnectionServicePrincipal_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionServicePrincipal_STATUS(subject WorkspaceConnectionServicePrincipal_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionServicePrincipal_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionServicePrincipal_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionServicePrincipal_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionServicePrincipal_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionServicePrincipal_STATUS, WorkspaceConnectionServicePrincipal_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionServicePrincipal_STATUS runs a test to see if a specific instance of WorkspaceConnectionServicePrincipal_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionServicePrincipal_STATUS(subject WorkspaceConnectionServicePrincipal_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionServicePrincipal_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionServicePrincipal_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionServicePrincipal_STATUSGenerator()
var workspaceConnectionServicePrincipal_STATUSGenerator gopter.Gen

// WorkspaceConnectionServicePrincipal_STATUSGenerator returns a generator of WorkspaceConnectionServicePrincipal_STATUS instances for property testing.
func WorkspaceConnectionServicePrincipal_STATUSGenerator() gopter.Gen {
	if workspaceConnectionServicePrincipal_STATUSGenerator != nil {
		return workspaceConnectionServicePrincipal_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal_STATUS(generators)
	workspaceConnectionServicePrincipal_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionServicePrincipal_STATUS{}), generators)

	return workspaceConnectionServicePrincipal_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionServicePrincipal_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionSharedAccessSignature_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionSharedAccessSignature to WorkspaceConnectionSharedAccessSignature via AssignProperties_To_WorkspaceConnectionSharedAccessSignature & AssignProperties_From_WorkspaceConnectionSharedAccessSignature returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature, WorkspaceConnectionSharedAccessSignatureGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature tests if a specific instance of WorkspaceConnectionSharedAccessSignature can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature(subject WorkspaceConnectionSharedAccessSignature) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionSharedAccessSignature
	err := copied.AssignProperties_To_WorkspaceConnectionSharedAccessSignature(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionSharedAccessSignature
	err = actual.AssignProperties_From_WorkspaceConnectionSharedAccessSignature(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionSharedAccessSignature_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionSharedAccessSignature via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature, WorkspaceConnectionSharedAccessSignatureGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature runs a test to see if a specific instance of WorkspaceConnectionSharedAccessSignature round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature(subject WorkspaceConnectionSharedAccessSignature) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionSharedAccessSignature
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionSharedAccessSignature instances for property testing - lazily instantiated by
// WorkspaceConnectionSharedAccessSignatureGenerator()
var workspaceConnectionSharedAccessSignatureGenerator gopter.Gen

// WorkspaceConnectionSharedAccessSignatureGenerator returns a generator of WorkspaceConnectionSharedAccessSignature instances for property testing.
func WorkspaceConnectionSharedAccessSignatureGenerator() gopter.Gen {
	if workspaceConnectionSharedAccessSignatureGenerator != nil {
		return workspaceConnectionSharedAccessSignatureGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionSharedAccessSignatureGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionSharedAccessSignature{}), generators)

	return workspaceConnectionSharedAccessSignatureGenerator
}

func Test_WorkspaceConnectionSharedAccessSignature_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionSharedAccessSignature_STATUS to WorkspaceConnectionSharedAccessSignature_STATUS via AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS & AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature_STATUS, WorkspaceConnectionSharedAccessSignature_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature_STATUS tests if a specific instance of WorkspaceConnectionSharedAccessSignature_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionSharedAccessSignature_STATUS(subject WorkspaceConnectionSharedAccessSignature_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionSharedAccessSignature_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionSharedAccessSignature_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionSharedAccessSignature_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionSharedAccessSignature_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature_STATUS, WorkspaceConnectionSharedAccessSignature_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature_STATUS runs a test to see if a specific instance of WorkspaceConnectionSharedAccessSignature_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionSharedAccessSignature_STATUS(subject WorkspaceConnectionSharedAccessSignature_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionSharedAccessSignature_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionSharedAccessSignature_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionSharedAccessSignature_STATUSGenerator()
var workspaceConnectionSharedAccessSignature_STATUSGenerator gopter.Gen

// WorkspaceConnectionSharedAccessSignature_STATUSGenerator returns a generator of WorkspaceConnectionSharedAccessSignature_STATUS instances for property testing.
func WorkspaceConnectionSharedAccessSignature_STATUSGenerator() gopter.Gen {
	if workspaceConnectionSharedAccessSignature_STATUSGenerator != nil {
		return workspaceConnectionSharedAccessSignature_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceConnectionSharedAccessSignature_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionSharedAccessSignature_STATUS{}), generators)

	return workspaceConnectionSharedAccessSignature_STATUSGenerator
}

func Test_WorkspaceConnectionUsernamePassword_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionUsernamePassword to WorkspaceConnectionUsernamePassword via AssignProperties_To_WorkspaceConnectionUsernamePassword & AssignProperties_From_WorkspaceConnectionUsernamePassword returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword, WorkspaceConnectionUsernamePasswordGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword tests if a specific instance of WorkspaceConnectionUsernamePassword can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword(subject WorkspaceConnectionUsernamePassword) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionUsernamePassword
	err := copied.AssignProperties_To_WorkspaceConnectionUsernamePassword(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionUsernamePassword
	err = actual.AssignProperties_From_WorkspaceConnectionUsernamePassword(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionUsernamePassword_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionUsernamePassword via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionUsernamePassword, WorkspaceConnectionUsernamePasswordGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionUsernamePassword runs a test to see if a specific instance of WorkspaceConnectionUsernamePassword round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionUsernamePassword(subject WorkspaceConnectionUsernamePassword) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionUsernamePassword
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionUsernamePassword instances for property testing - lazily instantiated by
// WorkspaceConnectionUsernamePasswordGenerator()
var workspaceConnectionUsernamePasswordGenerator gopter.Gen

// WorkspaceConnectionUsernamePasswordGenerator returns a generator of WorkspaceConnectionUsernamePassword instances for property testing.
func WorkspaceConnectionUsernamePasswordGenerator() gopter.Gen {
	if workspaceConnectionUsernamePasswordGenerator != nil {
		return workspaceConnectionUsernamePasswordGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword(generators)
	workspaceConnectionUsernamePasswordGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionUsernamePassword{}), generators)

	return workspaceConnectionUsernamePasswordGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword(gens map[string]gopter.Gen) {
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceConnectionUsernamePassword_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceConnectionUsernamePassword_STATUS to WorkspaceConnectionUsernamePassword_STATUS via AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS & AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword_STATUS, WorkspaceConnectionUsernamePassword_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword_STATUS tests if a specific instance of WorkspaceConnectionUsernamePassword_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceConnectionUsernamePassword_STATUS(subject WorkspaceConnectionUsernamePassword_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspaceConnectionUsernamePassword_STATUS
	err := copied.AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceConnectionUsernamePassword_STATUS
	err = actual.AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceConnectionUsernamePassword_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceConnectionUsernamePassword_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceConnectionUsernamePassword_STATUS, WorkspaceConnectionUsernamePassword_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceConnectionUsernamePassword_STATUS runs a test to see if a specific instance of WorkspaceConnectionUsernamePassword_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceConnectionUsernamePassword_STATUS(subject WorkspaceConnectionUsernamePassword_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceConnectionUsernamePassword_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceConnectionUsernamePassword_STATUS instances for property testing - lazily instantiated by
// WorkspaceConnectionUsernamePassword_STATUSGenerator()
var workspaceConnectionUsernamePassword_STATUSGenerator gopter.Gen

// WorkspaceConnectionUsernamePassword_STATUSGenerator returns a generator of WorkspaceConnectionUsernamePassword_STATUS instances for property testing.
func WorkspaceConnectionUsernamePassword_STATUSGenerator() gopter.Gen {
	if workspaceConnectionUsernamePassword_STATUSGenerator != nil {
		return workspaceConnectionUsernamePassword_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword_STATUS(generators)
	workspaceConnectionUsernamePassword_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceConnectionUsernamePassword_STATUS{}), generators)

	return workspaceConnectionUsernamePassword_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceConnectionUsernamePassword_STATUS(gens map[string]gopter.Gen) {
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspacesConnection_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspacesConnection to hub returns original",
		prop.ForAll(RunResourceConversionTestForWorkspacesConnection, WorkspacesConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWorkspacesConnection tests if a specific instance of WorkspacesConnection round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWorkspacesConnection(subject WorkspacesConnection) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.WorkspacesConnection
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual WorkspacesConnection
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspacesConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspacesConnection to WorkspacesConnection via AssignProperties_To_WorkspacesConnection & AssignProperties_From_WorkspacesConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspacesConnection, WorkspacesConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspacesConnection tests if a specific instance of WorkspacesConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspacesConnection(subject WorkspacesConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkspacesConnection
	err := copied.AssignProperties_To_WorkspacesConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspacesConnection
	err = actual.AssignProperties_From_WorkspacesConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspacesConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspacesConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspacesConnection, WorkspacesConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspacesConnection runs a test to see if a specific instance of WorkspacesConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspacesConnection(subject WorkspacesConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspacesConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspacesConnection instances for property testing - lazily instantiated by
// WorkspacesConnectionGenerator()
var workspacesConnectionGenerator gopter.Gen

// WorkspacesConnectionGenerator returns a generator of WorkspacesConnection instances for property testing.
func WorkspacesConnectionGenerator() gopter.Gen {
	if workspacesConnectionGenerator != nil {
		return workspacesConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspacesConnection(generators)
	workspacesConnectionGenerator = gen.Struct(reflect.TypeOf(WorkspacesConnection{}), generators)

	return workspacesConnectionGenerator
}

// AddRelatedPropertyGeneratorsForWorkspacesConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspacesConnection(gens map[string]gopter.Gen) {
	gens["Spec"] = Workspaces_Connection_SpecGenerator()
	gens["Status"] = Workspaces_Connection_STATUSGenerator()
}

func Test_Workspaces_Connection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspaces_Connection_STATUS to Workspaces_Connection_STATUS via AssignProperties_To_Workspaces_Connection_STATUS & AssignProperties_From_Workspaces_Connection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaces_Connection_STATUS, Workspaces_Connection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaces_Connection_STATUS tests if a specific instance of Workspaces_Connection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaces_Connection_STATUS(subject Workspaces_Connection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Workspaces_Connection_STATUS
	err := copied.AssignProperties_To_Workspaces_Connection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspaces_Connection_STATUS
	err = actual.AssignProperties_From_Workspaces_Connection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspaces_Connection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Connection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaces_Connection_STATUS, Workspaces_Connection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaces_Connection_STATUS runs a test to see if a specific instance of Workspaces_Connection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaces_Connection_STATUS(subject Workspaces_Connection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Connection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Connection_STATUS instances for property testing - lazily instantiated by
// Workspaces_Connection_STATUSGenerator()
var workspaces_Connection_STATUSGenerator gopter.Gen

// Workspaces_Connection_STATUSGenerator returns a generator of Workspaces_Connection_STATUS instances for property testing.
// We first initialize workspaces_Connection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspaces_Connection_STATUSGenerator() gopter.Gen {
	if workspaces_Connection_STATUSGenerator != nil {
		return workspaces_Connection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Connection_STATUS(generators)
	workspaces_Connection_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspaces_Connection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Connection_STATUS(generators)
	AddRelatedPropertyGeneratorsForWorkspaces_Connection_STATUS(generators)
	workspaces_Connection_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspaces_Connection_STATUS{}), generators)

	return workspaces_Connection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaces_Connection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaces_Connection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspaces_Connection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaces_Connection_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WorkspaceConnectionPropertiesV2_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Workspaces_Connection_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspaces_Connection_Spec to Workspaces_Connection_Spec via AssignProperties_To_Workspaces_Connection_Spec & AssignProperties_From_Workspaces_Connection_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaces_Connection_Spec, Workspaces_Connection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaces_Connection_Spec tests if a specific instance of Workspaces_Connection_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkspaces_Connection_Spec(subject Workspaces_Connection_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Workspaces_Connection_Spec
	err := copied.AssignProperties_To_Workspaces_Connection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspaces_Connection_Spec
	err = actual.AssignProperties_From_Workspaces_Connection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspaces_Connection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Connection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaces_Connection_Spec, Workspaces_Connection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaces_Connection_Spec runs a test to see if a specific instance of Workspaces_Connection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaces_Connection_Spec(subject Workspaces_Connection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Connection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Connection_Spec instances for property testing - lazily instantiated by
// Workspaces_Connection_SpecGenerator()
var workspaces_Connection_SpecGenerator gopter.Gen

// Workspaces_Connection_SpecGenerator returns a generator of Workspaces_Connection_Spec instances for property testing.
// We first initialize workspaces_Connection_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspaces_Connection_SpecGenerator() gopter.Gen {
	if workspaces_Connection_SpecGenerator != nil {
		return workspaces_Connection_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Connection_Spec(generators)
	workspaces_Connection_SpecGenerator = gen.Struct(reflect.TypeOf(Workspaces_Connection_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Connection_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspaces_Connection_Spec(generators)
	workspaces_Connection_SpecGenerator = gen.Struct(reflect.TypeOf(Workspaces_Connection_Spec{}), generators)

	return workspaces_Connection_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaces_Connection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaces_Connection_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForWorkspaces_Connection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaces_Connection_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WorkspaceConnectionPropertiesV2Generator())
}
