// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ComputeRuntimeDto_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeRuntimeDto via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeRuntimeDto, ComputeRuntimeDtoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeRuntimeDto runs a test to see if a specific instance of ComputeRuntimeDto round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeRuntimeDto(subject ComputeRuntimeDto) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeRuntimeDto
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeRuntimeDto instances for property testing - lazily instantiated by ComputeRuntimeDtoGenerator()
var computeRuntimeDtoGenerator gopter.Gen

// ComputeRuntimeDtoGenerator returns a generator of ComputeRuntimeDto instances for property testing.
func ComputeRuntimeDtoGenerator() gopter.Gen {
	if computeRuntimeDtoGenerator != nil {
		return computeRuntimeDtoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeRuntimeDto(generators)
	computeRuntimeDtoGenerator = gen.Struct(reflect.TypeOf(ComputeRuntimeDto{}), generators)

	return computeRuntimeDtoGenerator
}

// AddIndependentPropertyGeneratorsForComputeRuntimeDto is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeRuntimeDto(gens map[string]gopter.Gen) {
	gens["SparkRuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CosmosDbSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings, CosmosDbSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings runs a test to see if a specific instance of CosmosDbSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings(subject CosmosDbSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings instances for property testing - lazily instantiated by CosmosDbSettingsGenerator()
var cosmosDbSettingsGenerator gopter.Gen

// CosmosDbSettingsGenerator returns a generator of CosmosDbSettings instances for property testing.
func CosmosDbSettingsGenerator() gopter.Gen {
	if cosmosDbSettingsGenerator != nil {
		return cosmosDbSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings(generators)
	cosmosDbSettingsGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings{}), generators)

	return cosmosDbSettingsGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings(gens map[string]gopter.Gen) {
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_EncryptionKeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionKeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionKeyVaultProperties, EncryptionKeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionKeyVaultProperties runs a test to see if a specific instance of EncryptionKeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionKeyVaultProperties(subject EncryptionKeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionKeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionKeyVaultProperties instances for property testing - lazily instantiated by
// EncryptionKeyVaultPropertiesGenerator()
var encryptionKeyVaultPropertiesGenerator gopter.Gen

// EncryptionKeyVaultPropertiesGenerator returns a generator of EncryptionKeyVaultProperties instances for property testing.
func EncryptionKeyVaultPropertiesGenerator() gopter.Gen {
	if encryptionKeyVaultPropertiesGenerator != nil {
		return encryptionKeyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties(generators)
	encryptionKeyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionKeyVaultProperties{}), generators)

	return encryptionKeyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperty_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty runs a test to see if a specific instance of EncryptionProperty round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty(subject EncryptionProperty) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty instances for property testing - lazily instantiated by EncryptionPropertyGenerator()
var encryptionPropertyGenerator gopter.Gen

// EncryptionPropertyGenerator returns a generator of EncryptionProperty instances for property testing.
func EncryptionPropertyGenerator() gopter.Gen {
	if encryptionPropertyGenerator != nil {
		return encryptionPropertyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	return encryptionPropertyGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmkGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(EncryptionKeyVaultPropertiesGenerator())
}

func Test_FeatureStoreSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeatureStoreSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeatureStoreSettings, FeatureStoreSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeatureStoreSettings runs a test to see if a specific instance of FeatureStoreSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForFeatureStoreSettings(subject FeatureStoreSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeatureStoreSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeatureStoreSettings instances for property testing - lazily instantiated by
// FeatureStoreSettingsGenerator()
var featureStoreSettingsGenerator gopter.Gen

// FeatureStoreSettingsGenerator returns a generator of FeatureStoreSettings instances for property testing.
// We first initialize featureStoreSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FeatureStoreSettingsGenerator() gopter.Gen {
	if featureStoreSettingsGenerator != nil {
		return featureStoreSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings(generators)
	featureStoreSettingsGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeatureStoreSettings(generators)
	AddRelatedPropertyGeneratorsForFeatureStoreSettings(generators)
	featureStoreSettingsGenerator = gen.Struct(reflect.TypeOf(FeatureStoreSettings{}), generators)

	return featureStoreSettingsGenerator
}

// AddIndependentPropertyGeneratorsForFeatureStoreSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeatureStoreSettings(gens map[string]gopter.Gen) {
	gens["OfflineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
	gens["OnlineStoreConnectionName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFeatureStoreSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFeatureStoreSettings(gens map[string]gopter.Gen) {
	gens["ComputeRuntime"] = gen.PtrOf(ComputeRuntimeDtoGenerator())
}

func Test_FqdnOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FqdnOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFqdnOutboundRule, FqdnOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFqdnOutboundRule runs a test to see if a specific instance of FqdnOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForFqdnOutboundRule(subject FqdnOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FqdnOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FqdnOutboundRule instances for property testing - lazily instantiated by FqdnOutboundRuleGenerator()
var fqdnOutboundRuleGenerator gopter.Gen

// FqdnOutboundRuleGenerator returns a generator of FqdnOutboundRule instances for property testing.
func FqdnOutboundRuleGenerator() gopter.Gen {
	if fqdnOutboundRuleGenerator != nil {
		return fqdnOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFqdnOutboundRule(generators)
	fqdnOutboundRuleGenerator = gen.Struct(reflect.TypeOf(FqdnOutboundRule{}), generators)

	return fqdnOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForFqdnOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFqdnOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.OneConstOf(FqdnOutboundRule_Type_FQDN)
}

func Test_IdentityForCmk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk, IdentityForCmkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk runs a test to see if a specific instance of IdentityForCmk round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk(subject IdentityForCmk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk instances for property testing - lazily instantiated by IdentityForCmkGenerator()
var identityForCmkGenerator gopter.Gen

// IdentityForCmkGenerator returns a generator of IdentityForCmk instances for property testing.
func IdentityForCmkGenerator() gopter.Gen {
	if identityForCmkGenerator != nil {
		return identityForCmkGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmk(generators)
	identityForCmkGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk{}), generators)

	return identityForCmkGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmk(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedNetworkProvisionStatus_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkProvisionStatus via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkProvisionStatus, ManagedNetworkProvisionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkProvisionStatus runs a test to see if a specific instance of ManagedNetworkProvisionStatus round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkProvisionStatus(subject ManagedNetworkProvisionStatus) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkProvisionStatus
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkProvisionStatus instances for property testing - lazily instantiated by
// ManagedNetworkProvisionStatusGenerator()
var managedNetworkProvisionStatusGenerator gopter.Gen

// ManagedNetworkProvisionStatusGenerator returns a generator of ManagedNetworkProvisionStatus instances for property testing.
func ManagedNetworkProvisionStatusGenerator() gopter.Gen {
	if managedNetworkProvisionStatusGenerator != nil {
		return managedNetworkProvisionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus(generators)
	managedNetworkProvisionStatusGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkProvisionStatus{}), generators)

	return managedNetworkProvisionStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkProvisionStatus(gens map[string]gopter.Gen) {
	gens["SparkReady"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ManagedNetworkStatus_Active, ManagedNetworkStatus_Inactive))
}

func Test_ManagedNetworkSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedNetworkSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedNetworkSettings, ManagedNetworkSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedNetworkSettings runs a test to see if a specific instance of ManagedNetworkSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedNetworkSettings(subject ManagedNetworkSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedNetworkSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedNetworkSettings instances for property testing - lazily instantiated by
// ManagedNetworkSettingsGenerator()
var managedNetworkSettingsGenerator gopter.Gen

// ManagedNetworkSettingsGenerator returns a generator of ManagedNetworkSettings instances for property testing.
// We first initialize managedNetworkSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedNetworkSettingsGenerator() gopter.Gen {
	if managedNetworkSettingsGenerator != nil {
		return managedNetworkSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings(generators)
	managedNetworkSettingsGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedNetworkSettings(generators)
	AddRelatedPropertyGeneratorsForManagedNetworkSettings(generators)
	managedNetworkSettingsGenerator = gen.Struct(reflect.TypeOf(ManagedNetworkSettings{}), generators)

	return managedNetworkSettingsGenerator
}

// AddIndependentPropertyGeneratorsForManagedNetworkSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedNetworkSettings(gens map[string]gopter.Gen) {
	gens["IsolationMode"] = gen.PtrOf(gen.OneConstOf(IsolationMode_AllowInternetOutbound, IsolationMode_AllowOnlyApprovedOutbound, IsolationMode_Disabled))
}

// AddRelatedPropertyGeneratorsForManagedNetworkSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedNetworkSettings(gens map[string]gopter.Gen) {
	gens["OutboundRules"] = gen.MapOf(
		gen.AlphaString(),
		OutboundRuleGenerator())
	gens["Status"] = gen.PtrOf(ManagedNetworkProvisionStatusGenerator())
}

func Test_OutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule, OutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule runs a test to see if a specific instance of OutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule(subject OutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule instances for property testing - lazily instantiated by OutboundRuleGenerator()
var outboundRuleGenerator gopter.Gen

// OutboundRuleGenerator returns a generator of OutboundRule instances for property testing.
func OutboundRuleGenerator() gopter.Gen {
	if outboundRuleGenerator != nil {
		return outboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOutboundRule(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(OutboundRule{}), map[string]gopter.Gen{propName: propGen}))
	}
	outboundRuleGenerator = gen.OneGenOf(gens...)

	return outboundRuleGenerator
}

// AddRelatedPropertyGeneratorsForOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule(gens map[string]gopter.Gen) {
	gens["FQDN"] = FqdnOutboundRuleGenerator().Map(func(it FqdnOutboundRule) *FqdnOutboundRule {
		return &it
	}) // generate one case for OneOf type
	gens["PrivateEndpoint"] = PrivateEndpointOutboundRuleGenerator().Map(func(it PrivateEndpointOutboundRule) *PrivateEndpointOutboundRule {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceTag"] = ServiceTagOutboundRuleGenerator().Map(func(it ServiceTagOutboundRule) *ServiceTagOutboundRule {
		return &it
	}) // generate one case for OneOf type
}

func Test_PrivateEndpointDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointDestination, PrivateEndpointDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointDestination runs a test to see if a specific instance of PrivateEndpointDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointDestination(subject PrivateEndpointDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointDestination instances for property testing - lazily instantiated by
// PrivateEndpointDestinationGenerator()
var privateEndpointDestinationGenerator gopter.Gen

// PrivateEndpointDestinationGenerator returns a generator of PrivateEndpointDestination instances for property testing.
func PrivateEndpointDestinationGenerator() gopter.Gen {
	if privateEndpointDestinationGenerator != nil {
		return privateEndpointDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointDestination(generators)
	privateEndpointDestinationGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointDestination{}), generators)

	return privateEndpointDestinationGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointDestination(gens map[string]gopter.Gen) {
	gens["ServiceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SparkEnabled"] = gen.PtrOf(gen.Bool())
	gens["SparkStatus"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["SubresourceTarget"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointOutboundRule, PrivateEndpointOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointOutboundRule runs a test to see if a specific instance of PrivateEndpointOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointOutboundRule(subject PrivateEndpointOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointOutboundRule instances for property testing - lazily instantiated by
// PrivateEndpointOutboundRuleGenerator()
var privateEndpointOutboundRuleGenerator gopter.Gen

// PrivateEndpointOutboundRuleGenerator returns a generator of PrivateEndpointOutboundRule instances for property testing.
// We first initialize privateEndpointOutboundRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointOutboundRuleGenerator() gopter.Gen {
	if privateEndpointOutboundRuleGenerator != nil {
		return privateEndpointOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	privateEndpointOutboundRuleGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule(generators)
	privateEndpointOutboundRuleGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointOutboundRule{}), generators)

	return privateEndpointOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.OneConstOf(PrivateEndpointOutboundRule_Type_PrivateEndpoint)
}

// AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointOutboundRule(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(PrivateEndpointDestinationGenerator())
}

func Test_ServerlessComputeSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessComputeSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessComputeSettings, ServerlessComputeSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessComputeSettings runs a test to see if a specific instance of ServerlessComputeSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessComputeSettings(subject ServerlessComputeSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessComputeSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessComputeSettings instances for property testing - lazily instantiated by
// ServerlessComputeSettingsGenerator()
var serverlessComputeSettingsGenerator gopter.Gen

// ServerlessComputeSettingsGenerator returns a generator of ServerlessComputeSettings instances for property testing.
func ServerlessComputeSettingsGenerator() gopter.Gen {
	if serverlessComputeSettingsGenerator != nil {
		return serverlessComputeSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerlessComputeSettings(generators)
	serverlessComputeSettingsGenerator = gen.Struct(reflect.TypeOf(ServerlessComputeSettings{}), generators)

	return serverlessComputeSettingsGenerator
}

// AddIndependentPropertyGeneratorsForServerlessComputeSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerlessComputeSettings(gens map[string]gopter.Gen) {
	gens["ServerlessComputeCustomSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["ServerlessComputeNoPublicIP"] = gen.PtrOf(gen.Bool())
}

func Test_ServiceManagedResourcesSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings, ServiceManagedResourcesSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings runs a test to see if a specific instance of ServiceManagedResourcesSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings(subject ServiceManagedResourcesSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings instances for property testing - lazily instantiated by
// ServiceManagedResourcesSettingsGenerator()
var serviceManagedResourcesSettingsGenerator gopter.Gen

// ServiceManagedResourcesSettingsGenerator returns a generator of ServiceManagedResourcesSettings instances for property testing.
func ServiceManagedResourcesSettingsGenerator() gopter.Gen {
	if serviceManagedResourcesSettingsGenerator != nil {
		return serviceManagedResourcesSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(generators)
	serviceManagedResourcesSettingsGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings{}), generators)

	return serviceManagedResourcesSettingsGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettingsGenerator())
}

func Test_ServiceTagDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagDestination, ServiceTagDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagDestination runs a test to see if a specific instance of ServiceTagDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagDestination(subject ServiceTagDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagDestination instances for property testing - lazily instantiated by
// ServiceTagDestinationGenerator()
var serviceTagDestinationGenerator gopter.Gen

// ServiceTagDestinationGenerator returns a generator of ServiceTagDestination instances for property testing.
func ServiceTagDestinationGenerator() gopter.Gen {
	if serviceTagDestinationGenerator != nil {
		return serviceTagDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagDestination(generators)
	serviceTagDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceTagDestination{}), generators)

	return serviceTagDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagDestination(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(RuleAction_Allow, RuleAction_Deny))
	gens["PortRanges"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceTag"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceTagOutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceTagOutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceTagOutboundRule, ServiceTagOutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceTagOutboundRule runs a test to see if a specific instance of ServiceTagOutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceTagOutboundRule(subject ServiceTagOutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceTagOutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceTagOutboundRule instances for property testing - lazily instantiated by
// ServiceTagOutboundRuleGenerator()
var serviceTagOutboundRuleGenerator gopter.Gen

// ServiceTagOutboundRuleGenerator returns a generator of ServiceTagOutboundRule instances for property testing.
// We first initialize serviceTagOutboundRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceTagOutboundRuleGenerator() gopter.Gen {
	if serviceTagOutboundRuleGenerator != nil {
		return serviceTagOutboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule(generators)
	serviceTagOutboundRuleGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceTagOutboundRule(generators)
	AddRelatedPropertyGeneratorsForServiceTagOutboundRule(generators)
	serviceTagOutboundRuleGenerator = gen.Struct(reflect.TypeOf(ServiceTagOutboundRule{}), generators)

	return serviceTagOutboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForServiceTagOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceTagOutboundRule(gens map[string]gopter.Gen) {
	gens["Category"] = gen.PtrOf(gen.OneConstOf(
		RuleCategory_Dependency,
		RuleCategory_Recommended,
		RuleCategory_Required,
		RuleCategory_UserDefined))
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RuleStatus_Active, RuleStatus_Inactive))
	gens["Type"] = gen.OneConstOf(ServiceTagOutboundRule_Type_ServiceTag)
}

// AddRelatedPropertyGeneratorsForServiceTagOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceTagOutboundRule(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(ServiceTagDestinationGenerator())
}

func Test_SharedPrivateLinkResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource, SharedPrivateLinkResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource runs a test to see if a specific instance of SharedPrivateLinkResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource(subject SharedPrivateLinkResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource instances for property testing - lazily instantiated by
// SharedPrivateLinkResourceGenerator()
var sharedPrivateLinkResourceGenerator gopter.Gen

// SharedPrivateLinkResourceGenerator returns a generator of SharedPrivateLinkResource instances for property testing.
// We first initialize sharedPrivateLinkResourceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResourceGenerator() gopter.Gen {
	if sharedPrivateLinkResourceGenerator != nil {
		return sharedPrivateLinkResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(generators)
	sharedPrivateLinkResourceGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResource(generators)
	sharedPrivateLinkResourceGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource{}), generators)

	return sharedPrivateLinkResourceGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResource is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResource(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SharedPrivateLinkResourcePropertyGenerator())
}

func Test_SharedPrivateLinkResourceProperty_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResourceProperty via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceProperty, SharedPrivateLinkResourcePropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceProperty runs a test to see if a specific instance of SharedPrivateLinkResourceProperty round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceProperty(subject SharedPrivateLinkResourceProperty) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResourceProperty
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResourceProperty instances for property testing - lazily instantiated by
// SharedPrivateLinkResourcePropertyGenerator()
var sharedPrivateLinkResourcePropertyGenerator gopter.Gen

// SharedPrivateLinkResourcePropertyGenerator returns a generator of SharedPrivateLinkResourceProperty instances for property testing.
func SharedPrivateLinkResourcePropertyGenerator() gopter.Gen {
	if sharedPrivateLinkResourcePropertyGenerator != nil {
		return sharedPrivateLinkResourcePropertyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty(generators)
	sharedPrivateLinkResourcePropertyGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResourceProperty{}), generators)

	return sharedPrivateLinkResourcePropertyGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceProperty(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_Approved,
		PrivateEndpointServiceConnectionStatus_Disconnected,
		PrivateEndpointServiceConnectionStatus_Pending,
		PrivateEndpointServiceConnectionStatus_Rejected,
		PrivateEndpointServiceConnectionStatus_Timeout))
}

func Test_WorkspaceHubConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceHubConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceHubConfig, WorkspaceHubConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceHubConfig runs a test to see if a specific instance of WorkspaceHubConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceHubConfig(subject WorkspaceHubConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceHubConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceHubConfig instances for property testing - lazily instantiated by WorkspaceHubConfigGenerator()
var workspaceHubConfigGenerator gopter.Gen

// WorkspaceHubConfigGenerator returns a generator of WorkspaceHubConfig instances for property testing.
func WorkspaceHubConfigGenerator() gopter.Gen {
	if workspaceHubConfigGenerator != nil {
		return workspaceHubConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceHubConfig(generators)
	workspaceHubConfigGenerator = gen.Struct(reflect.TypeOf(WorkspaceHubConfig{}), generators)

	return workspaceHubConfigGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceHubConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceHubConfig(gens map[string]gopter.Gen) {
	gens["AdditionalWorkspaceStorageAccounts"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultWorkspaceResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceProperties, WorkspacePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceProperties runs a test to see if a specific instance of WorkspaceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceProperties(subject WorkspaceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceProperties instances for property testing - lazily instantiated by
// WorkspacePropertiesGenerator()
var workspacePropertiesGenerator gopter.Gen

// WorkspacePropertiesGenerator returns a generator of WorkspaceProperties instances for property testing.
// We first initialize workspacePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WorkspacePropertiesGenerator() gopter.Gen {
	if workspacePropertiesGenerator != nil {
		return workspacePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceProperties(generators)
	workspacePropertiesGenerator = gen.Struct(reflect.TypeOf(WorkspaceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceProperties(generators)
	AddRelatedPropertyGeneratorsForWorkspaceProperties(generators)
	workspacePropertiesGenerator = gen.Struct(reflect.TypeOf(WorkspaceProperties{}), generators)

	return workspacePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceProperties(gens map[string]gopter.Gen) {
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["ApplicationInsights"] = gen.PtrOf(gen.AlphaString())
	gens["AssociatedWorkspaces"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerRegistry"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["EnableDataIsolation"] = gen.PtrOf(gen.Bool())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["HubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVault"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_Disabled, WorkspaceProperties_PublicNetworkAccess_Enabled))
	gens["StorageAccount"] = gen.PtrOf(gen.AlphaString())
	gens["V1LegacyMode"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWorkspaceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceProperties(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyGenerator())
	gens["FeatureStoreSettings"] = gen.PtrOf(FeatureStoreSettingsGenerator())
	gens["ManagedNetwork"] = gen.PtrOf(ManagedNetworkSettingsGenerator())
	gens["ServerlessComputeSettings"] = gen.PtrOf(ServerlessComputeSettingsGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettingsGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceGenerator())
	gens["WorkspaceHubConfig"] = gen.PtrOf(WorkspaceHubConfigGenerator())
}

func Test_Workspace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_Spec runs a test to see if a specific instance of Workspace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_Spec instances for property testing - lazily instantiated by Workspace_SpecGenerator()
var workspace_SpecGenerator gopter.Gen

// Workspace_SpecGenerator returns a generator of Workspace_Spec instances for property testing.
// We first initialize workspace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_SpecGenerator() gopter.Gen {
	if workspace_SpecGenerator != nil {
		return workspace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	return workspace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(WorkspacePropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}
