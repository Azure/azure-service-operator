// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AcrDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AcrDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAcrDetails_ARM, AcrDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAcrDetails_ARM runs a test to see if a specific instance of AcrDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAcrDetails_ARM(subject AcrDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AcrDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AcrDetails_ARM instances for property testing - lazily instantiated by AcrDetails_ARMGenerator()
var acrDetails_ARMGenerator gopter.Gen

// AcrDetails_ARMGenerator returns a generator of AcrDetails_ARM instances for property testing.
func AcrDetails_ARMGenerator() gopter.Gen {
	if acrDetails_ARMGenerator != nil {
		return acrDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAcrDetails_ARM(generators)
	acrDetails_ARMGenerator = gen.Struct(reflect.TypeOf(AcrDetails_ARM{}), generators)

	return acrDetails_ARMGenerator
}

// AddRelatedPropertyGeneratorsForAcrDetails_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAcrDetails_ARM(gens map[string]gopter.Gen) {
	gens["SystemCreatedAcrAccount"] = gen.PtrOf(SystemCreatedAcrAccount_ARMGenerator())
	gens["UserCreatedAcrAccount"] = gen.PtrOf(UserCreatedAcrAccount_ARMGenerator())
}

func Test_ArmResourceId_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmResourceId_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmResourceId_ARM, ArmResourceId_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmResourceId_ARM runs a test to see if a specific instance of ArmResourceId_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForArmResourceId_ARM(subject ArmResourceId_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmResourceId_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmResourceId_ARM instances for property testing - lazily instantiated by ArmResourceId_ARMGenerator()
var armResourceId_ARMGenerator gopter.Gen

// ArmResourceId_ARMGenerator returns a generator of ArmResourceId_ARM instances for property testing.
func ArmResourceId_ARMGenerator() gopter.Gen {
	if armResourceId_ARMGenerator != nil {
		return armResourceId_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmResourceId_ARM(generators)
	armResourceId_ARMGenerator = gen.Struct(reflect.TypeOf(ArmResourceId_ARM{}), generators)

	return armResourceId_ARMGenerator
}

// AddIndependentPropertyGeneratorsForArmResourceId_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmResourceId_ARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_ARM, ManagedServiceIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_ARM runs a test to see if a specific instance of ManagedServiceIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_ARM(subject ManagedServiceIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_ARM instances for property testing - lazily instantiated by
// ManagedServiceIdentity_ARMGenerator()
var managedServiceIdentity_ARMGenerator gopter.Gen

// ManagedServiceIdentity_ARMGenerator returns a generator of ManagedServiceIdentity_ARM instances for property testing.
// We first initialize managedServiceIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_ARMGenerator() gopter.Gen {
	if managedServiceIdentity_ARMGenerator != nil {
		return managedServiceIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	managedServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	managedServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_ARM{}), generators)

	return managedServiceIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_ARM_None,
		ManagedServiceIdentityType_ARM_SystemAssigned,
		ManagedServiceIdentityType_ARM_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_ARM_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetails_ARMGenerator())
}

func Test_PrivateEndpointResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointResource_ARM, PrivateEndpointResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointResource_ARM runs a test to see if a specific instance of PrivateEndpointResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointResource_ARM(subject PrivateEndpointResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointResource_ARM instances for property testing - lazily instantiated by
// PrivateEndpointResource_ARMGenerator()
var privateEndpointResource_ARMGenerator gopter.Gen

// PrivateEndpointResource_ARMGenerator returns a generator of PrivateEndpointResource_ARM instances for property testing.
func PrivateEndpointResource_ARMGenerator() gopter.Gen {
	if privateEndpointResource_ARMGenerator != nil {
		return privateEndpointResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointResource_ARM(generators)
	privateEndpointResource_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointResource_ARM{}), generators)

	return privateEndpointResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointResource_ARM(gens map[string]gopter.Gen) {
	gens["SubnetArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_RegistryPrivateEndpointConnectionProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryPrivateEndpointConnectionProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryPrivateEndpointConnectionProperties_ARM, RegistryPrivateEndpointConnectionProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryPrivateEndpointConnectionProperties_ARM runs a test to see if a specific instance of RegistryPrivateEndpointConnectionProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryPrivateEndpointConnectionProperties_ARM(subject RegistryPrivateEndpointConnectionProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryPrivateEndpointConnectionProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryPrivateEndpointConnectionProperties_ARM instances for property testing - lazily instantiated by
// RegistryPrivateEndpointConnectionProperties_ARMGenerator()
var registryPrivateEndpointConnectionProperties_ARMGenerator gopter.Gen

// RegistryPrivateEndpointConnectionProperties_ARMGenerator returns a generator of RegistryPrivateEndpointConnectionProperties_ARM instances for property testing.
// We first initialize registryPrivateEndpointConnectionProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryPrivateEndpointConnectionProperties_ARMGenerator() gopter.Gen {
	if registryPrivateEndpointConnectionProperties_ARMGenerator != nil {
		return registryPrivateEndpointConnectionProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM(generators)
	registryPrivateEndpointConnectionProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryPrivateEndpointConnectionProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM(generators)
	registryPrivateEndpointConnectionProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryPrivateEndpointConnectionProperties_ARM{}), generators)

	return registryPrivateEndpointConnectionProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM(gens map[string]gopter.Gen) {
	gens["GroupIds"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnectionProperties_ARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointResource_ARMGenerator())
	gens["RegistryPrivateLinkServiceConnectionState"] = gen.PtrOf(RegistryPrivateLinkServiceConnectionState_ARMGenerator())
}

func Test_RegistryPrivateEndpointConnection_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryPrivateEndpointConnection_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryPrivateEndpointConnection_ARM, RegistryPrivateEndpointConnection_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryPrivateEndpointConnection_ARM runs a test to see if a specific instance of RegistryPrivateEndpointConnection_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryPrivateEndpointConnection_ARM(subject RegistryPrivateEndpointConnection_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryPrivateEndpointConnection_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryPrivateEndpointConnection_ARM instances for property testing - lazily instantiated by
// RegistryPrivateEndpointConnection_ARMGenerator()
var registryPrivateEndpointConnection_ARMGenerator gopter.Gen

// RegistryPrivateEndpointConnection_ARMGenerator returns a generator of RegistryPrivateEndpointConnection_ARM instances for property testing.
// We first initialize registryPrivateEndpointConnection_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryPrivateEndpointConnection_ARMGenerator() gopter.Gen {
	if registryPrivateEndpointConnection_ARMGenerator != nil {
		return registryPrivateEndpointConnection_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM(generators)
	registryPrivateEndpointConnection_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryPrivateEndpointConnection_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM(generators)
	AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM(generators)
	registryPrivateEndpointConnection_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryPrivateEndpointConnection_ARM{}), generators)

	return registryPrivateEndpointConnection_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryPrivateEndpointConnection_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(RegistryPrivateEndpointConnectionProperties_ARMGenerator())
}

func Test_RegistryPrivateLinkServiceConnectionState_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryPrivateLinkServiceConnectionState_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryPrivateLinkServiceConnectionState_ARM, RegistryPrivateLinkServiceConnectionState_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryPrivateLinkServiceConnectionState_ARM runs a test to see if a specific instance of RegistryPrivateLinkServiceConnectionState_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryPrivateLinkServiceConnectionState_ARM(subject RegistryPrivateLinkServiceConnectionState_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryPrivateLinkServiceConnectionState_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryPrivateLinkServiceConnectionState_ARM instances for property testing - lazily instantiated by
// RegistryPrivateLinkServiceConnectionState_ARMGenerator()
var registryPrivateLinkServiceConnectionState_ARMGenerator gopter.Gen

// RegistryPrivateLinkServiceConnectionState_ARMGenerator returns a generator of RegistryPrivateLinkServiceConnectionState_ARM instances for property testing.
func RegistryPrivateLinkServiceConnectionState_ARMGenerator() gopter.Gen {
	if registryPrivateLinkServiceConnectionState_ARMGenerator != nil {
		return registryPrivateLinkServiceConnectionState_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPrivateLinkServiceConnectionState_ARM(generators)
	registryPrivateLinkServiceConnectionState_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryPrivateLinkServiceConnectionState_ARM{}), generators)

	return registryPrivateLinkServiceConnectionState_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryPrivateLinkServiceConnectionState_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryPrivateLinkServiceConnectionState_ARM(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		EndpointServiceConnectionStatus_ARM_Approved,
		EndpointServiceConnectionStatus_ARM_Disconnected,
		EndpointServiceConnectionStatus_ARM_Pending,
		EndpointServiceConnectionStatus_ARM_Rejected))
}

func Test_RegistryRegionArmDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryRegionArmDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryRegionArmDetails_ARM, RegistryRegionArmDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryRegionArmDetails_ARM runs a test to see if a specific instance of RegistryRegionArmDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryRegionArmDetails_ARM(subject RegistryRegionArmDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryRegionArmDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryRegionArmDetails_ARM instances for property testing - lazily instantiated by
// RegistryRegionArmDetails_ARMGenerator()
var registryRegionArmDetails_ARMGenerator gopter.Gen

// RegistryRegionArmDetails_ARMGenerator returns a generator of RegistryRegionArmDetails_ARM instances for property testing.
// We first initialize registryRegionArmDetails_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryRegionArmDetails_ARMGenerator() gopter.Gen {
	if registryRegionArmDetails_ARMGenerator != nil {
		return registryRegionArmDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryRegionArmDetails_ARM(generators)
	registryRegionArmDetails_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryRegionArmDetails_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryRegionArmDetails_ARM(generators)
	AddRelatedPropertyGeneratorsForRegistryRegionArmDetails_ARM(generators)
	registryRegionArmDetails_ARMGenerator = gen.Struct(reflect.TypeOf(RegistryRegionArmDetails_ARM{}), generators)

	return registryRegionArmDetails_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryRegionArmDetails_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryRegionArmDetails_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistryRegionArmDetails_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryRegionArmDetails_ARM(gens map[string]gopter.Gen) {
	gens["AcrDetails"] = gen.SliceOf(AcrDetails_ARMGenerator())
	gens["StorageAccountDetails"] = gen.SliceOf(StorageAccountDetails_ARMGenerator())
}

func Test_RegistrySpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistrySpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistrySpec_ARM, RegistrySpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistrySpec_ARM runs a test to see if a specific instance of RegistrySpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistrySpec_ARM(subject RegistrySpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistrySpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistrySpec_ARM instances for property testing - lazily instantiated by RegistrySpec_ARMGenerator()
var registrySpec_ARMGenerator gopter.Gen

// RegistrySpec_ARMGenerator returns a generator of RegistrySpec_ARM instances for property testing.
// We first initialize registrySpec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistrySpec_ARMGenerator() gopter.Gen {
	if registrySpec_ARMGenerator != nil {
		return registrySpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySpec_ARM(generators)
	registrySpec_ARMGenerator = gen.Struct(reflect.TypeOf(RegistrySpec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySpec_ARM(generators)
	AddRelatedPropertyGeneratorsForRegistrySpec_ARM(generators)
	registrySpec_ARMGenerator = gen.Struct(reflect.TypeOf(RegistrySpec_ARM{}), generators)

	return registrySpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistrySpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistrySpec_ARM(gens map[string]gopter.Gen) {
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["IntellectualPropertyPublisher"] = gen.PtrOf(gen.AlphaString())
	gens["MlFlowRegistryUri"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistrySpec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistrySpec_ARM(gens map[string]gopter.Gen) {
	gens["ManagedResourceGroup"] = gen.PtrOf(ArmResourceId_ARMGenerator())
	gens["RegionDetails"] = gen.SliceOf(RegistryRegionArmDetails_ARMGenerator())
	gens["RegistryPrivateEndpointConnections"] = gen.SliceOf(RegistryPrivateEndpointConnection_ARMGenerator())
}

func Test_Registry_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistry_Spec_ARM, Registry_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistry_Spec_ARM runs a test to see if a specific instance of Registry_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistry_Spec_ARM(subject Registry_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_Spec_ARM instances for property testing - lazily instantiated by Registry_Spec_ARMGenerator()
var registry_Spec_ARMGenerator gopter.Gen

// Registry_Spec_ARMGenerator returns a generator of Registry_Spec_ARM instances for property testing.
// We first initialize registry_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Registry_Spec_ARMGenerator() gopter.Gen {
	if registry_Spec_ARMGenerator != nil {
		return registry_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_Spec_ARM(generators)
	registry_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Registry_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForRegistry_Spec_ARM(generators)
	registry_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Registry_Spec_ARM{}), generators)

	return registry_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistry_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistry_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistry_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistry_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(RegistrySpec_ARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_ARMGenerator())
}

func Test_Sku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_ARM, Sku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_ARM runs a test to see if a specific instance of Sku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_ARM(subject Sku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_ARM instances for property testing - lazily instantiated by Sku_ARMGenerator()
var sku_ARMGenerator gopter.Gen

// Sku_ARMGenerator returns a generator of Sku_ARM instances for property testing.
func Sku_ARMGenerator() gopter.Gen {
	if sku_ARMGenerator != nil {
		return sku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_ARM(generators)
	sku_ARMGenerator = gen.Struct(reflect.TypeOf(Sku_ARM{}), generators)

	return sku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuTier_ARM_Basic,
		SkuTier_ARM_Free,
		SkuTier_ARM_Premium,
		SkuTier_ARM_Standard))
}

func Test_StorageAccountDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageAccountDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageAccountDetails_ARM, StorageAccountDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageAccountDetails_ARM runs a test to see if a specific instance of StorageAccountDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageAccountDetails_ARM(subject StorageAccountDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageAccountDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageAccountDetails_ARM instances for property testing - lazily instantiated by
// StorageAccountDetails_ARMGenerator()
var storageAccountDetails_ARMGenerator gopter.Gen

// StorageAccountDetails_ARMGenerator returns a generator of StorageAccountDetails_ARM instances for property testing.
func StorageAccountDetails_ARMGenerator() gopter.Gen {
	if storageAccountDetails_ARMGenerator != nil {
		return storageAccountDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageAccountDetails_ARM(generators)
	storageAccountDetails_ARMGenerator = gen.Struct(reflect.TypeOf(StorageAccountDetails_ARM{}), generators)

	return storageAccountDetails_ARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageAccountDetails_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageAccountDetails_ARM(gens map[string]gopter.Gen) {
	gens["SystemCreatedStorageAccount"] = gen.PtrOf(SystemCreatedStorageAccount_ARMGenerator())
	gens["UserCreatedStorageAccount"] = gen.PtrOf(UserCreatedStorageAccount_ARMGenerator())
}

func Test_SystemCreatedAcrAccount_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemCreatedAcrAccount_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemCreatedAcrAccount_ARM, SystemCreatedAcrAccount_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemCreatedAcrAccount_ARM runs a test to see if a specific instance of SystemCreatedAcrAccount_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemCreatedAcrAccount_ARM(subject SystemCreatedAcrAccount_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemCreatedAcrAccount_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemCreatedAcrAccount_ARM instances for property testing - lazily instantiated by
// SystemCreatedAcrAccount_ARMGenerator()
var systemCreatedAcrAccount_ARMGenerator gopter.Gen

// SystemCreatedAcrAccount_ARMGenerator returns a generator of SystemCreatedAcrAccount_ARM instances for property testing.
func SystemCreatedAcrAccount_ARMGenerator() gopter.Gen {
	if systemCreatedAcrAccount_ARMGenerator != nil {
		return systemCreatedAcrAccount_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemCreatedAcrAccount_ARM(generators)
	systemCreatedAcrAccount_ARMGenerator = gen.Struct(reflect.TypeOf(SystemCreatedAcrAccount_ARM{}), generators)

	return systemCreatedAcrAccount_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemCreatedAcrAccount_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemCreatedAcrAccount_ARM(gens map[string]gopter.Gen) {
	gens["AcrAccountName"] = gen.PtrOf(gen.AlphaString())
	gens["AcrAccountSku"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemCreatedStorageAccount_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemCreatedStorageAccount_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemCreatedStorageAccount_ARM, SystemCreatedStorageAccount_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemCreatedStorageAccount_ARM runs a test to see if a specific instance of SystemCreatedStorageAccount_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemCreatedStorageAccount_ARM(subject SystemCreatedStorageAccount_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemCreatedStorageAccount_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemCreatedStorageAccount_ARM instances for property testing - lazily instantiated by
// SystemCreatedStorageAccount_ARMGenerator()
var systemCreatedStorageAccount_ARMGenerator gopter.Gen

// SystemCreatedStorageAccount_ARMGenerator returns a generator of SystemCreatedStorageAccount_ARM instances for property testing.
func SystemCreatedStorageAccount_ARMGenerator() gopter.Gen {
	if systemCreatedStorageAccount_ARMGenerator != nil {
		return systemCreatedStorageAccount_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemCreatedStorageAccount_ARM(generators)
	systemCreatedStorageAccount_ARMGenerator = gen.Struct(reflect.TypeOf(SystemCreatedStorageAccount_ARM{}), generators)

	return systemCreatedStorageAccount_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemCreatedStorageAccount_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemCreatedStorageAccount_ARM(gens map[string]gopter.Gen) {
	gens["AllowBlobPublicAccess"] = gen.PtrOf(gen.Bool())
	gens["StorageAccountHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}

func Test_UserCreatedAcrAccount_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserCreatedAcrAccount_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserCreatedAcrAccount_ARM, UserCreatedAcrAccount_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserCreatedAcrAccount_ARM runs a test to see if a specific instance of UserCreatedAcrAccount_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserCreatedAcrAccount_ARM(subject UserCreatedAcrAccount_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserCreatedAcrAccount_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserCreatedAcrAccount_ARM instances for property testing - lazily instantiated by
// UserCreatedAcrAccount_ARMGenerator()
var userCreatedAcrAccount_ARMGenerator gopter.Gen

// UserCreatedAcrAccount_ARMGenerator returns a generator of UserCreatedAcrAccount_ARM instances for property testing.
func UserCreatedAcrAccount_ARMGenerator() gopter.Gen {
	if userCreatedAcrAccount_ARMGenerator != nil {
		return userCreatedAcrAccount_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUserCreatedAcrAccount_ARM(generators)
	userCreatedAcrAccount_ARMGenerator = gen.Struct(reflect.TypeOf(UserCreatedAcrAccount_ARM{}), generators)

	return userCreatedAcrAccount_ARMGenerator
}

// AddRelatedPropertyGeneratorsForUserCreatedAcrAccount_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserCreatedAcrAccount_ARM(gens map[string]gopter.Gen) {
	gens["ArmResourceId"] = gen.PtrOf(ArmResourceId_ARMGenerator())
}

func Test_UserCreatedStorageAccount_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserCreatedStorageAccount_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserCreatedStorageAccount_ARM, UserCreatedStorageAccount_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserCreatedStorageAccount_ARM runs a test to see if a specific instance of UserCreatedStorageAccount_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserCreatedStorageAccount_ARM(subject UserCreatedStorageAccount_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserCreatedStorageAccount_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserCreatedStorageAccount_ARM instances for property testing - lazily instantiated by
// UserCreatedStorageAccount_ARMGenerator()
var userCreatedStorageAccount_ARMGenerator gopter.Gen

// UserCreatedStorageAccount_ARMGenerator returns a generator of UserCreatedStorageAccount_ARM instances for property testing.
func UserCreatedStorageAccount_ARMGenerator() gopter.Gen {
	if userCreatedStorageAccount_ARMGenerator != nil {
		return userCreatedStorageAccount_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUserCreatedStorageAccount_ARM(generators)
	userCreatedStorageAccount_ARMGenerator = gen.Struct(reflect.TypeOf(UserCreatedStorageAccount_ARM{}), generators)

	return userCreatedStorageAccount_ARMGenerator
}

// AddRelatedPropertyGeneratorsForUserCreatedStorageAccount_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserCreatedStorageAccount_ARM(gens map[string]gopter.Gen) {
	gens["ArmResourceId"] = gen.PtrOf(ArmResourceId_ARMGenerator())
}
