// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210701

import (
	"encoding/json"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1beta20210701storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Workspace_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to hub returns original",
		prop.ForAll(RunResourceConversionTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWorkspace tests if a specific instance of Workspace round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210701s.Workspace
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Workspace
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to Workspace via AssignPropertiesToWorkspace & AssignPropertiesFromWorkspace returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace tests if a specific instance of Workspace can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Workspace
	err := copied.AssignPropertiesToWorkspace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace
	err = actual.AssignPropertiesFromWorkspace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace runs a test to see if a specific instance of Workspace round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace(subject Workspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace instances for property testing - lazily instantiated by WorkspaceGenerator()
var workspaceGenerator gopter.Gen

// WorkspaceGenerator returns a generator of Workspace instances for property testing.
func WorkspaceGenerator() gopter.Gen {
	if workspaceGenerator != nil {
		return workspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspace(generators)
	workspaceGenerator = gen.Struct(reflect.TypeOf(Workspace{}), generators)

	return workspaceGenerator
}

// AddRelatedPropertyGeneratorsForWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace(gens map[string]gopter.Gen) {
<<<<<<< HEAD
	gens["Spec"] = Workspace_SpecGenerator()
	gens["Status"] = Workspace_STATUSGenerator()
=======
	gens["Spec"] = WorkspacesSpecGenerator()
	gens["Status"] = WorkspaceSTATUSGenerator()
>>>>>>> main
}

func Test_Workspace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Workspace_STATUS to Workspace_STATUS via AssignPropertiesToWorkspace_STATUS & AssignPropertiesFromWorkspace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_STATUS tests if a specific instance of Workspace_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_STATUS(subject Workspace_STATUS) string {
=======
		"Round trip from Workspace_STATUS to Workspace_STATUS via AssignPropertiesToWorkspaceSTATUS & AssignPropertiesFromWorkspaceSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceSTATUS, WorkspaceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceSTATUS tests if a specific instance of Workspace_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceSTATUS(subject Workspace_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Workspace_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToWorkspace_STATUS(&other)
=======
	err := copied.AssignPropertiesToWorkspaceSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromWorkspace_STATUS(&other)
=======
	err = actual.AssignPropertiesFromWorkspaceSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_STATUS runs a test to see if a specific instance of Workspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_STATUS(subject Workspace_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForWorkspaceSTATUS, WorkspaceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceSTATUS runs a test to see if a specific instance of Workspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceSTATUS(subject Workspace_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Workspace_STATUS instances for property testing - lazily instantiated by Workspace_STATUSGenerator()
var workspace_STATUSGenerator gopter.Gen

// Workspace_STATUSGenerator returns a generator of Workspace_STATUS instances for property testing.
// We first initialize workspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_STATUSGenerator() gopter.Gen {
	if workspace_STATUSGenerator != nil {
		return workspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	return workspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of Workspace_STATUS instances for property testing - lazily instantiated by WorkspaceSTATUSGenerator()
var workspaceSTATUSGenerator gopter.Gen

// WorkspaceSTATUSGenerator returns a generator of Workspace_STATUS instances for property testing.
// We first initialize workspaceSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WorkspaceSTATUSGenerator() gopter.Gen {
	if workspaceSTATUSGenerator != nil {
		return workspaceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceSTATUS(generators)
	workspaceSTATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceSTATUS(generators)
	AddRelatedPropertyGeneratorsForWorkspaceSTATUS(generators)
	workspaceSTATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	return workspaceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["ApplicationInsights"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerRegistry"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVault"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MlFlowTrackingUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkCount"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
<<<<<<< HEAD
		WorkspaceProperties_ProvisioningState_Canceled_STATUS,
		WorkspaceProperties_ProvisioningState_Creating_STATUS,
		WorkspaceProperties_ProvisioningState_Deleting_STATUS,
		WorkspaceProperties_ProvisioningState_Failed_STATUS,
		WorkspaceProperties_ProvisioningState_Succeeded_STATUS,
		WorkspaceProperties_ProvisioningState_Unknown_STATUS,
		WorkspaceProperties_ProvisioningState_Updating_STATUS))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_Disabled_STATUS, WorkspaceProperties_PublicNetworkAccess_Enabled_STATUS))
=======
		WorkspacePropertiesSTATUSProvisioningState_Canceled,
		WorkspacePropertiesSTATUSProvisioningState_Creating,
		WorkspacePropertiesSTATUSProvisioningState_Deleting,
		WorkspacePropertiesSTATUSProvisioningState_Failed,
		WorkspacePropertiesSTATUSProvisioningState_Succeeded,
		WorkspacePropertiesSTATUSProvisioningState_Unknown,
		WorkspacePropertiesSTATUSProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspacePropertiesSTATUSPublicNetworkAccess_Disabled, WorkspacePropertiesSTATUSPublicNetworkAccess_Enabled))
>>>>>>> main
	gens["ServiceProvisionedResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccount"] = gen.PtrOf(gen.AlphaString())
	gens["StorageHnsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionProperty_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["NotebookInfo"] = gen.PtrOf(NotebookResourceInfo_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettings_STATUSGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
=======
// AddRelatedPropertyGeneratorsForWorkspaceSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceSTATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertySTATUSGenerator())
	gens["Identity"] = gen.PtrOf(IdentitySTATUSGenerator())
	gens["NotebookInfo"] = gen.PtrOf(NotebookResourceInfoSTATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettingsSTATUSGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceSTATUSGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
>>>>>>> main
}

func Test_Workspace_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace_Spec to Workspace_Spec via AssignPropertiesToWorkspace_Spec & AssignPropertiesFromWorkspace_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_Spec tests if a specific instance of Workspace_Spec can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Workspace_Spec
	err := copied.AssignPropertiesToWorkspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_Spec
	err = actual.AssignPropertiesFromWorkspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_Spec runs a test to see if a specific instance of Workspace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_Spec instances for property testing - lazily instantiated by Workspace_SpecGenerator()
var workspace_SpecGenerator gopter.Gen

// Workspace_SpecGenerator returns a generator of Workspace_Spec instances for property testing.
// We first initialize workspace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_SpecGenerator() gopter.Gen {
	if workspace_SpecGenerator != nil {
		return workspace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	return workspace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["AllowPublicAccessWhenBehindVnet"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DiscoveryUrl"] = gen.PtrOf(gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["HbiWorkspace"] = gen.PtrOf(gen.Bool())
	gens["ImageBuildCompute"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_Disabled, WorkspaceProperties_PublicNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyGenerator())
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(WorkspaceOperatorSpecGenerator())
	gens["ServiceManagedResourcesSettings"] = gen.PtrOf(ServiceManagedResourcesSettingsGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_EncryptionProperty_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperty to EncryptionProperty via AssignPropertiesToEncryptionProperty & AssignPropertiesFromEncryptionProperty returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty tests if a specific instance of EncryptionProperty can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty(subject EncryptionProperty) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.EncryptionProperty
	err := copied.AssignPropertiesToEncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty
	err = actual.AssignPropertiesFromEncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty runs a test to see if a specific instance of EncryptionProperty round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty(subject EncryptionProperty) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty instances for property testing - lazily instantiated by EncryptionPropertyGenerator()
var encryptionPropertyGenerator gopter.Gen

// EncryptionPropertyGenerator returns a generator of EncryptionProperty instances for property testing.
// We first initialize encryptionPropertyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertyGenerator() gopter.Gen {
	if encryptionPropertyGenerator != nil {
		return encryptionPropertyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	return encryptionPropertyGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_Status_Disabled, EncryptionProperty_Status_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmkGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesGenerator())
}

func Test_EncryptionProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from EncryptionProperty_STATUS to EncryptionProperty_STATUS via AssignPropertiesToEncryptionProperty_STATUS & AssignPropertiesFromEncryptionProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty_STATUS tests if a specific instance of EncryptionProperty_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
=======
		"Round trip from EncryptionProperty_STATUS to EncryptionProperty_STATUS via AssignPropertiesToEncryptionPropertySTATUS & AssignPropertiesFromEncryptionPropertySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertySTATUS, EncryptionPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertySTATUS tests if a specific instance of EncryptionProperty_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertySTATUS(subject EncryptionProperty_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.EncryptionProperty_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToEncryptionProperty_STATUS(&other)
=======
	err := copied.AssignPropertiesToEncryptionPropertySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromEncryptionProperty_STATUS(&other)
=======
	err = actual.AssignPropertiesFromEncryptionPropertySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty_STATUS runs a test to see if a specific instance of EncryptionProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertySTATUS, EncryptionPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertySTATUS runs a test to see if a specific instance of EncryptionProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertySTATUS(subject EncryptionProperty_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// EncryptionProperty_STATUSGenerator()
var encryptionProperty_STATUSGenerator gopter.Gen

// EncryptionProperty_STATUSGenerator returns a generator of EncryptionProperty_STATUS instances for property testing.
// We first initialize encryptionProperty_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperty_STATUSGenerator() gopter.Gen {
	if encryptionProperty_STATUSGenerator != nil {
		return encryptionProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	return encryptionProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_Status_Disabled_STATUS, EncryptionProperty_Status_Enabled_STATUS))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmk_STATUSGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_STATUSGenerator())
=======
// EncryptionPropertySTATUSGenerator()
var encryptionPropertySTATUSGenerator gopter.Gen

// EncryptionPropertySTATUSGenerator returns a generator of EncryptionProperty_STATUS instances for property testing.
// We first initialize encryptionPropertySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertySTATUSGenerator() gopter.Gen {
	if encryptionPropertySTATUSGenerator != nil {
		return encryptionPropertySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	encryptionPropertySTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	encryptionPropertySTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	return encryptionPropertySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertySTATUSStatus_Disabled, EncryptionPropertySTATUSStatus_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityForCmkSTATUSGenerator())
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSGenerator())
>>>>>>> main
}

func Test_Identity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Identity to Identity via AssignPropertiesToIdentity & AssignPropertiesFromIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity tests if a specific instance of Identity can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentity(subject Identity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Identity
	err := copied.AssignPropertiesToIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity
	err = actual.AssignPropertiesFromIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_None,
		Identity_Type_SystemAssigned,
		Identity_Type_SystemAssignedUserAssigned,
		Identity_Type_UserAssigned))
}

func Test_Identity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Identity_STATUS to Identity_STATUS via AssignPropertiesToIdentity_STATUS & AssignPropertiesFromIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity_STATUS tests if a specific instance of Identity_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentity_STATUS(subject Identity_STATUS) string {
=======
		"Round trip from Identity_STATUS to Identity_STATUS via AssignPropertiesToIdentitySTATUS & AssignPropertiesFromIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentitySTATUS, IdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentitySTATUS tests if a specific instance of Identity_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentitySTATUS(subject Identity_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Identity_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToIdentity_STATUS(&other)
=======
	err := copied.AssignPropertiesToIdentitySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromIdentity_STATUS(&other)
=======
	err = actual.AssignPropertiesFromIdentitySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
<<<<<<< HEAD
=======
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentitySTATUS, IdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentitySTATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentitySTATUS(subject Identity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUS instances for property testing - lazily instantiated by IdentitySTATUSGenerator()
var identitySTATUSGenerator gopter.Gen

// IdentitySTATUSGenerator returns a generator of Identity_STATUS instances for property testing.
// We first initialize identitySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentitySTATUSGenerator() gopter.Gen {
	if identitySTATUSGenerator != nil {
		return identitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUS(generators)
	identitySTATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentitySTATUS(generators)
	AddRelatedPropertyGeneratorsForIdentitySTATUS(generators)
	identitySTATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentitySTATUSType_None,
		IdentitySTATUSType_SystemAssigned,
		IdentitySTATUSType_SystemAssignedUserAssigned,
		IdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentitySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentitySTATUSGenerator())
}

func Test_NotebookResourceInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotebookResourceInfo_STATUS to NotebookResourceInfo_STATUS via AssignPropertiesToNotebookResourceInfoSTATUS & AssignPropertiesFromNotebookResourceInfoSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookResourceInfoSTATUS, NotebookResourceInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookResourceInfoSTATUS tests if a specific instance of NotebookResourceInfo_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForNotebookResourceInfoSTATUS(subject NotebookResourceInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.NotebookResourceInfo_STATUS
	err := copied.AssignPropertiesToNotebookResourceInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotebookResourceInfo_STATUS
	err = actual.AssignPropertiesFromNotebookResourceInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotebookResourceInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotebookResourceInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotebookResourceInfoSTATUS, NotebookResourceInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookResourceInfoSTATUS runs a test to see if a specific instance of NotebookResourceInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookResourceInfoSTATUS(subject NotebookResourceInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotebookResourceInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotebookResourceInfo_STATUS instances for property testing - lazily instantiated by
// NotebookResourceInfoSTATUSGenerator()
var notebookResourceInfoSTATUSGenerator gopter.Gen

// NotebookResourceInfoSTATUSGenerator returns a generator of NotebookResourceInfo_STATUS instances for property testing.
// We first initialize notebookResourceInfoSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotebookResourceInfoSTATUSGenerator() gopter.Gen {
	if notebookResourceInfoSTATUSGenerator != nil {
		return notebookResourceInfoSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfoSTATUS(generators)
	notebookResourceInfoSTATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfoSTATUS(generators)
	AddRelatedPropertyGeneratorsForNotebookResourceInfoSTATUS(generators)
	notebookResourceInfoSTATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	return notebookResourceInfoSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookResourceInfoSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookResourceInfoSTATUS(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotebookResourceInfoSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotebookResourceInfoSTATUS(gens map[string]gopter.Gen) {
	gens["NotebookPreparationError"] = gen.PtrOf(NotebookPreparationErrorSTATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS_SubResourceEmbedded to PrivateEndpointConnection_STATUS_SubResourceEmbedded via AssignPropertiesToPrivateEndpointConnectionSTATUSSubResourceEmbedded & AssignPropertiesFromPrivateEndpointConnectionSTATUSSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded, PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded tests if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbedded can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.PrivateEndpointConnection_STATUS_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointConnectionSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointConnectionSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUS(subject Identity_STATUS) string {
=======
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded, PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SubResourceEmbedded) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
<<<<<<< HEAD
	var actual Identity_STATUS
=======
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbedded
>>>>>>> main
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Identity_STATUS instances for property testing - lazily instantiated by Identity_STATUSGenerator()
var identity_STATUSGenerator gopter.Gen

// Identity_STATUSGenerator returns a generator of Identity_STATUS instances for property testing.
// We first initialize identity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_STATUSGenerator() gopter.Gen {
	if identity_STATUSGenerator != nil {
		return identity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_None_STATUS,
		Identity_Type_SystemAssigned_STATUS,
		Identity_Type_SystemAssignedUserAssigned_STATUS,
		Identity_Type_UserAssigned_STATUS))
}

// AddRelatedPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_STATUSGenerator())
}

func Test_NotebookResourceInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotebookResourceInfo_STATUS to NotebookResourceInfo_STATUS via AssignPropertiesToNotebookResourceInfo_STATUS & AssignPropertiesFromNotebookResourceInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookResourceInfo_STATUS, NotebookResourceInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookResourceInfo_STATUS tests if a specific instance of NotebookResourceInfo_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForNotebookResourceInfo_STATUS(subject NotebookResourceInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.NotebookResourceInfo_STATUS
	err := copied.AssignPropertiesToNotebookResourceInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotebookResourceInfo_STATUS
	err = actual.AssignPropertiesFromNotebookResourceInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotebookResourceInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotebookResourceInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotebookResourceInfo_STATUS, NotebookResourceInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookResourceInfo_STATUS runs a test to see if a specific instance of NotebookResourceInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookResourceInfo_STATUS(subject NotebookResourceInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotebookResourceInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotebookResourceInfo_STATUS instances for property testing - lazily instantiated by
// NotebookResourceInfo_STATUSGenerator()
var notebookResourceInfo_STATUSGenerator gopter.Gen

// NotebookResourceInfo_STATUSGenerator returns a generator of NotebookResourceInfo_STATUS instances for property testing.
// We first initialize notebookResourceInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotebookResourceInfo_STATUSGenerator() gopter.Gen {
	if notebookResourceInfo_STATUSGenerator != nil {
		return notebookResourceInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	notebookResourceInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS(generators)
	notebookResourceInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookResourceInfo_STATUS{}), generators)

	return notebookResourceInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookResourceInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotebookResourceInfo_STATUS(gens map[string]gopter.Gen) {
	gens["NotebookPreparationError"] = gen.PtrOf(NotebookPreparationError_STATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignPropertiesToPrivateEndpointConnection_STATUS & AssignPropertiesFromPrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.PrivateEndpointConnection_STATUS
	err := copied.AssignPropertiesToPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignPropertiesFromPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
// We first initialize privateEndpointConnection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
=======
// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()
var privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator != nil {
		return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbedded{}), generators)

	return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentitySTATUSGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
>>>>>>> main
}

func Test_ServiceManagedResourcesSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceManagedResourcesSettings to ServiceManagedResourcesSettings via AssignPropertiesToServiceManagedResourcesSettings & AssignPropertiesFromServiceManagedResourcesSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceManagedResourcesSettings, ServiceManagedResourcesSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceManagedResourcesSettings tests if a specific instance of ServiceManagedResourcesSettings can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForServiceManagedResourcesSettings(subject ServiceManagedResourcesSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ServiceManagedResourcesSettings
	err := copied.AssignPropertiesToServiceManagedResourcesSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceManagedResourcesSettings
	err = actual.AssignPropertiesFromServiceManagedResourcesSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceManagedResourcesSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings, ServiceManagedResourcesSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings runs a test to see if a specific instance of ServiceManagedResourcesSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings(subject ServiceManagedResourcesSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings instances for property testing - lazily instantiated by
// ServiceManagedResourcesSettingsGenerator()
var serviceManagedResourcesSettingsGenerator gopter.Gen

// ServiceManagedResourcesSettingsGenerator returns a generator of ServiceManagedResourcesSettings instances for property testing.
func ServiceManagedResourcesSettingsGenerator() gopter.Gen {
	if serviceManagedResourcesSettingsGenerator != nil {
		return serviceManagedResourcesSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(generators)
	serviceManagedResourcesSettingsGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings{}), generators)

	return serviceManagedResourcesSettingsGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettingsGenerator())
}

func Test_ServiceManagedResourcesSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ServiceManagedResourcesSettings_STATUS to ServiceManagedResourcesSettings_STATUS via AssignPropertiesToServiceManagedResourcesSettings_STATUS & AssignPropertiesFromServiceManagedResourcesSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS, ServiceManagedResourcesSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS tests if a specific instance of ServiceManagedResourcesSettings_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForServiceManagedResourcesSettings_STATUS(subject ServiceManagedResourcesSettings_STATUS) string {
=======
		"Round trip from ServiceManagedResourcesSettings_STATUS to ServiceManagedResourcesSettings_STATUS via AssignPropertiesToServiceManagedResourcesSettingsSTATUS & AssignPropertiesFromServiceManagedResourcesSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceManagedResourcesSettingsSTATUS, ServiceManagedResourcesSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceManagedResourcesSettingsSTATUS tests if a specific instance of ServiceManagedResourcesSettings_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForServiceManagedResourcesSettingsSTATUS(subject ServiceManagedResourcesSettings_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ServiceManagedResourcesSettings_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToServiceManagedResourcesSettings_STATUS(&other)
=======
	err := copied.AssignPropertiesToServiceManagedResourcesSettingsSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceManagedResourcesSettings_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromServiceManagedResourcesSettings_STATUS(&other)
=======
	err = actual.AssignPropertiesFromServiceManagedResourcesSettingsSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceManagedResourcesSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceManagedResourcesSettings_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS, ServiceManagedResourcesSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS runs a test to see if a specific instance of ServiceManagedResourcesSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettings_STATUS(subject ServiceManagedResourcesSettings_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForServiceManagedResourcesSettingsSTATUS, ServiceManagedResourcesSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceManagedResourcesSettingsSTATUS runs a test to see if a specific instance of ServiceManagedResourcesSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceManagedResourcesSettingsSTATUS(subject ServiceManagedResourcesSettings_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceManagedResourcesSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceManagedResourcesSettings_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// ServiceManagedResourcesSettings_STATUSGenerator()
var serviceManagedResourcesSettings_STATUSGenerator gopter.Gen

// ServiceManagedResourcesSettings_STATUSGenerator returns a generator of ServiceManagedResourcesSettings_STATUS instances for property testing.
func ServiceManagedResourcesSettings_STATUSGenerator() gopter.Gen {
	if serviceManagedResourcesSettings_STATUSGenerator != nil {
		return serviceManagedResourcesSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS(generators)
	serviceManagedResourcesSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings_STATUS{}), generators)

	return serviceManagedResourcesSettings_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettings_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettings_STATUSGenerator())
}

func Test_SharedPrivateLinkResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
=======
// ServiceManagedResourcesSettingsSTATUSGenerator()
var serviceManagedResourcesSettingsSTATUSGenerator gopter.Gen

// ServiceManagedResourcesSettingsSTATUSGenerator returns a generator of ServiceManagedResourcesSettings_STATUS instances for property testing.
func ServiceManagedResourcesSettingsSTATUSGenerator() gopter.Gen {
	if serviceManagedResourcesSettingsSTATUSGenerator != nil {
		return serviceManagedResourcesSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServiceManagedResourcesSettingsSTATUS(generators)
	serviceManagedResourcesSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(ServiceManagedResourcesSettings_STATUS{}), generators)

	return serviceManagedResourcesSettingsSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForServiceManagedResourcesSettingsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceManagedResourcesSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = gen.PtrOf(CosmosDbSettingsSTATUSGenerator())
}

func Test_SharedPrivateLinkResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from SharedPrivateLinkResource to SharedPrivateLinkResource via AssignPropertiesToSharedPrivateLinkResource & AssignPropertiesFromSharedPrivateLinkResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResource, SharedPrivateLinkResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResource tests if a specific instance of SharedPrivateLinkResource can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResource(subject SharedPrivateLinkResource) string {
=======
		"Round trip from SharedPrivateLinkResource_STATUS to SharedPrivateLinkResource_STATUS via AssignPropertiesToSharedPrivateLinkResourceSTATUS & AssignPropertiesFromSharedPrivateLinkResourceSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUS, SharedPrivateLinkResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUS tests if a specific instance of SharedPrivateLinkResource_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUS(subject SharedPrivateLinkResource_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
<<<<<<< HEAD
	var other v20210701s.SharedPrivateLinkResource
	err := copied.AssignPropertiesToSharedPrivateLinkResource(&other)
=======
	var other v20210701s.SharedPrivateLinkResource_STATUS
	err := copied.AssignPropertiesToSharedPrivateLinkResourceSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
<<<<<<< HEAD
	var actual SharedPrivateLinkResource
	err = actual.AssignPropertiesFromSharedPrivateLinkResource(&other)
=======
	var actual SharedPrivateLinkResource_STATUS
	err = actual.AssignPropertiesFromSharedPrivateLinkResourceSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
func Test_SharedPrivateLinkResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
=======
func Test_SharedPrivateLinkResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip of SharedPrivateLinkResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource, SharedPrivateLinkResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource runs a test to see if a specific instance of SharedPrivateLinkResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource(subject SharedPrivateLinkResource) string {
=======
		"Round trip of SharedPrivateLinkResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceSTATUS, SharedPrivateLinkResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceSTATUS runs a test to see if a specific instance of SharedPrivateLinkResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceSTATUS(subject SharedPrivateLinkResource_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
<<<<<<< HEAD
	var actual SharedPrivateLinkResource
=======
	var actual SharedPrivateLinkResource_STATUS
>>>>>>> main
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of SharedPrivateLinkResource instances for property testing - lazily instantiated by
// SharedPrivateLinkResourceGenerator()
var sharedPrivateLinkResourceGenerator gopter.Gen

// SharedPrivateLinkResourceGenerator returns a generator of SharedPrivateLinkResource instances for property testing.
func SharedPrivateLinkResourceGenerator() gopter.Gen {
	if sharedPrivateLinkResourceGenerator != nil {
		return sharedPrivateLinkResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(generators)
	sharedPrivateLinkResourceGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource{}), generators)

	return sharedPrivateLinkResourceGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_Approved,
		PrivateEndpointServiceConnectionStatus_Disconnected,
		PrivateEndpointServiceConnectionStatus_Pending,
		PrivateEndpointServiceConnectionStatus_Rejected,
		PrivateEndpointServiceConnectionStatus_Timeout))
}

func Test_SharedPrivateLinkResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource_STATUS to SharedPrivateLinkResource_STATUS via AssignPropertiesToSharedPrivateLinkResource_STATUS & AssignPropertiesFromSharedPrivateLinkResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS, SharedPrivateLinkResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS tests if a specific instance of SharedPrivateLinkResource_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResource_STATUS(subject SharedPrivateLinkResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SharedPrivateLinkResource_STATUS
	err := copied.AssignPropertiesToSharedPrivateLinkResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource_STATUS
	err = actual.AssignPropertiesFromSharedPrivateLinkResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource_STATUS, SharedPrivateLinkResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource_STATUS runs a test to see if a specific instance of SharedPrivateLinkResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource_STATUS(subject SharedPrivateLinkResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_STATUS instances for property testing - lazily instantiated by
// SharedPrivateLinkResource_STATUSGenerator()
var sharedPrivateLinkResource_STATUSGenerator gopter.Gen

// SharedPrivateLinkResource_STATUSGenerator returns a generator of SharedPrivateLinkResource_STATUS instances for property testing.
func SharedPrivateLinkResource_STATUSGenerator() gopter.Gen {
	if sharedPrivateLinkResource_STATUSGenerator != nil {
		return sharedPrivateLinkResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS(generators)
	sharedPrivateLinkResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS{}), generators)

	return sharedPrivateLinkResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of SharedPrivateLinkResource_STATUS instances for property testing - lazily instantiated by
// SharedPrivateLinkResourceSTATUSGenerator()
var sharedPrivateLinkResourceSTATUSGenerator gopter.Gen

// SharedPrivateLinkResourceSTATUSGenerator returns a generator of SharedPrivateLinkResource_STATUS instances for property testing.
func SharedPrivateLinkResourceSTATUSGenerator() gopter.Gen {
	if sharedPrivateLinkResourceSTATUSGenerator != nil {
		return sharedPrivateLinkResourceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUS(generators)
	sharedPrivateLinkResourceSTATUSGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS{}), generators)

	return sharedPrivateLinkResourceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
<<<<<<< HEAD
		PrivateEndpointServiceConnectionStatus_Approved_STATUS,
		PrivateEndpointServiceConnectionStatus_Disconnected_STATUS,
		PrivateEndpointServiceConnectionStatus_Pending_STATUS,
		PrivateEndpointServiceConnectionStatus_Rejected_STATUS,
		PrivateEndpointServiceConnectionStatus_Timeout_STATUS))
=======
		PrivateEndpointServiceConnectionStatus_STATUS_Approved,
		PrivateEndpointServiceConnectionStatus_STATUS_Disconnected,
		PrivateEndpointServiceConnectionStatus_STATUS_Pending,
		PrivateEndpointServiceConnectionStatus_STATUS_Rejected,
		PrivateEndpointServiceConnectionStatus_STATUS_Timeout))
>>>>>>> main
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignPropertiesToSku & AssignPropertiesFromSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Sku
	err := copied.AssignPropertiesToSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignPropertiesFromSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Sku_STATUS to Sku_STATUS via AssignPropertiesToSku_STATUS & AssignPropertiesFromSku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
=======
		"Round trip from Sku_STATUS to Sku_STATUS via AssignPropertiesToSkuSTATUS & AssignPropertiesFromSkuSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSkuSTATUS, SkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSkuSTATUS tests if a specific instance of Sku_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSkuSTATUS(subject Sku_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Sku_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToSku_STATUS(&other)
=======
	err := copied.AssignPropertiesToSkuSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromSku_STATUS(&other)
=======
	err = actual.AssignPropertiesFromSkuSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForSkuSTATUS, SkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUS(subject Sku_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of Sku_STATUS instances for property testing - lazily instantiated by SkuSTATUSGenerator()
var skuSTATUSGenerator gopter.Gen

// SkuSTATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func SkuSTATUSGenerator() gopter.Gen {
	if skuSTATUSGenerator != nil {
		return skuSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUS(generators)
	skuSTATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return skuSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData to SystemData via AssignPropertiesToSystemData & AssignPropertiesFromSystemData returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData tests if a specific instance of SystemData can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSystemData(subject SystemData) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SystemData
	err := copied.AssignPropertiesToSystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData
	err = actual.AssignPropertiesFromSystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData runs a test to see if a specific instance of SystemData round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData(subject SystemData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData instances for property testing - lazily instantiated by SystemDataGenerator()
var systemDataGenerator gopter.Gen

// SystemDataGenerator returns a generator of SystemData instances for property testing.
func SystemDataGenerator() gopter.Gen {
	if systemDataGenerator != nil {
		return systemDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData(generators)
	systemDataGenerator = gen.Struct(reflect.TypeOf(SystemData{}), generators)

	return systemDataGenerator
}

// AddIndependentPropertyGeneratorsForSystemData is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application,
		SystemData_CreatedByType_Key,
		SystemData_CreatedByType_ManagedIdentity,
		SystemData_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application,
		SystemData_LastModifiedByType_Key,
		SystemData_LastModifiedByType_ManagedIdentity,
		SystemData_LastModifiedByType_User))
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignPropertiesToSystemData_STATUS & AssignPropertiesFromSystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
=======
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignPropertiesToSystemDataSTATUS & AssignPropertiesFromSystemDataSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemDataSTATUS tests if a specific instance of SystemData_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSystemDataSTATUS(subject SystemData_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SystemData_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToSystemData_STATUS(&other)
=======
	err := copied.AssignPropertiesToSystemDataSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromSystemData_STATUS(&other)
=======
	err = actual.AssignPropertiesFromSystemDataSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUS(subject SystemData_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application_STATUS,
		SystemData_CreatedByType_Key_STATUS,
		SystemData_CreatedByType_ManagedIdentity_STATUS,
		SystemData_CreatedByType_User_STATUS))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application_STATUS,
		SystemData_LastModifiedByType_Key_STATUS,
		SystemData_LastModifiedByType_ManagedIdentity_STATUS,
		SystemData_LastModifiedByType_User_STATUS))
=======
// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemDataSTATUSGenerator()
var systemDataSTATUSGenerator gopter.Gen

// SystemDataSTATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemDataSTATUSGenerator() gopter.Gen {
	if systemDataSTATUSGenerator != nil {
		return systemDataSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUS(generators)
	systemDataSTATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemDataSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSCreatedByType_Application,
		SystemDataSTATUSCreatedByType_Key,
		SystemDataSTATUSCreatedByType_ManagedIdentity,
		SystemDataSTATUSCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSLastModifiedByType_Application,
		SystemDataSTATUSLastModifiedByType_Key,
		SystemDataSTATUSLastModifiedByType_ManagedIdentity,
		SystemDataSTATUSLastModifiedByType_User))
>>>>>>> main
}

func Test_WorkspaceOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceOperatorSpec to WorkspaceOperatorSpec via AssignPropertiesToWorkspaceOperatorSpec & AssignPropertiesFromWorkspaceOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceOperatorSpec, WorkspaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceOperatorSpec tests if a specific instance of WorkspaceOperatorSpec can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceOperatorSpec(subject WorkspaceOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.WorkspaceOperatorSpec
	err := copied.AssignPropertiesToWorkspaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceOperatorSpec
	err = actual.AssignPropertiesFromWorkspaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceOperatorSpec, WorkspaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceOperatorSpec runs a test to see if a specific instance of WorkspaceOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceOperatorSpec(subject WorkspaceOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceOperatorSpec instances for property testing - lazily instantiated by
// WorkspaceOperatorSpecGenerator()
var workspaceOperatorSpecGenerator gopter.Gen

// WorkspaceOperatorSpecGenerator returns a generator of WorkspaceOperatorSpec instances for property testing.
func WorkspaceOperatorSpecGenerator() gopter.Gen {
	if workspaceOperatorSpecGenerator != nil {
		return workspaceOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec(generators)
	workspaceOperatorSpecGenerator = gen.Struct(reflect.TypeOf(WorkspaceOperatorSpec{}), generators)

	return workspaceOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaceOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(WorkspaceOperatorSecretsGenerator())
}

<<<<<<< HEAD
=======
func Test_Workspaces_Spec_Properties_SharedPrivateLinkResources_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspaces_Spec_Properties_SharedPrivateLinkResources to Workspaces_Spec_Properties_SharedPrivateLinkResources via AssignPropertiesToWorkspacesSpecPropertiesSharedPrivateLinkResources & AssignPropertiesFromWorkspacesSpecPropertiesSharedPrivateLinkResources returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspacesSpecPropertiesSharedPrivateLinkResources, WorkspacesSpecPropertiesSharedPrivateLinkResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspacesSpecPropertiesSharedPrivateLinkResources tests if a specific instance of Workspaces_Spec_Properties_SharedPrivateLinkResources can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspacesSpecPropertiesSharedPrivateLinkResources(subject Workspaces_Spec_Properties_SharedPrivateLinkResources) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Workspaces_Spec_Properties_SharedPrivateLinkResources
	err := copied.AssignPropertiesToWorkspacesSpecPropertiesSharedPrivateLinkResources(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspaces_Spec_Properties_SharedPrivateLinkResources
	err = actual.AssignPropertiesFromWorkspacesSpecPropertiesSharedPrivateLinkResources(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspaces_Spec_Properties_SharedPrivateLinkResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Spec_Properties_SharedPrivateLinkResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspacesSpecPropertiesSharedPrivateLinkResources, WorkspacesSpecPropertiesSharedPrivateLinkResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspacesSpecPropertiesSharedPrivateLinkResources runs a test to see if a specific instance of Workspaces_Spec_Properties_SharedPrivateLinkResources round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspacesSpecPropertiesSharedPrivateLinkResources(subject Workspaces_Spec_Properties_SharedPrivateLinkResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Spec_Properties_SharedPrivateLinkResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Spec_Properties_SharedPrivateLinkResources instances for property testing - lazily
// instantiated by WorkspacesSpecPropertiesSharedPrivateLinkResourcesGenerator()
var workspacesSpecPropertiesSharedPrivateLinkResourcesGenerator gopter.Gen

// WorkspacesSpecPropertiesSharedPrivateLinkResourcesGenerator returns a generator of Workspaces_Spec_Properties_SharedPrivateLinkResources instances for property testing.
func WorkspacesSpecPropertiesSharedPrivateLinkResourcesGenerator() gopter.Gen {
	if workspacesSpecPropertiesSharedPrivateLinkResourcesGenerator != nil {
		return workspacesSpecPropertiesSharedPrivateLinkResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspacesSpecPropertiesSharedPrivateLinkResources(generators)
	workspacesSpecPropertiesSharedPrivateLinkResourcesGenerator = gen.Struct(reflect.TypeOf(Workspaces_Spec_Properties_SharedPrivateLinkResources{}), generators)

	return workspacesSpecPropertiesSharedPrivateLinkResourcesGenerator
}

// AddIndependentPropertyGeneratorsForWorkspacesSpecPropertiesSharedPrivateLinkResources is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspacesSpecPropertiesSharedPrivateLinkResources(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequestMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		SharedPrivateLinkResourcePropertyStatus_Approved,
		SharedPrivateLinkResourcePropertyStatus_Disconnected,
		SharedPrivateLinkResourcePropertyStatus_Pending,
		SharedPrivateLinkResourcePropertyStatus_Rejected,
		SharedPrivateLinkResourcePropertyStatus_Timeout))
}

>>>>>>> main
func Test_CosmosDbSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CosmosDbSettings to CosmosDbSettings via AssignPropertiesToCosmosDbSettings & AssignPropertiesFromCosmosDbSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbSettings, CosmosDbSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbSettings tests if a specific instance of CosmosDbSettings can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbSettings(subject CosmosDbSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.CosmosDbSettings
	err := copied.AssignPropertiesToCosmosDbSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbSettings
	err = actual.AssignPropertiesFromCosmosDbSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings, CosmosDbSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings runs a test to see if a specific instance of CosmosDbSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings(subject CosmosDbSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings instances for property testing - lazily instantiated by CosmosDbSettingsGenerator()
var cosmosDbSettingsGenerator gopter.Gen

// CosmosDbSettingsGenerator returns a generator of CosmosDbSettings instances for property testing.
func CosmosDbSettingsGenerator() gopter.Gen {
	if cosmosDbSettingsGenerator != nil {
		return cosmosDbSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings(generators)
	cosmosDbSettingsGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings{}), generators)

	return cosmosDbSettingsGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings(gens map[string]gopter.Gen) {
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_CosmosDbSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from CosmosDbSettings_STATUS to CosmosDbSettings_STATUS via AssignPropertiesToCosmosDbSettings_STATUS & AssignPropertiesFromCosmosDbSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbSettings_STATUS, CosmosDbSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbSettings_STATUS tests if a specific instance of CosmosDbSettings_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbSettings_STATUS(subject CosmosDbSettings_STATUS) string {
=======
		"Round trip from CosmosDbSettings_STATUS to CosmosDbSettings_STATUS via AssignPropertiesToCosmosDbSettingsSTATUS & AssignPropertiesFromCosmosDbSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbSettingsSTATUS, CosmosDbSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbSettingsSTATUS tests if a specific instance of CosmosDbSettings_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbSettingsSTATUS(subject CosmosDbSettings_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.CosmosDbSettings_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToCosmosDbSettings_STATUS(&other)
=======
	err := copied.AssignPropertiesToCosmosDbSettingsSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbSettings_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromCosmosDbSettings_STATUS(&other)
=======
	err = actual.AssignPropertiesFromCosmosDbSettingsSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbSettings_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettings_STATUS, CosmosDbSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettings_STATUS runs a test to see if a specific instance of CosmosDbSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettings_STATUS(subject CosmosDbSettings_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForCosmosDbSettingsSTATUS, CosmosDbSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbSettingsSTATUS runs a test to see if a specific instance of CosmosDbSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbSettingsSTATUS(subject CosmosDbSettings_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbSettings_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// CosmosDbSettings_STATUSGenerator()
var cosmosDbSettings_STATUSGenerator gopter.Gen

// CosmosDbSettings_STATUSGenerator returns a generator of CosmosDbSettings_STATUS instances for property testing.
func CosmosDbSettings_STATUSGenerator() gopter.Gen {
	if cosmosDbSettings_STATUSGenerator != nil {
		return cosmosDbSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS(generators)
	cosmosDbSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings_STATUS{}), generators)

	return cosmosDbSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettings_STATUS(gens map[string]gopter.Gen) {
=======
// CosmosDbSettingsSTATUSGenerator()
var cosmosDbSettingsSTATUSGenerator gopter.Gen

// CosmosDbSettingsSTATUSGenerator returns a generator of CosmosDbSettings_STATUS instances for property testing.
func CosmosDbSettingsSTATUSGenerator() gopter.Gen {
	if cosmosDbSettingsSTATUSGenerator != nil {
		return cosmosDbSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbSettingsSTATUS(generators)
	cosmosDbSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(CosmosDbSettings_STATUS{}), generators)

	return cosmosDbSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbSettingsSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["CollectionsThroughput"] = gen.PtrOf(gen.Int())
}

func Test_IdentityForCmk_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IdentityForCmk to IdentityForCmk via AssignPropertiesToIdentityForCmk & AssignPropertiesFromIdentityForCmk returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityForCmk, IdentityForCmkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityForCmk tests if a specific instance of IdentityForCmk can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentityForCmk(subject IdentityForCmk) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.IdentityForCmk
	err := copied.AssignPropertiesToIdentityForCmk(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityForCmk
	err = actual.AssignPropertiesFromIdentityForCmk(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityForCmk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk, IdentityForCmkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk runs a test to see if a specific instance of IdentityForCmk round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk(subject IdentityForCmk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk instances for property testing - lazily instantiated by IdentityForCmkGenerator()
var identityForCmkGenerator gopter.Gen

// IdentityForCmkGenerator returns a generator of IdentityForCmk instances for property testing.
func IdentityForCmkGenerator() gopter.Gen {
	if identityForCmkGenerator != nil {
		return identityForCmkGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmk(generators)
	identityForCmkGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk{}), generators)

	return identityForCmkGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmk(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_IdentityForCmk_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from IdentityForCmk_STATUS to IdentityForCmk_STATUS via AssignPropertiesToIdentityForCmk_STATUS & AssignPropertiesFromIdentityForCmk_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityForCmk_STATUS, IdentityForCmk_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityForCmk_STATUS tests if a specific instance of IdentityForCmk_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentityForCmk_STATUS(subject IdentityForCmk_STATUS) string {
=======
		"Round trip from IdentityForCmk_STATUS to IdentityForCmk_STATUS via AssignPropertiesToIdentityForCmkSTATUS & AssignPropertiesFromIdentityForCmkSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityForCmkSTATUS, IdentityForCmkSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityForCmkSTATUS tests if a specific instance of IdentityForCmk_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForIdentityForCmkSTATUS(subject IdentityForCmk_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.IdentityForCmk_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToIdentityForCmk_STATUS(&other)
=======
	err := copied.AssignPropertiesToIdentityForCmkSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityForCmk_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromIdentityForCmk_STATUS(&other)
=======
	err = actual.AssignPropertiesFromIdentityForCmkSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityForCmk_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityForCmk_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIdentityForCmk_STATUS, IdentityForCmk_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmk_STATUS runs a test to see if a specific instance of IdentityForCmk_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmk_STATUS(subject IdentityForCmk_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForIdentityForCmkSTATUS, IdentityForCmkSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityForCmkSTATUS runs a test to see if a specific instance of IdentityForCmk_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityForCmkSTATUS(subject IdentityForCmk_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityForCmk_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityForCmk_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// IdentityForCmk_STATUSGenerator()
var identityForCmk_STATUSGenerator gopter.Gen

// IdentityForCmk_STATUSGenerator returns a generator of IdentityForCmk_STATUS instances for property testing.
func IdentityForCmk_STATUSGenerator() gopter.Gen {
	if identityForCmk_STATUSGenerator != nil {
		return identityForCmk_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS(generators)
	identityForCmk_STATUSGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk_STATUS{}), generators)

	return identityForCmk_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmk_STATUS(gens map[string]gopter.Gen) {
=======
// IdentityForCmkSTATUSGenerator()
var identityForCmkSTATUSGenerator gopter.Gen

// IdentityForCmkSTATUSGenerator returns a generator of IdentityForCmk_STATUS instances for property testing.
func IdentityForCmkSTATUSGenerator() gopter.Gen {
	if identityForCmkSTATUSGenerator != nil {
		return identityForCmkSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityForCmkSTATUS(generators)
	identityForCmkSTATUSGenerator = gen.Struct(reflect.TypeOf(IdentityForCmk_STATUS{}), generators)

	return identityForCmkSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentityForCmkSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityForCmkSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties to KeyVaultProperties via AssignPropertiesToKeyVaultProperties & AssignPropertiesFromKeyVaultProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties tests if a specific instance of KeyVaultProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.KeyVaultProperties
	err := copied.AssignPropertiesToKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties
	err = actual.AssignPropertiesFromKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties runs a test to see if a specific instance of KeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties instances for property testing - lazily instantiated by KeyVaultPropertiesGenerator()
var keyVaultPropertiesGenerator gopter.Gen

// KeyVaultPropertiesGenerator returns a generator of KeyVaultProperties instances for property testing.
func KeyVaultPropertiesGenerator() gopter.Gen {
	if keyVaultPropertiesGenerator != nil {
		return keyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties(generators)
	keyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties{}), generators)

	return keyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from KeyVaultProperties_STATUS to KeyVaultProperties_STATUS via AssignPropertiesToKeyVaultProperties_STATUS & AssignPropertiesFromKeyVaultProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_STATUS, KeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_STATUS tests if a specific instance of KeyVaultProperties_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_STATUS(subject KeyVaultProperties_STATUS) string {
=======
		"Round trip from KeyVaultProperties_STATUS to KeyVaultProperties_STATUS via AssignPropertiesToKeyVaultPropertiesSTATUS & AssignPropertiesFromKeyVaultPropertiesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS, KeyVaultPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS tests if a specific instance of KeyVaultProperties_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS(subject KeyVaultProperties_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.KeyVaultProperties_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToKeyVaultProperties_STATUS(&other)
=======
	err := copied.AssignPropertiesToKeyVaultPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromKeyVaultProperties_STATUS(&other)
=======
	err = actual.AssignPropertiesFromKeyVaultPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUS, KeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUS(subject KeyVaultProperties_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUS, KeyVaultPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUS(subject KeyVaultProperties_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// KeyVaultProperties_STATUSGenerator()
var keyVaultProperties_STATUSGenerator gopter.Gen

// KeyVaultProperties_STATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultProperties_STATUSGenerator() gopter.Gen {
	if keyVaultProperties_STATUSGenerator != nil {
		return keyVaultProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(generators)
	keyVaultProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(gens map[string]gopter.Gen) {
=======
// KeyVaultPropertiesSTATUSGenerator()
var keyVaultPropertiesSTATUSGenerator gopter.Gen

// KeyVaultPropertiesSTATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultPropertiesSTATUSGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSGenerator != nil {
		return keyVaultPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(generators)
	keyVaultPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultArmId"] = gen.PtrOf(gen.AlphaString())
}

func Test_NotebookPreparationError_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from NotebookPreparationError_STATUS to NotebookPreparationError_STATUS via AssignPropertiesToNotebookPreparationError_STATUS & AssignPropertiesFromNotebookPreparationError_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookPreparationError_STATUS, NotebookPreparationError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookPreparationError_STATUS tests if a specific instance of NotebookPreparationError_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForNotebookPreparationError_STATUS(subject NotebookPreparationError_STATUS) string {
=======
		"Round trip from NotebookPreparationError_STATUS to NotebookPreparationError_STATUS via AssignPropertiesToNotebookPreparationErrorSTATUS & AssignPropertiesFromNotebookPreparationErrorSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotebookPreparationErrorSTATUS, NotebookPreparationErrorSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotebookPreparationErrorSTATUS tests if a specific instance of NotebookPreparationError_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForNotebookPreparationErrorSTATUS(subject NotebookPreparationError_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.NotebookPreparationError_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToNotebookPreparationError_STATUS(&other)
=======
	err := copied.AssignPropertiesToNotebookPreparationErrorSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotebookPreparationError_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromNotebookPreparationError_STATUS(&other)
=======
	err = actual.AssignPropertiesFromNotebookPreparationErrorSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotebookPreparationError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotebookPreparationError_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForNotebookPreparationError_STATUS, NotebookPreparationError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookPreparationError_STATUS runs a test to see if a specific instance of NotebookPreparationError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookPreparationError_STATUS(subject NotebookPreparationError_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForNotebookPreparationErrorSTATUS, NotebookPreparationErrorSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotebookPreparationErrorSTATUS runs a test to see if a specific instance of NotebookPreparationError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotebookPreparationErrorSTATUS(subject NotebookPreparationError_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotebookPreparationError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotebookPreparationError_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// NotebookPreparationError_STATUSGenerator()
var notebookPreparationError_STATUSGenerator gopter.Gen

// NotebookPreparationError_STATUSGenerator returns a generator of NotebookPreparationError_STATUS instances for property testing.
func NotebookPreparationError_STATUSGenerator() gopter.Gen {
	if notebookPreparationError_STATUSGenerator != nil {
		return notebookPreparationError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS(generators)
	notebookPreparationError_STATUSGenerator = gen.Struct(reflect.TypeOf(NotebookPreparationError_STATUS{}), generators)

	return notebookPreparationError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookPreparationError_STATUS(gens map[string]gopter.Gen) {
=======
// NotebookPreparationErrorSTATUSGenerator()
var notebookPreparationErrorSTATUSGenerator gopter.Gen

// NotebookPreparationErrorSTATUSGenerator returns a generator of NotebookPreparationError_STATUS instances for property testing.
func NotebookPreparationErrorSTATUSGenerator() gopter.Gen {
	if notebookPreparationErrorSTATUSGenerator != nil {
		return notebookPreparationErrorSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotebookPreparationErrorSTATUS(generators)
	notebookPreparationErrorSTATUSGenerator = gen.Struct(reflect.TypeOf(NotebookPreparationError_STATUS{}), generators)

	return notebookPreparationErrorSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotebookPreparationErrorSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotebookPreparationErrorSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["ErrorMessage"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCode"] = gen.PtrOf(gen.Int())
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignPropertiesToUserAssignedIdentity_STATUS & AssignPropertiesFromUserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
=======
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignPropertiesToUserAssignedIdentitySTATUS & AssignPropertiesFromUserAssignedIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentitySTATUS, UserAssignedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentitySTATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentitySTATUS(subject UserAssignedIdentity_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.UserAssignedIdentity_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToUserAssignedIdentity_STATUS(&other)
=======
	err := copied.AssignPropertiesToUserAssignedIdentitySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromUserAssignedIdentity_STATUS(&other)
=======
	err = actual.AssignPropertiesFromUserAssignedIdentitySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySTATUS, UserAssignedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySTATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySTATUS(subject UserAssignedIdentity_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
=======
// UserAssignedIdentitySTATUSGenerator()
var userAssignedIdentitySTATUSGenerator gopter.Gen

// UserAssignedIdentitySTATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentitySTATUSGenerator() gopter.Gen {
	if userAssignedIdentitySTATUSGenerator != nil {
		return userAssignedIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(generators)
	userAssignedIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceOperatorSecrets to WorkspaceOperatorSecrets via AssignPropertiesToWorkspaceOperatorSecrets & AssignPropertiesFromWorkspaceOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceOperatorSecrets, WorkspaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceOperatorSecrets tests if a specific instance of WorkspaceOperatorSecrets can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceOperatorSecrets(subject WorkspaceOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.WorkspaceOperatorSecrets
	err := copied.AssignPropertiesToWorkspaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceOperatorSecrets
	err = actual.AssignPropertiesFromWorkspaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceOperatorSecrets, WorkspaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceOperatorSecrets runs a test to see if a specific instance of WorkspaceOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceOperatorSecrets(subject WorkspaceOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceOperatorSecrets instances for property testing - lazily instantiated by
// WorkspaceOperatorSecretsGenerator()
var workspaceOperatorSecretsGenerator gopter.Gen

// WorkspaceOperatorSecretsGenerator returns a generator of WorkspaceOperatorSecrets instances for property testing.
func WorkspaceOperatorSecretsGenerator() gopter.Gen {
	if workspaceOperatorSecretsGenerator != nil {
		return workspaceOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	workspaceOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(WorkspaceOperatorSecrets{}), generators)

	return workspaceOperatorSecretsGenerator
}
