// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210701

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Workspaces_Compute_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Compute_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM, Workspaces_Compute_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM runs a test to see if a specific instance of Workspaces_Compute_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM(subject Workspaces_Compute_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Compute_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Compute_Spec_ARM instances for property testing - lazily instantiated by
// Workspaces_Compute_Spec_ARMGenerator()
var workspaces_Compute_Spec_ARMGenerator gopter.Gen

// Workspaces_Compute_Spec_ARMGenerator returns a generator of Workspaces_Compute_Spec_ARM instances for property testing.
// We first initialize workspaces_Compute_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspaces_Compute_Spec_ARMGenerator() gopter.Gen {
	if workspaces_Compute_Spec_ARMGenerator != nil {
		return workspaces_Compute_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	workspaces_Compute_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	workspaces_Compute_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec_ARM{}), generators)

	return workspaces_Compute_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(Compute_ARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_ARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_ARMGenerator())
}

func Test_Compute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_ARM, Compute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_ARM runs a test to see if a specific instance of Compute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_ARM(subject Compute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_ARM instances for property testing - lazily instantiated by Compute_ARMGenerator()
var compute_ARMGenerator gopter.Gen

// Compute_ARMGenerator returns a generator of Compute_ARM instances for property testing.
func Compute_ARMGenerator() gopter.Gen {
	if compute_ARMGenerator != nil {
		return compute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCompute_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(Compute_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	compute_ARMGenerator = gen.OneGenOf(gens...)

	return compute_ARMGenerator
}

// AddRelatedPropertyGeneratorsForCompute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_ARM(gens map[string]gopter.Gen) {
	gens["AKS"] = Compute_AKS_ARMGenerator().Map(func(it Compute_AKS_ARM) *Compute_AKS_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["AmlCompute"] = Compute_AmlCompute_ARMGenerator().Map(func(it Compute_AmlCompute_ARM) *Compute_AmlCompute_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ComputeInstance"] = Compute_ComputeInstance_ARMGenerator().Map(func(it Compute_ComputeInstance_ARM) *Compute_ComputeInstance_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataFactory"] = Compute_DataFactory_ARMGenerator().Map(func(it Compute_DataFactory_ARM) *Compute_DataFactory_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataLakeAnalytics"] = Compute_DataLakeAnalytics_ARMGenerator().Map(func(it Compute_DataLakeAnalytics_ARM) *Compute_DataLakeAnalytics_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["Databricks"] = Compute_Databricks_ARMGenerator().Map(func(it Compute_Databricks_ARM) *Compute_Databricks_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["HDInsight"] = Compute_HDInsight_ARMGenerator().Map(func(it Compute_HDInsight_ARM) *Compute_HDInsight_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["SynapseSpark"] = Compute_SynapseSpark_ARMGenerator().Map(func(it Compute_SynapseSpark_ARM) *Compute_SynapseSpark_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["VirtualMachine"] = Compute_VirtualMachine_ARMGenerator().Map(func(it Compute_VirtualMachine_ARM) *Compute_VirtualMachine_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_Compute_AKS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AKS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_AKS_ARM, Compute_AKS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_AKS_ARM runs a test to see if a specific instance of Compute_AKS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_AKS_ARM(subject Compute_AKS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AKS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AKS_ARM instances for property testing - lazily instantiated by Compute_AKS_ARMGenerator()
var compute_AKS_ARMGenerator gopter.Gen

// Compute_AKS_ARMGenerator returns a generator of Compute_AKS_ARM instances for property testing.
// We first initialize compute_AKS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_AKS_ARMGenerator() gopter.Gen {
	if compute_AKS_ARMGenerator != nil {
		return compute_AKS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AKS_ARM(generators)
	compute_AKS_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_AKS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AKS_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_AKS_ARM(generators)
	compute_AKS_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_AKS_ARM{}), generators)

	return compute_AKS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_AKS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_AKS_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_AKS_ComputeType_AKS)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_AKS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_AKS_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AKSProperties_ARMGenerator())
}

func Test_Compute_AmlCompute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AmlCompute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_AmlCompute_ARM, Compute_AmlCompute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_AmlCompute_ARM runs a test to see if a specific instance of Compute_AmlCompute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_AmlCompute_ARM(subject Compute_AmlCompute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AmlCompute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AmlCompute_ARM instances for property testing - lazily instantiated by
// Compute_AmlCompute_ARMGenerator()
var compute_AmlCompute_ARMGenerator gopter.Gen

// Compute_AmlCompute_ARMGenerator returns a generator of Compute_AmlCompute_ARM instances for property testing.
// We first initialize compute_AmlCompute_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_AmlCompute_ARMGenerator() gopter.Gen {
	if compute_AmlCompute_ARMGenerator != nil {
		return compute_AmlCompute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AmlCompute_ARM(generators)
	compute_AmlCompute_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_AmlCompute_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AmlCompute_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_AmlCompute_ARM(generators)
	compute_AmlCompute_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_AmlCompute_ARM{}), generators)

	return compute_AmlCompute_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_AmlCompute_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_AmlCompute_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_AmlCompute_ComputeType_AmlCompute)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_AmlCompute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_AmlCompute_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AmlComputeProperties_ARMGenerator())
}

func Test_Compute_ComputeInstance_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_ComputeInstance_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_ComputeInstance_ARM, Compute_ComputeInstance_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_ComputeInstance_ARM runs a test to see if a specific instance of Compute_ComputeInstance_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_ComputeInstance_ARM(subject Compute_ComputeInstance_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_ComputeInstance_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_ComputeInstance_ARM instances for property testing - lazily instantiated by
// Compute_ComputeInstance_ARMGenerator()
var compute_ComputeInstance_ARMGenerator gopter.Gen

// Compute_ComputeInstance_ARMGenerator returns a generator of Compute_ComputeInstance_ARM instances for property testing.
// We first initialize compute_ComputeInstance_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_ComputeInstance_ARMGenerator() gopter.Gen {
	if compute_ComputeInstance_ARMGenerator != nil {
		return compute_ComputeInstance_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_ComputeInstance_ARM(generators)
	compute_ComputeInstance_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstance_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_ComputeInstance_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_ComputeInstance_ARM(generators)
	compute_ComputeInstance_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstance_ARM{}), generators)

	return compute_ComputeInstance_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_ComputeInstance_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_ComputeInstance_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_ComputeInstance_ComputeType_ComputeInstance)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_ComputeInstance_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_ComputeInstance_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ComputeInstanceProperties_ARMGenerator())
}

func Test_Compute_Databricks_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_Databricks_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_Databricks_ARM, Compute_Databricks_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_Databricks_ARM runs a test to see if a specific instance of Compute_Databricks_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_Databricks_ARM(subject Compute_Databricks_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_Databricks_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_Databricks_ARM instances for property testing - lazily instantiated by
// Compute_Databricks_ARMGenerator()
var compute_Databricks_ARMGenerator gopter.Gen

// Compute_Databricks_ARMGenerator returns a generator of Compute_Databricks_ARM instances for property testing.
// We first initialize compute_Databricks_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_Databricks_ARMGenerator() gopter.Gen {
	if compute_Databricks_ARMGenerator != nil {
		return compute_Databricks_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_Databricks_ARM(generators)
	compute_Databricks_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_Databricks_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_Databricks_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_Databricks_ARM(generators)
	compute_Databricks_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_Databricks_ARM{}), generators)

	return compute_Databricks_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_Databricks_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_Databricks_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_Databricks_ComputeType_Databricks)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_Databricks_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_Databricks_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DatabricksProperties_ARMGenerator())
}

func Test_Compute_DataFactory_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataFactory_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_DataFactory_ARM, Compute_DataFactory_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_DataFactory_ARM runs a test to see if a specific instance of Compute_DataFactory_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_DataFactory_ARM(subject Compute_DataFactory_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataFactory_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataFactory_ARM instances for property testing - lazily instantiated by
// Compute_DataFactory_ARMGenerator()
var compute_DataFactory_ARMGenerator gopter.Gen

// Compute_DataFactory_ARMGenerator returns a generator of Compute_DataFactory_ARM instances for property testing.
func Compute_DataFactory_ARMGenerator() gopter.Gen {
	if compute_DataFactory_ARMGenerator != nil {
		return compute_DataFactory_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataFactory_ARM(generators)
	compute_DataFactory_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataFactory_ARM{}), generators)

	return compute_DataFactory_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_DataFactory_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_DataFactory_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_DataFactory_ComputeType_DataFactory)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Compute_DataLakeAnalytics_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataLakeAnalytics_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_DataLakeAnalytics_ARM, Compute_DataLakeAnalytics_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_DataLakeAnalytics_ARM runs a test to see if a specific instance of Compute_DataLakeAnalytics_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_DataLakeAnalytics_ARM(subject Compute_DataLakeAnalytics_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataLakeAnalytics_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataLakeAnalytics_ARM instances for property testing - lazily instantiated by
// Compute_DataLakeAnalytics_ARMGenerator()
var compute_DataLakeAnalytics_ARMGenerator gopter.Gen

// Compute_DataLakeAnalytics_ARMGenerator returns a generator of Compute_DataLakeAnalytics_ARM instances for property testing.
// We first initialize compute_DataLakeAnalytics_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_DataLakeAnalytics_ARMGenerator() gopter.Gen {
	if compute_DataLakeAnalytics_ARMGenerator != nil {
		return compute_DataLakeAnalytics_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics_ARM(generators)
	compute_DataLakeAnalytics_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalytics_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics_ARM(generators)
	compute_DataLakeAnalytics_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalytics_ARM{}), generators)

	return compute_DataLakeAnalytics_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_DataLakeAnalytics_ComputeType_DataLakeAnalytics)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DataLakeAnalyticsProperties_ARMGenerator())
}

func Test_Compute_HDInsight_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_HDInsight_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_HDInsight_ARM, Compute_HDInsight_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_HDInsight_ARM runs a test to see if a specific instance of Compute_HDInsight_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_HDInsight_ARM(subject Compute_HDInsight_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_HDInsight_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_HDInsight_ARM instances for property testing - lazily instantiated by
// Compute_HDInsight_ARMGenerator()
var compute_HDInsight_ARMGenerator gopter.Gen

// Compute_HDInsight_ARMGenerator returns a generator of Compute_HDInsight_ARM instances for property testing.
// We first initialize compute_HDInsight_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_HDInsight_ARMGenerator() gopter.Gen {
	if compute_HDInsight_ARMGenerator != nil {
		return compute_HDInsight_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_HDInsight_ARM(generators)
	compute_HDInsight_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsight_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_HDInsight_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_HDInsight_ARM(generators)
	compute_HDInsight_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsight_ARM{}), generators)

	return compute_HDInsight_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_HDInsight_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_HDInsight_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_HDInsight_ComputeType_HDInsight)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_HDInsight_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_HDInsight_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HDInsightProperties_ARMGenerator())
}

func Test_Compute_SynapseSpark_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_SynapseSpark_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_SynapseSpark_ARM, Compute_SynapseSpark_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_SynapseSpark_ARM runs a test to see if a specific instance of Compute_SynapseSpark_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_SynapseSpark_ARM(subject Compute_SynapseSpark_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_SynapseSpark_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_SynapseSpark_ARM instances for property testing - lazily instantiated by
// Compute_SynapseSpark_ARMGenerator()
var compute_SynapseSpark_ARMGenerator gopter.Gen

// Compute_SynapseSpark_ARMGenerator returns a generator of Compute_SynapseSpark_ARM instances for property testing.
// We first initialize compute_SynapseSpark_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_SynapseSpark_ARMGenerator() gopter.Gen {
	if compute_SynapseSpark_ARMGenerator != nil {
		return compute_SynapseSpark_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_SynapseSpark_ARM(generators)
	compute_SynapseSpark_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSpark_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_SynapseSpark_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_SynapseSpark_ARM(generators)
	compute_SynapseSpark_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSpark_ARM{}), generators)

	return compute_SynapseSpark_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_SynapseSpark_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_SynapseSpark_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_SynapseSpark_ComputeType_SynapseSpark)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_SynapseSpark_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_SynapseSpark_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SynapseSparkProperties_ARMGenerator())
}

func Test_Compute_VirtualMachine_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_VirtualMachine_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_VirtualMachine_ARM, Compute_VirtualMachine_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_VirtualMachine_ARM runs a test to see if a specific instance of Compute_VirtualMachine_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_VirtualMachine_ARM(subject Compute_VirtualMachine_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_VirtualMachine_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_VirtualMachine_ARM instances for property testing - lazily instantiated by
// Compute_VirtualMachine_ARMGenerator()
var compute_VirtualMachine_ARMGenerator gopter.Gen

// Compute_VirtualMachine_ARMGenerator returns a generator of Compute_VirtualMachine_ARM instances for property testing.
// We first initialize compute_VirtualMachine_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_VirtualMachine_ARMGenerator() gopter.Gen {
	if compute_VirtualMachine_ARMGenerator != nil {
		return compute_VirtualMachine_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_VirtualMachine_ARM(generators)
	compute_VirtualMachine_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachine_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_VirtualMachine_ARM(generators)
	AddRelatedPropertyGeneratorsForCompute_VirtualMachine_ARM(generators)
	compute_VirtualMachine_ARMGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachine_ARM{}), generators)

	return compute_VirtualMachine_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCompute_VirtualMachine_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_VirtualMachine_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Compute_VirtualMachine_ComputeType_VirtualMachine)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_VirtualMachine_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_VirtualMachine_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineProperties_ARMGenerator())
}

func Test_AKSProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AKSProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAKSProperties_ARM, AKSProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAKSProperties_ARM runs a test to see if a specific instance of AKSProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAKSProperties_ARM(subject AKSProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AKSProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AKSProperties_ARM instances for property testing - lazily instantiated by AKSProperties_ARMGenerator()
var aksProperties_ARMGenerator gopter.Gen

// AKSProperties_ARMGenerator returns a generator of AKSProperties_ARM instances for property testing.
// We first initialize aksProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AKSProperties_ARMGenerator() gopter.Gen {
	if aksProperties_ARMGenerator != nil {
		return aksProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSProperties_ARM(generators)
	aksProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AKSProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForAKSProperties_ARM(generators)
	aksProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AKSProperties_ARM{}), generators)

	return aksProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAKSProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAKSProperties_ARM(gens map[string]gopter.Gen) {
	gens["AgentCount"] = gen.PtrOf(gen.Int())
	gens["AgentVmSize"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterPurpose"] = gen.PtrOf(gen.OneConstOf(AKSProperties_ClusterPurpose_DenseProd, AKSProperties_ClusterPurpose_DevTest, AKSProperties_ClusterPurpose_FastProd))
	gens["LoadBalancerSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerType"] = gen.PtrOf(gen.OneConstOf(AKSProperties_LoadBalancerType_InternalLoadBalancer, AKSProperties_LoadBalancerType_PublicIp))
}

// AddRelatedPropertyGeneratorsForAKSProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAKSProperties_ARM(gens map[string]gopter.Gen) {
	gens["AksNetworkingConfiguration"] = gen.PtrOf(AksNetworkingConfiguration_ARMGenerator())
	gens["SslConfiguration"] = gen.PtrOf(SslConfiguration_ARMGenerator())
}

func Test_AmlComputeProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AmlComputeProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAmlComputeProperties_ARM, AmlComputeProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAmlComputeProperties_ARM runs a test to see if a specific instance of AmlComputeProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAmlComputeProperties_ARM(subject AmlComputeProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AmlComputeProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AmlComputeProperties_ARM instances for property testing - lazily instantiated by
// AmlComputeProperties_ARMGenerator()
var amlComputeProperties_ARMGenerator gopter.Gen

// AmlComputeProperties_ARMGenerator returns a generator of AmlComputeProperties_ARM instances for property testing.
// We first initialize amlComputeProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AmlComputeProperties_ARMGenerator() gopter.Gen {
	if amlComputeProperties_ARMGenerator != nil {
		return amlComputeProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	amlComputeProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	amlComputeProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties_ARM{}), generators)

	return amlComputeProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnableNodePublicIp"] = gen.PtrOf(gen.Bool())
	gens["IsolatedNetwork"] = gen.PtrOf(gen.Bool())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_OsType_Linux, AmlComputeProperties_OsType_Windows))
	gens["RemoteLoginPortPublicAccess"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled, AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled, AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified))
	gens["VmPriority"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_VmPriority_Dedicated, AmlComputeProperties_VmPriority_LowPriority))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM(gens map[string]gopter.Gen) {
	gens["ScaleSettings"] = gen.PtrOf(ScaleSettings_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceId_ARMGenerator())
	gens["UserAccountCredentials"] = gen.PtrOf(UserAccountCredentials_ARMGenerator())
	gens["VirtualMachineImage"] = gen.PtrOf(VirtualMachineImage_ARMGenerator())
}

func Test_ComputeInstanceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceProperties_ARM, ComputeInstanceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceProperties_ARM runs a test to see if a specific instance of ComputeInstanceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceProperties_ARM(subject ComputeInstanceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceProperties_ARM instances for property testing - lazily instantiated by
// ComputeInstanceProperties_ARMGenerator()
var computeInstanceProperties_ARMGenerator gopter.Gen

// ComputeInstanceProperties_ARMGenerator returns a generator of ComputeInstanceProperties_ARM instances for property testing.
// We first initialize computeInstanceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeInstanceProperties_ARMGenerator() gopter.Gen {
	if computeInstanceProperties_ARMGenerator != nil {
		return computeInstanceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	computeInstanceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	computeInstanceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties_ARM{}), generators)

	return computeInstanceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(gens map[string]gopter.Gen) {
	gens["ApplicationSharingPolicy"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ApplicationSharingPolicy_Personal, ComputeInstanceProperties_ApplicationSharingPolicy_Shared))
	gens["ComputeInstanceAuthorizationType"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM(gens map[string]gopter.Gen) {
	gens["PersonalComputeInstanceSettings"] = gen.PtrOf(PersonalComputeInstanceSettings_ARMGenerator())
	gens["SetupScripts"] = gen.PtrOf(SetupScripts_ARMGenerator())
	gens["SshSettings"] = gen.PtrOf(ComputeInstanceSshSettings_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceId_ARMGenerator())
}

func Test_DatabricksProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabricksProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabricksProperties_ARM, DatabricksProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabricksProperties_ARM runs a test to see if a specific instance of DatabricksProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabricksProperties_ARM(subject DatabricksProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabricksProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabricksProperties_ARM instances for property testing - lazily instantiated by
// DatabricksProperties_ARMGenerator()
var databricksProperties_ARMGenerator gopter.Gen

// DatabricksProperties_ARMGenerator returns a generator of DatabricksProperties_ARM instances for property testing.
func DatabricksProperties_ARMGenerator() gopter.Gen {
	if databricksProperties_ARMGenerator != nil {
		return databricksProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricksProperties_ARM(generators)
	databricksProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DatabricksProperties_ARM{}), generators)

	return databricksProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabricksProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabricksProperties_ARM(gens map[string]gopter.Gen) {
	gens["DatabricksAccessToken"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeAnalyticsProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeAnalyticsProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeAnalyticsProperties_ARM, DataLakeAnalyticsProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeAnalyticsProperties_ARM runs a test to see if a specific instance of DataLakeAnalyticsProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeAnalyticsProperties_ARM(subject DataLakeAnalyticsProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeAnalyticsProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeAnalyticsProperties_ARM instances for property testing - lazily instantiated by
// DataLakeAnalyticsProperties_ARMGenerator()
var dataLakeAnalyticsProperties_ARMGenerator gopter.Gen

// DataLakeAnalyticsProperties_ARMGenerator returns a generator of DataLakeAnalyticsProperties_ARM instances for property testing.
func DataLakeAnalyticsProperties_ARMGenerator() gopter.Gen {
	if dataLakeAnalyticsProperties_ARMGenerator != nil {
		return dataLakeAnalyticsProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties_ARM(generators)
	dataLakeAnalyticsProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalyticsProperties_ARM{}), generators)

	return dataLakeAnalyticsProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties_ARM(gens map[string]gopter.Gen) {
	gens["DataLakeStoreAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HDInsightProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HDInsightProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHDInsightProperties_ARM, HDInsightProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHDInsightProperties_ARM runs a test to see if a specific instance of HDInsightProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHDInsightProperties_ARM(subject HDInsightProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HDInsightProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HDInsightProperties_ARM instances for property testing - lazily instantiated by
// HDInsightProperties_ARMGenerator()
var hdInsightProperties_ARMGenerator gopter.Gen

// HDInsightProperties_ARMGenerator returns a generator of HDInsightProperties_ARM instances for property testing.
// We first initialize hdInsightProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HDInsightProperties_ARMGenerator() gopter.Gen {
	if hdInsightProperties_ARMGenerator != nil {
		return hdInsightProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(generators)
	hdInsightProperties_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForHDInsightProperties_ARM(generators)
	hdInsightProperties_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties_ARM{}), generators)

	return hdInsightProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHDInsightProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["SshPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHDInsightProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHDInsightProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentials_ARMGenerator())
}

func Test_SynapseSparkProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SynapseSparkProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSynapseSparkProperties_ARM, SynapseSparkProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSynapseSparkProperties_ARM runs a test to see if a specific instance of SynapseSparkProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSynapseSparkProperties_ARM(subject SynapseSparkProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SynapseSparkProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SynapseSparkProperties_ARM instances for property testing - lazily instantiated by
// SynapseSparkProperties_ARMGenerator()
var synapseSparkProperties_ARMGenerator gopter.Gen

// SynapseSparkProperties_ARMGenerator returns a generator of SynapseSparkProperties_ARM instances for property testing.
// We first initialize synapseSparkProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SynapseSparkProperties_ARMGenerator() gopter.Gen {
	if synapseSparkProperties_ARMGenerator != nil {
		return synapseSparkProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkProperties_ARM(generators)
	synapseSparkProperties_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSparkProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForSynapseSparkProperties_ARM(generators)
	synapseSparkProperties_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSparkProperties_ARM{}), generators)

	return synapseSparkProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSynapseSparkProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSynapseSparkProperties_ARM(gens map[string]gopter.Gen) {
	gens["NodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeSize"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSizeFamily"] = gen.PtrOf(gen.AlphaString())
	gens["PoolName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SparkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSynapseSparkProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSynapseSparkProperties_ARM(gens map[string]gopter.Gen) {
	gens["AutoPauseProperties"] = gen.PtrOf(AutoPauseProperties_ARMGenerator())
	gens["AutoScaleProperties"] = gen.PtrOf(AutoScaleProperties_ARMGenerator())
}

func Test_VirtualMachineProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties_ARM, VirtualMachineProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties_ARM runs a test to see if a specific instance of VirtualMachineProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties_ARM(subject VirtualMachineProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_ARM instances for property testing - lazily instantiated by
// VirtualMachineProperties_ARMGenerator()
var virtualMachineProperties_ARMGenerator gopter.Gen

// VirtualMachineProperties_ARMGenerator returns a generator of VirtualMachineProperties_ARM instances for property testing.
// We first initialize virtualMachineProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineProperties_ARMGenerator() gopter.Gen {
	if virtualMachineProperties_ARMGenerator != nil {
		return virtualMachineProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	virtualMachineProperties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	virtualMachineProperties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_ARM{}), generators)

	return virtualMachineProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["IsNotebookInstanceCompute"] = gen.PtrOf(gen.Bool())
	gens["SshPort"] = gen.PtrOf(gen.Int())
	gens["VirtualMachineSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentials_ARMGenerator())
}

func Test_AksNetworkingConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AksNetworkingConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAksNetworkingConfiguration_ARM, AksNetworkingConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAksNetworkingConfiguration_ARM runs a test to see if a specific instance of AksNetworkingConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAksNetworkingConfiguration_ARM(subject AksNetworkingConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AksNetworkingConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AksNetworkingConfiguration_ARM instances for property testing - lazily instantiated by
// AksNetworkingConfiguration_ARMGenerator()
var aksNetworkingConfiguration_ARMGenerator gopter.Gen

// AksNetworkingConfiguration_ARMGenerator returns a generator of AksNetworkingConfiguration_ARM instances for property testing.
func AksNetworkingConfiguration_ARMGenerator() gopter.Gen {
	if aksNetworkingConfiguration_ARMGenerator != nil {
		return aksNetworkingConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM(generators)
	aksNetworkingConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(AksNetworkingConfiguration_ARM{}), generators)

	return aksNetworkingConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoPauseProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoPauseProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoPauseProperties_ARM, AutoPauseProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoPauseProperties_ARM runs a test to see if a specific instance of AutoPauseProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoPauseProperties_ARM(subject AutoPauseProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoPauseProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoPauseProperties_ARM instances for property testing - lazily instantiated by
// AutoPauseProperties_ARMGenerator()
var autoPauseProperties_ARMGenerator gopter.Gen

// AutoPauseProperties_ARMGenerator returns a generator of AutoPauseProperties_ARM instances for property testing.
func AutoPauseProperties_ARMGenerator() gopter.Gen {
	if autoPauseProperties_ARMGenerator != nil {
		return autoPauseProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM(generators)
	autoPauseProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoPauseProperties_ARM{}), generators)

	return autoPauseProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM(gens map[string]gopter.Gen) {
	gens["DelayInMinutes"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AutoScaleProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScaleProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScaleProperties_ARM, AutoScaleProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScaleProperties_ARM runs a test to see if a specific instance of AutoScaleProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScaleProperties_ARM(subject AutoScaleProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScaleProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScaleProperties_ARM instances for property testing - lazily instantiated by
// AutoScaleProperties_ARMGenerator()
var autoScaleProperties_ARMGenerator gopter.Gen

// AutoScaleProperties_ARMGenerator returns a generator of AutoScaleProperties_ARM instances for property testing.
func AutoScaleProperties_ARMGenerator() gopter.Gen {
	if autoScaleProperties_ARMGenerator != nil {
		return autoScaleProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM(generators)
	autoScaleProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoScaleProperties_ARM{}), generators)

	return autoScaleProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
}

func Test_ComputeInstanceSshSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceSshSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceSshSettings_ARM, ComputeInstanceSshSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceSshSettings_ARM runs a test to see if a specific instance of ComputeInstanceSshSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceSshSettings_ARM(subject ComputeInstanceSshSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceSshSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceSshSettings_ARM instances for property testing - lazily instantiated by
// ComputeInstanceSshSettings_ARMGenerator()
var computeInstanceSshSettings_ARMGenerator gopter.Gen

// ComputeInstanceSshSettings_ARMGenerator returns a generator of ComputeInstanceSshSettings_ARM instances for property testing.
func ComputeInstanceSshSettings_ARMGenerator() gopter.Gen {
	if computeInstanceSshSettings_ARMGenerator != nil {
		return computeInstanceSshSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM(generators)
	computeInstanceSshSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceSshSettings_ARM{}), generators)

	return computeInstanceSshSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM(gens map[string]gopter.Gen) {
	gens["AdminPublicKey"] = gen.PtrOf(gen.AlphaString())
	gens["SshPublicAccess"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceSshSettings_SshPublicAccess_Disabled, ComputeInstanceSshSettings_SshPublicAccess_Enabled))
}

func Test_PersonalComputeInstanceSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PersonalComputeInstanceSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM, PersonalComputeInstanceSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM runs a test to see if a specific instance of PersonalComputeInstanceSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM(subject PersonalComputeInstanceSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PersonalComputeInstanceSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PersonalComputeInstanceSettings_ARM instances for property testing - lazily instantiated by
// PersonalComputeInstanceSettings_ARMGenerator()
var personalComputeInstanceSettings_ARMGenerator gopter.Gen

// PersonalComputeInstanceSettings_ARMGenerator returns a generator of PersonalComputeInstanceSettings_ARM instances for property testing.
func PersonalComputeInstanceSettings_ARMGenerator() gopter.Gen {
	if personalComputeInstanceSettings_ARMGenerator != nil {
		return personalComputeInstanceSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM(generators)
	personalComputeInstanceSettings_ARMGenerator = gen.Struct(reflect.TypeOf(PersonalComputeInstanceSettings_ARM{}), generators)

	return personalComputeInstanceSettings_ARMGenerator
}

// AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM(gens map[string]gopter.Gen) {
	gens["AssignedUser"] = gen.PtrOf(AssignedUser_ARMGenerator())
}

func Test_ResourceId_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceId_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceId_ARM, ResourceId_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceId_ARM runs a test to see if a specific instance of ResourceId_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceId_ARM(subject ResourceId_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceId_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceId_ARM instances for property testing - lazily instantiated by ResourceId_ARMGenerator()
var resourceId_ARMGenerator gopter.Gen

// ResourceId_ARMGenerator returns a generator of ResourceId_ARM instances for property testing.
func ResourceId_ARMGenerator() gopter.Gen {
	if resourceId_ARMGenerator != nil {
		return resourceId_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceId_ARM(generators)
	resourceId_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceId_ARM{}), generators)

	return resourceId_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceId_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceId_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleSettings_ARM, ScaleSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleSettings_ARM runs a test to see if a specific instance of ScaleSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleSettings_ARM(subject ScaleSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleSettings_ARM instances for property testing - lazily instantiated by ScaleSettings_ARMGenerator()
var scaleSettings_ARMGenerator gopter.Gen

// ScaleSettings_ARMGenerator returns a generator of ScaleSettings_ARM instances for property testing.
func ScaleSettings_ARMGenerator() gopter.Gen {
	if scaleSettings_ARMGenerator != nil {
		return scaleSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleSettings_ARM(generators)
	scaleSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleSettings_ARM{}), generators)

	return scaleSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleSettings_ARM(gens map[string]gopter.Gen) {
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeIdleTimeBeforeScaleDown"] = gen.PtrOf(gen.AlphaString())
}

func Test_SetupScripts_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SetupScripts_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSetupScripts_ARM, SetupScripts_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSetupScripts_ARM runs a test to see if a specific instance of SetupScripts_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSetupScripts_ARM(subject SetupScripts_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SetupScripts_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SetupScripts_ARM instances for property testing - lazily instantiated by SetupScripts_ARMGenerator()
var setupScripts_ARMGenerator gopter.Gen

// SetupScripts_ARMGenerator returns a generator of SetupScripts_ARM instances for property testing.
func SetupScripts_ARMGenerator() gopter.Gen {
	if setupScripts_ARMGenerator != nil {
		return setupScripts_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSetupScripts_ARM(generators)
	setupScripts_ARMGenerator = gen.Struct(reflect.TypeOf(SetupScripts_ARM{}), generators)

	return setupScripts_ARMGenerator
}

// AddRelatedPropertyGeneratorsForSetupScripts_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSetupScripts_ARM(gens map[string]gopter.Gen) {
	gens["Scripts"] = gen.PtrOf(ScriptsToExecute_ARMGenerator())
}

func Test_SslConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslConfiguration_ARM, SslConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslConfiguration_ARM runs a test to see if a specific instance of SslConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslConfiguration_ARM(subject SslConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslConfiguration_ARM instances for property testing - lazily instantiated by
// SslConfiguration_ARMGenerator()
var sslConfiguration_ARMGenerator gopter.Gen

// SslConfiguration_ARMGenerator returns a generator of SslConfiguration_ARM instances for property testing.
func SslConfiguration_ARMGenerator() gopter.Gen {
	if sslConfiguration_ARMGenerator != nil {
		return sslConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslConfiguration_ARM(generators)
	sslConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(SslConfiguration_ARM{}), generators)

	return sslConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSslConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Cert"] = gen.PtrOf(gen.AlphaString())
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["LeafDomainLabel"] = gen.PtrOf(gen.AlphaString())
	gens["OverwriteExistingDomain"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(SslConfiguration_Status_Auto, SslConfiguration_Status_Disabled, SslConfiguration_Status_Enabled))
}

func Test_UserAccountCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAccountCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAccountCredentials_ARM, UserAccountCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAccountCredentials_ARM runs a test to see if a specific instance of UserAccountCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAccountCredentials_ARM(subject UserAccountCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAccountCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAccountCredentials_ARM instances for property testing - lazily instantiated by
// UserAccountCredentials_ARMGenerator()
var userAccountCredentials_ARMGenerator gopter.Gen

// UserAccountCredentials_ARMGenerator returns a generator of UserAccountCredentials_ARM instances for property testing.
func UserAccountCredentials_ARMGenerator() gopter.Gen {
	if userAccountCredentials_ARMGenerator != nil {
		return userAccountCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM(generators)
	userAccountCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(UserAccountCredentials_ARM{}), generators)

	return userAccountCredentials_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM(gens map[string]gopter.Gen) {
	gens["AdminUserName"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserSshPublicKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineImage_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineImage_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineImage_ARM, VirtualMachineImage_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineImage_ARM runs a test to see if a specific instance of VirtualMachineImage_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineImage_ARM(subject VirtualMachineImage_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineImage_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineImage_ARM instances for property testing - lazily instantiated by
// VirtualMachineImage_ARMGenerator()
var virtualMachineImage_ARMGenerator gopter.Gen

// VirtualMachineImage_ARMGenerator returns a generator of VirtualMachineImage_ARM instances for property testing.
func VirtualMachineImage_ARMGenerator() gopter.Gen {
	if virtualMachineImage_ARMGenerator != nil {
		return virtualMachineImage_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM(generators)
	virtualMachineImage_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineImage_ARM{}), generators)

	return virtualMachineImage_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineSshCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineSshCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineSshCredentials_ARM, VirtualMachineSshCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineSshCredentials_ARM runs a test to see if a specific instance of VirtualMachineSshCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineSshCredentials_ARM(subject VirtualMachineSshCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineSshCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineSshCredentials_ARM instances for property testing - lazily instantiated by
// VirtualMachineSshCredentials_ARMGenerator()
var virtualMachineSshCredentials_ARMGenerator gopter.Gen

// VirtualMachineSshCredentials_ARMGenerator returns a generator of VirtualMachineSshCredentials_ARM instances for property testing.
func VirtualMachineSshCredentials_ARMGenerator() gopter.Gen {
	if virtualMachineSshCredentials_ARMGenerator != nil {
		return virtualMachineSshCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM(generators)
	virtualMachineSshCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineSshCredentials_ARM{}), generators)

	return virtualMachineSshCredentials_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM(gens map[string]gopter.Gen) {
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["PublicKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_AssignedUser_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AssignedUser_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAssignedUser_ARM, AssignedUser_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAssignedUser_ARM runs a test to see if a specific instance of AssignedUser_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAssignedUser_ARM(subject AssignedUser_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AssignedUser_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AssignedUser_ARM instances for property testing - lazily instantiated by AssignedUser_ARMGenerator()
var assignedUser_ARMGenerator gopter.Gen

// AssignedUser_ARMGenerator returns a generator of AssignedUser_ARM instances for property testing.
func AssignedUser_ARMGenerator() gopter.Gen {
	if assignedUser_ARMGenerator != nil {
		return assignedUser_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAssignedUser_ARM(generators)
	assignedUser_ARMGenerator = gen.Struct(reflect.TypeOf(AssignedUser_ARM{}), generators)

	return assignedUser_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAssignedUser_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAssignedUser_ARM(gens map[string]gopter.Gen) {
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScriptsToExecute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptsToExecute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptsToExecute_ARM, ScriptsToExecute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptsToExecute_ARM runs a test to see if a specific instance of ScriptsToExecute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptsToExecute_ARM(subject ScriptsToExecute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptsToExecute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptsToExecute_ARM instances for property testing - lazily instantiated by
// ScriptsToExecute_ARMGenerator()
var scriptsToExecute_ARMGenerator gopter.Gen

// ScriptsToExecute_ARMGenerator returns a generator of ScriptsToExecute_ARM instances for property testing.
func ScriptsToExecute_ARMGenerator() gopter.Gen {
	if scriptsToExecute_ARMGenerator != nil {
		return scriptsToExecute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScriptsToExecute_ARM(generators)
	scriptsToExecute_ARMGenerator = gen.Struct(reflect.TypeOf(ScriptsToExecute_ARM{}), generators)

	return scriptsToExecute_ARMGenerator
}

// AddRelatedPropertyGeneratorsForScriptsToExecute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScriptsToExecute_ARM(gens map[string]gopter.Gen) {
	gens["CreationScript"] = gen.PtrOf(ScriptReference_ARMGenerator())
	gens["StartupScript"] = gen.PtrOf(ScriptReference_ARMGenerator())
}

func Test_ScriptReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptReference_ARM, ScriptReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptReference_ARM runs a test to see if a specific instance of ScriptReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptReference_ARM(subject ScriptReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptReference_ARM instances for property testing - lazily instantiated by
// ScriptReference_ARMGenerator()
var scriptReference_ARMGenerator gopter.Gen

// ScriptReference_ARMGenerator returns a generator of ScriptReference_ARM instances for property testing.
func ScriptReference_ARMGenerator() gopter.Gen {
	if scriptReference_ARMGenerator != nil {
		return scriptReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScriptReference_ARM(generators)
	scriptReference_ARMGenerator = gen.Struct(reflect.TypeOf(ScriptReference_ARM{}), generators)

	return scriptReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScriptReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScriptReference_ARM(gens map[string]gopter.Gen) {
	gens["ScriptArguments"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptData"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptSource"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.AlphaString())
}
