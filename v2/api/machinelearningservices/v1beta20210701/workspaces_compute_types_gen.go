// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210701

import (
	"fmt"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1beta20210701storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/resourceDefinitions/workspaces_computes
type WorkspacesCompute struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Workspaces_Compute_Spec `json:"spec,omitempty"`
	Status            ComputeResource_STATUS  `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WorkspacesCompute{}

// GetConditions returns the conditions of the resource
func (compute *WorkspacesCompute) GetConditions() conditions.Conditions {
	return compute.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (compute *WorkspacesCompute) SetConditions(conditions conditions.Conditions) {
	compute.Status.Conditions = conditions
}

var _ conversion.Convertible = &WorkspacesCompute{}

// ConvertFrom populates our WorkspacesCompute from the provided hub WorkspacesCompute
func (compute *WorkspacesCompute) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210701s.WorkspacesCompute)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1beta20210701storage/WorkspacesCompute but received %T instead", hub)
	}

	return compute.AssignProperties_From_WorkspacesCompute(source)
}

// ConvertTo populates the provided hub WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210701s.WorkspacesCompute)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1beta20210701storage/WorkspacesCompute but received %T instead", hub)
	}

	return compute.AssignProperties_To_WorkspacesCompute(destination)
}

// +kubebuilder:webhook:path=/mutate-machinelearningservices-azure-com-v1beta20210701-workspacescompute,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacescomputes,verbs=create;update,versions=v1beta20210701,name=default.v1beta20210701.workspacescomputes.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WorkspacesCompute{}

// Default applies defaults to the WorkspacesCompute resource
func (compute *WorkspacesCompute) Default() {
	compute.defaultImpl()
	var temp interface{} = compute
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (compute *WorkspacesCompute) defaultAzureName() {
	if compute.Spec.AzureName == "" {
		compute.Spec.AzureName = compute.Name
	}
}

// defaultImpl applies the code generated defaults to the WorkspacesCompute resource
func (compute *WorkspacesCompute) defaultImpl() { compute.defaultAzureName() }

var _ genruntime.KubernetesResource = &WorkspacesCompute{}

// AzureName returns the Azure name of the resource
func (compute *WorkspacesCompute) AzureName() string {
	return compute.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-07-01"
func (compute WorkspacesCompute) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (compute *WorkspacesCompute) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (compute *WorkspacesCompute) GetSpec() genruntime.ConvertibleSpec {
	return &compute.Spec
}

// GetStatus returns the status of this resource
func (compute *WorkspacesCompute) GetStatus() genruntime.ConvertibleStatus {
	return &compute.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/workspaces/computes"
func (compute *WorkspacesCompute) GetType() string {
	return "Microsoft.MachineLearningServices/workspaces/computes"
}

// NewEmptyStatus returns a new empty (blank) status
func (compute *WorkspacesCompute) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ComputeResource_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (compute *WorkspacesCompute) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(compute.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  compute.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (compute *WorkspacesCompute) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ComputeResource_STATUS); ok {
		compute.Status = *st
		return nil
	}

	// Convert status to required version
	var st ComputeResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	compute.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-machinelearningservices-azure-com-v1beta20210701-workspacescompute,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacescomputes,verbs=create;update,versions=v1beta20210701,name=validate.v1beta20210701.workspacescomputes.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WorkspacesCompute{}

// ValidateCreate validates the creation of the resource
func (compute *WorkspacesCompute) ValidateCreate() error {
	validations := compute.createValidations()
	var temp interface{} = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (compute *WorkspacesCompute) ValidateDelete() error {
	validations := compute.deleteValidations()
	var temp interface{} = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (compute *WorkspacesCompute) ValidateUpdate(old runtime.Object) error {
	validations := compute.updateValidations()
	var temp interface{} = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (compute *WorkspacesCompute) createValidations() []func() error {
	return []func() error{compute.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (compute *WorkspacesCompute) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (compute *WorkspacesCompute) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return compute.validateResourceReferences()
		},
		compute.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (compute *WorkspacesCompute) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&compute.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (compute *WorkspacesCompute) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*WorkspacesCompute)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, compute)
}

// AssignProperties_From_WorkspacesCompute populates our WorkspacesCompute from the provided source WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_From_WorkspacesCompute(source *v20210701s.WorkspacesCompute) error {

	// ObjectMeta
	compute.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Workspaces_Compute_Spec
	err := spec.AssignProperties_From_Workspaces_Compute_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Workspaces_Compute_Spec() to populate field Spec")
	}
	compute.Spec = spec

	// Status
	var status ComputeResource_STATUS
	err = status.AssignProperties_From_ComputeResource_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ComputeResource_STATUS() to populate field Status")
	}
	compute.Status = status

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute populates the provided destination WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_To_WorkspacesCompute(destination *v20210701s.WorkspacesCompute) error {

	// ObjectMeta
	destination.ObjectMeta = *compute.ObjectMeta.DeepCopy()

	// Spec
	var spec v20210701s.Workspaces_Compute_Spec
	err := compute.Spec.AssignProperties_To_Workspaces_Compute_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Workspaces_Compute_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20210701s.ComputeResource_STATUS
	err = compute.Status.AssignProperties_To_ComputeResource_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ComputeResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (compute *WorkspacesCompute) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: compute.Spec.OriginalVersion(),
		Kind:    "WorkspacesCompute",
	}
}

// +kubebuilder:object:root=true
// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/resourceDefinitions/workspaces_computes
type WorkspacesComputeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WorkspacesCompute `json:"items"`
}

type ComputeResource_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Compute properties
	Properties *Compute_STATUS `json:"properties,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: System data
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ComputeResource_STATUS{}

// ConvertStatusFrom populates our ComputeResource_STATUS from the provided source
func (resource *ComputeResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210701s.ComputeResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_ComputeResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20210701s.ComputeResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_ComputeResource_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ComputeResource_STATUS
func (resource *ComputeResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210701s.ComputeResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_ComputeResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20210701s.ComputeResource_STATUS{}
	err := resource.AssignProperties_To_ComputeResource_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ComputeResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *ComputeResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ComputeResource_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *ComputeResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ComputeResource_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ComputeResource_STATUS_ARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		resource.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 Compute_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		resource.Properties = &properties
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		resource.Sku = &sku
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		resource.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		resource.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			resource.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeResource_STATUS populates our ComputeResource_STATUS from the provided source ComputeResource_STATUS
func (resource *ComputeResource_STATUS) AssignProperties_From_ComputeResource_STATUS(source *v20210701s.ComputeResource_STATUS) error {

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property Compute_STATUS
		err := property.AssignProperties_From_Compute_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_STATUS() to populate field Properties")
		}
		resource.Properties = &property
	} else {
		resource.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ComputeResource_STATUS populates the provided destination ComputeResource_STATUS from our ComputeResource_STATUS
func (resource *ComputeResource_STATUS) AssignProperties_To_ComputeResource_STATUS(destination *v20210701s.ComputeResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var identity v20210701s.Identity_STATUS
		err := resource.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Properties
	if resource.Properties != nil {
		var property v20210701s.Compute_STATUS
		err := resource.Properties.AssignProperties_To_Compute_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if resource.Sku != nil {
		var sku v20210701s.Sku_STATUS
		err := resource.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDatum v20210701s.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Workspaces_Compute_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: Identity for the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a machinelearningservices.azure.com/Workspace resource
	Owner *genruntime.KnownResourceReference `group:"machinelearningservices.azure.com" json:"owner,omitempty" kind:"Workspace"`

	// +kubebuilder:validation:Required
	// Properties: Machine Learning compute object.
	Properties *Compute `json:"properties,omitempty"`

	// Sku: Sku of the resource
	Sku *Sku `json:"sku,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Workspaces_Compute_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *Workspaces_Compute_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &Workspaces_Compute_Spec_ARM{}

	// Set property ‘Identity’:
	if compute.Identity != nil {
		identity_ARM, err := (*compute.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*Identity_ARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if compute.Location != nil {
		location := *compute.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*Compute_ARM)
		result.Properties = &properties
	}

	// Set property ‘Sku’:
	if compute.Sku != nil {
		sku_ARM, err := (*compute.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property ‘SystemData’:
	if compute.SystemData != nil {
		systemData_ARM, err := (*compute.SystemData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemData := *systemData_ARM.(*SystemData_ARM)
		result.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if compute.Tags != nil {
		result.Tags = make(map[string]string, len(compute.Tags))
		for key, value := range compute.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Workspaces_Compute_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Workspaces_Compute_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Workspaces_Compute_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Workspaces_Compute_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Workspaces_Compute_Spec_ARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	compute.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		compute.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		compute.Location = &location
	}

	// Set property ‘Owner’:
	compute.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 Compute
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		compute.Sku = &sku
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		compute.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		compute.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			compute.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Workspaces_Compute_Spec{}

// ConvertSpecFrom populates our Workspaces_Compute_Spec from the provided source
func (compute *Workspaces_Compute_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210701s.Workspaces_Compute_Spec)
	if ok {
		// Populate our instance from source
		return compute.AssignProperties_From_Workspaces_Compute_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210701s.Workspaces_Compute_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = compute.AssignProperties_From_Workspaces_Compute_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Workspaces_Compute_Spec
func (compute *Workspaces_Compute_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210701s.Workspaces_Compute_Spec)
	if ok {
		// Populate destination from our instance
		return compute.AssignProperties_To_Workspaces_Compute_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210701s.Workspaces_Compute_Spec{}
	err := compute.AssignProperties_To_Workspaces_Compute_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Workspaces_Compute_Spec populates our Workspaces_Compute_Spec from the provided source Workspaces_Compute_Spec
func (compute *Workspaces_Compute_Spec) AssignProperties_From_Workspaces_Compute_Spec(source *v20210701s.Workspaces_Compute_Spec) error {

	// AzureName
	compute.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		compute.Owner = &owner
	} else {
		compute.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property Compute
		err := property.AssignProperties_From_Compute(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.AssignProperties_From_SystemData(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData() to populate field SystemData")
		}
		compute.SystemData = &systemDatum
	} else {
		compute.SystemData = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Workspaces_Compute_Spec populates the provided destination Workspaces_Compute_Spec from our Workspaces_Compute_Spec
func (compute *Workspaces_Compute_Spec) AssignProperties_To_Workspaces_Compute_Spec(destination *v20210701s.Workspaces_Compute_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = compute.AzureName

	// Identity
	if compute.Identity != nil {
		var identity v20210701s.Identity
		err := compute.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(compute.Location)

	// OriginalVersion
	destination.OriginalVersion = compute.OriginalVersion()

	// Owner
	if compute.Owner != nil {
		owner := compute.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if compute.Properties != nil {
		var property v20210701s.Compute
		err := compute.Properties.AssignProperties_To_Compute(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if compute.Sku != nil {
		var sku v20210701s.Sku
		err := compute.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if compute.SystemData != nil {
		var systemDatum v20210701s.SystemData
		err := compute.SystemData.AssignProperties_To_SystemData(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(compute.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (compute *Workspaces_Compute_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (compute *Workspaces_Compute_Spec) SetAzureName(azureName string) { compute.AzureName = azureName }

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/Compute
type Compute struct {
	// AKS: Mutually exclusive with all other properties
	AKS *Compute_AKS `json:"aks,omitempty"`

	// AmlCompute: Mutually exclusive with all other properties
	AmlCompute *Compute_AmlCompute `json:"amlCompute,omitempty"`

	// ComputeInstance: Mutually exclusive with all other properties
	ComputeInstance *Compute_ComputeInstance `json:"computeInstance,omitempty"`

	// DataFactory: Mutually exclusive with all other properties
	DataFactory *Compute_DataFactory `json:"dataFactory,omitempty"`

	// DataLakeAnalytics: Mutually exclusive with all other properties
	DataLakeAnalytics *Compute_DataLakeAnalytics `json:"dataLakeAnalytics,omitempty"`

	// Databricks: Mutually exclusive with all other properties
	Databricks *Compute_Databricks `json:"databricks,omitempty"`

	// HDInsight: Mutually exclusive with all other properties
	HDInsight *Compute_HDInsight `json:"hdInsight,omitempty"`

	// SynapseSpark: Mutually exclusive with all other properties
	SynapseSpark *Compute_SynapseSpark `json:"synapseSpark,omitempty"`

	// VirtualMachine: Mutually exclusive with all other properties
	VirtualMachine *Compute_VirtualMachine `json:"virtualMachine,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *Compute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &Compute_ARM{}

	// Set property ‘AKS’:
	if compute.AKS != nil {
		aks_ARM, err := (*compute.AKS).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aks := *aks_ARM.(*Compute_AKS_ARM)
		result.AKS = &aks
	}

	// Set property ‘AmlCompute’:
	if compute.AmlCompute != nil {
		amlCompute_ARM, err := (*compute.AmlCompute).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		amlCompute := *amlCompute_ARM.(*Compute_AmlCompute_ARM)
		result.AmlCompute = &amlCompute
	}

	// Set property ‘ComputeInstance’:
	if compute.ComputeInstance != nil {
		computeInstance_ARM, err := (*compute.ComputeInstance).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		computeInstance := *computeInstance_ARM.(*Compute_ComputeInstance_ARM)
		result.ComputeInstance = &computeInstance
	}

	// Set property ‘DataFactory’:
	if compute.DataFactory != nil {
		dataFactory_ARM, err := (*compute.DataFactory).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataFactory := *dataFactory_ARM.(*Compute_DataFactory_ARM)
		result.DataFactory = &dataFactory
	}

	// Set property ‘DataLakeAnalytics’:
	if compute.DataLakeAnalytics != nil {
		dataLakeAnalytics_ARM, err := (*compute.DataLakeAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataLakeAnalytics := *dataLakeAnalytics_ARM.(*Compute_DataLakeAnalytics_ARM)
		result.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property ‘Databricks’:
	if compute.Databricks != nil {
		databricks_ARM, err := (*compute.Databricks).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		databricks := *databricks_ARM.(*Compute_Databricks_ARM)
		result.Databricks = &databricks
	}

	// Set property ‘HDInsight’:
	if compute.HDInsight != nil {
		hdInsight_ARM, err := (*compute.HDInsight).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hdInsight := *hdInsight_ARM.(*Compute_HDInsight_ARM)
		result.HDInsight = &hdInsight
	}

	// Set property ‘SynapseSpark’:
	if compute.SynapseSpark != nil {
		synapseSpark_ARM, err := (*compute.SynapseSpark).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		synapseSpark := *synapseSpark_ARM.(*Compute_SynapseSpark_ARM)
		result.SynapseSpark = &synapseSpark
	}

	// Set property ‘VirtualMachine’:
	if compute.VirtualMachine != nil {
		virtualMachine_ARM, err := (*compute.VirtualMachine).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachine := *virtualMachine_ARM.(*Compute_VirtualMachine_ARM)
		result.VirtualMachine = &virtualMachine
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_ARM, got %T", armInput)
	}

	// Set property ‘AKS’:
	if typedInput.AKS != nil {
		var aks1 Compute_AKS
		err := aks1.PopulateFromARM(owner, *typedInput.AKS)
		if err != nil {
			return err
		}
		aks := aks1
		compute.AKS = &aks
	}

	// Set property ‘AmlCompute’:
	if typedInput.AmlCompute != nil {
		var amlCompute1 Compute_AmlCompute
		err := amlCompute1.PopulateFromARM(owner, *typedInput.AmlCompute)
		if err != nil {
			return err
		}
		amlCompute := amlCompute1
		compute.AmlCompute = &amlCompute
	}

	// Set property ‘ComputeInstance’:
	if typedInput.ComputeInstance != nil {
		var computeInstance1 Compute_ComputeInstance
		err := computeInstance1.PopulateFromARM(owner, *typedInput.ComputeInstance)
		if err != nil {
			return err
		}
		computeInstance := computeInstance1
		compute.ComputeInstance = &computeInstance
	}

	// Set property ‘DataFactory’:
	if typedInput.DataFactory != nil {
		var dataFactory1 Compute_DataFactory
		err := dataFactory1.PopulateFromARM(owner, *typedInput.DataFactory)
		if err != nil {
			return err
		}
		dataFactory := dataFactory1
		compute.DataFactory = &dataFactory
	}

	// Set property ‘DataLakeAnalytics’:
	if typedInput.DataLakeAnalytics != nil {
		var dataLakeAnalytics1 Compute_DataLakeAnalytics
		err := dataLakeAnalytics1.PopulateFromARM(owner, *typedInput.DataLakeAnalytics)
		if err != nil {
			return err
		}
		dataLakeAnalytics := dataLakeAnalytics1
		compute.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property ‘Databricks’:
	if typedInput.Databricks != nil {
		var databricks1 Compute_Databricks
		err := databricks1.PopulateFromARM(owner, *typedInput.Databricks)
		if err != nil {
			return err
		}
		databricks := databricks1
		compute.Databricks = &databricks
	}

	// Set property ‘HDInsight’:
	if typedInput.HDInsight != nil {
		var hdInsight1 Compute_HDInsight
		err := hdInsight1.PopulateFromARM(owner, *typedInput.HDInsight)
		if err != nil {
			return err
		}
		hdInsight := hdInsight1
		compute.HDInsight = &hdInsight
	}

	// Set property ‘SynapseSpark’:
	if typedInput.SynapseSpark != nil {
		var synapseSpark1 Compute_SynapseSpark
		err := synapseSpark1.PopulateFromARM(owner, *typedInput.SynapseSpark)
		if err != nil {
			return err
		}
		synapseSpark := synapseSpark1
		compute.SynapseSpark = &synapseSpark
	}

	// Set property ‘VirtualMachine’:
	if typedInput.VirtualMachine != nil {
		var virtualMachine1 Compute_VirtualMachine
		err := virtualMachine1.PopulateFromARM(owner, *typedInput.VirtualMachine)
		if err != nil {
			return err
		}
		virtualMachine := virtualMachine1
		compute.VirtualMachine = &virtualMachine
	}

	// No error
	return nil
}

// AssignProperties_From_Compute populates our Compute from the provided source Compute
func (compute *Compute) AssignProperties_From_Compute(source *v20210701s.Compute) error {

	// AKS
	if source.AKS != nil {
		var aks Compute_AKS
		err := aks.AssignProperties_From_Compute_AKS(source.AKS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_AKS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute Compute_AmlCompute
		err := amlCompute.AssignProperties_From_Compute_AmlCompute(source.AmlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_AmlCompute() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance Compute_ComputeInstance
		err := computeInstance.AssignProperties_From_Compute_ComputeInstance(source.ComputeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_ComputeInstance() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory Compute_DataFactory
		err := dataFactory.AssignProperties_From_Compute_DataFactory(source.DataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_DataFactory() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic Compute_DataLakeAnalytics
		err := dataLakeAnalytic.AssignProperties_From_Compute_DataLakeAnalytics(source.DataLakeAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Compute_Databricks
		err := databrick.AssignProperties_From_Compute_Databricks(source.Databricks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_Databricks() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight Compute_HDInsight
		err := hdInsight.AssignProperties_From_Compute_HDInsight(source.HDInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_HDInsight() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark Compute_SynapseSpark
		err := synapseSpark.AssignProperties_From_Compute_SynapseSpark(source.SynapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_SynapseSpark() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine Compute_VirtualMachine
		err := virtualMachine.AssignProperties_From_Compute_VirtualMachine(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_VirtualMachine() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute populates the provided destination Compute from our Compute
func (compute *Compute) AssignProperties_To_Compute(destination *v20210701s.Compute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AKS
	if compute.AKS != nil {
		var aks v20210701s.Compute_AKS
		err := compute.AKS.AssignProperties_To_Compute_AKS(&aks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_AKS() to populate field AKS")
		}
		destination.AKS = &aks
	} else {
		destination.AKS = nil
	}

	// AmlCompute
	if compute.AmlCompute != nil {
		var amlCompute v20210701s.Compute_AmlCompute
		err := compute.AmlCompute.AssignProperties_To_Compute_AmlCompute(&amlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_AmlCompute() to populate field AmlCompute")
		}
		destination.AmlCompute = &amlCompute
	} else {
		destination.AmlCompute = nil
	}

	// ComputeInstance
	if compute.ComputeInstance != nil {
		var computeInstance v20210701s.Compute_ComputeInstance
		err := compute.ComputeInstance.AssignProperties_To_Compute_ComputeInstance(&computeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_ComputeInstance() to populate field ComputeInstance")
		}
		destination.ComputeInstance = &computeInstance
	} else {
		destination.ComputeInstance = nil
	}

	// DataFactory
	if compute.DataFactory != nil {
		var dataFactory v20210701s.Compute_DataFactory
		err := compute.DataFactory.AssignProperties_To_Compute_DataFactory(&dataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_DataFactory() to populate field DataFactory")
		}
		destination.DataFactory = &dataFactory
	} else {
		destination.DataFactory = nil
	}

	// DataLakeAnalytics
	if compute.DataLakeAnalytics != nil {
		var dataLakeAnalytic v20210701s.Compute_DataLakeAnalytics
		err := compute.DataLakeAnalytics.AssignProperties_To_Compute_DataLakeAnalytics(&dataLakeAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		destination.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		destination.DataLakeAnalytics = nil
	}

	// Databricks
	if compute.Databricks != nil {
		var databrick v20210701s.Compute_Databricks
		err := compute.Databricks.AssignProperties_To_Compute_Databricks(&databrick)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_Databricks() to populate field Databricks")
		}
		destination.Databricks = &databrick
	} else {
		destination.Databricks = nil
	}

	// HDInsight
	if compute.HDInsight != nil {
		var hdInsight v20210701s.Compute_HDInsight
		err := compute.HDInsight.AssignProperties_To_Compute_HDInsight(&hdInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_HDInsight() to populate field HDInsight")
		}
		destination.HDInsight = &hdInsight
	} else {
		destination.HDInsight = nil
	}

	// SynapseSpark
	if compute.SynapseSpark != nil {
		var synapseSpark v20210701s.Compute_SynapseSpark
		err := compute.SynapseSpark.AssignProperties_To_Compute_SynapseSpark(&synapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_SynapseSpark() to populate field SynapseSpark")
		}
		destination.SynapseSpark = &synapseSpark
	} else {
		destination.SynapseSpark = nil
	}

	// VirtualMachine
	if compute.VirtualMachine != nil {
		var virtualMachine v20210701s.Compute_VirtualMachine
		err := compute.VirtualMachine.AssignProperties_To_Compute_VirtualMachine(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_VirtualMachine() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *Compute_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Compute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if typedInput.ComputeType != nil {
		computeType := *typedInput.ComputeType
		compute.ComputeType = &computeType
	}

	// Set property ‘CreatedOn’:
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		compute.CreatedOn = &createdOn
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘IsAttachedCompute’:
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	}

	// Set property ‘ModifiedOn’:
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		compute.ModifiedOn = &modifiedOn
	}

	// Set property ‘ProvisioningErrors’:
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		compute.ProvisioningErrors = append(compute.ProvisioningErrors, item1)
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		compute.ProvisioningState = &provisioningState
	}

	// Set property ‘ResourceId’:
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		compute.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Compute_STATUS populates our Compute_STATUS from the provided source Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_From_Compute_STATUS(source *v20210701s.Compute_STATUS) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := ComputeType_STATUS(*source.ComputeType)
		compute.ComputeType = &computeType
	} else {
		compute.ComputeType = nil
	}

	// CreatedOn
	compute.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	} else {
		compute.IsAttachedCompute = nil
	}

	// ModifiedOn
	compute.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		compute.ProvisioningErrors = provisioningErrorList
	} else {
		compute.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := Compute_ProvisioningState_STATUS(*source.ProvisioningState)
		compute.ProvisioningState = &provisioningState
	} else {
		compute.ProvisioningState = nil
	}

	// ResourceId
	compute.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_Compute_STATUS populates the provided destination Compute_STATUS from our Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_To_Compute_STATUS(destination *v20210701s.Compute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(compute.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if compute.IsAttachedCompute != nil {
		isAttachedCompute := *compute.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(compute.ModifiedOn)

	// ProvisioningErrors
	if compute.ProvisioningErrors != nil {
		provisioningErrorList := make([]v20210701s.ErrorResponse_STATUS, len(compute.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range compute.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError v20210701s.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if compute.ProvisioningState != nil {
		provisioningState := string(*compute.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(compute.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_AKS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_AKS_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: AKS properties
	Properties *AKSProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_AKS{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (computeAKS *Compute_AKS) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if computeAKS == nil {
		return nil, nil
	}
	result := &Compute_AKS_ARM{}

	// Set property ‘ComputeLocation’:
	if computeAKS.ComputeLocation != nil {
		computeLocation := *computeAKS.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if computeAKS.ComputeType != nil {
		result.ComputeType = *computeAKS.ComputeType
	}

	// Set property ‘Description’:
	if computeAKS.Description != nil {
		description := *computeAKS.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if computeAKS.DisableLocalAuth != nil {
		disableLocalAuth := *computeAKS.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if computeAKS.Properties != nil {
		properties_ARM, err := (*computeAKS.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*AKSProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if computeAKS.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*computeAKS.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (computeAKS *Compute_AKS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_AKS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (computeAKS *Compute_AKS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_AKS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_AKS_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		computeAKS.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	computeAKS.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		computeAKS.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		computeAKS.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 AKSProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		computeAKS.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_AKS populates our Compute_AKS from the provided source Compute_AKS
func (computeAKS *Compute_AKS) AssignProperties_From_Compute_AKS(source *v20210701s.Compute_AKS) error {

	// ComputeLocation
	computeAKS.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_AKS_ComputeType(*source.ComputeType)
		computeAKS.ComputeType = &computeType
	} else {
		computeAKS.ComputeType = nil
	}

	// Description
	computeAKS.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		computeAKS.DisableLocalAuth = &disableLocalAuth
	} else {
		computeAKS.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AKSProperties
		err := property.AssignProperties_From_AKSProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AKSProperties() to populate field Properties")
		}
		computeAKS.Properties = &property
	} else {
		computeAKS.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		computeAKS.ResourceReference = &resourceReference
	} else {
		computeAKS.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_AKS populates the provided destination Compute_AKS from our Compute_AKS
func (computeAKS *Compute_AKS) AssignProperties_To_Compute_AKS(destination *v20210701s.Compute_AKS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(computeAKS.ComputeLocation)

	// ComputeType
	if computeAKS.ComputeType != nil {
		computeType := string(*computeAKS.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(computeAKS.Description)

	// DisableLocalAuth
	if computeAKS.DisableLocalAuth != nil {
		disableLocalAuth := *computeAKS.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if computeAKS.Properties != nil {
		var property v20210701s.AKSProperties
		err := computeAKS.Properties.AssignProperties_To_AKSProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AKSProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if computeAKS.ResourceReference != nil {
		resourceReference := computeAKS.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_AmlCompute struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_AmlCompute_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: AML Compute properties
	Properties *AmlComputeProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_AmlCompute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *Compute_AmlCompute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &Compute_AmlCompute_ARM{}

	// Set property ‘ComputeLocation’:
	if compute.ComputeLocation != nil {
		computeLocation := *compute.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if compute.ComputeType != nil {
		result.ComputeType = *compute.ComputeType
	}

	// Set property ‘Description’:
	if compute.Description != nil {
		description := *compute.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*AmlComputeProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if compute.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*compute.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute_AmlCompute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_AmlCompute_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute_AmlCompute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_AmlCompute_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_AmlCompute_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	compute.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 AmlComputeProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_AmlCompute populates our Compute_AmlCompute from the provided source Compute_AmlCompute
func (compute *Compute_AmlCompute) AssignProperties_From_Compute_AmlCompute(source *v20210701s.Compute_AmlCompute) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_AmlCompute_ComputeType(*source.ComputeType)
		compute.ComputeType = &computeType
	} else {
		compute.ComputeType = nil
	}

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties
		err := property.AssignProperties_From_AmlComputeProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AmlComputeProperties() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		compute.ResourceReference = &resourceReference
	} else {
		compute.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_AmlCompute populates the provided destination Compute_AmlCompute from our Compute_AmlCompute
func (compute *Compute_AmlCompute) AssignProperties_To_Compute_AmlCompute(destination *v20210701s.Compute_AmlCompute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if compute.Properties != nil {
		var property v20210701s.AmlComputeProperties
		err := compute.Properties.AssignProperties_To_AmlComputeProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AmlComputeProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if compute.ResourceReference != nil {
		resourceReference := compute.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_ComputeInstance struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_ComputeInstance_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Compute Instance properties
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_ComputeInstance{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *Compute_ComputeInstance) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &Compute_ComputeInstance_ARM{}

	// Set property ‘ComputeLocation’:
	if instance.ComputeLocation != nil {
		computeLocation := *instance.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if instance.ComputeType != nil {
		result.ComputeType = *instance.ComputeType
	}

	// Set property ‘Description’:
	if instance.Description != nil {
		description := *instance.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if instance.Properties != nil {
		properties_ARM, err := (*instance.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*ComputeInstanceProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if instance.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*instance.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *Compute_ComputeInstance) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_ComputeInstance_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *Compute_ComputeInstance) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_ComputeInstance_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_ComputeInstance_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		instance.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	instance.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		instance.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 ComputeInstanceProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_ComputeInstance populates our Compute_ComputeInstance from the provided source Compute_ComputeInstance
func (instance *Compute_ComputeInstance) AssignProperties_From_Compute_ComputeInstance(source *v20210701s.Compute_ComputeInstance) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_ComputeInstance_ComputeType(*source.ComputeType)
		instance.ComputeType = &computeType
	} else {
		instance.ComputeType = nil
	}

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties
		err := property.AssignProperties_From_ComputeInstanceProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceProperties() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		instance.ResourceReference = &resourceReference
	} else {
		instance.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_ComputeInstance populates the provided destination Compute_ComputeInstance from our Compute_ComputeInstance
func (instance *Compute_ComputeInstance) AssignProperties_To_Compute_ComputeInstance(destination *v20210701s.Compute_ComputeInstance) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(instance.ComputeLocation)

	// ComputeType
	if instance.ComputeType != nil {
		computeType := string(*instance.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(instance.Description)

	// DisableLocalAuth
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if instance.Properties != nil {
		var property v20210701s.ComputeInstanceProperties
		err := instance.Properties.AssignProperties_To_ComputeInstanceProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if instance.ResourceReference != nil {
		resourceReference := instance.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_Databricks struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_Databricks_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of Databricks
	Properties *DatabricksProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_Databricks{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (databricks *Compute_Databricks) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if databricks == nil {
		return nil, nil
	}
	result := &Compute_Databricks_ARM{}

	// Set property ‘ComputeLocation’:
	if databricks.ComputeLocation != nil {
		computeLocation := *databricks.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if databricks.ComputeType != nil {
		result.ComputeType = *databricks.ComputeType
	}

	// Set property ‘Description’:
	if databricks.Description != nil {
		description := *databricks.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if databricks.Properties != nil {
		properties_ARM, err := (*databricks.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*DatabricksProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if databricks.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*databricks.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (databricks *Compute_Databricks) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_Databricks_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (databricks *Compute_Databricks) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_Databricks_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_Databricks_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		databricks.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	databricks.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		databricks.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 DatabricksProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		databricks.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_Databricks populates our Compute_Databricks from the provided source Compute_Databricks
func (databricks *Compute_Databricks) AssignProperties_From_Compute_Databricks(source *v20210701s.Compute_Databricks) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_Databricks_ComputeType(*source.ComputeType)
		databricks.ComputeType = &computeType
	} else {
		databricks.ComputeType = nil
	}

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties
		err := property.AssignProperties_From_DatabricksProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatabricksProperties() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		databricks.ResourceReference = &resourceReference
	} else {
		databricks.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_Databricks populates the provided destination Compute_Databricks from our Compute_Databricks
func (databricks *Compute_Databricks) AssignProperties_To_Compute_Databricks(destination *v20210701s.Compute_Databricks) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(databricks.ComputeLocation)

	// ComputeType
	if databricks.ComputeType != nil {
		computeType := string(*databricks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(databricks.Description)

	// DisableLocalAuth
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if databricks.Properties != nil {
		var property v20210701s.DatabricksProperties
		err := databricks.Properties.AssignProperties_To_DatabricksProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatabricksProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if databricks.ResourceReference != nil {
		resourceReference := databricks.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_DataFactory struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_DataFactory_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_DataFactory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (factory *Compute_DataFactory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if factory == nil {
		return nil, nil
	}
	result := &Compute_DataFactory_ARM{}

	// Set property ‘ComputeLocation’:
	if factory.ComputeLocation != nil {
		computeLocation := *factory.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if factory.ComputeType != nil {
		result.ComputeType = *factory.ComputeType
	}

	// Set property ‘Description’:
	if factory.Description != nil {
		description := *factory.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘ResourceId’:
	if factory.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*factory.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *Compute_DataFactory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_DataFactory_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *Compute_DataFactory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_DataFactory_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_DataFactory_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		factory.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	factory.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		factory.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_DataFactory populates our Compute_DataFactory from the provided source Compute_DataFactory
func (factory *Compute_DataFactory) AssignProperties_From_Compute_DataFactory(source *v20210701s.Compute_DataFactory) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_DataFactory_ComputeType(*source.ComputeType)
		factory.ComputeType = &computeType
	} else {
		factory.ComputeType = nil
	}

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		factory.ResourceReference = &resourceReference
	} else {
		factory.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_DataFactory populates the provided destination Compute_DataFactory from our Compute_DataFactory
func (factory *Compute_DataFactory) AssignProperties_To_Compute_DataFactory(destination *v20210701s.Compute_DataFactory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(factory.ComputeLocation)

	// ComputeType
	if factory.ComputeType != nil {
		computeType := string(*factory.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(factory.Description)

	// DisableLocalAuth
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// ResourceReference
	if factory.ResourceReference != nil {
		resourceReference := factory.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_DataLakeAnalytics struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_DataLakeAnalytics_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                        `json:"disableLocalAuth,omitempty"`
	Properties       *DataLakeAnalyticsProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_DataLakeAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *Compute_DataLakeAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &Compute_DataLakeAnalytics_ARM{}

	// Set property ‘ComputeLocation’:
	if analytics.ComputeLocation != nil {
		computeLocation := *analytics.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if analytics.ComputeType != nil {
		result.ComputeType = *analytics.ComputeType
	}

	// Set property ‘Description’:
	if analytics.Description != nil {
		description := *analytics.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if analytics.Properties != nil {
		properties_ARM, err := (*analytics.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*DataLakeAnalyticsProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if analytics.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*analytics.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *Compute_DataLakeAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_DataLakeAnalytics_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *Compute_DataLakeAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_DataLakeAnalytics_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_DataLakeAnalytics_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		analytics.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	analytics.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		analytics.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 DataLakeAnalyticsProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		analytics.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_DataLakeAnalytics populates our Compute_DataLakeAnalytics from the provided source Compute_DataLakeAnalytics
func (analytics *Compute_DataLakeAnalytics) AssignProperties_From_Compute_DataLakeAnalytics(source *v20210701s.Compute_DataLakeAnalytics) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_DataLakeAnalytics_ComputeType(*source.ComputeType)
		analytics.ComputeType = &computeType
	} else {
		analytics.ComputeType = nil
	}

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalyticsProperties
		err := property.AssignProperties_From_DataLakeAnalyticsProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataLakeAnalyticsProperties() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		analytics.ResourceReference = &resourceReference
	} else {
		analytics.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_DataLakeAnalytics populates the provided destination Compute_DataLakeAnalytics from our Compute_DataLakeAnalytics
func (analytics *Compute_DataLakeAnalytics) AssignProperties_To_Compute_DataLakeAnalytics(destination *v20210701s.Compute_DataLakeAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(analytics.ComputeLocation)

	// ComputeType
	if analytics.ComputeType != nil {
		computeType := string(*analytics.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(analytics.Description)

	// DisableLocalAuth
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if analytics.Properties != nil {
		var property v20210701s.DataLakeAnalyticsProperties
		err := analytics.Properties.AssignProperties_To_DataLakeAnalyticsProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataLakeAnalyticsProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if analytics.ResourceReference != nil {
		resourceReference := analytics.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_HDInsight struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_HDInsight_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: HDInsight compute properties
	Properties *HDInsightProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_HDInsight{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (insight *Compute_HDInsight) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if insight == nil {
		return nil, nil
	}
	result := &Compute_HDInsight_ARM{}

	// Set property ‘ComputeLocation’:
	if insight.ComputeLocation != nil {
		computeLocation := *insight.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if insight.ComputeType != nil {
		result.ComputeType = *insight.ComputeType
	}

	// Set property ‘Description’:
	if insight.Description != nil {
		description := *insight.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if insight.Properties != nil {
		properties_ARM, err := (*insight.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*HDInsightProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if insight.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*insight.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insight *Compute_HDInsight) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_HDInsight_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insight *Compute_HDInsight) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_HDInsight_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_HDInsight_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		insight.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	insight.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		insight.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 HDInsightProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		insight.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_HDInsight populates our Compute_HDInsight from the provided source Compute_HDInsight
func (insight *Compute_HDInsight) AssignProperties_From_Compute_HDInsight(source *v20210701s.Compute_HDInsight) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_HDInsight_ComputeType(*source.ComputeType)
		insight.ComputeType = &computeType
	} else {
		insight.ComputeType = nil
	}

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties
		err := property.AssignProperties_From_HDInsightProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HDInsightProperties() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		insight.ResourceReference = &resourceReference
	} else {
		insight.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_HDInsight populates the provided destination Compute_HDInsight from our Compute_HDInsight
func (insight *Compute_HDInsight) AssignProperties_To_Compute_HDInsight(destination *v20210701s.Compute_HDInsight) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(insight.ComputeLocation)

	// ComputeType
	if insight.ComputeType != nil {
		computeType := string(*insight.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(insight.Description)

	// DisableLocalAuth
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if insight.Properties != nil {
		var property v20210701s.HDInsightProperties
		err := insight.Properties.AssignProperties_To_HDInsightProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HDInsightProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if insight.ResourceReference != nil {
		resourceReference := insight.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_SynapseSpark struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_SynapseSpark_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                   `json:"disableLocalAuth,omitempty"`
	Properties       *SynapseSparkProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_SynapseSpark{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spark *Compute_SynapseSpark) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spark == nil {
		return nil, nil
	}
	result := &Compute_SynapseSpark_ARM{}

	// Set property ‘ComputeLocation’:
	if spark.ComputeLocation != nil {
		computeLocation := *spark.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if spark.ComputeType != nil {
		result.ComputeType = *spark.ComputeType
	}

	// Set property ‘Description’:
	if spark.Description != nil {
		description := *spark.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if spark.Properties != nil {
		properties_ARM, err := (*spark.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*SynapseSparkProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if spark.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*spark.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spark *Compute_SynapseSpark) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_SynapseSpark_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spark *Compute_SynapseSpark) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_SynapseSpark_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_SynapseSpark_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		spark.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	spark.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		spark.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 SynapseSparkProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		spark.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_SynapseSpark populates our Compute_SynapseSpark from the provided source Compute_SynapseSpark
func (spark *Compute_SynapseSpark) AssignProperties_From_Compute_SynapseSpark(source *v20210701s.Compute_SynapseSpark) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_SynapseSpark_ComputeType(*source.ComputeType)
		spark.ComputeType = &computeType
	} else {
		spark.ComputeType = nil
	}

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property SynapseSparkProperties
		err := property.AssignProperties_From_SynapseSparkProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SynapseSparkProperties() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		spark.ResourceReference = &resourceReference
	} else {
		spark.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_SynapseSpark populates the provided destination Compute_SynapseSpark from our Compute_SynapseSpark
func (spark *Compute_SynapseSpark) AssignProperties_To_Compute_SynapseSpark(destination *v20210701s.Compute_SynapseSpark) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(spark.ComputeLocation)

	// ComputeType
	if spark.ComputeType != nil {
		computeType := string(*spark.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(spark.Description)

	// DisableLocalAuth
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if spark.Properties != nil {
		var property v20210701s.SynapseSparkProperties
		err := spark.Properties.AssignProperties_To_SynapseSparkProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SynapseSparkProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if spark.ResourceReference != nil {
		resourceReference := spark.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_VirtualMachine struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	ComputeType *Compute_VirtualMachine_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                     `json:"disableLocalAuth,omitempty"`
	Properties       *VirtualMachineProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute_VirtualMachine{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (machine *Compute_VirtualMachine) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if machine == nil {
		return nil, nil
	}
	result := &Compute_VirtualMachine_ARM{}

	// Set property ‘ComputeLocation’:
	if machine.ComputeLocation != nil {
		computeLocation := *machine.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	if machine.ComputeType != nil {
		result.ComputeType = *machine.ComputeType
	}

	// Set property ‘Description’:
	if machine.Description != nil {
		description := *machine.Description
		result.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if machine.Properties != nil {
		properties_ARM, err := (*machine.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*VirtualMachineProperties_ARM)
		result.Properties = &properties
	}

	// Set property ‘ResourceId’:
	if machine.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*machine.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *Compute_VirtualMachine) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Compute_VirtualMachine_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *Compute_VirtualMachine) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Compute_VirtualMachine_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Compute_VirtualMachine_ARM, got %T", armInput)
	}

	// Set property ‘ComputeLocation’:
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		machine.ComputeLocation = &computeLocation
	}

	// Set property ‘ComputeType’:
	machine.ComputeType = &typedInput.ComputeType

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		machine.Description = &description
	}

	// Set property ‘DisableLocalAuth’:
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 VirtualMachineProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		machine.Properties = &properties
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignProperties_From_Compute_VirtualMachine populates our Compute_VirtualMachine from the provided source Compute_VirtualMachine
func (machine *Compute_VirtualMachine) AssignProperties_From_Compute_VirtualMachine(source *v20210701s.Compute_VirtualMachine) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := Compute_VirtualMachine_ComputeType(*source.ComputeType)
		machine.ComputeType = &computeType
	} else {
		machine.ComputeType = nil
	}

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property VirtualMachineProperties
		err := property.AssignProperties_From_VirtualMachineProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineProperties() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		machine.ResourceReference = &resourceReference
	} else {
		machine.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_VirtualMachine populates the provided destination Compute_VirtualMachine from our Compute_VirtualMachine
func (machine *Compute_VirtualMachine) AssignProperties_To_Compute_VirtualMachine(destination *v20210701s.Compute_VirtualMachine) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(machine.ComputeLocation)

	// ComputeType
	if machine.ComputeType != nil {
		computeType := string(*machine.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(machine.Description)

	// DisableLocalAuth
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if machine.Properties != nil {
		var property v20210701s.VirtualMachineProperties
		err := machine.Properties.AssignProperties_To_VirtualMachineProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if machine.ResourceReference != nil {
		resourceReference := machine.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorResponse_STATUS struct {
	// Error: The error object.
	Error *ErrorDetail_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorResponse_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (response *ErrorResponse_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorResponse_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (response *ErrorResponse_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorResponse_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorResponse_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ErrorDetail_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		response.Error = &error
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorResponse_STATUS populates our ErrorResponse_STATUS from the provided source ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_From_ErrorResponse_STATUS(source *v20210701s.ErrorResponse_STATUS) error {

	// Error
	if source.Error != nil {
		var error ErrorDetail_STATUS
		err := error.AssignProperties_From_ErrorDetail_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS() to populate field Error")
		}
		response.Error = &error
	} else {
		response.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorResponse_STATUS populates the provided destination ErrorResponse_STATUS from our ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_To_ErrorResponse_STATUS(destination *v20210701s.ErrorResponse_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if response.Error != nil {
		var error v20210701s.ErrorDetail_STATUS
		err := response.Error.AssignProperties_To_ErrorDetail_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AKSProperties
type AKSProperties struct {
	// +kubebuilder:validation:Minimum=0
	// AgentCount: Number of agents
	AgentCount *int `json:"agentCount,omitempty"`

	// AgentVmSize: Agent virtual machine size
	AgentVmSize *string `json:"agentVmSize,omitempty"`

	// AksNetworkingConfiguration: Advance configuration for AKS networking
	AksNetworkingConfiguration *AksNetworkingConfiguration `json:"aksNetworkingConfiguration,omitempty"`

	// ClusterFqdn: Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterPurpose: Intended usage of the cluster.
	ClusterPurpose *AKSProperties_ClusterPurpose `json:"clusterPurpose,omitempty"`

	// LoadBalancerSubnet: Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`

	// LoadBalancerType: Load Balancer Type.
	LoadBalancerType *AKSProperties_LoadBalancerType `json:"loadBalancerType,omitempty"`

	// SslConfiguration: The ssl configuration for scoring
	SslConfiguration *SslConfiguration `json:"sslConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &AKSProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AKSProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &AKSProperties_ARM{}

	// Set property ‘AgentCount’:
	if properties.AgentCount != nil {
		agentCount := *properties.AgentCount
		result.AgentCount = &agentCount
	}

	// Set property ‘AgentVmSize’:
	if properties.AgentVmSize != nil {
		agentVmSize := *properties.AgentVmSize
		result.AgentVmSize = &agentVmSize
	}

	// Set property ‘AksNetworkingConfiguration’:
	if properties.AksNetworkingConfiguration != nil {
		aksNetworkingConfiguration_ARM, err := (*properties.AksNetworkingConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aksNetworkingConfiguration := *aksNetworkingConfiguration_ARM.(*AksNetworkingConfiguration_ARM)
		result.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property ‘ClusterFqdn’:
	if properties.ClusterFqdn != nil {
		clusterFqdn := *properties.ClusterFqdn
		result.ClusterFqdn = &clusterFqdn
	}

	// Set property ‘ClusterPurpose’:
	if properties.ClusterPurpose != nil {
		clusterPurpose := *properties.ClusterPurpose
		result.ClusterPurpose = &clusterPurpose
	}

	// Set property ‘LoadBalancerSubnet’:
	if properties.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *properties.LoadBalancerSubnet
		result.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property ‘LoadBalancerType’:
	if properties.LoadBalancerType != nil {
		loadBalancerType := *properties.LoadBalancerType
		result.LoadBalancerType = &loadBalancerType
	}

	// Set property ‘SslConfiguration’:
	if properties.SslConfiguration != nil {
		sslConfiguration_ARM, err := (*properties.SslConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslConfiguration := *sslConfiguration_ARM.(*SslConfiguration_ARM)
		result.SslConfiguration = &sslConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AKSProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AKSProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AKSProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AKSProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AKSProperties_ARM, got %T", armInput)
	}

	// Set property ‘AgentCount’:
	if typedInput.AgentCount != nil {
		agentCount := *typedInput.AgentCount
		properties.AgentCount = &agentCount
	}

	// Set property ‘AgentVmSize’:
	if typedInput.AgentVmSize != nil {
		agentVmSize := *typedInput.AgentVmSize
		properties.AgentVmSize = &agentVmSize
	}

	// Set property ‘AksNetworkingConfiguration’:
	if typedInput.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration1 AksNetworkingConfiguration
		err := aksNetworkingConfiguration1.PopulateFromARM(owner, *typedInput.AksNetworkingConfiguration)
		if err != nil {
			return err
		}
		aksNetworkingConfiguration := aksNetworkingConfiguration1
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property ‘ClusterFqdn’:
	if typedInput.ClusterFqdn != nil {
		clusterFqdn := *typedInput.ClusterFqdn
		properties.ClusterFqdn = &clusterFqdn
	}

	// Set property ‘ClusterPurpose’:
	if typedInput.ClusterPurpose != nil {
		clusterPurpose := *typedInput.ClusterPurpose
		properties.ClusterPurpose = &clusterPurpose
	}

	// Set property ‘LoadBalancerSubnet’:
	if typedInput.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *typedInput.LoadBalancerSubnet
		properties.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property ‘LoadBalancerType’:
	if typedInput.LoadBalancerType != nil {
		loadBalancerType := *typedInput.LoadBalancerType
		properties.LoadBalancerType = &loadBalancerType
	}

	// Set property ‘SslConfiguration’:
	if typedInput.SslConfiguration != nil {
		var sslConfiguration1 SslConfiguration
		err := sslConfiguration1.PopulateFromARM(owner, *typedInput.SslConfiguration)
		if err != nil {
			return err
		}
		sslConfiguration := sslConfiguration1
		properties.SslConfiguration = &sslConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_AKSProperties populates our AKSProperties from the provided source AKSProperties
func (properties *AKSProperties) AssignProperties_From_AKSProperties(source *v20210701s.AKSProperties) error {

	// AgentCount
	if source.AgentCount != nil {
		agentCount := *source.AgentCount
		properties.AgentCount = &agentCount
	} else {
		properties.AgentCount = nil
	}

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration
		err := aksNetworkingConfiguration.AssignProperties_From_AksNetworkingConfiguration(source.AksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := AKSProperties_ClusterPurpose(*source.ClusterPurpose)
		properties.ClusterPurpose = &clusterPurpose
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	properties.LoadBalancerSubnet = genruntime.ClonePointerToString(source.LoadBalancerSubnet)

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := AKSProperties_LoadBalancerType(*source.LoadBalancerType)
		properties.LoadBalancerType = &loadBalancerType
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration
		err := sslConfiguration.AssignProperties_From_SslConfiguration(source.SslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslConfiguration() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKSProperties populates the provided destination AKSProperties from our AKSProperties
func (properties *AKSProperties) AssignProperties_To_AKSProperties(destination *v20210701s.AKSProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentCount
	if properties.AgentCount != nil {
		agentCount := *properties.AgentCount
		destination.AgentCount = &agentCount
	} else {
		destination.AgentCount = nil
	}

	// AgentVmSize
	destination.AgentVmSize = genruntime.ClonePointerToString(properties.AgentVmSize)

	// AksNetworkingConfiguration
	if properties.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration v20210701s.AksNetworkingConfiguration
		err := properties.AksNetworkingConfiguration.AssignProperties_To_AksNetworkingConfiguration(&aksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		destination.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		destination.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	destination.ClusterFqdn = genruntime.ClonePointerToString(properties.ClusterFqdn)

	// ClusterPurpose
	if properties.ClusterPurpose != nil {
		clusterPurpose := string(*properties.ClusterPurpose)
		destination.ClusterPurpose = &clusterPurpose
	} else {
		destination.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	destination.LoadBalancerSubnet = genruntime.ClonePointerToString(properties.LoadBalancerSubnet)

	// LoadBalancerType
	if properties.LoadBalancerType != nil {
		loadBalancerType := string(*properties.LoadBalancerType)
		destination.LoadBalancerType = &loadBalancerType
	} else {
		destination.LoadBalancerType = nil
	}

	// SslConfiguration
	if properties.SslConfiguration != nil {
		var sslConfiguration v20210701s.SslConfiguration
		err := properties.SslConfiguration.AssignProperties_To_SslConfiguration(&sslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslConfiguration() to populate field SslConfiguration")
		}
		destination.SslConfiguration = &sslConfiguration
	} else {
		destination.SslConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AmlComputeProperties
type AmlComputeProperties struct {
	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// IsolatedNetwork: Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// OsType: Compute OS Type.
	OsType *AmlComputeProperties_OsType `json:"osType,omitempty"`

	// RemoteLoginPortPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh
	// port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the
	// cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
	// else is open all public nodes. It can be default only during cluster creation time, after creation it will be either
	// enabled or disabled.
	RemoteLoginPortPublicAccess *AmlComputeProperties_RemoteLoginPortPublicAccess `json:"remoteLoginPortPublicAccess,omitempty"`

	// ScaleSettings: scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`

	// Subnet: Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// UserAccountCredentials: Settings for user account that gets created on each on the nodes of a compute.
	UserAccountCredentials *UserAccountCredentials `json:"userAccountCredentials,omitempty"`

	// VirtualMachineImage: Virtual Machine image for Windows AML Compute
	VirtualMachineImage *VirtualMachineImage `json:"virtualMachineImage,omitempty"`

	// VmPriority: Virtual Machine priority.
	VmPriority *AmlComputeProperties_VmPriority `json:"vmPriority,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &AmlComputeProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AmlComputeProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &AmlComputeProperties_ARM{}

	// Set property ‘EnableNodePublicIp’:
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		result.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property ‘IsolatedNetwork’:
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		result.IsolatedNetwork = &isolatedNetwork
	}

	// Set property ‘OsType’:
	if properties.OsType != nil {
		osType := *properties.OsType
		result.OsType = &osType
	}

	// Set property ‘RemoteLoginPortPublicAccess’:
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *properties.RemoteLoginPortPublicAccess
		result.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property ‘ScaleSettings’:
	if properties.ScaleSettings != nil {
		scaleSettings_ARM, err := (*properties.ScaleSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleSettings := *scaleSettings_ARM.(*ScaleSettings_ARM)
		result.ScaleSettings = &scaleSettings
	}

	// Set property ‘Subnet’:
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*ResourceId_ARM)
		result.Subnet = &subnet
	}

	// Set property ‘UserAccountCredentials’:
	if properties.UserAccountCredentials != nil {
		userAccountCredentials_ARM, err := (*properties.UserAccountCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userAccountCredentials := *userAccountCredentials_ARM.(*UserAccountCredentials_ARM)
		result.UserAccountCredentials = &userAccountCredentials
	}

	// Set property ‘VirtualMachineImage’:
	if properties.VirtualMachineImage != nil {
		virtualMachineImage_ARM, err := (*properties.VirtualMachineImage).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineImage := *virtualMachineImage_ARM.(*VirtualMachineImage_ARM)
		result.VirtualMachineImage = &virtualMachineImage
	}

	// Set property ‘VmPriority’:
	if properties.VmPriority != nil {
		vmPriority := *properties.VmPriority
		result.VmPriority = &vmPriority
	}

	// Set property ‘VmSize’:
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AmlComputeProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AmlComputeProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AmlComputeProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AmlComputeProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AmlComputeProperties_ARM, got %T", armInput)
	}

	// Set property ‘EnableNodePublicIp’:
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property ‘IsolatedNetwork’:
	if typedInput.IsolatedNetwork != nil {
		isolatedNetwork := *typedInput.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		properties.OsType = &osType
	}

	// Set property ‘RemoteLoginPortPublicAccess’:
	if typedInput.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *typedInput.RemoteLoginPortPublicAccess
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property ‘ScaleSettings’:
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 ScaleSettings
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property ‘Subnet’:
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property ‘UserAccountCredentials’:
	if typedInput.UserAccountCredentials != nil {
		var userAccountCredentials1 UserAccountCredentials
		err := userAccountCredentials1.PopulateFromARM(owner, *typedInput.UserAccountCredentials)
		if err != nil {
			return err
		}
		userAccountCredentials := userAccountCredentials1
		properties.UserAccountCredentials = &userAccountCredentials
	}

	// Set property ‘VirtualMachineImage’:
	if typedInput.VirtualMachineImage != nil {
		var virtualMachineImage1 VirtualMachineImage
		err := virtualMachineImage1.PopulateFromARM(owner, *typedInput.VirtualMachineImage)
		if err != nil {
			return err
		}
		virtualMachineImage := virtualMachineImage1
		properties.VirtualMachineImage = &virtualMachineImage
	}

	// Set property ‘VmPriority’:
	if typedInput.VmPriority != nil {
		vmPriority := *typedInput.VmPriority
		properties.VmPriority = &vmPriority
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_AmlComputeProperties populates our AmlComputeProperties from the provided source AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_From_AmlComputeProperties(source *v20210701s.AmlComputeProperties) error {

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// OsType
	if source.OsType != nil {
		osType := AmlComputeProperties_OsType(*source.OsType)
		properties.OsType = &osType
	} else {
		properties.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := AmlComputeProperties_RemoteLoginPortPublicAccess(*source.RemoteLoginPortPublicAccess)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings
		err := scaleSetting.AssignProperties_From_ScaleSettings(source.ScaleSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleSettings() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials
		err := userAccountCredential.AssignProperties_From_UserAccountCredentials(source.UserAccountCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage
		err := virtualMachineImage.AssignProperties_From_VirtualMachineImage(source.VirtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := AmlComputeProperties_VmPriority(*source.VmPriority)
		properties.VmPriority = &vmPriority
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_AmlComputeProperties populates the provided destination AmlComputeProperties from our AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_To_AmlComputeProperties(destination *v20210701s.AmlComputeProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		destination.IsolatedNetwork = &isolatedNetwork
	} else {
		destination.IsolatedNetwork = nil
	}

	// OsType
	if properties.OsType != nil {
		osType := string(*properties.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := string(*properties.RemoteLoginPortPublicAccess)
		destination.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		destination.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting v20210701s.ScaleSettings
		err := properties.ScaleSettings.AssignProperties_To_ScaleSettings(&scaleSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleSettings() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet v20210701s.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// UserAccountCredentials
	if properties.UserAccountCredentials != nil {
		var userAccountCredential v20210701s.UserAccountCredentials
		err := properties.UserAccountCredentials.AssignProperties_To_UserAccountCredentials(&userAccountCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		destination.UserAccountCredentials = &userAccountCredential
	} else {
		destination.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if properties.VirtualMachineImage != nil {
		var virtualMachineImage v20210701s.VirtualMachineImage
		err := properties.VirtualMachineImage.AssignProperties_To_VirtualMachineImage(&virtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		destination.VirtualMachineImage = &virtualMachineImage
	} else {
		destination.VirtualMachineImage = nil
	}

	// VmPriority
	if properties.VmPriority != nil {
		vmPriority := string(*properties.VmPriority)
		destination.VmPriority = &vmPriority
	} else {
		destination.VmPriority = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ComputeInstanceProperties
type ComputeInstanceProperties struct {
	// ApplicationSharingPolicy: Policy for sharing applications on this compute instance among users of parent workspace. If
	// Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access
	// applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ComputeInstanceProperties_ApplicationSharingPolicy `json:"applicationSharingPolicy,omitempty"`

	// ComputeInstanceAuthorizationType: The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceProperties_ComputeInstanceAuthorizationType `json:"computeInstanceAuthorizationType,omitempty"`

	// PersonalComputeInstanceSettings: Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `json:"personalComputeInstanceSettings,omitempty"`

	// SetupScripts: Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `json:"setupScripts,omitempty"`

	// SshSettings: Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings `json:"sshSettings,omitempty"`

	// Subnet: Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ComputeInstanceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &ComputeInstanceProperties_ARM{}

	// Set property ‘ApplicationSharingPolicy’:
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *properties.ApplicationSharingPolicy
		result.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property ‘ComputeInstanceAuthorizationType’:
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *properties.ComputeInstanceAuthorizationType
		result.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property ‘PersonalComputeInstanceSettings’:
	if properties.PersonalComputeInstanceSettings != nil {
		personalComputeInstanceSettings_ARM, err := (*properties.PersonalComputeInstanceSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		personalComputeInstanceSettings := *personalComputeInstanceSettings_ARM.(*PersonalComputeInstanceSettings_ARM)
		result.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property ‘SetupScripts’:
	if properties.SetupScripts != nil {
		setupScripts_ARM, err := (*properties.SetupScripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		setupScripts := *setupScripts_ARM.(*SetupScripts_ARM)
		result.SetupScripts = &setupScripts
	}

	// Set property ‘SshSettings’:
	if properties.SshSettings != nil {
		sshSettings_ARM, err := (*properties.SshSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sshSettings := *sshSettings_ARM.(*ComputeInstanceSshSettings_ARM)
		result.SshSettings = &sshSettings
	}

	// Set property ‘Subnet’:
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*ResourceId_ARM)
		result.Subnet = &subnet
	}

	// Set property ‘VmSize’:
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ComputeInstanceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ComputeInstanceProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ComputeInstanceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ComputeInstanceProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ComputeInstanceProperties_ARM, got %T", armInput)
	}

	// Set property ‘ApplicationSharingPolicy’:
	if typedInput.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *typedInput.ApplicationSharingPolicy
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property ‘ComputeInstanceAuthorizationType’:
	if typedInput.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *typedInput.ComputeInstanceAuthorizationType
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property ‘PersonalComputeInstanceSettings’:
	if typedInput.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSettings1 PersonalComputeInstanceSettings
		err := personalComputeInstanceSettings1.PopulateFromARM(owner, *typedInput.PersonalComputeInstanceSettings)
		if err != nil {
			return err
		}
		personalComputeInstanceSettings := personalComputeInstanceSettings1
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property ‘SetupScripts’:
	if typedInput.SetupScripts != nil {
		var setupScripts1 SetupScripts
		err := setupScripts1.PopulateFromARM(owner, *typedInput.SetupScripts)
		if err != nil {
			return err
		}
		setupScripts := setupScripts1
		properties.SetupScripts = &setupScripts
	}

	// Set property ‘SshSettings’:
	if typedInput.SshSettings != nil {
		var sshSettings1 ComputeInstanceSshSettings
		err := sshSettings1.PopulateFromARM(owner, *typedInput.SshSettings)
		if err != nil {
			return err
		}
		sshSettings := sshSettings1
		properties.SshSettings = &sshSettings
	}

	// Set property ‘Subnet’:
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceProperties populates our ComputeInstanceProperties from the provided source ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_From_ComputeInstanceProperties(source *v20210701s.ComputeInstanceProperties) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := ComputeInstanceProperties_ApplicationSharingPolicy(*source.ApplicationSharingPolicy)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := ComputeInstanceProperties_ComputeInstanceAuthorizationType(*source.ComputeInstanceAuthorizationType)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings
		err := personalComputeInstanceSetting.AssignProperties_From_PersonalComputeInstanceSettings(source.PersonalComputeInstanceSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts
		err := setupScript.AssignProperties_From_SetupScripts(source.SetupScripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SetupScripts() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings
		err := sshSetting.AssignProperties_From_ComputeInstanceSshSettings(source.SshSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceProperties populates the provided destination ComputeInstanceProperties from our ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_To_ComputeInstanceProperties(destination *v20210701s.ComputeInstanceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationSharingPolicy
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := string(*properties.ApplicationSharingPolicy)
		destination.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		destination.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := string(*properties.ComputeInstanceAuthorizationType)
		destination.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		destination.ComputeInstanceAuthorizationType = nil
	}

	// PersonalComputeInstanceSettings
	if properties.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting v20210701s.PersonalComputeInstanceSettings
		err := properties.PersonalComputeInstanceSettings.AssignProperties_To_PersonalComputeInstanceSettings(&personalComputeInstanceSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		destination.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		destination.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if properties.SetupScripts != nil {
		var setupScript v20210701s.SetupScripts
		err := properties.SetupScripts.AssignProperties_To_SetupScripts(&setupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SetupScripts() to populate field SetupScripts")
		}
		destination.SetupScripts = &setupScript
	} else {
		destination.SetupScripts = nil
	}

	// SshSettings
	if properties.SshSettings != nil {
		var sshSetting v20210701s.ComputeInstanceSshSettings
		err := properties.SshSettings.AssignProperties_To_ComputeInstanceSshSettings(&sshSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		destination.SshSettings = &sshSetting
	} else {
		destination.SshSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet v20210701s.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/DatabricksProperties
type DatabricksProperties struct {
	// DatabricksAccessToken: Databricks access token
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`

	// WorkspaceUrl: Workspace Url
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &DatabricksProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DatabricksProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &DatabricksProperties_ARM{}

	// Set property ‘DatabricksAccessToken’:
	if properties.DatabricksAccessToken != nil {
		databricksAccessToken := *properties.DatabricksAccessToken
		result.DatabricksAccessToken = &databricksAccessToken
	}

	// Set property ‘WorkspaceUrl’:
	if properties.WorkspaceUrl != nil {
		workspaceUrl := *properties.WorkspaceUrl
		result.WorkspaceUrl = &workspaceUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DatabricksProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DatabricksProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DatabricksProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DatabricksProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DatabricksProperties_ARM, got %T", armInput)
	}

	// Set property ‘DatabricksAccessToken’:
	if typedInput.DatabricksAccessToken != nil {
		databricksAccessToken := *typedInput.DatabricksAccessToken
		properties.DatabricksAccessToken = &databricksAccessToken
	}

	// Set property ‘WorkspaceUrl’:
	if typedInput.WorkspaceUrl != nil {
		workspaceUrl := *typedInput.WorkspaceUrl
		properties.WorkspaceUrl = &workspaceUrl
	}

	// No error
	return nil
}

// AssignProperties_From_DatabricksProperties populates our DatabricksProperties from the provided source DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_From_DatabricksProperties(source *v20210701s.DatabricksProperties) error {

	// DatabricksAccessToken
	properties.DatabricksAccessToken = genruntime.ClonePointerToString(source.DatabricksAccessToken)

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_DatabricksProperties populates the provided destination DatabricksProperties from our DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_To_DatabricksProperties(destination *v20210701s.DatabricksProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatabricksAccessToken
	destination.DatabricksAccessToken = genruntime.ClonePointerToString(properties.DatabricksAccessToken)

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(properties.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/DataLakeAnalyticsProperties
type DataLakeAnalyticsProperties struct {
	// DataLakeStoreAccountName: DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &DataLakeAnalyticsProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DataLakeAnalyticsProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &DataLakeAnalyticsProperties_ARM{}

	// Set property ‘DataLakeStoreAccountName’:
	if properties.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *properties.DataLakeStoreAccountName
		result.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DataLakeAnalyticsProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataLakeAnalyticsProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DataLakeAnalyticsProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataLakeAnalyticsProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataLakeAnalyticsProperties_ARM, got %T", armInput)
	}

	// Set property ‘DataLakeStoreAccountName’:
	if typedInput.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *typedInput.DataLakeStoreAccountName
		properties.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalyticsProperties populates our DataLakeAnalyticsProperties from the provided source DataLakeAnalyticsProperties
func (properties *DataLakeAnalyticsProperties) AssignProperties_From_DataLakeAnalyticsProperties(source *v20210701s.DataLakeAnalyticsProperties) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalyticsProperties populates the provided destination DataLakeAnalyticsProperties from our DataLakeAnalyticsProperties
func (properties *DataLakeAnalyticsProperties) AssignProperties_To_DataLakeAnalyticsProperties(destination *v20210701s.DataLakeAnalyticsProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataLakeStoreAccountName
	destination.DataLakeStoreAccountName = genruntime.ClonePointerToString(properties.DataLakeStoreAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detail *ErrorDetail_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorDetail_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detail *ErrorDetail_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorDetail_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorDetail_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AdditionalInfo’:
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.AdditionalInfo = append(detail.AdditionalInfo, item1)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		detail.Code = &code
	}

	// Set property ‘Details’:
	for _, item := range typedInput.Details {
		var item1 ErrorDetail_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.Details = append(detail.Details, item1)
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		detail.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		detail.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *v20210701s.ErrorDetail_STATUS) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *v20210701s.ErrorDetail_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]v20210701s.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo v20210701s.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]v20210701s.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal v20210701s.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/HDInsightProperties
type HDInsightProperties struct {
	// Address: Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// SshPort: Port open for ssh connections on the master node of the cluster.
	SshPort *int `json:"sshPort,omitempty"`
}

var _ genruntime.ARMTransformer = &HDInsightProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *HDInsightProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &HDInsightProperties_ARM{}

	// Set property ‘Address’:
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property ‘AdministratorAccount’:
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*VirtualMachineSshCredentials_ARM)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property ‘SshPort’:
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HDInsightProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HDInsightProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HDInsightProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HDInsightProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HDInsightProperties_ARM, got %T", armInput)
	}

	// Set property ‘Address’:
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property ‘AdministratorAccount’:
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property ‘SshPort’:
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsightProperties populates our HDInsightProperties from the provided source HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_From_HDInsightProperties(source *v20210701s.HDInsightProperties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// AssignProperties_To_HDInsightProperties populates the provided destination HDInsightProperties from our HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_To_HDInsightProperties(destination *v20210701s.HDInsightProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount v20210701s.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/SynapseSparkProperties
type SynapseSparkProperties struct {
	// AutoPauseProperties: Auto pause properties
	AutoPauseProperties *AutoPauseProperties `json:"autoPauseProperties,omitempty"`

	// AutoScaleProperties: Auto scale properties
	AutoScaleProperties *AutoScaleProperties `json:"autoScaleProperties,omitempty"`

	// NodeCount: The number of compute nodes currently assigned to the compute.
	NodeCount *int `json:"nodeCount,omitempty"`

	// NodeSize: Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// NodeSizeFamily: Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// PoolName: Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// ResourceGroup: Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SparkVersion: Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// SubscriptionId: Azure subscription identifier.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// WorkspaceName: Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

var _ genruntime.ARMTransformer = &SynapseSparkProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *SynapseSparkProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &SynapseSparkProperties_ARM{}

	// Set property ‘AutoPauseProperties’:
	if properties.AutoPauseProperties != nil {
		autoPauseProperties_ARM, err := (*properties.AutoPauseProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoPauseProperties := *autoPauseProperties_ARM.(*AutoPauseProperties_ARM)
		result.AutoPauseProperties = &autoPauseProperties
	}

	// Set property ‘AutoScaleProperties’:
	if properties.AutoScaleProperties != nil {
		autoScaleProperties_ARM, err := (*properties.AutoScaleProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScaleProperties := *autoScaleProperties_ARM.(*AutoScaleProperties_ARM)
		result.AutoScaleProperties = &autoScaleProperties
	}

	// Set property ‘NodeCount’:
	if properties.NodeCount != nil {
		nodeCount := *properties.NodeCount
		result.NodeCount = &nodeCount
	}

	// Set property ‘NodeSize’:
	if properties.NodeSize != nil {
		nodeSize := *properties.NodeSize
		result.NodeSize = &nodeSize
	}

	// Set property ‘NodeSizeFamily’:
	if properties.NodeSizeFamily != nil {
		nodeSizeFamily := *properties.NodeSizeFamily
		result.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property ‘PoolName’:
	if properties.PoolName != nil {
		poolName := *properties.PoolName
		result.PoolName = &poolName
	}

	// Set property ‘ResourceGroup’:
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property ‘SparkVersion’:
	if properties.SparkVersion != nil {
		sparkVersion := *properties.SparkVersion
		result.SparkVersion = &sparkVersion
	}

	// Set property ‘SubscriptionId’:
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}

	// Set property ‘WorkspaceName’:
	if properties.WorkspaceName != nil {
		workspaceName := *properties.WorkspaceName
		result.WorkspaceName = &workspaceName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SynapseSparkProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SynapseSparkProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SynapseSparkProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SynapseSparkProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SynapseSparkProperties_ARM, got %T", armInput)
	}

	// Set property ‘AutoPauseProperties’:
	if typedInput.AutoPauseProperties != nil {
		var autoPauseProperties1 AutoPauseProperties
		err := autoPauseProperties1.PopulateFromARM(owner, *typedInput.AutoPauseProperties)
		if err != nil {
			return err
		}
		autoPauseProperties := autoPauseProperties1
		properties.AutoPauseProperties = &autoPauseProperties
	}

	// Set property ‘AutoScaleProperties’:
	if typedInput.AutoScaleProperties != nil {
		var autoScaleProperties1 AutoScaleProperties
		err := autoScaleProperties1.PopulateFromARM(owner, *typedInput.AutoScaleProperties)
		if err != nil {
			return err
		}
		autoScaleProperties := autoScaleProperties1
		properties.AutoScaleProperties = &autoScaleProperties
	}

	// Set property ‘NodeCount’:
	if typedInput.NodeCount != nil {
		nodeCount := *typedInput.NodeCount
		properties.NodeCount = &nodeCount
	}

	// Set property ‘NodeSize’:
	if typedInput.NodeSize != nil {
		nodeSize := *typedInput.NodeSize
		properties.NodeSize = &nodeSize
	}

	// Set property ‘NodeSizeFamily’:
	if typedInput.NodeSizeFamily != nil {
		nodeSizeFamily := *typedInput.NodeSizeFamily
		properties.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property ‘PoolName’:
	if typedInput.PoolName != nil {
		poolName := *typedInput.PoolName
		properties.PoolName = &poolName
	}

	// Set property ‘ResourceGroup’:
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property ‘SparkVersion’:
	if typedInput.SparkVersion != nil {
		sparkVersion := *typedInput.SparkVersion
		properties.SparkVersion = &sparkVersion
	}

	// Set property ‘SubscriptionId’:
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property ‘WorkspaceName’:
	if typedInput.WorkspaceName != nil {
		workspaceName := *typedInput.WorkspaceName
		properties.WorkspaceName = &workspaceName
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSparkProperties populates our SynapseSparkProperties from the provided source SynapseSparkProperties
func (properties *SynapseSparkProperties) AssignProperties_From_SynapseSparkProperties(source *v20210701s.SynapseSparkProperties) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties
		err := autoPauseProperty.AssignProperties_From_AutoPauseProperties(source.AutoPauseProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties
		err := autoScaleProperty.AssignProperties_From_AutoScaleProperties(source.AutoScaleProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

// AssignProperties_To_SynapseSparkProperties populates the provided destination SynapseSparkProperties from our SynapseSparkProperties
func (properties *SynapseSparkProperties) AssignProperties_To_SynapseSparkProperties(destination *v20210701s.SynapseSparkProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseProperties
	if properties.AutoPauseProperties != nil {
		var autoPauseProperty v20210701s.AutoPauseProperties
		err := properties.AutoPauseProperties.AssignProperties_To_AutoPauseProperties(&autoPauseProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		destination.AutoPauseProperties = &autoPauseProperty
	} else {
		destination.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if properties.AutoScaleProperties != nil {
		var autoScaleProperty v20210701s.AutoScaleProperties
		err := properties.AutoScaleProperties.AssignProperties_To_AutoScaleProperties(&autoScaleProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		destination.AutoScaleProperties = &autoScaleProperty
	} else {
		destination.AutoScaleProperties = nil
	}

	// NodeCount
	destination.NodeCount = genruntime.ClonePointerToInt(properties.NodeCount)

	// NodeSize
	destination.NodeSize = genruntime.ClonePointerToString(properties.NodeSize)

	// NodeSizeFamily
	destination.NodeSizeFamily = genruntime.ClonePointerToString(properties.NodeSizeFamily)

	// PoolName
	destination.PoolName = genruntime.ClonePointerToString(properties.PoolName)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SparkVersion
	destination.SparkVersion = genruntime.ClonePointerToString(properties.SparkVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// WorkspaceName
	destination.WorkspaceName = genruntime.ClonePointerToString(properties.WorkspaceName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/VirtualMachineProperties
type VirtualMachineProperties struct {
	// Address: Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// IsNotebookInstanceCompute: Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// SshPort: Port open for ssh connections.
	SshPort *int `json:"sshPort,omitempty"`

	// VirtualMachineSize: Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *VirtualMachineProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &VirtualMachineProperties_ARM{}

	// Set property ‘Address’:
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property ‘AdministratorAccount’:
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*VirtualMachineSshCredentials_ARM)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property ‘IsNotebookInstanceCompute’:
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		result.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property ‘SshPort’:
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}

	// Set property ‘VirtualMachineSize’:
	if properties.VirtualMachineSize != nil {
		virtualMachineSize := *properties.VirtualMachineSize
		result.VirtualMachineSize = &virtualMachineSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VirtualMachineProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VirtualMachineProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineProperties_ARM, got %T", armInput)
	}

	// Set property ‘Address’:
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property ‘AdministratorAccount’:
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property ‘IsNotebookInstanceCompute’:
	if typedInput.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *typedInput.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property ‘SshPort’:
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// Set property ‘VirtualMachineSize’:
	if typedInput.VirtualMachineSize != nil {
		virtualMachineSize := *typedInput.VirtualMachineSize
		properties.VirtualMachineSize = &virtualMachineSize
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineProperties populates our VirtualMachineProperties from the provided source VirtualMachineProperties
func (properties *VirtualMachineProperties) AssignProperties_From_VirtualMachineProperties(source *v20210701s.VirtualMachineProperties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineProperties populates the provided destination VirtualMachineProperties from our VirtualMachineProperties
func (properties *VirtualMachineProperties) AssignProperties_To_VirtualMachineProperties(destination *v20210701s.VirtualMachineProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount v20210701s.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		destination.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		destination.IsNotebookInstanceCompute = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// VirtualMachineSize
	destination.VirtualMachineSize = genruntime.ClonePointerToString(properties.VirtualMachineSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AksNetworkingConfiguration
type AksNetworkingConfiguration struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP
	// ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// SubnetReference: Virtual network subnet resource ID the compute nodes belong to
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AksNetworkingConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AksNetworkingConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &AksNetworkingConfiguration_ARM{}

	// Set property ‘DnsServiceIP’:
	if configuration.DnsServiceIP != nil {
		dnsServiceIP := *configuration.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘ServiceCidr’:
	if configuration.ServiceCidr != nil {
		serviceCidr := *configuration.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}

	// Set property ‘SubnetId’:
	if configuration.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AksNetworkingConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AksNetworkingConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AksNetworkingConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AksNetworkingConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AksNetworkingConfiguration_ARM, got %T", armInput)
	}

	// Set property ‘DnsServiceIP’:
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘ServiceCidr’:
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	}

	// no assignment for property ‘SubnetReference’

	// No error
	return nil
}

// AssignProperties_From_AksNetworkingConfiguration populates our AksNetworkingConfiguration from the provided source AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_From_AksNetworkingConfiguration(source *v20210701s.AksNetworkingConfiguration) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	} else {
		configuration.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		configuration.DockerBridgeCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	} else {
		configuration.ServiceCidr = nil
	}

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AksNetworkingConfiguration populates the provided destination AksNetworkingConfiguration from our AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_To_AksNetworkingConfiguration(destination *v20210701s.AksNetworkingConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if configuration.DnsServiceIP != nil {
		dnsServiceIP := *configuration.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// ServiceCidr
	if configuration.ServiceCidr != nil {
		serviceCidr := *configuration.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// SubnetReference
	if configuration.SubnetReference != nil {
		subnetReference := configuration.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AutoPauseProperties
type AutoPauseProperties struct {
	DelayInMinutes *int  `json:"delayInMinutes,omitempty"`
	Enabled        *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoPauseProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoPauseProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &AutoPauseProperties_ARM{}

	// Set property ‘DelayInMinutes’:
	if properties.DelayInMinutes != nil {
		delayInMinutes := *properties.DelayInMinutes
		result.DelayInMinutes = &delayInMinutes
	}

	// Set property ‘Enabled’:
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoPauseProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoPauseProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoPauseProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoPauseProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoPauseProperties_ARM, got %T", armInput)
	}

	// Set property ‘DelayInMinutes’:
	if typedInput.DelayInMinutes != nil {
		delayInMinutes := *typedInput.DelayInMinutes
		properties.DelayInMinutes = &delayInMinutes
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AutoPauseProperties populates our AutoPauseProperties from the provided source AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_From_AutoPauseProperties(source *v20210701s.AutoPauseProperties) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoPauseProperties populates the provided destination AutoPauseProperties from our AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_To_AutoPauseProperties(destination *v20210701s.AutoPauseProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelayInMinutes
	destination.DelayInMinutes = genruntime.ClonePointerToInt(properties.DelayInMinutes)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AutoScaleProperties
type AutoScaleProperties struct {
	Enabled      *bool `json:"enabled,omitempty"`
	MaxNodeCount *int  `json:"maxNodeCount,omitempty"`
	MinNodeCount *int  `json:"minNodeCount,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoScaleProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoScaleProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &AutoScaleProperties_ARM{}

	// Set property ‘Enabled’:
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘MaxNodeCount’:
	if properties.MaxNodeCount != nil {
		maxNodeCount := *properties.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property ‘MinNodeCount’:
	if properties.MinNodeCount != nil {
		minNodeCount := *properties.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoScaleProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoScaleProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoScaleProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoScaleProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoScaleProperties_ARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property ‘MaxNodeCount’:
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		properties.MaxNodeCount = &maxNodeCount
	}

	// Set property ‘MinNodeCount’:
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		properties.MinNodeCount = &minNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_AutoScaleProperties populates our AutoScaleProperties from the provided source AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_From_AutoScaleProperties(source *v20210701s.AutoScaleProperties) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// AssignProperties_To_AutoScaleProperties populates the provided destination AutoScaleProperties from our AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_To_AutoScaleProperties(destination *v20210701s.AutoScaleProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(properties.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(properties.MinNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ComputeInstanceSshSettings
type ComputeInstanceSshSettings struct {
	// AdminPublicKey: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH
	// key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// SshPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is
	// closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the
	// VNet/subnet policy if applicable.
	SshPublicAccess *ComputeInstanceSshSettings_SshPublicAccess `json:"sshPublicAccess,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceSshSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ComputeInstanceSshSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &ComputeInstanceSshSettings_ARM{}

	// Set property ‘AdminPublicKey’:
	if settings.AdminPublicKey != nil {
		adminPublicKey := *settings.AdminPublicKey
		result.AdminPublicKey = &adminPublicKey
	}

	// Set property ‘SshPublicAccess’:
	if settings.SshPublicAccess != nil {
		sshPublicAccess := *settings.SshPublicAccess
		result.SshPublicAccess = &sshPublicAccess
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ComputeInstanceSshSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ComputeInstanceSshSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ComputeInstanceSshSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ComputeInstanceSshSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ComputeInstanceSshSettings_ARM, got %T", armInput)
	}

	// Set property ‘AdminPublicKey’:
	if typedInput.AdminPublicKey != nil {
		adminPublicKey := *typedInput.AdminPublicKey
		settings.AdminPublicKey = &adminPublicKey
	}

	// Set property ‘SshPublicAccess’:
	if typedInput.SshPublicAccess != nil {
		sshPublicAccess := *typedInput.SshPublicAccess
		settings.SshPublicAccess = &sshPublicAccess
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceSshSettings populates our ComputeInstanceSshSettings from the provided source ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_From_ComputeInstanceSshSettings(source *v20210701s.ComputeInstanceSshSettings) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := ComputeInstanceSshSettings_SshPublicAccess(*source.SshPublicAccess)
		settings.SshPublicAccess = &sshPublicAccess
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceSshSettings populates the provided destination ComputeInstanceSshSettings from our ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_To_ComputeInstanceSshSettings(destination *v20210701s.ComputeInstanceSshSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPublicKey
	destination.AdminPublicKey = genruntime.ClonePointerToString(settings.AdminPublicKey)

	// SshPublicAccess
	if settings.SshPublicAccess != nil {
		sshPublicAccess := string(*settings.SshPublicAccess)
		destination.SshPublicAccess = &sshPublicAccess
	} else {
		destination.SshPublicAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info,omitempty"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorAdditionalInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ErrorAdditionalInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorAdditionalInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ErrorAdditionalInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorAdditionalInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorAdditionalInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Info’:
	if typedInput.Info != nil {
		info.Info = make(map[string]v1.JSON, len(typedInput.Info))
		for key, value := range typedInput.Info {
			info.Info[key] = *value.DeepCopy()
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *v20210701s.ErrorAdditionalInfo_STATUS) error {

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *v20210701s.ErrorAdditionalInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ErrorDetail_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ErrorDetail_STATUS_Unrolled_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ErrorDetail_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ErrorDetail_STATUS_Unrolled_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ErrorDetail_STATUS_Unrolled_ARM, got %T", armInput)
	}

	// Set property ‘AdditionalInfo’:
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		unrolled.AdditionalInfo = append(unrolled.AdditionalInfo, item1)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *v20210701s.ErrorDetail_STATUS_Unrolled) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *v20210701s.ErrorDetail_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]v20210701s.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo v20210701s.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/PersonalComputeInstanceSettings
type PersonalComputeInstanceSettings struct {
	// AssignedUser: A user that can be assigned to a compute instance.
	AssignedUser *AssignedUser `json:"assignedUser,omitempty"`
}

var _ genruntime.ARMTransformer = &PersonalComputeInstanceSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PersonalComputeInstanceSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &PersonalComputeInstanceSettings_ARM{}

	// Set property ‘AssignedUser’:
	if settings.AssignedUser != nil {
		assignedUser_ARM, err := (*settings.AssignedUser).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		assignedUser := *assignedUser_ARM.(*AssignedUser_ARM)
		result.AssignedUser = &assignedUser
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PersonalComputeInstanceSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PersonalComputeInstanceSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PersonalComputeInstanceSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PersonalComputeInstanceSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PersonalComputeInstanceSettings_ARM, got %T", armInput)
	}

	// Set property ‘AssignedUser’:
	if typedInput.AssignedUser != nil {
		var assignedUser1 AssignedUser
		err := assignedUser1.PopulateFromARM(owner, *typedInput.AssignedUser)
		if err != nil {
			return err
		}
		assignedUser := assignedUser1
		settings.AssignedUser = &assignedUser
	}

	// No error
	return nil
}

// AssignProperties_From_PersonalComputeInstanceSettings populates our PersonalComputeInstanceSettings from the provided source PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_From_PersonalComputeInstanceSettings(source *v20210701s.PersonalComputeInstanceSettings) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser
		err := assignedUser.AssignProperties_From_AssignedUser(source.AssignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AssignedUser() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PersonalComputeInstanceSettings populates the provided destination PersonalComputeInstanceSettings from our PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_To_PersonalComputeInstanceSettings(destination *v20210701s.PersonalComputeInstanceSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedUser
	if settings.AssignedUser != nil {
		var assignedUser v20210701s.AssignedUser
		err := settings.AssignedUser.AssignProperties_To_AssignedUser(&assignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AssignedUser() to populate field AssignedUser")
		}
		destination.AssignedUser = &assignedUser
	} else {
		destination.AssignedUser = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ResourceId
type ResourceId struct {
	// +kubebuilder:validation:Required
	// Reference: The ID of the resource
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceId *ResourceId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceId == nil {
		return nil, nil
	}
	result := &ResourceId_ARM{}

	// Set property ‘Id’:
	if resourceId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resourceId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ResourceId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceId_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ResourceId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ResourceId_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceId_ARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_ResourceId populates our ResourceId from the provided source ResourceId
func (resourceId *ResourceId) AssignProperties_From_ResourceId(source *v20210701s.ResourceId) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resourceId.Reference = &reference
	} else {
		resourceId.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceId populates the provided destination ResourceId from our ResourceId
func (resourceId *ResourceId) AssignProperties_To_ResourceId(destination *v20210701s.ResourceId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resourceId.Reference != nil {
		reference := resourceId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ScaleSettings
type ScaleSettings struct {
	// +kubebuilder:validation:Required
	// MaxNodeCount: Max number of nodes to use
	MaxNodeCount *int `json:"maxNodeCount,omitempty"`

	// MinNodeCount: Min number of nodes to use
	MinNodeCount *int `json:"minNodeCount,omitempty"`

	// NodeIdleTimeBeforeScaleDown: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ScaleSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &ScaleSettings_ARM{}

	// Set property ‘MaxNodeCount’:
	if settings.MaxNodeCount != nil {
		maxNodeCount := *settings.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property ‘MinNodeCount’:
	if settings.MinNodeCount != nil {
		minNodeCount := *settings.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}

	// Set property ‘NodeIdleTimeBeforeScaleDown’:
	if settings.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *settings.NodeIdleTimeBeforeScaleDown
		result.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ScaleSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ScaleSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleSettings_ARM, got %T", armInput)
	}

	// Set property ‘MaxNodeCount’:
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		settings.MaxNodeCount = &maxNodeCount
	}

	// Set property ‘MinNodeCount’:
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		settings.MinNodeCount = &minNodeCount
	}

	// Set property ‘NodeIdleTimeBeforeScaleDown’:
	if typedInput.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *typedInput.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleSettings populates our ScaleSettings from the provided source ScaleSettings
func (settings *ScaleSettings) AssignProperties_From_ScaleSettings(source *v20210701s.ScaleSettings) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	if source.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *source.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	} else {
		settings.NodeIdleTimeBeforeScaleDown = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleSettings populates the provided destination ScaleSettings from our ScaleSettings
func (settings *ScaleSettings) AssignProperties_To_ScaleSettings(destination *v20210701s.ScaleSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(settings.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(settings.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	if settings.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *settings.NodeIdleTimeBeforeScaleDown
		destination.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	} else {
		destination.NodeIdleTimeBeforeScaleDown = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/SetupScripts
type SetupScripts struct {
	// Scripts: Customized setup scripts
	Scripts *ScriptsToExecute `json:"scripts,omitempty"`
}

var _ genruntime.ARMTransformer = &SetupScripts{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scripts *SetupScripts) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scripts == nil {
		return nil, nil
	}
	result := &SetupScripts_ARM{}

	// Set property ‘Scripts’:
	if scripts.Scripts != nil {
		scripts_ARM, err := (*scripts.Scripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scripts1 := *scripts_ARM.(*ScriptsToExecute_ARM)
		result.Scripts = &scripts1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scripts *SetupScripts) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SetupScripts_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scripts *SetupScripts) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SetupScripts_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SetupScripts_ARM, got %T", armInput)
	}

	// Set property ‘Scripts’:
	if typedInput.Scripts != nil {
		var scripts2 ScriptsToExecute
		err := scripts2.PopulateFromARM(owner, *typedInput.Scripts)
		if err != nil {
			return err
		}
		scripts1 := scripts2
		scripts.Scripts = &scripts1
	}

	// No error
	return nil
}

// AssignProperties_From_SetupScripts populates our SetupScripts from the provided source SetupScripts
func (scripts *SetupScripts) AssignProperties_From_SetupScripts(source *v20210701s.SetupScripts) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute
		err := script.AssignProperties_From_ScriptsToExecute(source.Scripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptsToExecute() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SetupScripts populates the provided destination SetupScripts from our SetupScripts
func (scripts *SetupScripts) AssignProperties_To_SetupScripts(destination *v20210701s.SetupScripts) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scripts
	if scripts.Scripts != nil {
		var script v20210701s.ScriptsToExecute
		err := scripts.Scripts.AssignProperties_To_ScriptsToExecute(&script)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptsToExecute() to populate field Scripts")
		}
		destination.Scripts = &script
	} else {
		destination.Scripts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/SslConfiguration
type SslConfiguration struct {
	// Cert: Cert data
	Cert *string `json:"cert,omitempty"`

	// Cname: CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// Key: Key data
	Key *string `json:"key,omitempty"`

	// LeafDomainLabel: Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// OverwriteExistingDomain: Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Status: Enable or disable ssl for scoring.
	Status *SslConfiguration_Status `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &SslConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *SslConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &SslConfiguration_ARM{}

	// Set property ‘Cert’:
	if configuration.Cert != nil {
		cert := *configuration.Cert
		result.Cert = &cert
	}

	// Set property ‘Cname’:
	if configuration.Cname != nil {
		cname := *configuration.Cname
		result.Cname = &cname
	}

	// Set property ‘Key’:
	if configuration.Key != nil {
		key := *configuration.Key
		result.Key = &key
	}

	// Set property ‘LeafDomainLabel’:
	if configuration.LeafDomainLabel != nil {
		leafDomainLabel := *configuration.LeafDomainLabel
		result.LeafDomainLabel = &leafDomainLabel
	}

	// Set property ‘OverwriteExistingDomain’:
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		result.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property ‘Status’:
	if configuration.Status != nil {
		status := *configuration.Status
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SslConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SslConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SslConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SslConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SslConfiguration_ARM, got %T", armInput)
	}

	// Set property ‘Cert’:
	if typedInput.Cert != nil {
		cert := *typedInput.Cert
		configuration.Cert = &cert
	}

	// Set property ‘Cname’:
	if typedInput.Cname != nil {
		cname := *typedInput.Cname
		configuration.Cname = &cname
	}

	// Set property ‘Key’:
	if typedInput.Key != nil {
		key := *typedInput.Key
		configuration.Key = &key
	}

	// Set property ‘LeafDomainLabel’:
	if typedInput.LeafDomainLabel != nil {
		leafDomainLabel := *typedInput.LeafDomainLabel
		configuration.LeafDomainLabel = &leafDomainLabel
	}

	// Set property ‘OverwriteExistingDomain’:
	if typedInput.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *typedInput.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		configuration.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_SslConfiguration populates our SslConfiguration from the provided source SslConfiguration
func (configuration *SslConfiguration) AssignProperties_From_SslConfiguration(source *v20210701s.SslConfiguration) error {

	// Cert
	configuration.Cert = genruntime.ClonePointerToString(source.Cert)

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// Key
	configuration.Key = genruntime.ClonePointerToString(source.Key)

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := SslConfiguration_Status(*source.Status)
		configuration.Status = &status
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslConfiguration populates the provided destination SslConfiguration from our SslConfiguration
func (configuration *SslConfiguration) AssignProperties_To_SslConfiguration(destination *v20210701s.SslConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cert
	destination.Cert = genruntime.ClonePointerToString(configuration.Cert)

	// Cname
	destination.Cname = genruntime.ClonePointerToString(configuration.Cname)

	// Key
	destination.Key = genruntime.ClonePointerToString(configuration.Key)

	// LeafDomainLabel
	destination.LeafDomainLabel = genruntime.ClonePointerToString(configuration.LeafDomainLabel)

	// OverwriteExistingDomain
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		destination.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		destination.OverwriteExistingDomain = nil
	}

	// Status
	if configuration.Status != nil {
		status := string(*configuration.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/UserAccountCredentials
type UserAccountCredentials struct {
	// +kubebuilder:validation:Required
	// AdminUserName: Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// AdminUserPassword: Password of the administrator user account.
	AdminUserPassword *genruntime.SecretReference `json:"adminUserPassword,omitempty"`

	// AdminUserSshPublicKey: SSH public key of the administrator user account.
	AdminUserSshPublicKey *genruntime.SecretReference `json:"adminUserSshPublicKey,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAccountCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *UserAccountCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &UserAccountCredentials_ARM{}

	// Set property ‘AdminUserName’:
	if credentials.AdminUserName != nil {
		adminUserName := *credentials.AdminUserName
		result.AdminUserName = &adminUserName
	}

	// Set property ‘AdminUserPassword’:
	if credentials.AdminUserPassword != nil {
		adminUserPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminUserPassword")
		}
		adminUserPassword := adminUserPasswordSecret
		result.AdminUserPassword = &adminUserPassword
	}

	// Set property ‘AdminUserSshPublicKey’:
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKeySecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserSshPublicKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminUserSshPublicKey")
		}
		adminUserSshPublicKey := adminUserSshPublicKeySecret
		result.AdminUserSshPublicKey = &adminUserSshPublicKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *UserAccountCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAccountCredentials_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *UserAccountCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAccountCredentials_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAccountCredentials_ARM, got %T", armInput)
	}

	// Set property ‘AdminUserName’:
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		credentials.AdminUserName = &adminUserName
	}

	// no assignment for property ‘AdminUserPassword’

	// no assignment for property ‘AdminUserSshPublicKey’

	// No error
	return nil
}

// AssignProperties_From_UserAccountCredentials populates our UserAccountCredentials from the provided source UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_From_UserAccountCredentials(source *v20210701s.UserAccountCredentials) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// AdminUserPassword
	if source.AdminUserPassword != nil {
		adminUserPassword := source.AdminUserPassword.Copy()
		credentials.AdminUserPassword = &adminUserPassword
	} else {
		credentials.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if source.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := source.AdminUserSshPublicKey.Copy()
		credentials.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		credentials.AdminUserSshPublicKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAccountCredentials populates the provided destination UserAccountCredentials from our UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_To_UserAccountCredentials(destination *v20210701s.UserAccountCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(credentials.AdminUserName)

	// AdminUserPassword
	if credentials.AdminUserPassword != nil {
		adminUserPassword := credentials.AdminUserPassword.Copy()
		destination.AdminUserPassword = &adminUserPassword
	} else {
		destination.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := credentials.AdminUserSshPublicKey.Copy()
		destination.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		destination.AdminUserSshPublicKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/VirtualMachineImage
type VirtualMachineImage struct {
	// +kubebuilder:validation:Required
	// Reference: Virtual Machine image path
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineImage{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (image *VirtualMachineImage) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if image == nil {
		return nil, nil
	}
	result := &VirtualMachineImage_ARM{}

	// Set property ‘Id’:
	if image.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*image.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *VirtualMachineImage) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineImage_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *VirtualMachineImage) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(VirtualMachineImage_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineImage_ARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineImage populates our VirtualMachineImage from the provided source VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_From_VirtualMachineImage(source *v20210701s.VirtualMachineImage) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		image.Reference = &reference
	} else {
		image.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineImage populates the provided destination VirtualMachineImage from our VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_To_VirtualMachineImage(destination *v20210701s.VirtualMachineImage) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if image.Reference != nil {
		reference := image.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/VirtualMachineSshCredentials
type VirtualMachineSshCredentials struct {
	// Password: Password of admin account
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// PrivateKeyData: Private key data
	PrivateKeyData *string `json:"privateKeyData,omitempty"`

	// PublicKeyData: Public key data
	PublicKeyData *string `json:"publicKeyData,omitempty"`

	// Username: Username of admin account
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineSshCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *VirtualMachineSshCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &VirtualMachineSshCredentials_ARM{}

	// Set property ‘Password’:
	if credentials.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property ‘PrivateKeyData’:
	if credentials.PrivateKeyData != nil {
		privateKeyData := *credentials.PrivateKeyData
		result.PrivateKeyData = &privateKeyData
	}

	// Set property ‘PublicKeyData’:
	if credentials.PublicKeyData != nil {
		publicKeyData := *credentials.PublicKeyData
		result.PublicKeyData = &publicKeyData
	}

	// Set property ‘Username’:
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *VirtualMachineSshCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineSshCredentials_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *VirtualMachineSshCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineSshCredentials_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineSshCredentials_ARM, got %T", armInput)
	}

	// no assignment for property ‘Password’

	// Set property ‘PrivateKeyData’:
	if typedInput.PrivateKeyData != nil {
		privateKeyData := *typedInput.PrivateKeyData
		credentials.PrivateKeyData = &privateKeyData
	}

	// Set property ‘PublicKeyData’:
	if typedInput.PublicKeyData != nil {
		publicKeyData := *typedInput.PublicKeyData
		credentials.PublicKeyData = &publicKeyData
	}

	// Set property ‘Username’:
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineSshCredentials populates our VirtualMachineSshCredentials from the provided source VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_From_VirtualMachineSshCredentials(source *v20210701s.VirtualMachineSshCredentials) error {

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credentials.Password = &password
	} else {
		credentials.Password = nil
	}

	// PrivateKeyData
	credentials.PrivateKeyData = genruntime.ClonePointerToString(source.PrivateKeyData)

	// PublicKeyData
	credentials.PublicKeyData = genruntime.ClonePointerToString(source.PublicKeyData)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineSshCredentials populates the provided destination VirtualMachineSshCredentials from our VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_To_VirtualMachineSshCredentials(destination *v20210701s.VirtualMachineSshCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if credentials.Password != nil {
		password := credentials.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// PrivateKeyData
	destination.PrivateKeyData = genruntime.ClonePointerToString(credentials.PrivateKeyData)

	// PublicKeyData
	destination.PublicKeyData = genruntime.ClonePointerToString(credentials.PublicKeyData)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/AssignedUser
type AssignedUser struct {
	// +kubebuilder:validation:Required
	// ObjectId: User’s AAD Object Id.
	ObjectId *string `json:"objectId,omitempty"`

	// +kubebuilder:validation:Required
	// TenantId: User’s AAD Tenant Id.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.ARMTransformer = &AssignedUser{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (user *AssignedUser) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if user == nil {
		return nil, nil
	}
	result := &AssignedUser_ARM{}

	// Set property ‘ObjectId’:
	if user.ObjectId != nil {
		objectId := *user.ObjectId
		result.ObjectId = &objectId
	}

	// Set property ‘TenantId’:
	if user.TenantId != nil {
		tenantId := *user.TenantId
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (user *AssignedUser) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AssignedUser_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (user *AssignedUser) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AssignedUser_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AssignedUser_ARM, got %T", armInput)
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		user.ObjectId = &objectId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		user.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_AssignedUser populates our AssignedUser from the provided source AssignedUser
func (user *AssignedUser) AssignProperties_From_AssignedUser(source *v20210701s.AssignedUser) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_AssignedUser populates the provided destination AssignedUser from our AssignedUser
func (user *AssignedUser) AssignProperties_To_AssignedUser(destination *v20210701s.AssignedUser) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(user.ObjectId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(user.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ScriptsToExecute
type ScriptsToExecute struct {
	// CreationScript: Script reference
	CreationScript *ScriptReference `json:"creationScript,omitempty"`

	// StartupScript: Script reference
	StartupScript *ScriptReference `json:"startupScript,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptsToExecute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (execute *ScriptsToExecute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if execute == nil {
		return nil, nil
	}
	result := &ScriptsToExecute_ARM{}

	// Set property ‘CreationScript’:
	if execute.CreationScript != nil {
		creationScript_ARM, err := (*execute.CreationScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		creationScript := *creationScript_ARM.(*ScriptReference_ARM)
		result.CreationScript = &creationScript
	}

	// Set property ‘StartupScript’:
	if execute.StartupScript != nil {
		startupScript_ARM, err := (*execute.StartupScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		startupScript := *startupScript_ARM.(*ScriptReference_ARM)
		result.StartupScript = &startupScript
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (execute *ScriptsToExecute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScriptsToExecute_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (execute *ScriptsToExecute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScriptsToExecute_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScriptsToExecute_ARM, got %T", armInput)
	}

	// Set property ‘CreationScript’:
	if typedInput.CreationScript != nil {
		var creationScript1 ScriptReference
		err := creationScript1.PopulateFromARM(owner, *typedInput.CreationScript)
		if err != nil {
			return err
		}
		creationScript := creationScript1
		execute.CreationScript = &creationScript
	}

	// Set property ‘StartupScript’:
	if typedInput.StartupScript != nil {
		var startupScript1 ScriptReference
		err := startupScript1.PopulateFromARM(owner, *typedInput.StartupScript)
		if err != nil {
			return err
		}
		startupScript := startupScript1
		execute.StartupScript = &startupScript
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptsToExecute populates our ScriptsToExecute from the provided source ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_From_ScriptsToExecute(source *v20210701s.ScriptsToExecute) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference
		err := creationScript.AssignProperties_From_ScriptReference(source.CreationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference
		err := startupScript.AssignProperties_From_ScriptReference(source.StartupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScriptsToExecute populates the provided destination ScriptsToExecute from our ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_To_ScriptsToExecute(destination *v20210701s.ScriptsToExecute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreationScript
	if execute.CreationScript != nil {
		var creationScript v20210701s.ScriptReference
		err := execute.CreationScript.AssignProperties_To_ScriptReference(&creationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field CreationScript")
		}
		destination.CreationScript = &creationScript
	} else {
		destination.CreationScript = nil
	}

	// StartupScript
	if execute.StartupScript != nil {
		var startupScript v20210701s.ScriptReference
		err := execute.StartupScript.AssignProperties_To_ScriptReference(&startupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field StartupScript")
		}
		destination.StartupScript = &startupScript
	} else {
		destination.StartupScript = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-07-01/Microsoft.MachineLearningServices.json#/definitions/ScriptReference
type ScriptReference struct {
	// ScriptArguments: Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// ScriptData: The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// ScriptSource: The storage source of the script: inline, workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Timeout: Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ScriptReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &ScriptReference_ARM{}

	// Set property ‘ScriptArguments’:
	if reference.ScriptArguments != nil {
		scriptArguments := *reference.ScriptArguments
		result.ScriptArguments = &scriptArguments
	}

	// Set property ‘ScriptData’:
	if reference.ScriptData != nil {
		scriptData := *reference.ScriptData
		result.ScriptData = &scriptData
	}

	// Set property ‘ScriptSource’:
	if reference.ScriptSource != nil {
		scriptSource := *reference.ScriptSource
		result.ScriptSource = &scriptSource
	}

	// Set property ‘Timeout’:
	if reference.Timeout != nil {
		timeout := *reference.Timeout
		result.Timeout = &timeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ScriptReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScriptReference_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ScriptReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScriptReference_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScriptReference_ARM, got %T", armInput)
	}

	// Set property ‘ScriptArguments’:
	if typedInput.ScriptArguments != nil {
		scriptArguments := *typedInput.ScriptArguments
		reference.ScriptArguments = &scriptArguments
	}

	// Set property ‘ScriptData’:
	if typedInput.ScriptData != nil {
		scriptData := *typedInput.ScriptData
		reference.ScriptData = &scriptData
	}

	// Set property ‘ScriptSource’:
	if typedInput.ScriptSource != nil {
		scriptSource := *typedInput.ScriptSource
		reference.ScriptSource = &scriptSource
	}

	// Set property ‘Timeout’:
	if typedInput.Timeout != nil {
		timeout := *typedInput.Timeout
		reference.Timeout = &timeout
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptReference populates our ScriptReference from the provided source ScriptReference
func (reference *ScriptReference) AssignProperties_From_ScriptReference(source *v20210701s.ScriptReference) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// AssignProperties_To_ScriptReference populates the provided destination ScriptReference from our ScriptReference
func (reference *ScriptReference) AssignProperties_To_ScriptReference(destination *v20210701s.ScriptReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScriptArguments
	destination.ScriptArguments = genruntime.ClonePointerToString(reference.ScriptArguments)

	// ScriptData
	destination.ScriptData = genruntime.ClonePointerToString(reference.ScriptData)

	// ScriptSource
	destination.ScriptSource = genruntime.ClonePointerToString(reference.ScriptSource)

	// Timeout
	destination.Timeout = genruntime.ClonePointerToString(reference.Timeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&WorkspacesCompute{}, &WorkspacesComputeList{})
}
