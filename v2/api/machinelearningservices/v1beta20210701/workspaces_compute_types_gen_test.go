// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210701

import (
	"encoding/json"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1beta20210701storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_WorkspacesCompute_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspacesCompute to hub returns original",
		prop.ForAll(RunResourceConversionTestForWorkspacesCompute, WorkspacesComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWorkspacesCompute tests if a specific instance of WorkspacesCompute round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWorkspacesCompute(subject WorkspacesCompute) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210701s.WorkspacesCompute
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual WorkspacesCompute
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspacesCompute_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspacesCompute to WorkspacesCompute via AssignProperties_To_WorkspacesCompute & AssignProperties_From_WorkspacesCompute returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspacesCompute, WorkspacesComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspacesCompute tests if a specific instance of WorkspacesCompute can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspacesCompute(subject WorkspacesCompute) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.WorkspacesCompute
	err := copied.AssignProperties_To_WorkspacesCompute(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspacesCompute
	err = actual.AssignProperties_From_WorkspacesCompute(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspacesCompute_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspacesCompute via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspacesCompute, WorkspacesComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspacesCompute runs a test to see if a specific instance of WorkspacesCompute round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspacesCompute(subject WorkspacesCompute) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspacesCompute
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspacesCompute instances for property testing - lazily instantiated by WorkspacesComputeGenerator()
var workspacesComputeGenerator gopter.Gen

// WorkspacesComputeGenerator returns a generator of WorkspacesCompute instances for property testing.
func WorkspacesComputeGenerator() gopter.Gen {
	if workspacesComputeGenerator != nil {
		return workspacesComputeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspacesCompute(generators)
	workspacesComputeGenerator = gen.Struct(reflect.TypeOf(WorkspacesCompute{}), generators)

	return workspacesComputeGenerator
}

// AddRelatedPropertyGeneratorsForWorkspacesCompute is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspacesCompute(gens map[string]gopter.Gen) {
	gens["Spec"] = Workspaces_Compute_SpecGenerator()
	gens["Status"] = ComputeResource_STATUSGenerator()
}

func Test_ComputeResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ComputeResource_STATUS to ComputeResource_STATUS via AssignProperties_To_ComputeResource_STATUS & AssignProperties_From_ComputeResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForComputeResource_STATUS, ComputeResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForComputeResource_STATUS tests if a specific instance of ComputeResource_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForComputeResource_STATUS(subject ComputeResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ComputeResource_STATUS
	err := copied.AssignProperties_To_ComputeResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ComputeResource_STATUS
	err = actual.AssignProperties_From_ComputeResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ComputeResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeResource_STATUS, ComputeResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeResource_STATUS runs a test to see if a specific instance of ComputeResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeResource_STATUS(subject ComputeResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeResource_STATUS instances for property testing - lazily instantiated by
// ComputeResource_STATUSGenerator()
var computeResource_STATUSGenerator gopter.Gen

// ComputeResource_STATUSGenerator returns a generator of ComputeResource_STATUS instances for property testing.
// We first initialize computeResource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeResource_STATUSGenerator() gopter.Gen {
	if computeResource_STATUSGenerator != nil {
		return computeResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeResource_STATUS(generators)
	computeResource_STATUSGenerator = gen.Struct(reflect.TypeOf(ComputeResource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeResource_STATUS(generators)
	AddRelatedPropertyGeneratorsForComputeResource_STATUS(generators)
	computeResource_STATUSGenerator = gen.Struct(reflect.TypeOf(ComputeResource_STATUS{}), generators)

	return computeResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForComputeResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeResource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeResource_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(Compute_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Workspaces_Compute_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspaces_Compute_Spec to Workspaces_Compute_Spec via AssignProperties_To_Workspaces_Compute_Spec & AssignProperties_From_Workspaces_Compute_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaces_Compute_Spec, Workspaces_Compute_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaces_Compute_Spec tests if a specific instance of Workspaces_Compute_Spec can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForWorkspaces_Compute_Spec(subject Workspaces_Compute_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Workspaces_Compute_Spec
	err := copied.AssignProperties_To_Workspaces_Compute_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspaces_Compute_Spec
	err = actual.AssignProperties_From_Workspaces_Compute_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspaces_Compute_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Compute_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaces_Compute_Spec, Workspaces_Compute_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaces_Compute_Spec runs a test to see if a specific instance of Workspaces_Compute_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaces_Compute_Spec(subject Workspaces_Compute_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Compute_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Compute_Spec instances for property testing - lazily instantiated by
// Workspaces_Compute_SpecGenerator()
var workspaces_Compute_SpecGenerator gopter.Gen

// Workspaces_Compute_SpecGenerator returns a generator of Workspaces_Compute_Spec instances for property testing.
// We first initialize workspaces_Compute_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspaces_Compute_SpecGenerator() gopter.Gen {
	if workspaces_Compute_SpecGenerator != nil {
		return workspaces_Compute_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec(generators)
	workspaces_Compute_SpecGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec(generators)
	workspaces_Compute_SpecGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec{}), generators)

	return workspaces_Compute_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["Properties"] = gen.PtrOf(ComputeGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_Compute_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute to Compute via AssignProperties_To_Compute & AssignProperties_From_Compute returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute, ComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute tests if a specific instance of Compute can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute(subject Compute) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute
	err := copied.AssignProperties_To_Compute(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute
	err = actual.AssignProperties_From_Compute(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute, ComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute runs a test to see if a specific instance of Compute round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute(subject Compute) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute instances for property testing - lazily instantiated by ComputeGenerator()
var computeGenerator gopter.Gen

// ComputeGenerator returns a generator of Compute instances for property testing.
func ComputeGenerator() gopter.Gen {
	if computeGenerator != nil {
		return computeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCompute(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(Compute{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	computeGenerator = gen.OneGenOf(gens...)

	return computeGenerator
}

// AddRelatedPropertyGeneratorsForCompute is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute(gens map[string]gopter.Gen) {
	gens["AKS"] = Compute_AKSGenerator().Map(func(it Compute_AKS) *Compute_AKS {
		return &it
	}) // generate one case for OneOf type
	gens["AmlCompute"] = Compute_AmlComputeGenerator().Map(func(it Compute_AmlCompute) *Compute_AmlCompute {
		return &it
	}) // generate one case for OneOf type
	gens["ComputeInstance"] = Compute_ComputeInstanceGenerator().Map(func(it Compute_ComputeInstance) *Compute_ComputeInstance {
		return &it
	}) // generate one case for OneOf type
	gens["DataFactory"] = Compute_DataFactoryGenerator().Map(func(it Compute_DataFactory) *Compute_DataFactory {
		return &it
	}) // generate one case for OneOf type
	gens["DataLakeAnalytics"] = Compute_DataLakeAnalyticsGenerator().Map(func(it Compute_DataLakeAnalytics) *Compute_DataLakeAnalytics {
		return &it
	}) // generate one case for OneOf type
	gens["Databricks"] = Compute_DatabricksGenerator().Map(func(it Compute_Databricks) *Compute_Databricks {
		return &it
	}) // generate one case for OneOf type
	gens["HDInsight"] = Compute_HDInsightGenerator().Map(func(it Compute_HDInsight) *Compute_HDInsight {
		return &it
	}) // generate one case for OneOf type
	gens["SynapseSpark"] = Compute_SynapseSparkGenerator().Map(func(it Compute_SynapseSpark) *Compute_SynapseSpark {
		return &it
	}) // generate one case for OneOf type
	gens["VirtualMachine"] = Compute_VirtualMachineGenerator().Map(func(it Compute_VirtualMachine) *Compute_VirtualMachine {
		return &it
	}) // generate one case for OneOf type
}

func Test_Compute_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_STATUS to Compute_STATUS via AssignProperties_To_Compute_STATUS & AssignProperties_From_Compute_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_STATUS, Compute_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_STATUS tests if a specific instance of Compute_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_STATUS(subject Compute_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_STATUS
	err := copied.AssignProperties_To_Compute_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_STATUS
	err = actual.AssignProperties_From_Compute_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_STATUS, Compute_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_STATUS runs a test to see if a specific instance of Compute_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_STATUS(subject Compute_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_STATUS instances for property testing - lazily instantiated by Compute_STATUSGenerator()
var compute_STATUSGenerator gopter.Gen

// Compute_STATUSGenerator returns a generator of Compute_STATUS instances for property testing.
// We first initialize compute_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_STATUSGenerator() gopter.Gen {
	if compute_STATUSGenerator != nil {
		return compute_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_STATUS(generators)
	compute_STATUSGenerator = gen.Struct(reflect.TypeOf(Compute_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_STATUS(generators)
	AddRelatedPropertyGeneratorsForCompute_STATUS(generators)
	compute_STATUSGenerator = gen.Struct(reflect.TypeOf(Compute_STATUS{}), generators)

	return compute_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCompute_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_STATUS(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(
		ComputeType_STATUS_AKS,
		ComputeType_STATUS_AmlCompute,
		ComputeType_STATUS_ComputeInstance,
		ComputeType_STATUS_DataFactory,
		ComputeType_STATUS_DataLakeAnalytics,
		ComputeType_STATUS_Databricks,
		ComputeType_STATUS_HDInsight,
		ComputeType_STATUS_Kubernetes,
		ComputeType_STATUS_SynapseSpark,
		ComputeType_STATUS_VirtualMachine))
	gens["CreatedOn"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["IsAttachedCompute"] = gen.PtrOf(gen.Bool())
	gens["ModifiedOn"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		Compute_STATUS_ProvisioningState_Canceled,
		Compute_STATUS_ProvisioningState_Creating,
		Compute_STATUS_ProvisioningState_Deleting,
		Compute_STATUS_ProvisioningState_Failed,
		Compute_STATUS_ProvisioningState_Succeeded,
		Compute_STATUS_ProvisioningState_Unknown,
		Compute_STATUS_ProvisioningState_Updating))
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCompute_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisioningErrors"] = gen.SliceOf(ErrorResponse_STATUSGenerator())
}

func Test_Compute_AKS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_AKS to Compute_AKS via AssignProperties_To_Compute_AKS & AssignProperties_From_Compute_AKS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_AKS, Compute_AKSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_AKS tests if a specific instance of Compute_AKS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_AKS(subject Compute_AKS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_AKS
	err := copied.AssignProperties_To_Compute_AKS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_AKS
	err = actual.AssignProperties_From_Compute_AKS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_AKS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AKS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_AKS, Compute_AKSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_AKS runs a test to see if a specific instance of Compute_AKS round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_AKS(subject Compute_AKS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AKS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AKS instances for property testing - lazily instantiated by Compute_AKSGenerator()
var compute_AKSGenerator gopter.Gen

// Compute_AKSGenerator returns a generator of Compute_AKS instances for property testing.
// We first initialize compute_AKSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_AKSGenerator() gopter.Gen {
	if compute_AKSGenerator != nil {
		return compute_AKSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AKS(generators)
	compute_AKSGenerator = gen.Struct(reflect.TypeOf(Compute_AKS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AKS(generators)
	AddRelatedPropertyGeneratorsForCompute_AKS(generators)
	compute_AKSGenerator = gen.Struct(reflect.TypeOf(Compute_AKS{}), generators)

	return compute_AKSGenerator
}

// AddIndependentPropertyGeneratorsForCompute_AKS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_AKS(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_AKS_ComputeType_AKS))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_AKS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_AKS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AKSPropertiesGenerator())
}

func Test_Compute_AmlCompute_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_AmlCompute to Compute_AmlCompute via AssignProperties_To_Compute_AmlCompute & AssignProperties_From_Compute_AmlCompute returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_AmlCompute, Compute_AmlComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_AmlCompute tests if a specific instance of Compute_AmlCompute can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_AmlCompute(subject Compute_AmlCompute) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_AmlCompute
	err := copied.AssignProperties_To_Compute_AmlCompute(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_AmlCompute
	err = actual.AssignProperties_From_Compute_AmlCompute(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_AmlCompute_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AmlCompute via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_AmlCompute, Compute_AmlComputeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_AmlCompute runs a test to see if a specific instance of Compute_AmlCompute round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_AmlCompute(subject Compute_AmlCompute) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AmlCompute
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AmlCompute instances for property testing - lazily instantiated by Compute_AmlComputeGenerator()
var compute_AmlComputeGenerator gopter.Gen

// Compute_AmlComputeGenerator returns a generator of Compute_AmlCompute instances for property testing.
// We first initialize compute_AmlComputeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_AmlComputeGenerator() gopter.Gen {
	if compute_AmlComputeGenerator != nil {
		return compute_AmlComputeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AmlCompute(generators)
	compute_AmlComputeGenerator = gen.Struct(reflect.TypeOf(Compute_AmlCompute{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_AmlCompute(generators)
	AddRelatedPropertyGeneratorsForCompute_AmlCompute(generators)
	compute_AmlComputeGenerator = gen.Struct(reflect.TypeOf(Compute_AmlCompute{}), generators)

	return compute_AmlComputeGenerator
}

// AddIndependentPropertyGeneratorsForCompute_AmlCompute is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_AmlCompute(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_AmlCompute_ComputeType_AmlCompute))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_AmlCompute is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_AmlCompute(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AmlComputePropertiesGenerator())
}

func Test_Compute_ComputeInstance_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_ComputeInstance to Compute_ComputeInstance via AssignProperties_To_Compute_ComputeInstance & AssignProperties_From_Compute_ComputeInstance returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_ComputeInstance, Compute_ComputeInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_ComputeInstance tests if a specific instance of Compute_ComputeInstance can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_ComputeInstance(subject Compute_ComputeInstance) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_ComputeInstance
	err := copied.AssignProperties_To_Compute_ComputeInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_ComputeInstance
	err = actual.AssignProperties_From_Compute_ComputeInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_ComputeInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_ComputeInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_ComputeInstance, Compute_ComputeInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_ComputeInstance runs a test to see if a specific instance of Compute_ComputeInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_ComputeInstance(subject Compute_ComputeInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_ComputeInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_ComputeInstance instances for property testing - lazily instantiated by
// Compute_ComputeInstanceGenerator()
var compute_ComputeInstanceGenerator gopter.Gen

// Compute_ComputeInstanceGenerator returns a generator of Compute_ComputeInstance instances for property testing.
// We first initialize compute_ComputeInstanceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_ComputeInstanceGenerator() gopter.Gen {
	if compute_ComputeInstanceGenerator != nil {
		return compute_ComputeInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_ComputeInstance(generators)
	compute_ComputeInstanceGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstance{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_ComputeInstance(generators)
	AddRelatedPropertyGeneratorsForCompute_ComputeInstance(generators)
	compute_ComputeInstanceGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstance{}), generators)

	return compute_ComputeInstanceGenerator
}

// AddIndependentPropertyGeneratorsForCompute_ComputeInstance is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_ComputeInstance(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_ComputeInstance_ComputeType_ComputeInstance))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_ComputeInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_ComputeInstance(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ComputeInstancePropertiesGenerator())
}

func Test_Compute_Databricks_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_Databricks to Compute_Databricks via AssignProperties_To_Compute_Databricks & AssignProperties_From_Compute_Databricks returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_Databricks, Compute_DatabricksGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_Databricks tests if a specific instance of Compute_Databricks can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_Databricks(subject Compute_Databricks) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_Databricks
	err := copied.AssignProperties_To_Compute_Databricks(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_Databricks
	err = actual.AssignProperties_From_Compute_Databricks(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_Databricks_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_Databricks via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_Databricks, Compute_DatabricksGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_Databricks runs a test to see if a specific instance of Compute_Databricks round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_Databricks(subject Compute_Databricks) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_Databricks
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_Databricks instances for property testing - lazily instantiated by Compute_DatabricksGenerator()
var compute_DatabricksGenerator gopter.Gen

// Compute_DatabricksGenerator returns a generator of Compute_Databricks instances for property testing.
// We first initialize compute_DatabricksGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_DatabricksGenerator() gopter.Gen {
	if compute_DatabricksGenerator != nil {
		return compute_DatabricksGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_Databricks(generators)
	compute_DatabricksGenerator = gen.Struct(reflect.TypeOf(Compute_Databricks{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_Databricks(generators)
	AddRelatedPropertyGeneratorsForCompute_Databricks(generators)
	compute_DatabricksGenerator = gen.Struct(reflect.TypeOf(Compute_Databricks{}), generators)

	return compute_DatabricksGenerator
}

// AddIndependentPropertyGeneratorsForCompute_Databricks is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_Databricks(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_Databricks_ComputeType_Databricks))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_Databricks is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_Databricks(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DatabricksPropertiesGenerator())
}

func Test_Compute_DataFactory_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_DataFactory to Compute_DataFactory via AssignProperties_To_Compute_DataFactory & AssignProperties_From_Compute_DataFactory returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_DataFactory, Compute_DataFactoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_DataFactory tests if a specific instance of Compute_DataFactory can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_DataFactory(subject Compute_DataFactory) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_DataFactory
	err := copied.AssignProperties_To_Compute_DataFactory(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_DataFactory
	err = actual.AssignProperties_From_Compute_DataFactory(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_DataFactory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataFactory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_DataFactory, Compute_DataFactoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_DataFactory runs a test to see if a specific instance of Compute_DataFactory round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_DataFactory(subject Compute_DataFactory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataFactory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataFactory instances for property testing - lazily instantiated by
// Compute_DataFactoryGenerator()
var compute_DataFactoryGenerator gopter.Gen

// Compute_DataFactoryGenerator returns a generator of Compute_DataFactory instances for property testing.
func Compute_DataFactoryGenerator() gopter.Gen {
	if compute_DataFactoryGenerator != nil {
		return compute_DataFactoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataFactory(generators)
	compute_DataFactoryGenerator = gen.Struct(reflect.TypeOf(Compute_DataFactory{}), generators)

	return compute_DataFactoryGenerator
}

// AddIndependentPropertyGeneratorsForCompute_DataFactory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_DataFactory(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_DataFactory_ComputeType_DataFactory))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

func Test_Compute_DataLakeAnalytics_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_DataLakeAnalytics to Compute_DataLakeAnalytics via AssignProperties_To_Compute_DataLakeAnalytics & AssignProperties_From_Compute_DataLakeAnalytics returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_DataLakeAnalytics, Compute_DataLakeAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_DataLakeAnalytics tests if a specific instance of Compute_DataLakeAnalytics can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_DataLakeAnalytics(subject Compute_DataLakeAnalytics) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_DataLakeAnalytics
	err := copied.AssignProperties_To_Compute_DataLakeAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_DataLakeAnalytics
	err = actual.AssignProperties_From_Compute_DataLakeAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_DataLakeAnalytics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataLakeAnalytics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_DataLakeAnalytics, Compute_DataLakeAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_DataLakeAnalytics runs a test to see if a specific instance of Compute_DataLakeAnalytics round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_DataLakeAnalytics(subject Compute_DataLakeAnalytics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataLakeAnalytics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataLakeAnalytics instances for property testing - lazily instantiated by
// Compute_DataLakeAnalyticsGenerator()
var compute_DataLakeAnalyticsGenerator gopter.Gen

// Compute_DataLakeAnalyticsGenerator returns a generator of Compute_DataLakeAnalytics instances for property testing.
// We first initialize compute_DataLakeAnalyticsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_DataLakeAnalyticsGenerator() gopter.Gen {
	if compute_DataLakeAnalyticsGenerator != nil {
		return compute_DataLakeAnalyticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics(generators)
	compute_DataLakeAnalyticsGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalytics{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics(generators)
	AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics(generators)
	compute_DataLakeAnalyticsGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalytics{}), generators)

	return compute_DataLakeAnalyticsGenerator
}

// AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_DataLakeAnalytics(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_DataLakeAnalytics_ComputeType_DataLakeAnalytics))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_DataLakeAnalytics(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DataLakeAnalyticsPropertiesGenerator())
}

func Test_Compute_HDInsight_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_HDInsight to Compute_HDInsight via AssignProperties_To_Compute_HDInsight & AssignProperties_From_Compute_HDInsight returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_HDInsight, Compute_HDInsightGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_HDInsight tests if a specific instance of Compute_HDInsight can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_HDInsight(subject Compute_HDInsight) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_HDInsight
	err := copied.AssignProperties_To_Compute_HDInsight(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_HDInsight
	err = actual.AssignProperties_From_Compute_HDInsight(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_HDInsight_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_HDInsight via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_HDInsight, Compute_HDInsightGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_HDInsight runs a test to see if a specific instance of Compute_HDInsight round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_HDInsight(subject Compute_HDInsight) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_HDInsight
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_HDInsight instances for property testing - lazily instantiated by Compute_HDInsightGenerator()
var compute_HDInsightGenerator gopter.Gen

// Compute_HDInsightGenerator returns a generator of Compute_HDInsight instances for property testing.
// We first initialize compute_HDInsightGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_HDInsightGenerator() gopter.Gen {
	if compute_HDInsightGenerator != nil {
		return compute_HDInsightGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_HDInsight(generators)
	compute_HDInsightGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsight{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_HDInsight(generators)
	AddRelatedPropertyGeneratorsForCompute_HDInsight(generators)
	compute_HDInsightGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsight{}), generators)

	return compute_HDInsightGenerator
}

// AddIndependentPropertyGeneratorsForCompute_HDInsight is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_HDInsight(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_HDInsight_ComputeType_HDInsight))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_HDInsight is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_HDInsight(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HDInsightPropertiesGenerator())
}

func Test_Compute_SynapseSpark_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_SynapseSpark to Compute_SynapseSpark via AssignProperties_To_Compute_SynapseSpark & AssignProperties_From_Compute_SynapseSpark returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_SynapseSpark, Compute_SynapseSparkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_SynapseSpark tests if a specific instance of Compute_SynapseSpark can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_SynapseSpark(subject Compute_SynapseSpark) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_SynapseSpark
	err := copied.AssignProperties_To_Compute_SynapseSpark(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_SynapseSpark
	err = actual.AssignProperties_From_Compute_SynapseSpark(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_SynapseSpark_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_SynapseSpark via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_SynapseSpark, Compute_SynapseSparkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_SynapseSpark runs a test to see if a specific instance of Compute_SynapseSpark round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_SynapseSpark(subject Compute_SynapseSpark) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_SynapseSpark
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_SynapseSpark instances for property testing - lazily instantiated by
// Compute_SynapseSparkGenerator()
var compute_SynapseSparkGenerator gopter.Gen

// Compute_SynapseSparkGenerator returns a generator of Compute_SynapseSpark instances for property testing.
// We first initialize compute_SynapseSparkGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_SynapseSparkGenerator() gopter.Gen {
	if compute_SynapseSparkGenerator != nil {
		return compute_SynapseSparkGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_SynapseSpark(generators)
	compute_SynapseSparkGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSpark{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_SynapseSpark(generators)
	AddRelatedPropertyGeneratorsForCompute_SynapseSpark(generators)
	compute_SynapseSparkGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSpark{}), generators)

	return compute_SynapseSparkGenerator
}

// AddIndependentPropertyGeneratorsForCompute_SynapseSpark is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_SynapseSpark(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_SynapseSpark_ComputeType_SynapseSpark))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_SynapseSpark is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_SynapseSpark(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SynapseSparkPropertiesGenerator())
}

func Test_Compute_VirtualMachine_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Compute_VirtualMachine to Compute_VirtualMachine via AssignProperties_To_Compute_VirtualMachine & AssignProperties_From_Compute_VirtualMachine returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompute_VirtualMachine, Compute_VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompute_VirtualMachine tests if a specific instance of Compute_VirtualMachine can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForCompute_VirtualMachine(subject Compute_VirtualMachine) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.Compute_VirtualMachine
	err := copied.AssignProperties_To_Compute_VirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Compute_VirtualMachine
	err = actual.AssignProperties_From_Compute_VirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Compute_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_VirtualMachine, Compute_VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_VirtualMachine runs a test to see if a specific instance of Compute_VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_VirtualMachine(subject Compute_VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_VirtualMachine instances for property testing - lazily instantiated by
// Compute_VirtualMachineGenerator()
var compute_VirtualMachineGenerator gopter.Gen

// Compute_VirtualMachineGenerator returns a generator of Compute_VirtualMachine instances for property testing.
// We first initialize compute_VirtualMachineGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Compute_VirtualMachineGenerator() gopter.Gen {
	if compute_VirtualMachineGenerator != nil {
		return compute_VirtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_VirtualMachine(generators)
	compute_VirtualMachineGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachine{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompute_VirtualMachine(generators)
	AddRelatedPropertyGeneratorsForCompute_VirtualMachine(generators)
	compute_VirtualMachineGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachine{}), generators)

	return compute_VirtualMachineGenerator
}

// AddIndependentPropertyGeneratorsForCompute_VirtualMachine is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompute_VirtualMachine(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.PtrOf(gen.OneConstOf(Compute_VirtualMachine_ComputeType_VirtualMachine))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCompute_VirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_VirtualMachine(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesGenerator())
}

func Test_ErrorResponse_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorResponse_STATUS to ErrorResponse_STATUS via AssignProperties_To_ErrorResponse_STATUS & AssignProperties_From_ErrorResponse_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorResponse_STATUS, ErrorResponse_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorResponse_STATUS tests if a specific instance of ErrorResponse_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForErrorResponse_STATUS(subject ErrorResponse_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ErrorResponse_STATUS
	err := copied.AssignProperties_To_ErrorResponse_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorResponse_STATUS
	err = actual.AssignProperties_From_ErrorResponse_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorResponse_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorResponse_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorResponse_STATUS, ErrorResponse_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorResponse_STATUS runs a test to see if a specific instance of ErrorResponse_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorResponse_STATUS(subject ErrorResponse_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorResponse_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorResponse_STATUS instances for property testing - lazily instantiated by
// ErrorResponse_STATUSGenerator()
var errorResponse_STATUSGenerator gopter.Gen

// ErrorResponse_STATUSGenerator returns a generator of ErrorResponse_STATUS instances for property testing.
func ErrorResponse_STATUSGenerator() gopter.Gen {
	if errorResponse_STATUSGenerator != nil {
		return errorResponse_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForErrorResponse_STATUS(generators)
	errorResponse_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorResponse_STATUS{}), generators)

	return errorResponse_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForErrorResponse_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorResponse_STATUS(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ErrorDetail_STATUSGenerator())
}

func Test_AKSProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AKSProperties to AKSProperties via AssignProperties_To_AKSProperties & AssignProperties_From_AKSProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAKSProperties, AKSPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAKSProperties tests if a specific instance of AKSProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAKSProperties(subject AKSProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AKSProperties
	err := copied.AssignProperties_To_AKSProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AKSProperties
	err = actual.AssignProperties_From_AKSProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AKSProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AKSProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAKSProperties, AKSPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAKSProperties runs a test to see if a specific instance of AKSProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAKSProperties(subject AKSProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AKSProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AKSProperties instances for property testing - lazily instantiated by AKSPropertiesGenerator()
var aksPropertiesGenerator gopter.Gen

// AKSPropertiesGenerator returns a generator of AKSProperties instances for property testing.
// We first initialize aksPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AKSPropertiesGenerator() gopter.Gen {
	if aksPropertiesGenerator != nil {
		return aksPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSProperties(generators)
	aksPropertiesGenerator = gen.Struct(reflect.TypeOf(AKSProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSProperties(generators)
	AddRelatedPropertyGeneratorsForAKSProperties(generators)
	aksPropertiesGenerator = gen.Struct(reflect.TypeOf(AKSProperties{}), generators)

	return aksPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAKSProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAKSProperties(gens map[string]gopter.Gen) {
	gens["AgentCount"] = gen.PtrOf(gen.Int())
	gens["AgentVmSize"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterPurpose"] = gen.PtrOf(gen.OneConstOf(AKSProperties_ClusterPurpose_DenseProd, AKSProperties_ClusterPurpose_DevTest, AKSProperties_ClusterPurpose_FastProd))
	gens["LoadBalancerSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerType"] = gen.PtrOf(gen.OneConstOf(AKSProperties_LoadBalancerType_InternalLoadBalancer, AKSProperties_LoadBalancerType_PublicIp))
}

// AddRelatedPropertyGeneratorsForAKSProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAKSProperties(gens map[string]gopter.Gen) {
	gens["AksNetworkingConfiguration"] = gen.PtrOf(AksNetworkingConfigurationGenerator())
	gens["SslConfiguration"] = gen.PtrOf(SslConfigurationGenerator())
}

func Test_AmlComputeProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AmlComputeProperties to AmlComputeProperties via AssignProperties_To_AmlComputeProperties & AssignProperties_From_AmlComputeProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAmlComputeProperties, AmlComputePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAmlComputeProperties tests if a specific instance of AmlComputeProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAmlComputeProperties(subject AmlComputeProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AmlComputeProperties
	err := copied.AssignProperties_To_AmlComputeProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AmlComputeProperties
	err = actual.AssignProperties_From_AmlComputeProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AmlComputeProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AmlComputeProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAmlComputeProperties, AmlComputePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAmlComputeProperties runs a test to see if a specific instance of AmlComputeProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAmlComputeProperties(subject AmlComputeProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AmlComputeProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AmlComputeProperties instances for property testing - lazily instantiated by
// AmlComputePropertiesGenerator()
var amlComputePropertiesGenerator gopter.Gen

// AmlComputePropertiesGenerator returns a generator of AmlComputeProperties instances for property testing.
// We first initialize amlComputePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AmlComputePropertiesGenerator() gopter.Gen {
	if amlComputePropertiesGenerator != nil {
		return amlComputePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties(generators)
	amlComputePropertiesGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties(generators)
	AddRelatedPropertyGeneratorsForAmlComputeProperties(generators)
	amlComputePropertiesGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties{}), generators)

	return amlComputePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAmlComputeProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAmlComputeProperties(gens map[string]gopter.Gen) {
	gens["EnableNodePublicIp"] = gen.PtrOf(gen.Bool())
	gens["IsolatedNetwork"] = gen.PtrOf(gen.Bool())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_OsType_Linux, AmlComputeProperties_OsType_Windows))
	gens["RemoteLoginPortPublicAccess"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled, AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled, AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified))
	gens["VmPriority"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_VmPriority_Dedicated, AmlComputeProperties_VmPriority_LowPriority))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAmlComputeProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAmlComputeProperties(gens map[string]gopter.Gen) {
	gens["ScaleSettings"] = gen.PtrOf(ScaleSettingsGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceIdGenerator())
	gens["UserAccountCredentials"] = gen.PtrOf(UserAccountCredentialsGenerator())
	gens["VirtualMachineImage"] = gen.PtrOf(VirtualMachineImageGenerator())
}

func Test_ComputeInstanceProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ComputeInstanceProperties to ComputeInstanceProperties via AssignProperties_To_ComputeInstanceProperties & AssignProperties_From_ComputeInstanceProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForComputeInstanceProperties, ComputeInstancePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForComputeInstanceProperties tests if a specific instance of ComputeInstanceProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForComputeInstanceProperties(subject ComputeInstanceProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ComputeInstanceProperties
	err := copied.AssignProperties_To_ComputeInstanceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ComputeInstanceProperties
	err = actual.AssignProperties_From_ComputeInstanceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ComputeInstanceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceProperties, ComputeInstancePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceProperties runs a test to see if a specific instance of ComputeInstanceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceProperties(subject ComputeInstanceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceProperties instances for property testing - lazily instantiated by
// ComputeInstancePropertiesGenerator()
var computeInstancePropertiesGenerator gopter.Gen

// ComputeInstancePropertiesGenerator returns a generator of ComputeInstanceProperties instances for property testing.
// We first initialize computeInstancePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeInstancePropertiesGenerator() gopter.Gen {
	if computeInstancePropertiesGenerator != nil {
		return computeInstancePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties(generators)
	computeInstancePropertiesGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties(generators)
	AddRelatedPropertyGeneratorsForComputeInstanceProperties(generators)
	computeInstancePropertiesGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties{}), generators)

	return computeInstancePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceProperties(gens map[string]gopter.Gen) {
	gens["ApplicationSharingPolicy"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ApplicationSharingPolicy_Personal, ComputeInstanceProperties_ApplicationSharingPolicy_Shared))
	gens["ComputeInstanceAuthorizationType"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeInstanceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeInstanceProperties(gens map[string]gopter.Gen) {
	gens["PersonalComputeInstanceSettings"] = gen.PtrOf(PersonalComputeInstanceSettingsGenerator())
	gens["SetupScripts"] = gen.PtrOf(SetupScriptsGenerator())
	gens["SshSettings"] = gen.PtrOf(ComputeInstanceSshSettingsGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceIdGenerator())
}

func Test_DatabricksProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabricksProperties to DatabricksProperties via AssignProperties_To_DatabricksProperties & AssignProperties_From_DatabricksProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabricksProperties, DatabricksPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabricksProperties tests if a specific instance of DatabricksProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForDatabricksProperties(subject DatabricksProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.DatabricksProperties
	err := copied.AssignProperties_To_DatabricksProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabricksProperties
	err = actual.AssignProperties_From_DatabricksProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabricksProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabricksProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabricksProperties, DatabricksPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabricksProperties runs a test to see if a specific instance of DatabricksProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabricksProperties(subject DatabricksProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabricksProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabricksProperties instances for property testing - lazily instantiated by
// DatabricksPropertiesGenerator()
var databricksPropertiesGenerator gopter.Gen

// DatabricksPropertiesGenerator returns a generator of DatabricksProperties instances for property testing.
func DatabricksPropertiesGenerator() gopter.Gen {
	if databricksPropertiesGenerator != nil {
		return databricksPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricksProperties(generators)
	databricksPropertiesGenerator = gen.Struct(reflect.TypeOf(DatabricksProperties{}), generators)

	return databricksPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForDatabricksProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabricksProperties(gens map[string]gopter.Gen) {
	gens["DatabricksAccessToken"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeAnalyticsProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataLakeAnalyticsProperties to DataLakeAnalyticsProperties via AssignProperties_To_DataLakeAnalyticsProperties & AssignProperties_From_DataLakeAnalyticsProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataLakeAnalyticsProperties, DataLakeAnalyticsPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataLakeAnalyticsProperties tests if a specific instance of DataLakeAnalyticsProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForDataLakeAnalyticsProperties(subject DataLakeAnalyticsProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.DataLakeAnalyticsProperties
	err := copied.AssignProperties_To_DataLakeAnalyticsProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataLakeAnalyticsProperties
	err = actual.AssignProperties_From_DataLakeAnalyticsProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataLakeAnalyticsProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeAnalyticsProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeAnalyticsProperties, DataLakeAnalyticsPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeAnalyticsProperties runs a test to see if a specific instance of DataLakeAnalyticsProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeAnalyticsProperties(subject DataLakeAnalyticsProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeAnalyticsProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeAnalyticsProperties instances for property testing - lazily instantiated by
// DataLakeAnalyticsPropertiesGenerator()
var dataLakeAnalyticsPropertiesGenerator gopter.Gen

// DataLakeAnalyticsPropertiesGenerator returns a generator of DataLakeAnalyticsProperties instances for property testing.
func DataLakeAnalyticsPropertiesGenerator() gopter.Gen {
	if dataLakeAnalyticsPropertiesGenerator != nil {
		return dataLakeAnalyticsPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties(generators)
	dataLakeAnalyticsPropertiesGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalyticsProperties{}), generators)

	return dataLakeAnalyticsPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeAnalyticsProperties(gens map[string]gopter.Gen) {
	gens["DataLakeStoreAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorDetail_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorDetail_STATUS to ErrorDetail_STATUS via AssignProperties_To_ErrorDetail_STATUS & AssignProperties_From_ErrorDetail_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorDetail_STATUS tests if a specific instance of ErrorDetail_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ErrorDetail_STATUS
	err := copied.AssignProperties_To_ErrorDetail_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorDetail_STATUS
	err = actual.AssignProperties_From_ErrorDetail_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorDetail_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS runs a test to see if a specific instance of ErrorDetail_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS instances for property testing - lazily instantiated by ErrorDetail_STATUSGenerator()
var errorDetail_STATUSGenerator gopter.Gen

// ErrorDetail_STATUSGenerator returns a generator of ErrorDetail_STATUS instances for property testing.
// We first initialize errorDetail_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUSGenerator() gopter.Gen {
	if errorDetail_STATUSGenerator != nil {
		return errorDetail_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	return errorDetail_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
	gens["Details"] = gen.SliceOf(ErrorDetail_STATUS_UnrolledGenerator())
}

func Test_HDInsightProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HDInsightProperties to HDInsightProperties via AssignProperties_To_HDInsightProperties & AssignProperties_From_HDInsightProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForHDInsightProperties, HDInsightPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHDInsightProperties tests if a specific instance of HDInsightProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForHDInsightProperties(subject HDInsightProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.HDInsightProperties
	err := copied.AssignProperties_To_HDInsightProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HDInsightProperties
	err = actual.AssignProperties_From_HDInsightProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HDInsightProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HDInsightProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHDInsightProperties, HDInsightPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHDInsightProperties runs a test to see if a specific instance of HDInsightProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHDInsightProperties(subject HDInsightProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HDInsightProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HDInsightProperties instances for property testing - lazily instantiated by
// HDInsightPropertiesGenerator()
var hdInsightPropertiesGenerator gopter.Gen

// HDInsightPropertiesGenerator returns a generator of HDInsightProperties instances for property testing.
// We first initialize hdInsightPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HDInsightPropertiesGenerator() gopter.Gen {
	if hdInsightPropertiesGenerator != nil {
		return hdInsightPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties(generators)
	hdInsightPropertiesGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties(generators)
	AddRelatedPropertyGeneratorsForHDInsightProperties(generators)
	hdInsightPropertiesGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties{}), generators)

	return hdInsightPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHDInsightProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHDInsightProperties(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["SshPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHDInsightProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHDInsightProperties(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentialsGenerator())
}

func Test_SynapseSparkProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SynapseSparkProperties to SynapseSparkProperties via AssignProperties_To_SynapseSparkProperties & AssignProperties_From_SynapseSparkProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForSynapseSparkProperties, SynapseSparkPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSynapseSparkProperties tests if a specific instance of SynapseSparkProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSynapseSparkProperties(subject SynapseSparkProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SynapseSparkProperties
	err := copied.AssignProperties_To_SynapseSparkProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SynapseSparkProperties
	err = actual.AssignProperties_From_SynapseSparkProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SynapseSparkProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SynapseSparkProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSynapseSparkProperties, SynapseSparkPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSynapseSparkProperties runs a test to see if a specific instance of SynapseSparkProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForSynapseSparkProperties(subject SynapseSparkProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SynapseSparkProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SynapseSparkProperties instances for property testing - lazily instantiated by
// SynapseSparkPropertiesGenerator()
var synapseSparkPropertiesGenerator gopter.Gen

// SynapseSparkPropertiesGenerator returns a generator of SynapseSparkProperties instances for property testing.
// We first initialize synapseSparkPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SynapseSparkPropertiesGenerator() gopter.Gen {
	if synapseSparkPropertiesGenerator != nil {
		return synapseSparkPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkProperties(generators)
	synapseSparkPropertiesGenerator = gen.Struct(reflect.TypeOf(SynapseSparkProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkProperties(generators)
	AddRelatedPropertyGeneratorsForSynapseSparkProperties(generators)
	synapseSparkPropertiesGenerator = gen.Struct(reflect.TypeOf(SynapseSparkProperties{}), generators)

	return synapseSparkPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForSynapseSparkProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSynapseSparkProperties(gens map[string]gopter.Gen) {
	gens["NodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeSize"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSizeFamily"] = gen.PtrOf(gen.AlphaString())
	gens["PoolName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SparkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSynapseSparkProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSynapseSparkProperties(gens map[string]gopter.Gen) {
	gens["AutoPauseProperties"] = gen.PtrOf(AutoPausePropertiesGenerator())
	gens["AutoScaleProperties"] = gen.PtrOf(AutoScalePropertiesGenerator())
}

func Test_VirtualMachineProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineProperties to VirtualMachineProperties via AssignProperties_To_VirtualMachineProperties & AssignProperties_From_VirtualMachineProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineProperties, VirtualMachinePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineProperties tests if a specific instance of VirtualMachineProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineProperties(subject VirtualMachineProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.VirtualMachineProperties
	err := copied.AssignProperties_To_VirtualMachineProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineProperties
	err = actual.AssignProperties_From_VirtualMachineProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties, VirtualMachinePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties runs a test to see if a specific instance of VirtualMachineProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties(subject VirtualMachineProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties instances for property testing - lazily instantiated by
// VirtualMachinePropertiesGenerator()
var virtualMachinePropertiesGenerator gopter.Gen

// VirtualMachinePropertiesGenerator returns a generator of VirtualMachineProperties instances for property testing.
// We first initialize virtualMachinePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesGenerator() gopter.Gen {
	if virtualMachinePropertiesGenerator != nil {
		return virtualMachinePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties(generators)
	virtualMachinePropertiesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties(generators)
	virtualMachinePropertiesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties{}), generators)

	return virtualMachinePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["IsNotebookInstanceCompute"] = gen.PtrOf(gen.Bool())
	gens["SshPort"] = gen.PtrOf(gen.Int())
	gens["VirtualMachineSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentialsGenerator())
}

func Test_AksNetworkingConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AksNetworkingConfiguration to AksNetworkingConfiguration via AssignProperties_To_AksNetworkingConfiguration & AssignProperties_From_AksNetworkingConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForAksNetworkingConfiguration, AksNetworkingConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAksNetworkingConfiguration tests if a specific instance of AksNetworkingConfiguration can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAksNetworkingConfiguration(subject AksNetworkingConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AksNetworkingConfiguration
	err := copied.AssignProperties_To_AksNetworkingConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AksNetworkingConfiguration
	err = actual.AssignProperties_From_AksNetworkingConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AksNetworkingConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AksNetworkingConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAksNetworkingConfiguration, AksNetworkingConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAksNetworkingConfiguration runs a test to see if a specific instance of AksNetworkingConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAksNetworkingConfiguration(subject AksNetworkingConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AksNetworkingConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AksNetworkingConfiguration instances for property testing - lazily instantiated by
// AksNetworkingConfigurationGenerator()
var aksNetworkingConfigurationGenerator gopter.Gen

// AksNetworkingConfigurationGenerator returns a generator of AksNetworkingConfiguration instances for property testing.
func AksNetworkingConfigurationGenerator() gopter.Gen {
	if aksNetworkingConfigurationGenerator != nil {
		return aksNetworkingConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAksNetworkingConfiguration(generators)
	aksNetworkingConfigurationGenerator = gen.Struct(reflect.TypeOf(AksNetworkingConfiguration{}), generators)

	return aksNetworkingConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAksNetworkingConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAksNetworkingConfiguration(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoPauseProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoPauseProperties to AutoPauseProperties via AssignProperties_To_AutoPauseProperties & AssignProperties_From_AutoPauseProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoPauseProperties, AutoPausePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoPauseProperties tests if a specific instance of AutoPauseProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAutoPauseProperties(subject AutoPauseProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AutoPauseProperties
	err := copied.AssignProperties_To_AutoPauseProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoPauseProperties
	err = actual.AssignProperties_From_AutoPauseProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoPauseProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoPauseProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoPauseProperties, AutoPausePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoPauseProperties runs a test to see if a specific instance of AutoPauseProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoPauseProperties(subject AutoPauseProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoPauseProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoPauseProperties instances for property testing - lazily instantiated by
// AutoPausePropertiesGenerator()
var autoPausePropertiesGenerator gopter.Gen

// AutoPausePropertiesGenerator returns a generator of AutoPauseProperties instances for property testing.
func AutoPausePropertiesGenerator() gopter.Gen {
	if autoPausePropertiesGenerator != nil {
		return autoPausePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoPauseProperties(generators)
	autoPausePropertiesGenerator = gen.Struct(reflect.TypeOf(AutoPauseProperties{}), generators)

	return autoPausePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAutoPauseProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoPauseProperties(gens map[string]gopter.Gen) {
	gens["DelayInMinutes"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AutoScaleProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoScaleProperties to AutoScaleProperties via AssignProperties_To_AutoScaleProperties & AssignProperties_From_AutoScaleProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoScaleProperties, AutoScalePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoScaleProperties tests if a specific instance of AutoScaleProperties can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAutoScaleProperties(subject AutoScaleProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AutoScaleProperties
	err := copied.AssignProperties_To_AutoScaleProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoScaleProperties
	err = actual.AssignProperties_From_AutoScaleProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoScaleProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScaleProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScaleProperties, AutoScalePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScaleProperties runs a test to see if a specific instance of AutoScaleProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScaleProperties(subject AutoScaleProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScaleProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScaleProperties instances for property testing - lazily instantiated by
// AutoScalePropertiesGenerator()
var autoScalePropertiesGenerator gopter.Gen

// AutoScalePropertiesGenerator returns a generator of AutoScaleProperties instances for property testing.
func AutoScalePropertiesGenerator() gopter.Gen {
	if autoScalePropertiesGenerator != nil {
		return autoScalePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScaleProperties(generators)
	autoScalePropertiesGenerator = gen.Struct(reflect.TypeOf(AutoScaleProperties{}), generators)

	return autoScalePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAutoScaleProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScaleProperties(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
}

func Test_ComputeInstanceSshSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ComputeInstanceSshSettings to ComputeInstanceSshSettings via AssignProperties_To_ComputeInstanceSshSettings & AssignProperties_From_ComputeInstanceSshSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForComputeInstanceSshSettings, ComputeInstanceSshSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForComputeInstanceSshSettings tests if a specific instance of ComputeInstanceSshSettings can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForComputeInstanceSshSettings(subject ComputeInstanceSshSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ComputeInstanceSshSettings
	err := copied.AssignProperties_To_ComputeInstanceSshSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ComputeInstanceSshSettings
	err = actual.AssignProperties_From_ComputeInstanceSshSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ComputeInstanceSshSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceSshSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceSshSettings, ComputeInstanceSshSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceSshSettings runs a test to see if a specific instance of ComputeInstanceSshSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceSshSettings(subject ComputeInstanceSshSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceSshSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceSshSettings instances for property testing - lazily instantiated by
// ComputeInstanceSshSettingsGenerator()
var computeInstanceSshSettingsGenerator gopter.Gen

// ComputeInstanceSshSettingsGenerator returns a generator of ComputeInstanceSshSettings instances for property testing.
func ComputeInstanceSshSettingsGenerator() gopter.Gen {
	if computeInstanceSshSettingsGenerator != nil {
		return computeInstanceSshSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceSshSettings(generators)
	computeInstanceSshSettingsGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceSshSettings{}), generators)

	return computeInstanceSshSettingsGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceSshSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceSshSettings(gens map[string]gopter.Gen) {
	gens["AdminPublicKey"] = gen.PtrOf(gen.AlphaString())
	gens["SshPublicAccess"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceSshSettings_SshPublicAccess_Disabled, ComputeInstanceSshSettings_SshPublicAccess_Enabled))
}

func Test_ErrorAdditionalInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorAdditionalInfo_STATUS to ErrorAdditionalInfo_STATUS via AssignProperties_To_ErrorAdditionalInfo_STATUS & AssignProperties_From_ErrorAdditionalInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS tests if a specific instance of ErrorAdditionalInfo_STATUS can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ErrorAdditionalInfo_STATUS
	err := copied.AssignProperties_To_ErrorAdditionalInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorAdditionalInfo_STATUS
	err = actual.AssignProperties_From_ErrorAdditionalInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorAdditionalInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorAdditionalInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorAdditionalInfo_STATUS runs a test to see if a specific instance of ErrorAdditionalInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorAdditionalInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorAdditionalInfo_STATUS instances for property testing - lazily instantiated by
// ErrorAdditionalInfo_STATUSGenerator()
var errorAdditionalInfo_STATUSGenerator gopter.Gen

// ErrorAdditionalInfo_STATUSGenerator returns a generator of ErrorAdditionalInfo_STATUS instances for property testing.
func ErrorAdditionalInfo_STATUSGenerator() gopter.Gen {
	if errorAdditionalInfo_STATUSGenerator != nil {
		return errorAdditionalInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(generators)
	errorAdditionalInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorAdditionalInfo_STATUS{}), generators)

	return errorAdditionalInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorDetail_STATUS_Unrolled_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorDetail_STATUS_Unrolled to ErrorDetail_STATUS_Unrolled via AssignProperties_To_ErrorDetail_STATUS_Unrolled & AssignProperties_From_ErrorDetail_STATUS_Unrolled returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled tests if a specific instance of ErrorDetail_STATUS_Unrolled can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ErrorDetail_STATUS_Unrolled
	err := copied.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorDetail_STATUS_Unrolled
	err = actual.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorDetail_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS_Unrolled runs a test to see if a specific instance of ErrorDetail_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS_Unrolled instances for property testing - lazily instantiated by
// ErrorDetail_STATUS_UnrolledGenerator()
var errorDetail_STATUS_UnrolledGenerator gopter.Gen

// ErrorDetail_STATUS_UnrolledGenerator returns a generator of ErrorDetail_STATUS_Unrolled instances for property testing.
// We first initialize errorDetail_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUS_UnrolledGenerator() gopter.Gen {
	if errorDetail_STATUS_UnrolledGenerator != nil {
		return errorDetail_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	return errorDetail_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
}

func Test_PersonalComputeInstanceSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PersonalComputeInstanceSettings to PersonalComputeInstanceSettings via AssignProperties_To_PersonalComputeInstanceSettings & AssignProperties_From_PersonalComputeInstanceSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForPersonalComputeInstanceSettings, PersonalComputeInstanceSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPersonalComputeInstanceSettings tests if a specific instance of PersonalComputeInstanceSettings can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForPersonalComputeInstanceSettings(subject PersonalComputeInstanceSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.PersonalComputeInstanceSettings
	err := copied.AssignProperties_To_PersonalComputeInstanceSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PersonalComputeInstanceSettings
	err = actual.AssignProperties_From_PersonalComputeInstanceSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PersonalComputeInstanceSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PersonalComputeInstanceSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPersonalComputeInstanceSettings, PersonalComputeInstanceSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPersonalComputeInstanceSettings runs a test to see if a specific instance of PersonalComputeInstanceSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForPersonalComputeInstanceSettings(subject PersonalComputeInstanceSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PersonalComputeInstanceSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PersonalComputeInstanceSettings instances for property testing - lazily instantiated by
// PersonalComputeInstanceSettingsGenerator()
var personalComputeInstanceSettingsGenerator gopter.Gen

// PersonalComputeInstanceSettingsGenerator returns a generator of PersonalComputeInstanceSettings instances for property testing.
func PersonalComputeInstanceSettingsGenerator() gopter.Gen {
	if personalComputeInstanceSettingsGenerator != nil {
		return personalComputeInstanceSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings(generators)
	personalComputeInstanceSettingsGenerator = gen.Struct(reflect.TypeOf(PersonalComputeInstanceSettings{}), generators)

	return personalComputeInstanceSettingsGenerator
}

// AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings(gens map[string]gopter.Gen) {
	gens["AssignedUser"] = gen.PtrOf(AssignedUserGenerator())
}

func Test_ResourceId_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceId to ResourceId via AssignProperties_To_ResourceId & AssignProperties_From_ResourceId returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceId, ResourceIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceId tests if a specific instance of ResourceId can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForResourceId(subject ResourceId) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ResourceId
	err := copied.AssignProperties_To_ResourceId(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceId
	err = actual.AssignProperties_From_ResourceId(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceId, ResourceIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceId runs a test to see if a specific instance of ResourceId round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceId(subject ResourceId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceId instances for property testing - lazily instantiated by ResourceIdGenerator()
var resourceIdGenerator gopter.Gen

// ResourceIdGenerator returns a generator of ResourceId instances for property testing.
func ResourceIdGenerator() gopter.Gen {
	if resourceIdGenerator != nil {
		return resourceIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	resourceIdGenerator = gen.Struct(reflect.TypeOf(ResourceId{}), generators)

	return resourceIdGenerator
}

func Test_ScaleSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleSettings to ScaleSettings via AssignProperties_To_ScaleSettings & AssignProperties_From_ScaleSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleSettings, ScaleSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleSettings tests if a specific instance of ScaleSettings can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForScaleSettings(subject ScaleSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ScaleSettings
	err := copied.AssignProperties_To_ScaleSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleSettings
	err = actual.AssignProperties_From_ScaleSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleSettings, ScaleSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleSettings runs a test to see if a specific instance of ScaleSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleSettings(subject ScaleSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleSettings instances for property testing - lazily instantiated by ScaleSettingsGenerator()
var scaleSettingsGenerator gopter.Gen

// ScaleSettingsGenerator returns a generator of ScaleSettings instances for property testing.
func ScaleSettingsGenerator() gopter.Gen {
	if scaleSettingsGenerator != nil {
		return scaleSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleSettings(generators)
	scaleSettingsGenerator = gen.Struct(reflect.TypeOf(ScaleSettings{}), generators)

	return scaleSettingsGenerator
}

// AddIndependentPropertyGeneratorsForScaleSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleSettings(gens map[string]gopter.Gen) {
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeIdleTimeBeforeScaleDown"] = gen.PtrOf(gen.AlphaString())
}

func Test_SetupScripts_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SetupScripts to SetupScripts via AssignProperties_To_SetupScripts & AssignProperties_From_SetupScripts returns original",
		prop.ForAll(RunPropertyAssignmentTestForSetupScripts, SetupScriptsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSetupScripts tests if a specific instance of SetupScripts can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSetupScripts(subject SetupScripts) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SetupScripts
	err := copied.AssignProperties_To_SetupScripts(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SetupScripts
	err = actual.AssignProperties_From_SetupScripts(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SetupScripts_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SetupScripts via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSetupScripts, SetupScriptsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSetupScripts runs a test to see if a specific instance of SetupScripts round trips to JSON and back losslessly
func RunJSONSerializationTestForSetupScripts(subject SetupScripts) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SetupScripts
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SetupScripts instances for property testing - lazily instantiated by SetupScriptsGenerator()
var setupScriptsGenerator gopter.Gen

// SetupScriptsGenerator returns a generator of SetupScripts instances for property testing.
func SetupScriptsGenerator() gopter.Gen {
	if setupScriptsGenerator != nil {
		return setupScriptsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSetupScripts(generators)
	setupScriptsGenerator = gen.Struct(reflect.TypeOf(SetupScripts{}), generators)

	return setupScriptsGenerator
}

// AddRelatedPropertyGeneratorsForSetupScripts is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSetupScripts(gens map[string]gopter.Gen) {
	gens["Scripts"] = gen.PtrOf(ScriptsToExecuteGenerator())
}

func Test_SslConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SslConfiguration to SslConfiguration via AssignProperties_To_SslConfiguration & AssignProperties_From_SslConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForSslConfiguration, SslConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSslConfiguration tests if a specific instance of SslConfiguration can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForSslConfiguration(subject SslConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.SslConfiguration
	err := copied.AssignProperties_To_SslConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SslConfiguration
	err = actual.AssignProperties_From_SslConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SslConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslConfiguration, SslConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslConfiguration runs a test to see if a specific instance of SslConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForSslConfiguration(subject SslConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslConfiguration instances for property testing - lazily instantiated by SslConfigurationGenerator()
var sslConfigurationGenerator gopter.Gen

// SslConfigurationGenerator returns a generator of SslConfiguration instances for property testing.
func SslConfigurationGenerator() gopter.Gen {
	if sslConfigurationGenerator != nil {
		return sslConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslConfiguration(generators)
	sslConfigurationGenerator = gen.Struct(reflect.TypeOf(SslConfiguration{}), generators)

	return sslConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForSslConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslConfiguration(gens map[string]gopter.Gen) {
	gens["Cert"] = gen.PtrOf(gen.AlphaString())
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["LeafDomainLabel"] = gen.PtrOf(gen.AlphaString())
	gens["OverwriteExistingDomain"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(SslConfiguration_Status_Auto, SslConfiguration_Status_Disabled, SslConfiguration_Status_Enabled))
}

func Test_UserAccountCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAccountCredentials to UserAccountCredentials via AssignProperties_To_UserAccountCredentials & AssignProperties_From_UserAccountCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAccountCredentials, UserAccountCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAccountCredentials tests if a specific instance of UserAccountCredentials can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForUserAccountCredentials(subject UserAccountCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.UserAccountCredentials
	err := copied.AssignProperties_To_UserAccountCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAccountCredentials
	err = actual.AssignProperties_From_UserAccountCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAccountCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAccountCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAccountCredentials, UserAccountCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAccountCredentials runs a test to see if a specific instance of UserAccountCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAccountCredentials(subject UserAccountCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAccountCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAccountCredentials instances for property testing - lazily instantiated by
// UserAccountCredentialsGenerator()
var userAccountCredentialsGenerator gopter.Gen

// UserAccountCredentialsGenerator returns a generator of UserAccountCredentials instances for property testing.
func UserAccountCredentialsGenerator() gopter.Gen {
	if userAccountCredentialsGenerator != nil {
		return userAccountCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAccountCredentials(generators)
	userAccountCredentialsGenerator = gen.Struct(reflect.TypeOf(UserAccountCredentials{}), generators)

	return userAccountCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForUserAccountCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAccountCredentials(gens map[string]gopter.Gen) {
	gens["AdminUserName"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineImage_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineImage to VirtualMachineImage via AssignProperties_To_VirtualMachineImage & AssignProperties_From_VirtualMachineImage returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineImage, VirtualMachineImageGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineImage tests if a specific instance of VirtualMachineImage can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineImage(subject VirtualMachineImage) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.VirtualMachineImage
	err := copied.AssignProperties_To_VirtualMachineImage(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineImage
	err = actual.AssignProperties_From_VirtualMachineImage(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineImage_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineImage via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineImage, VirtualMachineImageGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineImage runs a test to see if a specific instance of VirtualMachineImage round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineImage(subject VirtualMachineImage) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineImage
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineImage instances for property testing - lazily instantiated by
// VirtualMachineImageGenerator()
var virtualMachineImageGenerator gopter.Gen

// VirtualMachineImageGenerator returns a generator of VirtualMachineImage instances for property testing.
func VirtualMachineImageGenerator() gopter.Gen {
	if virtualMachineImageGenerator != nil {
		return virtualMachineImageGenerator
	}

	generators := make(map[string]gopter.Gen)
	virtualMachineImageGenerator = gen.Struct(reflect.TypeOf(VirtualMachineImage{}), generators)

	return virtualMachineImageGenerator
}

func Test_VirtualMachineSshCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineSshCredentials to VirtualMachineSshCredentials via AssignProperties_To_VirtualMachineSshCredentials & AssignProperties_From_VirtualMachineSshCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineSshCredentials, VirtualMachineSshCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineSshCredentials tests if a specific instance of VirtualMachineSshCredentials can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineSshCredentials(subject VirtualMachineSshCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.VirtualMachineSshCredentials
	err := copied.AssignProperties_To_VirtualMachineSshCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineSshCredentials
	err = actual.AssignProperties_From_VirtualMachineSshCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineSshCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineSshCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineSshCredentials, VirtualMachineSshCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineSshCredentials runs a test to see if a specific instance of VirtualMachineSshCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineSshCredentials(subject VirtualMachineSshCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineSshCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineSshCredentials instances for property testing - lazily instantiated by
// VirtualMachineSshCredentialsGenerator()
var virtualMachineSshCredentialsGenerator gopter.Gen

// VirtualMachineSshCredentialsGenerator returns a generator of VirtualMachineSshCredentials instances for property testing.
func VirtualMachineSshCredentialsGenerator() gopter.Gen {
	if virtualMachineSshCredentialsGenerator != nil {
		return virtualMachineSshCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials(generators)
	virtualMachineSshCredentialsGenerator = gen.Struct(reflect.TypeOf(VirtualMachineSshCredentials{}), generators)

	return virtualMachineSshCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials(gens map[string]gopter.Gen) {
	gens["PrivateKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["PublicKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_AssignedUser_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AssignedUser to AssignedUser via AssignProperties_To_AssignedUser & AssignProperties_From_AssignedUser returns original",
		prop.ForAll(RunPropertyAssignmentTestForAssignedUser, AssignedUserGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAssignedUser tests if a specific instance of AssignedUser can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForAssignedUser(subject AssignedUser) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.AssignedUser
	err := copied.AssignProperties_To_AssignedUser(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AssignedUser
	err = actual.AssignProperties_From_AssignedUser(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AssignedUser_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AssignedUser via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAssignedUser, AssignedUserGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAssignedUser runs a test to see if a specific instance of AssignedUser round trips to JSON and back losslessly
func RunJSONSerializationTestForAssignedUser(subject AssignedUser) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AssignedUser
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AssignedUser instances for property testing - lazily instantiated by AssignedUserGenerator()
var assignedUserGenerator gopter.Gen

// AssignedUserGenerator returns a generator of AssignedUser instances for property testing.
func AssignedUserGenerator() gopter.Gen {
	if assignedUserGenerator != nil {
		return assignedUserGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAssignedUser(generators)
	assignedUserGenerator = gen.Struct(reflect.TypeOf(AssignedUser{}), generators)

	return assignedUserGenerator
}

// AddIndependentPropertyGeneratorsForAssignedUser is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAssignedUser(gens map[string]gopter.Gen) {
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScriptsToExecute_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScriptsToExecute to ScriptsToExecute via AssignProperties_To_ScriptsToExecute & AssignProperties_From_ScriptsToExecute returns original",
		prop.ForAll(RunPropertyAssignmentTestForScriptsToExecute, ScriptsToExecuteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScriptsToExecute tests if a specific instance of ScriptsToExecute can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForScriptsToExecute(subject ScriptsToExecute) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ScriptsToExecute
	err := copied.AssignProperties_To_ScriptsToExecute(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScriptsToExecute
	err = actual.AssignProperties_From_ScriptsToExecute(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScriptsToExecute_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptsToExecute via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptsToExecute, ScriptsToExecuteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptsToExecute runs a test to see if a specific instance of ScriptsToExecute round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptsToExecute(subject ScriptsToExecute) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptsToExecute
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptsToExecute instances for property testing - lazily instantiated by ScriptsToExecuteGenerator()
var scriptsToExecuteGenerator gopter.Gen

// ScriptsToExecuteGenerator returns a generator of ScriptsToExecute instances for property testing.
func ScriptsToExecuteGenerator() gopter.Gen {
	if scriptsToExecuteGenerator != nil {
		return scriptsToExecuteGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScriptsToExecute(generators)
	scriptsToExecuteGenerator = gen.Struct(reflect.TypeOf(ScriptsToExecute{}), generators)

	return scriptsToExecuteGenerator
}

// AddRelatedPropertyGeneratorsForScriptsToExecute is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScriptsToExecute(gens map[string]gopter.Gen) {
	gens["CreationScript"] = gen.PtrOf(ScriptReferenceGenerator())
	gens["StartupScript"] = gen.PtrOf(ScriptReferenceGenerator())
}

func Test_ScriptReference_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScriptReference to ScriptReference via AssignProperties_To_ScriptReference & AssignProperties_From_ScriptReference returns original",
		prop.ForAll(RunPropertyAssignmentTestForScriptReference, ScriptReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScriptReference tests if a specific instance of ScriptReference can be assigned to v1beta20210701storage and back losslessly
func RunPropertyAssignmentTestForScriptReference(subject ScriptReference) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210701s.ScriptReference
	err := copied.AssignProperties_To_ScriptReference(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScriptReference
	err = actual.AssignProperties_From_ScriptReference(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScriptReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptReference, ScriptReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptReference runs a test to see if a specific instance of ScriptReference round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptReference(subject ScriptReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptReference instances for property testing - lazily instantiated by ScriptReferenceGenerator()
var scriptReferenceGenerator gopter.Gen

// ScriptReferenceGenerator returns a generator of ScriptReference instances for property testing.
func ScriptReferenceGenerator() gopter.Gen {
	if scriptReferenceGenerator != nil {
		return scriptReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScriptReference(generators)
	scriptReferenceGenerator = gen.Struct(reflect.TypeOf(ScriptReference{}), generators)

	return scriptReferenceGenerator
}

// AddIndependentPropertyGeneratorsForScriptReference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScriptReference(gens map[string]gopter.Gen) {
	gens["ScriptArguments"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptData"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptSource"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.AlphaString())
}
