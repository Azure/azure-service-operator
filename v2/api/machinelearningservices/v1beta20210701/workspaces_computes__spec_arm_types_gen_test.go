// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210701

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_WorkspacesComputes_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspacesComputes_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspacesComputesSpecARM, WorkspacesComputesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspacesComputesSpecARM runs a test to see if a specific instance of WorkspacesComputes_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspacesComputesSpecARM(subject WorkspacesComputes_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspacesComputes_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspacesComputes_SpecARM instances for property testing - lazily instantiated by
// WorkspacesComputesSpecARMGenerator()
var workspacesComputesSpecARMGenerator gopter.Gen

// WorkspacesComputesSpecARMGenerator returns a generator of WorkspacesComputes_SpecARM instances for property testing.
// We first initialize workspacesComputesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WorkspacesComputesSpecARMGenerator() gopter.Gen {
	if workspacesComputesSpecARMGenerator != nil {
		return workspacesComputesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspacesComputesSpecARM(generators)
	workspacesComputesSpecARMGenerator = gen.Struct(reflect.TypeOf(WorkspacesComputes_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspacesComputesSpecARM(generators)
	AddRelatedPropertyGeneratorsForWorkspacesComputesSpecARM(generators)
	workspacesComputesSpecARMGenerator = gen.Struct(reflect.TypeOf(WorkspacesComputes_SpecARM{}), generators)

	return workspacesComputesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspacesComputesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspacesComputesSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspacesComputesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspacesComputesSpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(ComputeARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataARMGenerator())
}

func Test_ComputeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeARM, ComputeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeARM runs a test to see if a specific instance of ComputeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeARM(subject ComputeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeARM instances for property testing - lazily instantiated by ComputeARMGenerator()
var computeARMGenerator gopter.Gen

// ComputeARMGenerator returns a generator of ComputeARM instances for property testing.
func ComputeARMGenerator() gopter.Gen {
	if computeARMGenerator != nil {
		return computeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForComputeARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(ComputeARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	computeARMGenerator = gen.OneGenOf(gens...)

	return computeARMGenerator
}

// AddRelatedPropertyGeneratorsForComputeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeARM(gens map[string]gopter.Gen) {
	gens["AKS"] = ComputeAKSARMGenerator().Map(func(it Compute_AKSARM) *Compute_AKSARM {
		return &it
	}) // generate one case for OneOf type
	gens["AmlCompute"] = ComputeAmlComputeARMGenerator().Map(func(it Compute_AmlComputeARM) *Compute_AmlComputeARM {
		return &it
	}) // generate one case for OneOf type
	gens["ComputeInstance"] = ComputeComputeInstanceARMGenerator().Map(func(it Compute_ComputeInstanceARM) *Compute_ComputeInstanceARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataFactory"] = ComputeDataFactoryARMGenerator().Map(func(it Compute_DataFactoryARM) *Compute_DataFactoryARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataLakeAnalytics"] = ComputeDataLakeAnalyticsARMGenerator().Map(func(it Compute_DataLakeAnalyticsARM) *Compute_DataLakeAnalyticsARM {
		return &it
	}) // generate one case for OneOf type
	gens["Databricks"] = ComputeDatabricksARMGenerator().Map(func(it Compute_DatabricksARM) *Compute_DatabricksARM {
		return &it
	}) // generate one case for OneOf type
	gens["HDInsight"] = ComputeHDInsightARMGenerator().Map(func(it Compute_HDInsightARM) *Compute_HDInsightARM {
		return &it
	}) // generate one case for OneOf type
	gens["SynapseSpark"] = ComputeSynapseSparkARMGenerator().Map(func(it Compute_SynapseSparkARM) *Compute_SynapseSparkARM {
		return &it
	}) // generate one case for OneOf type
	gens["VirtualMachine"] = ComputeVirtualMachineARMGenerator().Map(func(it Compute_VirtualMachineARM) *Compute_VirtualMachineARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_IdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityARM, IdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityARM runs a test to see if a specific instance of IdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityARM(subject IdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityARM instances for property testing - lazily instantiated by IdentityARMGenerator()
var identityARMGenerator gopter.Gen

// IdentityARMGenerator returns a generator of IdentityARM instances for property testing.
func IdentityARMGenerator() gopter.Gen {
	if identityARMGenerator != nil {
		return identityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityARM(generators)
	identityARMGenerator = gen.Struct(reflect.TypeOf(IdentityARM{}), generators)

	return identityARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityTypeNone,
		IdentityTypeSystemAssigned,
		IdentityTypeSystemAssignedUserAssigned,
		IdentityTypeUserAssigned))
}

func Test_SkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuARM, SkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuARM runs a test to see if a specific instance of SkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuARM(subject SkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SkuARM instances for property testing - lazily instantiated by SkuARMGenerator()
var skuARMGenerator gopter.Gen

// SkuARMGenerator returns a generator of SkuARM instances for property testing.
func SkuARMGenerator() gopter.Gen {
	if skuARMGenerator != nil {
		return skuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuARM(generators)
	skuARMGenerator = gen.Struct(reflect.TypeOf(SkuARM{}), generators)

	return skuARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemDataARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemDataARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataARM, SystemDataARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataARM runs a test to see if a specific instance of SystemDataARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataARM(subject SystemDataARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemDataARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemDataARM instances for property testing - lazily instantiated by SystemDataARMGenerator()
var systemDataARMGenerator gopter.Gen

// SystemDataARMGenerator returns a generator of SystemDataARM instances for property testing.
func SystemDataARMGenerator() gopter.Gen {
	if systemDataARMGenerator != nil {
		return systemDataARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataARM(generators)
	systemDataARMGenerator = gen.Struct(reflect.TypeOf(SystemDataARM{}), generators)

	return systemDataARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataCreatedByTypeApplication,
		SystemDataCreatedByTypeKey,
		SystemDataCreatedByTypeManagedIdentity,
		SystemDataCreatedByTypeUser))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataLastModifiedByTypeApplication,
		SystemDataLastModifiedByTypeKey,
		SystemDataLastModifiedByTypeManagedIdentity,
		SystemDataLastModifiedByTypeUser))
}

func Test_Compute_AKSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AKSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeAKSARM, ComputeAKSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeAKSARM runs a test to see if a specific instance of Compute_AKSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeAKSARM(subject Compute_AKSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AKSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AKSARM instances for property testing - lazily instantiated by ComputeAKSARMGenerator()
var computeAKSARMGenerator gopter.Gen

// ComputeAKSARMGenerator returns a generator of Compute_AKSARM instances for property testing.
// We first initialize computeAKSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeAKSARMGenerator() gopter.Gen {
	if computeAKSARMGenerator != nil {
		return computeAKSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeAKSARM(generators)
	computeAKSARMGenerator = gen.Struct(reflect.TypeOf(Compute_AKSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeAKSARM(generators)
	AddRelatedPropertyGeneratorsForComputeAKSARM(generators)
	computeAKSARMGenerator = gen.Struct(reflect.TypeOf(Compute_AKSARM{}), generators)

	return computeAKSARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeAKSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeAKSARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeAKSComputeTypeAKS)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeAKSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeAKSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AKSPropertiesARMGenerator())
}

func Test_Compute_AmlComputeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_AmlComputeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeAmlComputeARM, ComputeAmlComputeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeAmlComputeARM runs a test to see if a specific instance of Compute_AmlComputeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeAmlComputeARM(subject Compute_AmlComputeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_AmlComputeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_AmlComputeARM instances for property testing - lazily instantiated by
// ComputeAmlComputeARMGenerator()
var computeAmlComputeARMGenerator gopter.Gen

// ComputeAmlComputeARMGenerator returns a generator of Compute_AmlComputeARM instances for property testing.
// We first initialize computeAmlComputeARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeAmlComputeARMGenerator() gopter.Gen {
	if computeAmlComputeARMGenerator != nil {
		return computeAmlComputeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeAmlComputeARM(generators)
	computeAmlComputeARMGenerator = gen.Struct(reflect.TypeOf(Compute_AmlComputeARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeAmlComputeARM(generators)
	AddRelatedPropertyGeneratorsForComputeAmlComputeARM(generators)
	computeAmlComputeARMGenerator = gen.Struct(reflect.TypeOf(Compute_AmlComputeARM{}), generators)

	return computeAmlComputeARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeAmlComputeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeAmlComputeARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeAmlComputeComputeTypeAmlCompute)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeAmlComputeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeAmlComputeARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AmlComputePropertiesARMGenerator())
}

func Test_Compute_ComputeInstanceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_ComputeInstanceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeComputeInstanceARM, ComputeComputeInstanceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeComputeInstanceARM runs a test to see if a specific instance of Compute_ComputeInstanceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeComputeInstanceARM(subject Compute_ComputeInstanceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_ComputeInstanceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_ComputeInstanceARM instances for property testing - lazily instantiated by
// ComputeComputeInstanceARMGenerator()
var computeComputeInstanceARMGenerator gopter.Gen

// ComputeComputeInstanceARMGenerator returns a generator of Compute_ComputeInstanceARM instances for property testing.
// We first initialize computeComputeInstanceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeComputeInstanceARMGenerator() gopter.Gen {
	if computeComputeInstanceARMGenerator != nil {
		return computeComputeInstanceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeComputeInstanceARM(generators)
	computeComputeInstanceARMGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstanceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeComputeInstanceARM(generators)
	AddRelatedPropertyGeneratorsForComputeComputeInstanceARM(generators)
	computeComputeInstanceARMGenerator = gen.Struct(reflect.TypeOf(Compute_ComputeInstanceARM{}), generators)

	return computeComputeInstanceARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeComputeInstanceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeComputeInstanceARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeComputeInstanceComputeTypeComputeInstance)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeComputeInstanceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeComputeInstanceARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ComputeInstancePropertiesARMGenerator())
}

func Test_Compute_DataFactoryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataFactoryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeDataFactoryARM, ComputeDataFactoryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeDataFactoryARM runs a test to see if a specific instance of Compute_DataFactoryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeDataFactoryARM(subject Compute_DataFactoryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataFactoryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataFactoryARM instances for property testing - lazily instantiated by
// ComputeDataFactoryARMGenerator()
var computeDataFactoryARMGenerator gopter.Gen

// ComputeDataFactoryARMGenerator returns a generator of Compute_DataFactoryARM instances for property testing.
func ComputeDataFactoryARMGenerator() gopter.Gen {
	if computeDataFactoryARMGenerator != nil {
		return computeDataFactoryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeDataFactoryARM(generators)
	computeDataFactoryARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataFactoryARM{}), generators)

	return computeDataFactoryARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeDataFactoryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeDataFactoryARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeDataFactoryComputeTypeDataFactory)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Compute_DataLakeAnalyticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DataLakeAnalyticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeDataLakeAnalyticsARM, ComputeDataLakeAnalyticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeDataLakeAnalyticsARM runs a test to see if a specific instance of Compute_DataLakeAnalyticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeDataLakeAnalyticsARM(subject Compute_DataLakeAnalyticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DataLakeAnalyticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DataLakeAnalyticsARM instances for property testing - lazily instantiated by
// ComputeDataLakeAnalyticsARMGenerator()
var computeDataLakeAnalyticsARMGenerator gopter.Gen

// ComputeDataLakeAnalyticsARMGenerator returns a generator of Compute_DataLakeAnalyticsARM instances for property testing.
// We first initialize computeDataLakeAnalyticsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeDataLakeAnalyticsARMGenerator() gopter.Gen {
	if computeDataLakeAnalyticsARMGenerator != nil {
		return computeDataLakeAnalyticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeDataLakeAnalyticsARM(generators)
	computeDataLakeAnalyticsARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalyticsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeDataLakeAnalyticsARM(generators)
	AddRelatedPropertyGeneratorsForComputeDataLakeAnalyticsARM(generators)
	computeDataLakeAnalyticsARMGenerator = gen.Struct(reflect.TypeOf(Compute_DataLakeAnalyticsARM{}), generators)

	return computeDataLakeAnalyticsARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeDataLakeAnalyticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeDataLakeAnalyticsARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeDataLakeAnalyticsComputeTypeDataLakeAnalytics)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeDataLakeAnalyticsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeDataLakeAnalyticsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DataLakeAnalyticsPropertiesARMGenerator())
}

func Test_Compute_DatabricksARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_DatabricksARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeDatabricksARM, ComputeDatabricksARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeDatabricksARM runs a test to see if a specific instance of Compute_DatabricksARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeDatabricksARM(subject Compute_DatabricksARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_DatabricksARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_DatabricksARM instances for property testing - lazily instantiated by
// ComputeDatabricksARMGenerator()
var computeDatabricksARMGenerator gopter.Gen

// ComputeDatabricksARMGenerator returns a generator of Compute_DatabricksARM instances for property testing.
// We first initialize computeDatabricksARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeDatabricksARMGenerator() gopter.Gen {
	if computeDatabricksARMGenerator != nil {
		return computeDatabricksARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeDatabricksARM(generators)
	computeDatabricksARMGenerator = gen.Struct(reflect.TypeOf(Compute_DatabricksARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeDatabricksARM(generators)
	AddRelatedPropertyGeneratorsForComputeDatabricksARM(generators)
	computeDatabricksARMGenerator = gen.Struct(reflect.TypeOf(Compute_DatabricksARM{}), generators)

	return computeDatabricksARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeDatabricksARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeDatabricksARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeDatabricksComputeTypeDatabricks)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeDatabricksARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeDatabricksARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DatabricksPropertiesARMGenerator())
}

func Test_Compute_HDInsightARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_HDInsightARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeHDInsightARM, ComputeHDInsightARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeHDInsightARM runs a test to see if a specific instance of Compute_HDInsightARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeHDInsightARM(subject Compute_HDInsightARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_HDInsightARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_HDInsightARM instances for property testing - lazily instantiated by
// ComputeHDInsightARMGenerator()
var computeHDInsightARMGenerator gopter.Gen

// ComputeHDInsightARMGenerator returns a generator of Compute_HDInsightARM instances for property testing.
// We first initialize computeHDInsightARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeHDInsightARMGenerator() gopter.Gen {
	if computeHDInsightARMGenerator != nil {
		return computeHDInsightARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeHDInsightARM(generators)
	computeHDInsightARMGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsightARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeHDInsightARM(generators)
	AddRelatedPropertyGeneratorsForComputeHDInsightARM(generators)
	computeHDInsightARMGenerator = gen.Struct(reflect.TypeOf(Compute_HDInsightARM{}), generators)

	return computeHDInsightARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeHDInsightARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeHDInsightARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeHDInsightComputeTypeHDInsight)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeHDInsightARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeHDInsightARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HDInsightPropertiesARMGenerator())
}

func Test_Compute_SynapseSparkARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_SynapseSparkARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeSynapseSparkARM, ComputeSynapseSparkARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeSynapseSparkARM runs a test to see if a specific instance of Compute_SynapseSparkARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeSynapseSparkARM(subject Compute_SynapseSparkARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_SynapseSparkARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_SynapseSparkARM instances for property testing - lazily instantiated by
// ComputeSynapseSparkARMGenerator()
var computeSynapseSparkARMGenerator gopter.Gen

// ComputeSynapseSparkARMGenerator returns a generator of Compute_SynapseSparkARM instances for property testing.
// We first initialize computeSynapseSparkARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeSynapseSparkARMGenerator() gopter.Gen {
	if computeSynapseSparkARMGenerator != nil {
		return computeSynapseSparkARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeSynapseSparkARM(generators)
	computeSynapseSparkARMGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSparkARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeSynapseSparkARM(generators)
	AddRelatedPropertyGeneratorsForComputeSynapseSparkARM(generators)
	computeSynapseSparkARMGenerator = gen.Struct(reflect.TypeOf(Compute_SynapseSparkARM{}), generators)

	return computeSynapseSparkARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeSynapseSparkARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeSynapseSparkARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeSynapseSparkComputeTypeSynapseSpark)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeSynapseSparkARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeSynapseSparkARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SynapseSparkPropertiesARMGenerator())
}

func Test_Compute_VirtualMachineARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_VirtualMachineARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeVirtualMachineARM, ComputeVirtualMachineARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeVirtualMachineARM runs a test to see if a specific instance of Compute_VirtualMachineARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeVirtualMachineARM(subject Compute_VirtualMachineARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_VirtualMachineARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_VirtualMachineARM instances for property testing - lazily instantiated by
// ComputeVirtualMachineARMGenerator()
var computeVirtualMachineARMGenerator gopter.Gen

// ComputeVirtualMachineARMGenerator returns a generator of Compute_VirtualMachineARM instances for property testing.
// We first initialize computeVirtualMachineARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeVirtualMachineARMGenerator() gopter.Gen {
	if computeVirtualMachineARMGenerator != nil {
		return computeVirtualMachineARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeVirtualMachineARM(generators)
	computeVirtualMachineARMGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachineARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeVirtualMachineARM(generators)
	AddRelatedPropertyGeneratorsForComputeVirtualMachineARM(generators)
	computeVirtualMachineARMGenerator = gen.Struct(reflect.TypeOf(Compute_VirtualMachineARM{}), generators)

	return computeVirtualMachineARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeVirtualMachineARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeVirtualMachineARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeVirtualMachineComputeTypeVirtualMachine)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeVirtualMachineARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeVirtualMachineARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesARMGenerator())
}

func Test_AKSPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AKSPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAKSPropertiesARM, AKSPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAKSPropertiesARM runs a test to see if a specific instance of AKSPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAKSPropertiesARM(subject AKSPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AKSPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AKSPropertiesARM instances for property testing - lazily instantiated by AKSPropertiesARMGenerator()
var aksPropertiesARMGenerator gopter.Gen

// AKSPropertiesARMGenerator returns a generator of AKSPropertiesARM instances for property testing.
// We first initialize aksPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AKSPropertiesARMGenerator() gopter.Gen {
	if aksPropertiesARMGenerator != nil {
		return aksPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSPropertiesARM(generators)
	aksPropertiesARMGenerator = gen.Struct(reflect.TypeOf(AKSPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKSPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForAKSPropertiesARM(generators)
	aksPropertiesARMGenerator = gen.Struct(reflect.TypeOf(AKSPropertiesARM{}), generators)

	return aksPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAKSPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAKSPropertiesARM(gens map[string]gopter.Gen) {
	gens["AgentCount"] = gen.PtrOf(gen.Int())
	gens["AgentVmSize"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterPurpose"] = gen.PtrOf(gen.OneConstOf(AKSPropertiesClusterPurposeDenseProd, AKSPropertiesClusterPurposeDevTest, AKSPropertiesClusterPurposeFastProd))
	gens["LoadBalancerSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerType"] = gen.PtrOf(gen.OneConstOf(AKSPropertiesLoadBalancerTypeInternalLoadBalancer, AKSPropertiesLoadBalancerTypePublicIp))
}

// AddRelatedPropertyGeneratorsForAKSPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAKSPropertiesARM(gens map[string]gopter.Gen) {
	gens["AksNetworkingConfiguration"] = gen.PtrOf(AksNetworkingConfigurationARMGenerator())
	gens["SslConfiguration"] = gen.PtrOf(SslConfigurationARMGenerator())
}

func Test_AmlComputePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AmlComputePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAmlComputePropertiesARM, AmlComputePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAmlComputePropertiesARM runs a test to see if a specific instance of AmlComputePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAmlComputePropertiesARM(subject AmlComputePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AmlComputePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AmlComputePropertiesARM instances for property testing - lazily instantiated by
// AmlComputePropertiesARMGenerator()
var amlComputePropertiesARMGenerator gopter.Gen

// AmlComputePropertiesARMGenerator returns a generator of AmlComputePropertiesARM instances for property testing.
// We first initialize amlComputePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AmlComputePropertiesARMGenerator() gopter.Gen {
	if amlComputePropertiesARMGenerator != nil {
		return amlComputePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputePropertiesARM(generators)
	amlComputePropertiesARMGenerator = gen.Struct(reflect.TypeOf(AmlComputePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForAmlComputePropertiesARM(generators)
	amlComputePropertiesARMGenerator = gen.Struct(reflect.TypeOf(AmlComputePropertiesARM{}), generators)

	return amlComputePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAmlComputePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAmlComputePropertiesARM(gens map[string]gopter.Gen) {
	gens["EnableNodePublicIp"] = gen.PtrOf(gen.Bool())
	gens["IsolatedNetwork"] = gen.PtrOf(gen.Bool())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(AmlComputePropertiesOsTypeLinux, AmlComputePropertiesOsTypeWindows))
	gens["RemoteLoginPortPublicAccess"] = gen.PtrOf(gen.OneConstOf(AmlComputePropertiesRemoteLoginPortPublicAccessDisabled, AmlComputePropertiesRemoteLoginPortPublicAccessEnabled, AmlComputePropertiesRemoteLoginPortPublicAccessNotSpecified))
	gens["VmPriority"] = gen.PtrOf(gen.OneConstOf(AmlComputePropertiesVmPriorityDedicated, AmlComputePropertiesVmPriorityLowPriority))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAmlComputePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAmlComputePropertiesARM(gens map[string]gopter.Gen) {
	gens["ScaleSettings"] = gen.PtrOf(ScaleSettingsARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceIdARMGenerator())
	gens["UserAccountCredentials"] = gen.PtrOf(UserAccountCredentialsARMGenerator())
	gens["VirtualMachineImage"] = gen.PtrOf(VirtualMachineImageARMGenerator())
}

func Test_ComputeInstancePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstancePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstancePropertiesARM, ComputeInstancePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstancePropertiesARM runs a test to see if a specific instance of ComputeInstancePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstancePropertiesARM(subject ComputeInstancePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstancePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstancePropertiesARM instances for property testing - lazily instantiated by
// ComputeInstancePropertiesARMGenerator()
var computeInstancePropertiesARMGenerator gopter.Gen

// ComputeInstancePropertiesARMGenerator returns a generator of ComputeInstancePropertiesARM instances for property testing.
// We first initialize computeInstancePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeInstancePropertiesARMGenerator() gopter.Gen {
	if computeInstancePropertiesARMGenerator != nil {
		return computeInstancePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstancePropertiesARM(generators)
	computeInstancePropertiesARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstancePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstancePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForComputeInstancePropertiesARM(generators)
	computeInstancePropertiesARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstancePropertiesARM{}), generators)

	return computeInstancePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstancePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstancePropertiesARM(gens map[string]gopter.Gen) {
	gens["ApplicationSharingPolicy"] = gen.PtrOf(gen.OneConstOf(ComputeInstancePropertiesApplicationSharingPolicyPersonal, ComputeInstancePropertiesApplicationSharingPolicyShared))
	gens["ComputeInstanceAuthorizationType"] = gen.PtrOf(gen.OneConstOf(ComputeInstancePropertiesComputeInstanceAuthorizationTypePersonal))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeInstancePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeInstancePropertiesARM(gens map[string]gopter.Gen) {
	gens["PersonalComputeInstanceSettings"] = gen.PtrOf(PersonalComputeInstanceSettingsARMGenerator())
	gens["SetupScripts"] = gen.PtrOf(SetupScriptsARMGenerator())
	gens["SshSettings"] = gen.PtrOf(ComputeInstanceSshSettingsARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceIdARMGenerator())
}

func Test_DataLakeAnalyticsPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeAnalyticsPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeAnalyticsPropertiesARM, DataLakeAnalyticsPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeAnalyticsPropertiesARM runs a test to see if a specific instance of DataLakeAnalyticsPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeAnalyticsPropertiesARM(subject DataLakeAnalyticsPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeAnalyticsPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeAnalyticsPropertiesARM instances for property testing - lazily instantiated by
// DataLakeAnalyticsPropertiesARMGenerator()
var dataLakeAnalyticsPropertiesARMGenerator gopter.Gen

// DataLakeAnalyticsPropertiesARMGenerator returns a generator of DataLakeAnalyticsPropertiesARM instances for property testing.
func DataLakeAnalyticsPropertiesARMGenerator() gopter.Gen {
	if dataLakeAnalyticsPropertiesARMGenerator != nil {
		return dataLakeAnalyticsPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalyticsPropertiesARM(generators)
	dataLakeAnalyticsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalyticsPropertiesARM{}), generators)

	return dataLakeAnalyticsPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeAnalyticsPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeAnalyticsPropertiesARM(gens map[string]gopter.Gen) {
	gens["DataLakeStoreAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_DatabricksPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabricksPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabricksPropertiesARM, DatabricksPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabricksPropertiesARM runs a test to see if a specific instance of DatabricksPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabricksPropertiesARM(subject DatabricksPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabricksPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabricksPropertiesARM instances for property testing - lazily instantiated by
// DatabricksPropertiesARMGenerator()
var databricksPropertiesARMGenerator gopter.Gen

// DatabricksPropertiesARMGenerator returns a generator of DatabricksPropertiesARM instances for property testing.
func DatabricksPropertiesARMGenerator() gopter.Gen {
	if databricksPropertiesARMGenerator != nil {
		return databricksPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricksPropertiesARM(generators)
	databricksPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DatabricksPropertiesARM{}), generators)

	return databricksPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabricksPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabricksPropertiesARM(gens map[string]gopter.Gen) {
	gens["DatabricksAccessToken"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_HDInsightPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HDInsightPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHDInsightPropertiesARM, HDInsightPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHDInsightPropertiesARM runs a test to see if a specific instance of HDInsightPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHDInsightPropertiesARM(subject HDInsightPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HDInsightPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HDInsightPropertiesARM instances for property testing - lazily instantiated by
// HDInsightPropertiesARMGenerator()
var hdInsightPropertiesARMGenerator gopter.Gen

// HDInsightPropertiesARMGenerator returns a generator of HDInsightPropertiesARM instances for property testing.
// We first initialize hdInsightPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HDInsightPropertiesARMGenerator() gopter.Gen {
	if hdInsightPropertiesARMGenerator != nil {
		return hdInsightPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightPropertiesARM(generators)
	hdInsightPropertiesARMGenerator = gen.Struct(reflect.TypeOf(HDInsightPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForHDInsightPropertiesARM(generators)
	hdInsightPropertiesARMGenerator = gen.Struct(reflect.TypeOf(HDInsightPropertiesARM{}), generators)

	return hdInsightPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForHDInsightPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHDInsightPropertiesARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["SshPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHDInsightPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHDInsightPropertiesARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentialsARMGenerator())
}

func Test_SynapseSparkPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SynapseSparkPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSynapseSparkPropertiesARM, SynapseSparkPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSynapseSparkPropertiesARM runs a test to see if a specific instance of SynapseSparkPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSynapseSparkPropertiesARM(subject SynapseSparkPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SynapseSparkPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SynapseSparkPropertiesARM instances for property testing - lazily instantiated by
// SynapseSparkPropertiesARMGenerator()
var synapseSparkPropertiesARMGenerator gopter.Gen

// SynapseSparkPropertiesARMGenerator returns a generator of SynapseSparkPropertiesARM instances for property testing.
// We first initialize synapseSparkPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SynapseSparkPropertiesARMGenerator() gopter.Gen {
	if synapseSparkPropertiesARMGenerator != nil {
		return synapseSparkPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkPropertiesARM(generators)
	synapseSparkPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SynapseSparkPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSparkPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSynapseSparkPropertiesARM(generators)
	synapseSparkPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SynapseSparkPropertiesARM{}), generators)

	return synapseSparkPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSynapseSparkPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSynapseSparkPropertiesARM(gens map[string]gopter.Gen) {
	gens["NodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeSize"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSizeFamily"] = gen.PtrOf(gen.AlphaString())
	gens["PoolName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SparkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSynapseSparkPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSynapseSparkPropertiesARM(gens map[string]gopter.Gen) {
	gens["AutoPauseProperties"] = gen.PtrOf(AutoPausePropertiesARMGenerator())
	gens["AutoScaleProperties"] = gen.PtrOf(AutoScalePropertiesARMGenerator())
}

func Test_VirtualMachinePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePropertiesARM, VirtualMachinePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePropertiesARM runs a test to see if a specific instance of VirtualMachinePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePropertiesARM(subject VirtualMachinePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePropertiesARM instances for property testing - lazily instantiated by
// VirtualMachinePropertiesARMGenerator()
var virtualMachinePropertiesARMGenerator gopter.Gen

// VirtualMachinePropertiesARMGenerator returns a generator of VirtualMachinePropertiesARM instances for property testing.
// We first initialize virtualMachinePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesARMGenerator() gopter.Gen {
	if virtualMachinePropertiesARMGenerator != nil {
		return virtualMachinePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	return virtualMachinePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["IsNotebookInstanceCompute"] = gen.PtrOf(gen.Bool())
	gens["SshPort"] = gen.PtrOf(gen.Int())
	gens["VirtualMachineSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentialsARMGenerator())
}

func Test_AksNetworkingConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AksNetworkingConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAksNetworkingConfigurationARM, AksNetworkingConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAksNetworkingConfigurationARM runs a test to see if a specific instance of AksNetworkingConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAksNetworkingConfigurationARM(subject AksNetworkingConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AksNetworkingConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AksNetworkingConfigurationARM instances for property testing - lazily instantiated by
// AksNetworkingConfigurationARMGenerator()
var aksNetworkingConfigurationARMGenerator gopter.Gen

// AksNetworkingConfigurationARMGenerator returns a generator of AksNetworkingConfigurationARM instances for property testing.
func AksNetworkingConfigurationARMGenerator() gopter.Gen {
	if aksNetworkingConfigurationARMGenerator != nil {
		return aksNetworkingConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAksNetworkingConfigurationARM(generators)
	aksNetworkingConfigurationARMGenerator = gen.Struct(reflect.TypeOf(AksNetworkingConfigurationARM{}), generators)

	return aksNetworkingConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForAksNetworkingConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAksNetworkingConfigurationARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoPausePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoPausePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoPausePropertiesARM, AutoPausePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoPausePropertiesARM runs a test to see if a specific instance of AutoPausePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoPausePropertiesARM(subject AutoPausePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoPausePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoPausePropertiesARM instances for property testing - lazily instantiated by
// AutoPausePropertiesARMGenerator()
var autoPausePropertiesARMGenerator gopter.Gen

// AutoPausePropertiesARMGenerator returns a generator of AutoPausePropertiesARM instances for property testing.
func AutoPausePropertiesARMGenerator() gopter.Gen {
	if autoPausePropertiesARMGenerator != nil {
		return autoPausePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoPausePropertiesARM(generators)
	autoPausePropertiesARMGenerator = gen.Struct(reflect.TypeOf(AutoPausePropertiesARM{}), generators)

	return autoPausePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoPausePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoPausePropertiesARM(gens map[string]gopter.Gen) {
	gens["DelayInMinutes"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AutoScalePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScalePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScalePropertiesARM, AutoScalePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScalePropertiesARM runs a test to see if a specific instance of AutoScalePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScalePropertiesARM(subject AutoScalePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScalePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScalePropertiesARM instances for property testing - lazily instantiated by
// AutoScalePropertiesARMGenerator()
var autoScalePropertiesARMGenerator gopter.Gen

// AutoScalePropertiesARMGenerator returns a generator of AutoScalePropertiesARM instances for property testing.
func AutoScalePropertiesARMGenerator() gopter.Gen {
	if autoScalePropertiesARMGenerator != nil {
		return autoScalePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScalePropertiesARM(generators)
	autoScalePropertiesARMGenerator = gen.Struct(reflect.TypeOf(AutoScalePropertiesARM{}), generators)

	return autoScalePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoScalePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScalePropertiesARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
}

func Test_ComputeInstanceSshSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceSshSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceSshSettingsARM, ComputeInstanceSshSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceSshSettingsARM runs a test to see if a specific instance of ComputeInstanceSshSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceSshSettingsARM(subject ComputeInstanceSshSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceSshSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceSshSettingsARM instances for property testing - lazily instantiated by
// ComputeInstanceSshSettingsARMGenerator()
var computeInstanceSshSettingsARMGenerator gopter.Gen

// ComputeInstanceSshSettingsARMGenerator returns a generator of ComputeInstanceSshSettingsARM instances for property testing.
func ComputeInstanceSshSettingsARMGenerator() gopter.Gen {
	if computeInstanceSshSettingsARMGenerator != nil {
		return computeInstanceSshSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceSshSettingsARM(generators)
	computeInstanceSshSettingsARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceSshSettingsARM{}), generators)

	return computeInstanceSshSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceSshSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceSshSettingsARM(gens map[string]gopter.Gen) {
	gens["AdminPublicKey"] = gen.PtrOf(gen.AlphaString())
	gens["SshPublicAccess"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceSshSettingsSshPublicAccessDisabled, ComputeInstanceSshSettingsSshPublicAccessEnabled))
}

func Test_PersonalComputeInstanceSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PersonalComputeInstanceSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPersonalComputeInstanceSettingsARM, PersonalComputeInstanceSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPersonalComputeInstanceSettingsARM runs a test to see if a specific instance of PersonalComputeInstanceSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPersonalComputeInstanceSettingsARM(subject PersonalComputeInstanceSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PersonalComputeInstanceSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PersonalComputeInstanceSettingsARM instances for property testing - lazily instantiated by
// PersonalComputeInstanceSettingsARMGenerator()
var personalComputeInstanceSettingsARMGenerator gopter.Gen

// PersonalComputeInstanceSettingsARMGenerator returns a generator of PersonalComputeInstanceSettingsARM instances for property testing.
func PersonalComputeInstanceSettingsARMGenerator() gopter.Gen {
	if personalComputeInstanceSettingsARMGenerator != nil {
		return personalComputeInstanceSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettingsARM(generators)
	personalComputeInstanceSettingsARMGenerator = gen.Struct(reflect.TypeOf(PersonalComputeInstanceSettingsARM{}), generators)

	return personalComputeInstanceSettingsARMGenerator
}

// AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettingsARM(gens map[string]gopter.Gen) {
	gens["AssignedUser"] = gen.PtrOf(AssignedUserARMGenerator())
}

func Test_ResourceIdARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceIdARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceIdARM, ResourceIdARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceIdARM runs a test to see if a specific instance of ResourceIdARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceIdARM(subject ResourceIdARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceIdARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceIdARM instances for property testing - lazily instantiated by ResourceIdARMGenerator()
var resourceIdARMGenerator gopter.Gen

// ResourceIdARMGenerator returns a generator of ResourceIdARM instances for property testing.
func ResourceIdARMGenerator() gopter.Gen {
	if resourceIdARMGenerator != nil {
		return resourceIdARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdARM(generators)
	resourceIdARMGenerator = gen.Struct(reflect.TypeOf(ResourceIdARM{}), generators)

	return resourceIdARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceIdARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceIdARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleSettingsARM, ScaleSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleSettingsARM runs a test to see if a specific instance of ScaleSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleSettingsARM(subject ScaleSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleSettingsARM instances for property testing - lazily instantiated by ScaleSettingsARMGenerator()
var scaleSettingsARMGenerator gopter.Gen

// ScaleSettingsARMGenerator returns a generator of ScaleSettingsARM instances for property testing.
func ScaleSettingsARMGenerator() gopter.Gen {
	if scaleSettingsARMGenerator != nil {
		return scaleSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleSettingsARM(generators)
	scaleSettingsARMGenerator = gen.Struct(reflect.TypeOf(ScaleSettingsARM{}), generators)

	return scaleSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleSettingsARM(gens map[string]gopter.Gen) {
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeIdleTimeBeforeScaleDown"] = gen.PtrOf(gen.AlphaString())
}

func Test_SetupScriptsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SetupScriptsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSetupScriptsARM, SetupScriptsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSetupScriptsARM runs a test to see if a specific instance of SetupScriptsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSetupScriptsARM(subject SetupScriptsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SetupScriptsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SetupScriptsARM instances for property testing - lazily instantiated by SetupScriptsARMGenerator()
var setupScriptsARMGenerator gopter.Gen

// SetupScriptsARMGenerator returns a generator of SetupScriptsARM instances for property testing.
func SetupScriptsARMGenerator() gopter.Gen {
	if setupScriptsARMGenerator != nil {
		return setupScriptsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSetupScriptsARM(generators)
	setupScriptsARMGenerator = gen.Struct(reflect.TypeOf(SetupScriptsARM{}), generators)

	return setupScriptsARMGenerator
}

// AddRelatedPropertyGeneratorsForSetupScriptsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSetupScriptsARM(gens map[string]gopter.Gen) {
	gens["Scripts"] = gen.PtrOf(ScriptsToExecuteARMGenerator())
}

func Test_SslConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslConfigurationARM, SslConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslConfigurationARM runs a test to see if a specific instance of SslConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslConfigurationARM(subject SslConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslConfigurationARM instances for property testing - lazily instantiated by
// SslConfigurationARMGenerator()
var sslConfigurationARMGenerator gopter.Gen

// SslConfigurationARMGenerator returns a generator of SslConfigurationARM instances for property testing.
func SslConfigurationARMGenerator() gopter.Gen {
	if sslConfigurationARMGenerator != nil {
		return sslConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslConfigurationARM(generators)
	sslConfigurationARMGenerator = gen.Struct(reflect.TypeOf(SslConfigurationARM{}), generators)

	return sslConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForSslConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslConfigurationARM(gens map[string]gopter.Gen) {
	gens["Cert"] = gen.PtrOf(gen.AlphaString())
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["LeafDomainLabel"] = gen.PtrOf(gen.AlphaString())
	gens["OverwriteExistingDomain"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(SslConfigurationStatusAuto, SslConfigurationStatusDisabled, SslConfigurationStatusEnabled))
}

func Test_UserAccountCredentialsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAccountCredentialsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAccountCredentialsARM, UserAccountCredentialsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAccountCredentialsARM runs a test to see if a specific instance of UserAccountCredentialsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAccountCredentialsARM(subject UserAccountCredentialsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAccountCredentialsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAccountCredentialsARM instances for property testing - lazily instantiated by
// UserAccountCredentialsARMGenerator()
var userAccountCredentialsARMGenerator gopter.Gen

// UserAccountCredentialsARMGenerator returns a generator of UserAccountCredentialsARM instances for property testing.
func UserAccountCredentialsARMGenerator() gopter.Gen {
	if userAccountCredentialsARMGenerator != nil {
		return userAccountCredentialsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAccountCredentialsARM(generators)
	userAccountCredentialsARMGenerator = gen.Struct(reflect.TypeOf(UserAccountCredentialsARM{}), generators)

	return userAccountCredentialsARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAccountCredentialsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAccountCredentialsARM(gens map[string]gopter.Gen) {
	gens["AdminUserName"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserSshPublicKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineImageARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineImageARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineImageARM, VirtualMachineImageARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineImageARM runs a test to see if a specific instance of VirtualMachineImageARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineImageARM(subject VirtualMachineImageARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineImageARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineImageARM instances for property testing - lazily instantiated by
// VirtualMachineImageARMGenerator()
var virtualMachineImageARMGenerator gopter.Gen

// VirtualMachineImageARMGenerator returns a generator of VirtualMachineImageARM instances for property testing.
func VirtualMachineImageARMGenerator() gopter.Gen {
	if virtualMachineImageARMGenerator != nil {
		return virtualMachineImageARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineImageARM(generators)
	virtualMachineImageARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineImageARM{}), generators)

	return virtualMachineImageARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineImageARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineImageARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineSshCredentialsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineSshCredentialsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineSshCredentialsARM, VirtualMachineSshCredentialsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineSshCredentialsARM runs a test to see if a specific instance of VirtualMachineSshCredentialsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineSshCredentialsARM(subject VirtualMachineSshCredentialsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineSshCredentialsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineSshCredentialsARM instances for property testing - lazily instantiated by
// VirtualMachineSshCredentialsARMGenerator()
var virtualMachineSshCredentialsARMGenerator gopter.Gen

// VirtualMachineSshCredentialsARMGenerator returns a generator of VirtualMachineSshCredentialsARM instances for property testing.
func VirtualMachineSshCredentialsARMGenerator() gopter.Gen {
	if virtualMachineSshCredentialsARMGenerator != nil {
		return virtualMachineSshCredentialsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSshCredentialsARM(generators)
	virtualMachineSshCredentialsARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineSshCredentialsARM{}), generators)

	return virtualMachineSshCredentialsARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineSshCredentialsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineSshCredentialsARM(gens map[string]gopter.Gen) {
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["PublicKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_AssignedUserARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AssignedUserARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAssignedUserARM, AssignedUserARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAssignedUserARM runs a test to see if a specific instance of AssignedUserARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAssignedUserARM(subject AssignedUserARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AssignedUserARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AssignedUserARM instances for property testing - lazily instantiated by AssignedUserARMGenerator()
var assignedUserARMGenerator gopter.Gen

// AssignedUserARMGenerator returns a generator of AssignedUserARM instances for property testing.
func AssignedUserARMGenerator() gopter.Gen {
	if assignedUserARMGenerator != nil {
		return assignedUserARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAssignedUserARM(generators)
	assignedUserARMGenerator = gen.Struct(reflect.TypeOf(AssignedUserARM{}), generators)

	return assignedUserARMGenerator
}

// AddIndependentPropertyGeneratorsForAssignedUserARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAssignedUserARM(gens map[string]gopter.Gen) {
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScriptsToExecuteARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptsToExecuteARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptsToExecuteARM, ScriptsToExecuteARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptsToExecuteARM runs a test to see if a specific instance of ScriptsToExecuteARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptsToExecuteARM(subject ScriptsToExecuteARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptsToExecuteARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptsToExecuteARM instances for property testing - lazily instantiated by
// ScriptsToExecuteARMGenerator()
var scriptsToExecuteARMGenerator gopter.Gen

// ScriptsToExecuteARMGenerator returns a generator of ScriptsToExecuteARM instances for property testing.
func ScriptsToExecuteARMGenerator() gopter.Gen {
	if scriptsToExecuteARMGenerator != nil {
		return scriptsToExecuteARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScriptsToExecuteARM(generators)
	scriptsToExecuteARMGenerator = gen.Struct(reflect.TypeOf(ScriptsToExecuteARM{}), generators)

	return scriptsToExecuteARMGenerator
}

// AddRelatedPropertyGeneratorsForScriptsToExecuteARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScriptsToExecuteARM(gens map[string]gopter.Gen) {
	gens["CreationScript"] = gen.PtrOf(ScriptReferenceARMGenerator())
	gens["StartupScript"] = gen.PtrOf(ScriptReferenceARMGenerator())
}

func Test_ScriptReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptReferenceARM, ScriptReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptReferenceARM runs a test to see if a specific instance of ScriptReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptReferenceARM(subject ScriptReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptReferenceARM instances for property testing - lazily instantiated by ScriptReferenceARMGenerator()
var scriptReferenceARMGenerator gopter.Gen

// ScriptReferenceARMGenerator returns a generator of ScriptReferenceARM instances for property testing.
func ScriptReferenceARMGenerator() gopter.Gen {
	if scriptReferenceARMGenerator != nil {
		return scriptReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScriptReferenceARM(generators)
	scriptReferenceARMGenerator = gen.Struct(reflect.TypeOf(ScriptReferenceARM{}), generators)

	return scriptReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForScriptReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScriptReferenceARM(gens map[string]gopter.Gen) {
	gens["ScriptArguments"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptData"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptSource"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.AlphaString())
}
