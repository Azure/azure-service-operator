// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210701

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Workspaces_Compute_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspaces_Compute_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM, Workspaces_Compute_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM runs a test to see if a specific instance of Workspaces_Compute_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaces_Compute_Spec_ARM(subject Workspaces_Compute_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspaces_Compute_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspaces_Compute_Spec_ARM instances for property testing - lazily instantiated by
// Workspaces_Compute_Spec_ARMGenerator()
var workspaces_Compute_Spec_ARMGenerator gopter.Gen

// Workspaces_Compute_Spec_ARMGenerator returns a generator of Workspaces_Compute_Spec_ARM instances for property testing.
// We first initialize workspaces_Compute_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspaces_Compute_Spec_ARMGenerator() gopter.Gen {
	if workspaces_Compute_Spec_ARMGenerator != nil {
		return workspaces_Compute_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	workspaces_Compute_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(generators)
	workspaces_Compute_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Workspaces_Compute_Spec_ARM{}), generators)

	return workspaces_Compute_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspaces_Compute_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(Compute_ARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_ARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_ARMGenerator())
}

func Test_Compute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Compute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompute_ARM, Compute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompute_ARM runs a test to see if a specific instance of Compute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompute_ARM(subject Compute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Compute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Compute_ARM instances for property testing - lazily instantiated by Compute_ARMGenerator()
var compute_ARMGenerator gopter.Gen

// Compute_ARMGenerator returns a generator of Compute_ARM instances for property testing.
func Compute_ARMGenerator() gopter.Gen {
	if compute_ARMGenerator != nil {
		return compute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCompute_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(Compute_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	compute_ARMGenerator = gen.OneGenOf(gens...)

	return compute_ARMGenerator
}

// AddRelatedPropertyGeneratorsForCompute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCompute_ARM(gens map[string]gopter.Gen) {
	gens["AKS"] = AKS_ARMGenerator().Map(func(it AKS_ARM) *AKS_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["AmlCompute"] = AmlCompute_ARMGenerator().Map(func(it AmlCompute_ARM) *AmlCompute_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ComputeInstance"] = ComputeInstance_ARMGenerator().Map(func(it ComputeInstance_ARM) *ComputeInstance_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataFactory"] = DataFactory_ARMGenerator().Map(func(it DataFactory_ARM) *DataFactory_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["DataLakeAnalytics"] = DataLakeAnalytics_ARMGenerator().Map(func(it DataLakeAnalytics_ARM) *DataLakeAnalytics_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["Databricks"] = Databricks_ARMGenerator().Map(func(it Databricks_ARM) *Databricks_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["HDInsight"] = HDInsight_ARMGenerator().Map(func(it HDInsight_ARM) *HDInsight_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["Kubernetes"] = Kubernetes_ARMGenerator().Map(func(it Kubernetes_ARM) *Kubernetes_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["SynapseSpark"] = SynapseSpark_ARMGenerator().Map(func(it SynapseSpark_ARM) *SynapseSpark_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["VirtualMachine"] = VirtualMachine_ARMGenerator().Map(func(it VirtualMachine_ARM) *VirtualMachine_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_AKS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AKS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAKS_ARM, AKS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAKS_ARM runs a test to see if a specific instance of AKS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAKS_ARM(subject AKS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AKS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AKS_ARM instances for property testing - lazily instantiated by AKS_ARMGenerator()
var aks_ARMGenerator gopter.Gen

// AKS_ARMGenerator returns a generator of AKS_ARM instances for property testing.
// We first initialize aks_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AKS_ARMGenerator() gopter.Gen {
	if aks_ARMGenerator != nil {
		return aks_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKS_ARM(generators)
	aks_ARMGenerator = gen.Struct(reflect.TypeOf(AKS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKS_ARM(generators)
	AddRelatedPropertyGeneratorsForAKS_ARM(generators)
	aks_ARMGenerator = gen.Struct(reflect.TypeOf(AKS_ARM{}), generators)

	return aks_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAKS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAKS_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(AKS_ComputeType_AKS)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAKS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAKS_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AKS_Properties_ARMGenerator())
}

func Test_AmlCompute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AmlCompute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAmlCompute_ARM, AmlCompute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAmlCompute_ARM runs a test to see if a specific instance of AmlCompute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAmlCompute_ARM(subject AmlCompute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AmlCompute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AmlCompute_ARM instances for property testing - lazily instantiated by AmlCompute_ARMGenerator()
var amlCompute_ARMGenerator gopter.Gen

// AmlCompute_ARMGenerator returns a generator of AmlCompute_ARM instances for property testing.
// We first initialize amlCompute_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AmlCompute_ARMGenerator() gopter.Gen {
	if amlCompute_ARMGenerator != nil {
		return amlCompute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlCompute_ARM(generators)
	amlCompute_ARMGenerator = gen.Struct(reflect.TypeOf(AmlCompute_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlCompute_ARM(generators)
	AddRelatedPropertyGeneratorsForAmlCompute_ARM(generators)
	amlCompute_ARMGenerator = gen.Struct(reflect.TypeOf(AmlCompute_ARM{}), generators)

	return amlCompute_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAmlCompute_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAmlCompute_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(AmlCompute_ComputeType_AmlCompute)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAmlCompute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAmlCompute_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AmlComputeProperties_ARMGenerator())
}

func Test_ComputeInstance_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstance_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstance_ARM, ComputeInstance_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstance_ARM runs a test to see if a specific instance of ComputeInstance_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstance_ARM(subject ComputeInstance_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstance_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstance_ARM instances for property testing - lazily instantiated by
// ComputeInstance_ARMGenerator()
var computeInstance_ARMGenerator gopter.Gen

// ComputeInstance_ARMGenerator returns a generator of ComputeInstance_ARM instances for property testing.
// We first initialize computeInstance_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeInstance_ARMGenerator() gopter.Gen {
	if computeInstance_ARMGenerator != nil {
		return computeInstance_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstance_ARM(generators)
	computeInstance_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstance_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstance_ARM(generators)
	AddRelatedPropertyGeneratorsForComputeInstance_ARM(generators)
	computeInstance_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstance_ARM{}), generators)

	return computeInstance_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstance_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstance_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(ComputeInstance_ComputeType_ComputeInstance)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeInstance_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeInstance_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ComputeInstanceProperties_ARMGenerator())
}

func Test_Databricks_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Databricks_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabricks_ARM, Databricks_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabricks_ARM runs a test to see if a specific instance of Databricks_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabricks_ARM(subject Databricks_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Databricks_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Databricks_ARM instances for property testing - lazily instantiated by Databricks_ARMGenerator()
var databricks_ARMGenerator gopter.Gen

// Databricks_ARMGenerator returns a generator of Databricks_ARM instances for property testing.
// We first initialize databricks_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Databricks_ARMGenerator() gopter.Gen {
	if databricks_ARMGenerator != nil {
		return databricks_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricks_ARM(generators)
	databricks_ARMGenerator = gen.Struct(reflect.TypeOf(Databricks_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricks_ARM(generators)
	AddRelatedPropertyGeneratorsForDatabricks_ARM(generators)
	databricks_ARMGenerator = gen.Struct(reflect.TypeOf(Databricks_ARM{}), generators)

	return databricks_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabricks_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabricks_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Databricks_ComputeType_Databricks)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabricks_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabricks_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DatabricksProperties_ARMGenerator())
}

func Test_DataFactory_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFactory_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFactory_ARM, DataFactory_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFactory_ARM runs a test to see if a specific instance of DataFactory_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFactory_ARM(subject DataFactory_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFactory_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFactory_ARM instances for property testing - lazily instantiated by DataFactory_ARMGenerator()
var dataFactory_ARMGenerator gopter.Gen

// DataFactory_ARMGenerator returns a generator of DataFactory_ARM instances for property testing.
func DataFactory_ARMGenerator() gopter.Gen {
	if dataFactory_ARMGenerator != nil {
		return dataFactory_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFactory_ARM(generators)
	dataFactory_ARMGenerator = gen.Struct(reflect.TypeOf(DataFactory_ARM{}), generators)

	return dataFactory_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataFactory_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFactory_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(DataFactory_ComputeType_DataFactory)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeAnalytics_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeAnalytics_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeAnalytics_ARM, DataLakeAnalytics_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeAnalytics_ARM runs a test to see if a specific instance of DataLakeAnalytics_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeAnalytics_ARM(subject DataLakeAnalytics_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeAnalytics_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeAnalytics_ARM instances for property testing - lazily instantiated by
// DataLakeAnalytics_ARMGenerator()
var dataLakeAnalytics_ARMGenerator gopter.Gen

// DataLakeAnalytics_ARMGenerator returns a generator of DataLakeAnalytics_ARM instances for property testing.
// We first initialize dataLakeAnalytics_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataLakeAnalytics_ARMGenerator() gopter.Gen {
	if dataLakeAnalytics_ARMGenerator != nil {
		return dataLakeAnalytics_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalytics_ARM(generators)
	dataLakeAnalytics_ARMGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalytics_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalytics_ARM(generators)
	AddRelatedPropertyGeneratorsForDataLakeAnalytics_ARM(generators)
	dataLakeAnalytics_ARMGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalytics_ARM{}), generators)

	return dataLakeAnalytics_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeAnalytics_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeAnalytics_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(DataLakeAnalytics_ComputeType_DataLakeAnalytics)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataLakeAnalytics_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataLakeAnalytics_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DataLakeAnalytics_Properties_ARMGenerator())
}

func Test_HDInsight_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HDInsight_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHDInsight_ARM, HDInsight_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHDInsight_ARM runs a test to see if a specific instance of HDInsight_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHDInsight_ARM(subject HDInsight_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HDInsight_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HDInsight_ARM instances for property testing - lazily instantiated by HDInsight_ARMGenerator()
var hdInsight_ARMGenerator gopter.Gen

// HDInsight_ARMGenerator returns a generator of HDInsight_ARM instances for property testing.
// We first initialize hdInsight_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HDInsight_ARMGenerator() gopter.Gen {
	if hdInsight_ARMGenerator != nil {
		return hdInsight_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsight_ARM(generators)
	hdInsight_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsight_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsight_ARM(generators)
	AddRelatedPropertyGeneratorsForHDInsight_ARM(generators)
	hdInsight_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsight_ARM{}), generators)

	return hdInsight_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHDInsight_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHDInsight_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(HDInsight_ComputeType_HDInsight)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHDInsight_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHDInsight_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HDInsightProperties_ARMGenerator())
}

func Test_Kubernetes_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Kubernetes_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetes_ARM, Kubernetes_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetes_ARM runs a test to see if a specific instance of Kubernetes_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetes_ARM(subject Kubernetes_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Kubernetes_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Kubernetes_ARM instances for property testing - lazily instantiated by Kubernetes_ARMGenerator()
var kubernetes_ARMGenerator gopter.Gen

// Kubernetes_ARMGenerator returns a generator of Kubernetes_ARM instances for property testing.
// We first initialize kubernetes_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Kubernetes_ARMGenerator() gopter.Gen {
	if kubernetes_ARMGenerator != nil {
		return kubernetes_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetes_ARM(generators)
	kubernetes_ARMGenerator = gen.Struct(reflect.TypeOf(Kubernetes_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetes_ARM(generators)
	AddRelatedPropertyGeneratorsForKubernetes_ARM(generators)
	kubernetes_ARMGenerator = gen.Struct(reflect.TypeOf(Kubernetes_ARM{}), generators)

	return kubernetes_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKubernetes_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetes_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(Kubernetes_ComputeType_Kubernetes)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKubernetes_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKubernetes_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(KubernetesProperties_ARMGenerator())
}

func Test_SynapseSpark_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SynapseSpark_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSynapseSpark_ARM, SynapseSpark_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSynapseSpark_ARM runs a test to see if a specific instance of SynapseSpark_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSynapseSpark_ARM(subject SynapseSpark_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SynapseSpark_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SynapseSpark_ARM instances for property testing - lazily instantiated by SynapseSpark_ARMGenerator()
var synapseSpark_ARMGenerator gopter.Gen

// SynapseSpark_ARMGenerator returns a generator of SynapseSpark_ARM instances for property testing.
// We first initialize synapseSpark_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SynapseSpark_ARMGenerator() gopter.Gen {
	if synapseSpark_ARMGenerator != nil {
		return synapseSpark_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSpark_ARM(generators)
	synapseSpark_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSpark_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSpark_ARM(generators)
	AddRelatedPropertyGeneratorsForSynapseSpark_ARM(generators)
	synapseSpark_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSpark_ARM{}), generators)

	return synapseSpark_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSynapseSpark_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSynapseSpark_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(SynapseSpark_ComputeType_SynapseSpark)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSynapseSpark_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSynapseSpark_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SynapseSpark_Properties_ARMGenerator())
}

func Test_VirtualMachine_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_ARM, VirtualMachine_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_ARM runs a test to see if a specific instance of VirtualMachine_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_ARM(subject VirtualMachine_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_ARM instances for property testing - lazily instantiated by VirtualMachine_ARMGenerator()
var virtualMachine_ARMGenerator gopter.Gen

// VirtualMachine_ARMGenerator returns a generator of VirtualMachine_ARM instances for property testing.
// We first initialize virtualMachine_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_ARMGenerator() gopter.Gen {
	if virtualMachine_ARMGenerator != nil {
		return virtualMachine_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_ARM(generators)
	virtualMachine_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_ARM(generators)
	virtualMachine_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_ARM{}), generators)

	return virtualMachine_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_ARM(gens map[string]gopter.Gen) {
	gens["ComputeLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ComputeType"] = gen.OneConstOf(VirtualMachine_ComputeType_VirtualMachine)
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachine_Properties_ARMGenerator())
}

func Test_AKS_Properties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AKS_Properties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAKS_Properties_ARM, AKS_Properties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAKS_Properties_ARM runs a test to see if a specific instance of AKS_Properties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAKS_Properties_ARM(subject AKS_Properties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AKS_Properties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AKS_Properties_ARM instances for property testing - lazily instantiated by AKS_Properties_ARMGenerator()
var aks_Properties_ARMGenerator gopter.Gen

// AKS_Properties_ARMGenerator returns a generator of AKS_Properties_ARM instances for property testing.
// We first initialize aks_Properties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AKS_Properties_ARMGenerator() gopter.Gen {
	if aks_Properties_ARMGenerator != nil {
		return aks_Properties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKS_Properties_ARM(generators)
	aks_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(AKS_Properties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAKS_Properties_ARM(generators)
	AddRelatedPropertyGeneratorsForAKS_Properties_ARM(generators)
	aks_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(AKS_Properties_ARM{}), generators)

	return aks_Properties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAKS_Properties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAKS_Properties_ARM(gens map[string]gopter.Gen) {
	gens["AgentCount"] = gen.PtrOf(gen.Int())
	gens["AgentVmSize"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ClusterPurpose"] = gen.PtrOf(gen.OneConstOf(AKS_Properties_ClusterPurpose_DenseProd, AKS_Properties_ClusterPurpose_DevTest, AKS_Properties_ClusterPurpose_FastProd))
	gens["LoadBalancerSubnet"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerType"] = gen.PtrOf(gen.OneConstOf(AKS_Properties_LoadBalancerType_InternalLoadBalancer, AKS_Properties_LoadBalancerType_PublicIp))
}

// AddRelatedPropertyGeneratorsForAKS_Properties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAKS_Properties_ARM(gens map[string]gopter.Gen) {
	gens["AksNetworkingConfiguration"] = gen.PtrOf(AksNetworkingConfiguration_ARMGenerator())
	gens["SslConfiguration"] = gen.PtrOf(SslConfiguration_ARMGenerator())
}

func Test_AmlComputeProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AmlComputeProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAmlComputeProperties_ARM, AmlComputeProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAmlComputeProperties_ARM runs a test to see if a specific instance of AmlComputeProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAmlComputeProperties_ARM(subject AmlComputeProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AmlComputeProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AmlComputeProperties_ARM instances for property testing - lazily instantiated by
// AmlComputeProperties_ARMGenerator()
var amlComputeProperties_ARMGenerator gopter.Gen

// AmlComputeProperties_ARMGenerator returns a generator of AmlComputeProperties_ARM instances for property testing.
// We first initialize amlComputeProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AmlComputeProperties_ARMGenerator() gopter.Gen {
	if amlComputeProperties_ARMGenerator != nil {
		return amlComputeProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	amlComputeProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM(generators)
	amlComputeProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AmlComputeProperties_ARM{}), generators)

	return amlComputeProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAmlComputeProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnableNodePublicIp"] = gen.PtrOf(gen.Bool())
	gens["IsolatedNetwork"] = gen.PtrOf(gen.Bool())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_OsType_Linux, AmlComputeProperties_OsType_Windows))
	gens["RemoteLoginPortPublicAccess"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled, AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled, AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified))
	gens["VmPriority"] = gen.PtrOf(gen.OneConstOf(AmlComputeProperties_VmPriority_Dedicated, AmlComputeProperties_VmPriority_LowPriority))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAmlComputeProperties_ARM(gens map[string]gopter.Gen) {
	gens["ScaleSettings"] = gen.PtrOf(ScaleSettings_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceId_ARMGenerator())
	gens["UserAccountCredentials"] = gen.PtrOf(UserAccountCredentials_ARMGenerator())
	gens["VirtualMachineImage"] = gen.PtrOf(VirtualMachineImage_ARMGenerator())
}

func Test_ComputeInstanceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceProperties_ARM, ComputeInstanceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceProperties_ARM runs a test to see if a specific instance of ComputeInstanceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceProperties_ARM(subject ComputeInstanceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceProperties_ARM instances for property testing - lazily instantiated by
// ComputeInstanceProperties_ARMGenerator()
var computeInstanceProperties_ARMGenerator gopter.Gen

// ComputeInstanceProperties_ARMGenerator returns a generator of ComputeInstanceProperties_ARM instances for property testing.
// We first initialize computeInstanceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ComputeInstanceProperties_ARMGenerator() gopter.Gen {
	if computeInstanceProperties_ARMGenerator != nil {
		return computeInstanceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	computeInstanceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM(generators)
	computeInstanceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceProperties_ARM{}), generators)

	return computeInstanceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceProperties_ARM(gens map[string]gopter.Gen) {
	gens["ApplicationSharingPolicy"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ApplicationSharingPolicy_Personal, ComputeInstanceProperties_ApplicationSharingPolicy_Shared))
	gens["ComputeInstanceAuthorizationType"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForComputeInstanceProperties_ARM(gens map[string]gopter.Gen) {
	gens["PersonalComputeInstanceSettings"] = gen.PtrOf(PersonalComputeInstanceSettings_ARMGenerator())
	gens["SetupScripts"] = gen.PtrOf(SetupScripts_ARMGenerator())
	gens["SshSettings"] = gen.PtrOf(ComputeInstanceSshSettings_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(ResourceId_ARMGenerator())
}

func Test_DatabricksProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabricksProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabricksProperties_ARM, DatabricksProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabricksProperties_ARM runs a test to see if a specific instance of DatabricksProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabricksProperties_ARM(subject DatabricksProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabricksProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabricksProperties_ARM instances for property testing - lazily instantiated by
// DatabricksProperties_ARMGenerator()
var databricksProperties_ARMGenerator gopter.Gen

// DatabricksProperties_ARMGenerator returns a generator of DatabricksProperties_ARM instances for property testing.
func DatabricksProperties_ARMGenerator() gopter.Gen {
	if databricksProperties_ARMGenerator != nil {
		return databricksProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabricksProperties_ARM(generators)
	databricksProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DatabricksProperties_ARM{}), generators)

	return databricksProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabricksProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabricksProperties_ARM(gens map[string]gopter.Gen) {
	gens["DatabricksAccessToken"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeAnalytics_Properties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeAnalytics_Properties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeAnalytics_Properties_ARM, DataLakeAnalytics_Properties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeAnalytics_Properties_ARM runs a test to see if a specific instance of DataLakeAnalytics_Properties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeAnalytics_Properties_ARM(subject DataLakeAnalytics_Properties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeAnalytics_Properties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeAnalytics_Properties_ARM instances for property testing - lazily instantiated by
// DataLakeAnalytics_Properties_ARMGenerator()
var dataLakeAnalytics_Properties_ARMGenerator gopter.Gen

// DataLakeAnalytics_Properties_ARMGenerator returns a generator of DataLakeAnalytics_Properties_ARM instances for property testing.
func DataLakeAnalytics_Properties_ARMGenerator() gopter.Gen {
	if dataLakeAnalytics_Properties_ARMGenerator != nil {
		return dataLakeAnalytics_Properties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeAnalytics_Properties_ARM(generators)
	dataLakeAnalytics_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(DataLakeAnalytics_Properties_ARM{}), generators)

	return dataLakeAnalytics_Properties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeAnalytics_Properties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeAnalytics_Properties_ARM(gens map[string]gopter.Gen) {
	gens["DataLakeStoreAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HDInsightProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HDInsightProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHDInsightProperties_ARM, HDInsightProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHDInsightProperties_ARM runs a test to see if a specific instance of HDInsightProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHDInsightProperties_ARM(subject HDInsightProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HDInsightProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HDInsightProperties_ARM instances for property testing - lazily instantiated by
// HDInsightProperties_ARMGenerator()
var hdInsightProperties_ARMGenerator gopter.Gen

// HDInsightProperties_ARMGenerator returns a generator of HDInsightProperties_ARM instances for property testing.
// We first initialize hdInsightProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HDInsightProperties_ARMGenerator() gopter.Gen {
	if hdInsightProperties_ARMGenerator != nil {
		return hdInsightProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(generators)
	hdInsightProperties_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForHDInsightProperties_ARM(generators)
	hdInsightProperties_ARMGenerator = gen.Struct(reflect.TypeOf(HDInsightProperties_ARM{}), generators)

	return hdInsightProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHDInsightProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHDInsightProperties_ARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["SshPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHDInsightProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHDInsightProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentials_ARMGenerator())
}

func Test_KubernetesProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesProperties_ARM, KubernetesProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesProperties_ARM runs a test to see if a specific instance of KubernetesProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesProperties_ARM(subject KubernetesProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesProperties_ARM instances for property testing - lazily instantiated by
// KubernetesProperties_ARMGenerator()
var kubernetesProperties_ARMGenerator gopter.Gen

// KubernetesProperties_ARMGenerator returns a generator of KubernetesProperties_ARM instances for property testing.
// We first initialize kubernetesProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KubernetesProperties_ARMGenerator() gopter.Gen {
	if kubernetesProperties_ARMGenerator != nil {
		return kubernetesProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesProperties_ARM(generators)
	kubernetesProperties_ARMGenerator = gen.Struct(reflect.TypeOf(KubernetesProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForKubernetesProperties_ARM(generators)
	kubernetesProperties_ARMGenerator = gen.Struct(reflect.TypeOf(KubernetesProperties_ARM{}), generators)

	return kubernetesProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesProperties_ARM(gens map[string]gopter.Gen) {
	gens["DefaultInstanceType"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionInstanceReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionPrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
	gens["RelayConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceBusConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["VcName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKubernetesProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKubernetesProperties_ARM(gens map[string]gopter.Gen) {
	gens["InstanceTypes"] = gen.MapOf(
		gen.AlphaString(),
		InstanceTypeSchema_ARMGenerator())
}

func Test_SynapseSpark_Properties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SynapseSpark_Properties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSynapseSpark_Properties_ARM, SynapseSpark_Properties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSynapseSpark_Properties_ARM runs a test to see if a specific instance of SynapseSpark_Properties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSynapseSpark_Properties_ARM(subject SynapseSpark_Properties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SynapseSpark_Properties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SynapseSpark_Properties_ARM instances for property testing - lazily instantiated by
// SynapseSpark_Properties_ARMGenerator()
var synapseSpark_Properties_ARMGenerator gopter.Gen

// SynapseSpark_Properties_ARMGenerator returns a generator of SynapseSpark_Properties_ARM instances for property testing.
// We first initialize synapseSpark_Properties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SynapseSpark_Properties_ARMGenerator() gopter.Gen {
	if synapseSpark_Properties_ARMGenerator != nil {
		return synapseSpark_Properties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSpark_Properties_ARM(generators)
	synapseSpark_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSpark_Properties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSynapseSpark_Properties_ARM(generators)
	AddRelatedPropertyGeneratorsForSynapseSpark_Properties_ARM(generators)
	synapseSpark_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(SynapseSpark_Properties_ARM{}), generators)

	return synapseSpark_Properties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSynapseSpark_Properties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSynapseSpark_Properties_ARM(gens map[string]gopter.Gen) {
	gens["NodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeSize"] = gen.PtrOf(gen.AlphaString())
	gens["NodeSizeFamily"] = gen.PtrOf(gen.AlphaString())
	gens["PoolName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SparkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSynapseSpark_Properties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSynapseSpark_Properties_ARM(gens map[string]gopter.Gen) {
	gens["AutoPauseProperties"] = gen.PtrOf(AutoPauseProperties_ARMGenerator())
	gens["AutoScaleProperties"] = gen.PtrOf(AutoScaleProperties_ARMGenerator())
}

func Test_VirtualMachine_Properties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Properties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_Properties_ARM, VirtualMachine_Properties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_Properties_ARM runs a test to see if a specific instance of VirtualMachine_Properties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_Properties_ARM(subject VirtualMachine_Properties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Properties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Properties_ARM instances for property testing - lazily instantiated by
// VirtualMachine_Properties_ARMGenerator()
var virtualMachine_Properties_ARMGenerator gopter.Gen

// VirtualMachine_Properties_ARMGenerator returns a generator of VirtualMachine_Properties_ARM instances for property testing.
// We first initialize virtualMachine_Properties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_Properties_ARMGenerator() gopter.Gen {
	if virtualMachine_Properties_ARMGenerator != nil {
		return virtualMachine_Properties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Properties_ARM(generators)
	virtualMachine_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Properties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Properties_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_Properties_ARM(generators)
	virtualMachine_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Properties_ARM{}), generators)

	return virtualMachine_Properties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_Properties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_Properties_ARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["IsNotebookInstanceCompute"] = gen.PtrOf(gen.Bool())
	gens["SshPort"] = gen.PtrOf(gen.Int())
	gens["VirtualMachineSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_Properties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_Properties_ARM(gens map[string]gopter.Gen) {
	gens["AdministratorAccount"] = gen.PtrOf(VirtualMachineSshCredentials_ARMGenerator())
}

func Test_AksNetworkingConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AksNetworkingConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAksNetworkingConfiguration_ARM, AksNetworkingConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAksNetworkingConfiguration_ARM runs a test to see if a specific instance of AksNetworkingConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAksNetworkingConfiguration_ARM(subject AksNetworkingConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AksNetworkingConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AksNetworkingConfiguration_ARM instances for property testing - lazily instantiated by
// AksNetworkingConfiguration_ARMGenerator()
var aksNetworkingConfiguration_ARMGenerator gopter.Gen

// AksNetworkingConfiguration_ARMGenerator returns a generator of AksNetworkingConfiguration_ARM instances for property testing.
func AksNetworkingConfiguration_ARMGenerator() gopter.Gen {
	if aksNetworkingConfiguration_ARMGenerator != nil {
		return aksNetworkingConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM(generators)
	aksNetworkingConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(AksNetworkingConfiguration_ARM{}), generators)

	return aksNetworkingConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAksNetworkingConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoPauseProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoPauseProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoPauseProperties_ARM, AutoPauseProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoPauseProperties_ARM runs a test to see if a specific instance of AutoPauseProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoPauseProperties_ARM(subject AutoPauseProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoPauseProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoPauseProperties_ARM instances for property testing - lazily instantiated by
// AutoPauseProperties_ARMGenerator()
var autoPauseProperties_ARMGenerator gopter.Gen

// AutoPauseProperties_ARMGenerator returns a generator of AutoPauseProperties_ARM instances for property testing.
func AutoPauseProperties_ARMGenerator() gopter.Gen {
	if autoPauseProperties_ARMGenerator != nil {
		return autoPauseProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM(generators)
	autoPauseProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoPauseProperties_ARM{}), generators)

	return autoPauseProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoPauseProperties_ARM(gens map[string]gopter.Gen) {
	gens["DelayInMinutes"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_AutoScaleProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoScaleProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoScaleProperties_ARM, AutoScaleProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoScaleProperties_ARM runs a test to see if a specific instance of AutoScaleProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoScaleProperties_ARM(subject AutoScaleProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoScaleProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoScaleProperties_ARM instances for property testing - lazily instantiated by
// AutoScaleProperties_ARMGenerator()
var autoScaleProperties_ARMGenerator gopter.Gen

// AutoScaleProperties_ARMGenerator returns a generator of AutoScaleProperties_ARM instances for property testing.
func AutoScaleProperties_ARMGenerator() gopter.Gen {
	if autoScaleProperties_ARMGenerator != nil {
		return autoScaleProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM(generators)
	autoScaleProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoScaleProperties_ARM{}), generators)

	return autoScaleProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoScaleProperties_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
}

func Test_ComputeInstanceSshSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeInstanceSshSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeInstanceSshSettings_ARM, ComputeInstanceSshSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeInstanceSshSettings_ARM runs a test to see if a specific instance of ComputeInstanceSshSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeInstanceSshSettings_ARM(subject ComputeInstanceSshSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeInstanceSshSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeInstanceSshSettings_ARM instances for property testing - lazily instantiated by
// ComputeInstanceSshSettings_ARMGenerator()
var computeInstanceSshSettings_ARMGenerator gopter.Gen

// ComputeInstanceSshSettings_ARMGenerator returns a generator of ComputeInstanceSshSettings_ARM instances for property testing.
func ComputeInstanceSshSettings_ARMGenerator() gopter.Gen {
	if computeInstanceSshSettings_ARMGenerator != nil {
		return computeInstanceSshSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM(generators)
	computeInstanceSshSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ComputeInstanceSshSettings_ARM{}), generators)

	return computeInstanceSshSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeInstanceSshSettings_ARM(gens map[string]gopter.Gen) {
	gens["AdminPublicKey"] = gen.PtrOf(gen.AlphaString())
	gens["SshPublicAccess"] = gen.PtrOf(gen.OneConstOf(ComputeInstanceSshSettings_SshPublicAccess_Disabled, ComputeInstanceSshSettings_SshPublicAccess_Enabled))
}

func Test_InstanceTypeSchema_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceTypeSchema_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceTypeSchema_ARM, InstanceTypeSchema_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceTypeSchema_ARM runs a test to see if a specific instance of InstanceTypeSchema_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceTypeSchema_ARM(subject InstanceTypeSchema_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceTypeSchema_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceTypeSchema_ARM instances for property testing - lazily instantiated by
// InstanceTypeSchema_ARMGenerator()
var instanceTypeSchema_ARMGenerator gopter.Gen

// InstanceTypeSchema_ARMGenerator returns a generator of InstanceTypeSchema_ARM instances for property testing.
// We first initialize instanceTypeSchema_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InstanceTypeSchema_ARMGenerator() gopter.Gen {
	if instanceTypeSchema_ARMGenerator != nil {
		return instanceTypeSchema_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceTypeSchema_ARM(generators)
	instanceTypeSchema_ARMGenerator = gen.Struct(reflect.TypeOf(InstanceTypeSchema_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceTypeSchema_ARM(generators)
	AddRelatedPropertyGeneratorsForInstanceTypeSchema_ARM(generators)
	instanceTypeSchema_ARMGenerator = gen.Struct(reflect.TypeOf(InstanceTypeSchema_ARM{}), generators)

	return instanceTypeSchema_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceTypeSchema_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceTypeSchema_ARM(gens map[string]gopter.Gen) {
	gens["NodeSelector"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInstanceTypeSchema_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInstanceTypeSchema_ARM(gens map[string]gopter.Gen) {
	gens["Resources"] = gen.PtrOf(InstanceTypeSchema_Resources_ARMGenerator())
}

func Test_PersonalComputeInstanceSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PersonalComputeInstanceSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM, PersonalComputeInstanceSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM runs a test to see if a specific instance of PersonalComputeInstanceSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPersonalComputeInstanceSettings_ARM(subject PersonalComputeInstanceSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PersonalComputeInstanceSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PersonalComputeInstanceSettings_ARM instances for property testing - lazily instantiated by
// PersonalComputeInstanceSettings_ARMGenerator()
var personalComputeInstanceSettings_ARMGenerator gopter.Gen

// PersonalComputeInstanceSettings_ARMGenerator returns a generator of PersonalComputeInstanceSettings_ARM instances for property testing.
func PersonalComputeInstanceSettings_ARMGenerator() gopter.Gen {
	if personalComputeInstanceSettings_ARMGenerator != nil {
		return personalComputeInstanceSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM(generators)
	personalComputeInstanceSettings_ARMGenerator = gen.Struct(reflect.TypeOf(PersonalComputeInstanceSettings_ARM{}), generators)

	return personalComputeInstanceSettings_ARMGenerator
}

// AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPersonalComputeInstanceSettings_ARM(gens map[string]gopter.Gen) {
	gens["AssignedUser"] = gen.PtrOf(AssignedUser_ARMGenerator())
}

func Test_ResourceId_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceId_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceId_ARM, ResourceId_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceId_ARM runs a test to see if a specific instance of ResourceId_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceId_ARM(subject ResourceId_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceId_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceId_ARM instances for property testing - lazily instantiated by ResourceId_ARMGenerator()
var resourceId_ARMGenerator gopter.Gen

// ResourceId_ARMGenerator returns a generator of ResourceId_ARM instances for property testing.
func ResourceId_ARMGenerator() gopter.Gen {
	if resourceId_ARMGenerator != nil {
		return resourceId_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceId_ARM(generators)
	resourceId_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceId_ARM{}), generators)

	return resourceId_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceId_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceId_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleSettings_ARM, ScaleSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleSettings_ARM runs a test to see if a specific instance of ScaleSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleSettings_ARM(subject ScaleSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleSettings_ARM instances for property testing - lazily instantiated by ScaleSettings_ARMGenerator()
var scaleSettings_ARMGenerator gopter.Gen

// ScaleSettings_ARMGenerator returns a generator of ScaleSettings_ARM instances for property testing.
func ScaleSettings_ARMGenerator() gopter.Gen {
	if scaleSettings_ARMGenerator != nil {
		return scaleSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleSettings_ARM(generators)
	scaleSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleSettings_ARM{}), generators)

	return scaleSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleSettings_ARM(gens map[string]gopter.Gen) {
	gens["MaxNodeCount"] = gen.PtrOf(gen.Int())
	gens["MinNodeCount"] = gen.PtrOf(gen.Int())
	gens["NodeIdleTimeBeforeScaleDown"] = gen.PtrOf(gen.AlphaString())
}

func Test_SetupScripts_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SetupScripts_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSetupScripts_ARM, SetupScripts_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSetupScripts_ARM runs a test to see if a specific instance of SetupScripts_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSetupScripts_ARM(subject SetupScripts_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SetupScripts_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SetupScripts_ARM instances for property testing - lazily instantiated by SetupScripts_ARMGenerator()
var setupScripts_ARMGenerator gopter.Gen

// SetupScripts_ARMGenerator returns a generator of SetupScripts_ARM instances for property testing.
func SetupScripts_ARMGenerator() gopter.Gen {
	if setupScripts_ARMGenerator != nil {
		return setupScripts_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSetupScripts_ARM(generators)
	setupScripts_ARMGenerator = gen.Struct(reflect.TypeOf(SetupScripts_ARM{}), generators)

	return setupScripts_ARMGenerator
}

// AddRelatedPropertyGeneratorsForSetupScripts_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSetupScripts_ARM(gens map[string]gopter.Gen) {
	gens["Scripts"] = gen.PtrOf(ScriptsToExecute_ARMGenerator())
}

func Test_SslConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslConfiguration_ARM, SslConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslConfiguration_ARM runs a test to see if a specific instance of SslConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslConfiguration_ARM(subject SslConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslConfiguration_ARM instances for property testing - lazily instantiated by
// SslConfiguration_ARMGenerator()
var sslConfiguration_ARMGenerator gopter.Gen

// SslConfiguration_ARMGenerator returns a generator of SslConfiguration_ARM instances for property testing.
func SslConfiguration_ARMGenerator() gopter.Gen {
	if sslConfiguration_ARMGenerator != nil {
		return sslConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslConfiguration_ARM(generators)
	sslConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(SslConfiguration_ARM{}), generators)

	return sslConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSslConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Cert"] = gen.PtrOf(gen.AlphaString())
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["LeafDomainLabel"] = gen.PtrOf(gen.AlphaString())
	gens["OverwriteExistingDomain"] = gen.PtrOf(gen.Bool())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(SslConfiguration_Status_Auto, SslConfiguration_Status_Disabled, SslConfiguration_Status_Enabled))
}

func Test_UserAccountCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAccountCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAccountCredentials_ARM, UserAccountCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAccountCredentials_ARM runs a test to see if a specific instance of UserAccountCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAccountCredentials_ARM(subject UserAccountCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAccountCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAccountCredentials_ARM instances for property testing - lazily instantiated by
// UserAccountCredentials_ARMGenerator()
var userAccountCredentials_ARMGenerator gopter.Gen

// UserAccountCredentials_ARMGenerator returns a generator of UserAccountCredentials_ARM instances for property testing.
func UserAccountCredentials_ARMGenerator() gopter.Gen {
	if userAccountCredentials_ARMGenerator != nil {
		return userAccountCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM(generators)
	userAccountCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(UserAccountCredentials_ARM{}), generators)

	return userAccountCredentials_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAccountCredentials_ARM(gens map[string]gopter.Gen) {
	gens["AdminUserName"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUserSshPublicKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineImage_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineImage_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineImage_ARM, VirtualMachineImage_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineImage_ARM runs a test to see if a specific instance of VirtualMachineImage_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineImage_ARM(subject VirtualMachineImage_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineImage_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineImage_ARM instances for property testing - lazily instantiated by
// VirtualMachineImage_ARMGenerator()
var virtualMachineImage_ARMGenerator gopter.Gen

// VirtualMachineImage_ARMGenerator returns a generator of VirtualMachineImage_ARM instances for property testing.
func VirtualMachineImage_ARMGenerator() gopter.Gen {
	if virtualMachineImage_ARMGenerator != nil {
		return virtualMachineImage_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM(generators)
	virtualMachineImage_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineImage_ARM{}), generators)

	return virtualMachineImage_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineImage_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineSshCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineSshCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineSshCredentials_ARM, VirtualMachineSshCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineSshCredentials_ARM runs a test to see if a specific instance of VirtualMachineSshCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineSshCredentials_ARM(subject VirtualMachineSshCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineSshCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineSshCredentials_ARM instances for property testing - lazily instantiated by
// VirtualMachineSshCredentials_ARMGenerator()
var virtualMachineSshCredentials_ARMGenerator gopter.Gen

// VirtualMachineSshCredentials_ARMGenerator returns a generator of VirtualMachineSshCredentials_ARM instances for property testing.
func VirtualMachineSshCredentials_ARMGenerator() gopter.Gen {
	if virtualMachineSshCredentials_ARMGenerator != nil {
		return virtualMachineSshCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM(generators)
	virtualMachineSshCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineSshCredentials_ARM{}), generators)

	return virtualMachineSshCredentials_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineSshCredentials_ARM(gens map[string]gopter.Gen) {
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["PublicKeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_AssignedUser_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AssignedUser_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAssignedUser_ARM, AssignedUser_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAssignedUser_ARM runs a test to see if a specific instance of AssignedUser_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAssignedUser_ARM(subject AssignedUser_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AssignedUser_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AssignedUser_ARM instances for property testing - lazily instantiated by AssignedUser_ARMGenerator()
var assignedUser_ARMGenerator gopter.Gen

// AssignedUser_ARMGenerator returns a generator of AssignedUser_ARM instances for property testing.
func AssignedUser_ARMGenerator() gopter.Gen {
	if assignedUser_ARMGenerator != nil {
		return assignedUser_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAssignedUser_ARM(generators)
	assignedUser_ARMGenerator = gen.Struct(reflect.TypeOf(AssignedUser_ARM{}), generators)

	return assignedUser_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAssignedUser_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAssignedUser_ARM(gens map[string]gopter.Gen) {
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceTypeSchema_Resources_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceTypeSchema_Resources_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceTypeSchema_Resources_ARM, InstanceTypeSchema_Resources_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceTypeSchema_Resources_ARM runs a test to see if a specific instance of InstanceTypeSchema_Resources_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceTypeSchema_Resources_ARM(subject InstanceTypeSchema_Resources_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceTypeSchema_Resources_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceTypeSchema_Resources_ARM instances for property testing - lazily instantiated by
// InstanceTypeSchema_Resources_ARMGenerator()
var instanceTypeSchema_Resources_ARMGenerator gopter.Gen

// InstanceTypeSchema_Resources_ARMGenerator returns a generator of InstanceTypeSchema_Resources_ARM instances for property testing.
func InstanceTypeSchema_Resources_ARMGenerator() gopter.Gen {
	if instanceTypeSchema_Resources_ARMGenerator != nil {
		return instanceTypeSchema_Resources_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceTypeSchema_Resources_ARM(generators)
	instanceTypeSchema_Resources_ARMGenerator = gen.Struct(reflect.TypeOf(InstanceTypeSchema_Resources_ARM{}), generators)

	return instanceTypeSchema_Resources_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceTypeSchema_Resources_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceTypeSchema_Resources_ARM(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Requests"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_ScriptsToExecute_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptsToExecute_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptsToExecute_ARM, ScriptsToExecute_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptsToExecute_ARM runs a test to see if a specific instance of ScriptsToExecute_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptsToExecute_ARM(subject ScriptsToExecute_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptsToExecute_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptsToExecute_ARM instances for property testing - lazily instantiated by
// ScriptsToExecute_ARMGenerator()
var scriptsToExecute_ARMGenerator gopter.Gen

// ScriptsToExecute_ARMGenerator returns a generator of ScriptsToExecute_ARM instances for property testing.
func ScriptsToExecute_ARMGenerator() gopter.Gen {
	if scriptsToExecute_ARMGenerator != nil {
		return scriptsToExecute_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScriptsToExecute_ARM(generators)
	scriptsToExecute_ARMGenerator = gen.Struct(reflect.TypeOf(ScriptsToExecute_ARM{}), generators)

	return scriptsToExecute_ARMGenerator
}

// AddRelatedPropertyGeneratorsForScriptsToExecute_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScriptsToExecute_ARM(gens map[string]gopter.Gen) {
	gens["CreationScript"] = gen.PtrOf(ScriptReference_ARMGenerator())
	gens["StartupScript"] = gen.PtrOf(ScriptReference_ARMGenerator())
}

func Test_ScriptReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScriptReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScriptReference_ARM, ScriptReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScriptReference_ARM runs a test to see if a specific instance of ScriptReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScriptReference_ARM(subject ScriptReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScriptReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScriptReference_ARM instances for property testing - lazily instantiated by
// ScriptReference_ARMGenerator()
var scriptReference_ARMGenerator gopter.Gen

// ScriptReference_ARMGenerator returns a generator of ScriptReference_ARM instances for property testing.
func ScriptReference_ARMGenerator() gopter.Gen {
	if scriptReference_ARMGenerator != nil {
		return scriptReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScriptReference_ARM(generators)
	scriptReference_ARMGenerator = gen.Struct(reflect.TypeOf(ScriptReference_ARM{}), generators)

	return scriptReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScriptReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScriptReference_ARM(gens map[string]gopter.Gen) {
	gens["ScriptArguments"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptData"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptSource"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.AlphaString())
}
