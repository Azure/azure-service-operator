// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	v20211001s "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1beta20211001storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroup_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup to hub returns original",
		prop.ForAll(RunResourceConversionTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForContainerGroup tests if a specific instance of ContainerGroup round trips to the hub storage version and back losslessly
func RunResourceConversionTestForContainerGroup(subject ContainerGroup) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20211001s.ContainerGroup
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ContainerGroup
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup to ContainerGroup via AssignPropertiesToContainerGroup & AssignPropertiesFromContainerGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroup tests if a specific instance of ContainerGroup can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroup(subject ContainerGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup
	err := copied.AssignPropertiesToContainerGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup
	err = actual.AssignPropertiesFromContainerGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup runs a test to see if a specific instance of ContainerGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup(subject ContainerGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup instances for property testing - lazily instantiated by ContainerGroupGenerator()
var containerGroupGenerator gopter.Gen

// ContainerGroupGenerator returns a generator of ContainerGroup instances for property testing.
func ContainerGroupGenerator() gopter.Gen {
	if containerGroupGenerator != nil {
		return containerGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroup(generators)
	containerGroupGenerator = gen.Struct(reflect.TypeOf(ContainerGroup{}), generators)

	return containerGroupGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = ContainerGroupsSpecGenerator()
	gens["Status"] = ContainerGroupStatusGenerator()
}

func Test_ContainerGroup_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup_Status to ContainerGroup_Status via AssignPropertiesToContainerGroupStatus & AssignPropertiesFromContainerGroupStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupStatus, ContainerGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupStatus tests if a specific instance of ContainerGroup_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupStatus(subject ContainerGroup_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup_Status
	err := copied.AssignPropertiesToContainerGroupStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup_Status
	err = actual.AssignPropertiesFromContainerGroupStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupStatus, ContainerGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupStatus runs a test to see if a specific instance of ContainerGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupStatus(subject ContainerGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Status instances for property testing - lazily instantiated by
// ContainerGroupStatusGenerator()
var containerGroupStatusGenerator gopter.Gen

// ContainerGroupStatusGenerator returns a generator of ContainerGroup_Status instances for property testing.
// We first initialize containerGroupStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupStatusGenerator() gopter.Gen {
	if containerGroupStatusGenerator != nil {
		return containerGroupStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatus(generators)
	containerGroupStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatus(generators)
	AddRelatedPropertyGeneratorsForContainerGroupStatus(generators)
	containerGroupStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status{}), generators)

	return containerGroupStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroupStatusPropertiesOsTypeLinux, ContainerGroupStatusPropertiesOsTypeWindows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroupStatusPropertiesRestartPolicyAlways, ContainerGroupStatusPropertiesRestartPolicyNever, ContainerGroupStatusPropertiesRestartPolicyOnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSku_StatusDedicated, ContainerGroupSku_StatusStandard))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupStatus(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerStatusGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsStatusGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationStatusGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesStatusGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityStatusGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredentialStatusGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinitionStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerGroupStatusPropertiesInstanceViewGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressStatusGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdStatusGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeStatusGenerator())
}

func Test_ContainerGroups_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec to ContainerGroups_Spec via AssignPropertiesToContainerGroupsSpec & AssignPropertiesFromContainerGroupsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpec, ContainerGroupsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpec tests if a specific instance of ContainerGroups_Spec can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpec(subject ContainerGroups_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec
	err := copied.AssignPropertiesToContainerGroupsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec
	err = actual.AssignPropertiesFromContainerGroupsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpec, ContainerGroupsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpec runs a test to see if a specific instance of ContainerGroups_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpec(subject ContainerGroups_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec instances for property testing - lazily instantiated by
// ContainerGroupsSpecGenerator()
var containerGroupsSpecGenerator gopter.Gen

// ContainerGroupsSpecGenerator returns a generator of ContainerGroups_Spec instances for property testing.
// We first initialize containerGroupsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecGenerator() gopter.Gen {
	if containerGroupsSpecGenerator != nil {
		return containerGroupsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	return containerGroupsSpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesOsTypeLinux, ContainerGroupsSpecPropertiesOsTypeWindows))
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesRestartPolicyAlways, ContainerGroupsSpecPropertiesRestartPolicyNever, ContainerGroupsSpecPropertiesRestartPolicyOnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesSkuDedicated, ContainerGroupsSpecPropertiesSkuStandard))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGroupsSpecPropertiesContainersGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator())
	gens["InitContainers"] = gen.SliceOf(ContainerGroupsSpecPropertiesInitContainersGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_ContainerGroupDiagnostics_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupDiagnostics to ContainerGroupDiagnostics via AssignPropertiesToContainerGroupDiagnostics & AssignPropertiesFromContainerGroupDiagnostics returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupDiagnostics tests if a specific instance of ContainerGroupDiagnostics can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupDiagnostics
	err := copied.AssignPropertiesToContainerGroupDiagnostics(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupDiagnostics
	err = actual.AssignPropertiesFromContainerGroupDiagnostics(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupDiagnostics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics runs a test to see if a specific instance of ContainerGroupDiagnostics round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsGenerator()
var containerGroupDiagnosticsGenerator gopter.Gen

// ContainerGroupDiagnosticsGenerator returns a generator of ContainerGroupDiagnostics instances for property testing.
func ContainerGroupDiagnosticsGenerator() gopter.Gen {
	if containerGroupDiagnosticsGenerator != nil {
		return containerGroupDiagnosticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(generators)
	containerGroupDiagnosticsGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics{}), generators)

	return containerGroupDiagnosticsGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsGenerator())
}

func Test_ContainerGroupDiagnostics_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupDiagnostics_Status to ContainerGroupDiagnostics_Status via AssignPropertiesToContainerGroupDiagnosticsStatus & AssignPropertiesFromContainerGroupDiagnosticsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupDiagnosticsStatus, ContainerGroupDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupDiagnosticsStatus tests if a specific instance of ContainerGroupDiagnostics_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupDiagnosticsStatus(subject ContainerGroupDiagnostics_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupDiagnostics_Status
	err := copied.AssignPropertiesToContainerGroupDiagnosticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupDiagnostics_Status
	err = actual.AssignPropertiesFromContainerGroupDiagnosticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnosticsStatus, ContainerGroupDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnosticsStatus runs a test to see if a specific instance of ContainerGroupDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnosticsStatus(subject ContainerGroupDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics_Status instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsStatusGenerator()
var containerGroupDiagnosticsStatusGenerator gopter.Gen

// ContainerGroupDiagnosticsStatusGenerator returns a generator of ContainerGroupDiagnostics_Status instances for property testing.
func ContainerGroupDiagnosticsStatusGenerator() gopter.Gen {
	if containerGroupDiagnosticsStatusGenerator != nil {
		return containerGroupDiagnosticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus(generators)
	containerGroupDiagnosticsStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics_Status{}), generators)

	return containerGroupDiagnosticsStatusGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsStatusGenerator())
}

func Test_ContainerGroupIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity to ContainerGroupIdentity via AssignPropertiesToContainerGroupIdentity & AssignPropertiesFromContainerGroupIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentity tests if a specific instance of ContainerGroupIdentity can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity
	err := copied.AssignPropertiesToContainerGroupIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity
	err = actual.AssignPropertiesFromContainerGroupIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity runs a test to see if a specific instance of ContainerGroupIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity instances for property testing - lazily instantiated by
// ContainerGroupIdentityGenerator()
var containerGroupIdentityGenerator gopter.Gen

// ContainerGroupIdentityGenerator returns a generator of ContainerGroupIdentity instances for property testing.
func ContainerGroupIdentityGenerator() gopter.Gen {
	if containerGroupIdentityGenerator != nil {
		return containerGroupIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	return containerGroupIdentityGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentityTypeNone,
		ContainerGroupIdentityTypeSystemAssigned,
		ContainerGroupIdentityTypeSystemAssignedUserAssigned,
		ContainerGroupIdentityTypeUserAssigned))
}

func Test_ContainerGroupIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity_Status to ContainerGroupIdentity_Status via AssignPropertiesToContainerGroupIdentityStatus & AssignPropertiesFromContainerGroupIdentityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentityStatus, ContainerGroupIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentityStatus tests if a specific instance of ContainerGroupIdentity_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentityStatus(subject ContainerGroupIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity_Status
	err := copied.AssignPropertiesToContainerGroupIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity_Status
	err = actual.AssignPropertiesFromContainerGroupIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentityStatus, ContainerGroupIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentityStatus runs a test to see if a specific instance of ContainerGroupIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentityStatus(subject ContainerGroupIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_Status instances for property testing - lazily instantiated by
// ContainerGroupIdentityStatusGenerator()
var containerGroupIdentityStatusGenerator gopter.Gen

// ContainerGroupIdentityStatusGenerator returns a generator of ContainerGroupIdentity_Status instances for property testing.
// We first initialize containerGroupIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentityStatusGenerator() gopter.Gen {
	if containerGroupIdentityStatusGenerator != nil {
		return containerGroupIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	containerGroupIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	containerGroupIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status{}), generators)

	return containerGroupIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentityStatusTypeNone,
		ContainerGroupIdentityStatusTypeSystemAssigned,
		ContainerGroupIdentityStatusTypeSystemAssignedUserAssigned,
		ContainerGroupIdentityStatusTypeUserAssigned))
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_ContainerGroupSubnetId_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupSubnetId to ContainerGroupSubnetId via AssignPropertiesToContainerGroupSubnetId & AssignPropertiesFromContainerGroupSubnetId returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSubnetId tests if a specific instance of ContainerGroupSubnetId can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupSubnetId
	err := copied.AssignPropertiesToContainerGroupSubnetId(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupSubnetId
	err = actual.AssignPropertiesFromContainerGroupSubnetId(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupSubnetId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId runs a test to see if a specific instance of ContainerGroupSubnetId round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdGenerator()
var containerGroupSubnetIdGenerator gopter.Gen

// ContainerGroupSubnetIdGenerator returns a generator of ContainerGroupSubnetId instances for property testing.
func ContainerGroupSubnetIdGenerator() gopter.Gen {
	if containerGroupSubnetIdGenerator != nil {
		return containerGroupSubnetIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId(generators)
	containerGroupSubnetIdGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId{}), generators)

	return containerGroupSubnetIdGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupSubnetId_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupSubnetId_Status to ContainerGroupSubnetId_Status via AssignPropertiesToContainerGroupSubnetIdStatus & AssignPropertiesFromContainerGroupSubnetIdStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSubnetIdStatus, ContainerGroupSubnetIdStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSubnetIdStatus tests if a specific instance of ContainerGroupSubnetId_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSubnetIdStatus(subject ContainerGroupSubnetId_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupSubnetId_Status
	err := copied.AssignPropertiesToContainerGroupSubnetIdStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupSubnetId_Status
	err = actual.AssignPropertiesFromContainerGroupSubnetIdStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupSubnetId_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetIdStatus, ContainerGroupSubnetIdStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetIdStatus runs a test to see if a specific instance of ContainerGroupSubnetId_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetIdStatus(subject ContainerGroupSubnetId_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId_Status instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdStatusGenerator()
var containerGroupSubnetIdStatusGenerator gopter.Gen

// ContainerGroupSubnetIdStatusGenerator returns a generator of ContainerGroupSubnetId_Status instances for property testing.
func ContainerGroupSubnetIdStatusGenerator() gopter.Gen {
	if containerGroupSubnetIdStatusGenerator != nil {
		return containerGroupSubnetIdStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus(generators)
	containerGroupSubnetIdStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId_Status{}), generators)

	return containerGroupSubnetIdStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Status_Properties_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup_Status_Properties_InstanceView to ContainerGroup_Status_Properties_InstanceView via AssignPropertiesToContainerGroupStatusPropertiesInstanceView & AssignPropertiesFromContainerGroupStatusPropertiesInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupStatusPropertiesInstanceView, ContainerGroupStatusPropertiesInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupStatusPropertiesInstanceView tests if a specific instance of ContainerGroup_Status_Properties_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupStatusPropertiesInstanceView(subject ContainerGroup_Status_Properties_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup_Status_Properties_InstanceView
	err := copied.AssignPropertiesToContainerGroupStatusPropertiesInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup_Status_Properties_InstanceView
	err = actual.AssignPropertiesFromContainerGroupStatusPropertiesInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_Status_Properties_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Status_Properties_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView, ContainerGroupStatusPropertiesInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView runs a test to see if a specific instance of ContainerGroup_Status_Properties_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView(subject ContainerGroup_Status_Properties_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Status_Properties_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Status_Properties_InstanceView instances for property testing - lazily instantiated by
// ContainerGroupStatusPropertiesInstanceViewGenerator()
var containerGroupStatusPropertiesInstanceViewGenerator gopter.Gen

// ContainerGroupStatusPropertiesInstanceViewGenerator returns a generator of ContainerGroup_Status_Properties_InstanceView instances for property testing.
// We first initialize containerGroupStatusPropertiesInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupStatusPropertiesInstanceViewGenerator() gopter.Gen {
	if containerGroupStatusPropertiesInstanceViewGenerator != nil {
		return containerGroupStatusPropertiesInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	containerGroupStatusPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status_Properties_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	containerGroupStatusPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status_Properties_InstanceView{}), generators)

	return containerGroupStatusPropertiesInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
}

func Test_ContainerGroups_Spec_Properties_Containers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_Containers to ContainerGroups_Spec_Properties_Containers via AssignPropertiesToContainerGroupsSpecPropertiesContainers & AssignPropertiesFromContainerGroupsSpecPropertiesContainers returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers, ContainerGroupsSpecPropertiesContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers tests if a specific instance of ContainerGroups_Spec_Properties_Containers can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers(subject ContainerGroups_Spec_Properties_Containers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_Containers
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_Containers
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_Containers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_Containers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers, ContainerGroupsSpecPropertiesContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_Containers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers(subject ContainerGroups_Spec_Properties_Containers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_Containers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_Containers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesContainersGenerator()
var containerGroupsSpecPropertiesContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesContainersGenerator returns a generator of ContainerGroups_Spec_Properties_Containers instances for property testing.
// We first initialize containerGroupsSpecPropertiesContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesContainersGenerator != nil {
		return containerGroupsSpecPropertiesContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	return containerGroupsSpecPropertiesContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroups_Spec_Properties_ImageRegistryCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_ImageRegistryCredentials to ContainerGroups_Spec_Properties_ImageRegistryCredentials via AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials & AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials, ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials tests if a specific instance of ContainerGroups_Spec_Properties_ImageRegistryCredentials can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials(subject ContainerGroups_Spec_Properties_ImageRegistryCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_ImageRegistryCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_ImageRegistryCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials, ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials runs a test to see if a specific instance of ContainerGroups_Spec_Properties_ImageRegistryCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials(subject ContainerGroups_Spec_Properties_ImageRegistryCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_ImageRegistryCredentials instances for property testing - lazily
// instantiated by ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()
var containerGroupsSpecPropertiesImageRegistryCredentialsGenerator gopter.Gen

// ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator returns a generator of ContainerGroups_Spec_Properties_ImageRegistryCredentials instances for property testing.
func ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesImageRegistryCredentialsGenerator != nil {
		return containerGroupsSpecPropertiesImageRegistryCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials(generators)
	containerGroupsSpecPropertiesImageRegistryCredentialsGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_ImageRegistryCredentials{}), generators)

	return containerGroupsSpecPropertiesImageRegistryCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroups_Spec_Properties_InitContainers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_InitContainers to ContainerGroups_Spec_Properties_InitContainers via AssignPropertiesToContainerGroupsSpecPropertiesInitContainers & AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers, ContainerGroupsSpecPropertiesInitContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers tests if a specific instance of ContainerGroups_Spec_Properties_InitContainers can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers(subject ContainerGroups_Spec_Properties_InitContainers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_InitContainers
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesInitContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_InitContainers
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_InitContainers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_InitContainers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers, ContainerGroupsSpecPropertiesInitContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_InitContainers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers(subject ContainerGroups_Spec_Properties_InitContainers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_InitContainers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesInitContainersGenerator()
var containerGroupsSpecPropertiesInitContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesInitContainersGenerator returns a generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing.
// We first initialize containerGroupsSpecPropertiesInitContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesInitContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesInitContainersGenerator != nil {
		return containerGroupsSpecPropertiesInitContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	return containerGroupsSpecPropertiesInitContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_Container_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Container_Status to Container_Status via AssignPropertiesToContainerStatus & AssignPropertiesFromContainerStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerStatus, ContainerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerStatus tests if a specific instance of Container_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerStatus(subject Container_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Container_Status
	err := copied.AssignPropertiesToContainerStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Container_Status
	err = actual.AssignPropertiesFromContainerStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Container_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerStatus, ContainerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerStatus runs a test to see if a specific instance of Container_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerStatus(subject Container_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_Status instances for property testing - lazily instantiated by ContainerStatusGenerator()
var containerStatusGenerator gopter.Gen

// ContainerStatusGenerator returns a generator of Container_Status instances for property testing.
// We first initialize containerStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerStatusGenerator() gopter.Gen {
	if containerStatusGenerator != nil {
		return containerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStatus(generators)
	containerStatusGenerator = gen.Struct(reflect.TypeOf(Container_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStatus(generators)
	AddRelatedPropertyGeneratorsForContainerStatus(generators)
	containerStatusGenerator = gen.Struct(reflect.TypeOf(Container_Status{}), generators)

	return containerStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerStatus(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerPropertiesStatusInstanceViewGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeStatusGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortStatusGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeStatusGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsStatusGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountStatusGenerator())
}

func Test_DnsConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsConfiguration to DnsConfiguration via AssignPropertiesToDnsConfiguration & AssignPropertiesFromDnsConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsConfiguration tests if a specific instance of DnsConfiguration can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForDnsConfiguration(subject DnsConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.DnsConfiguration
	err := copied.AssignPropertiesToDnsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsConfiguration
	err = actual.AssignPropertiesFromDnsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration runs a test to see if a specific instance of DnsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration(subject DnsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration instances for property testing - lazily instantiated by DnsConfigurationGenerator()
var dnsConfigurationGenerator gopter.Gen

// DnsConfigurationGenerator returns a generator of DnsConfiguration instances for property testing.
func DnsConfigurationGenerator() gopter.Gen {
	if dnsConfigurationGenerator != nil {
		return dnsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration(generators)
	dnsConfigurationGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration{}), generators)

	return dnsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsConfiguration_Status to DnsConfiguration_Status via AssignPropertiesToDnsConfigurationStatus & AssignPropertiesFromDnsConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsConfigurationStatus, DnsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsConfigurationStatus tests if a specific instance of DnsConfiguration_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForDnsConfigurationStatus(subject DnsConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.DnsConfiguration_Status
	err := copied.AssignPropertiesToDnsConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsConfiguration_Status
	err = actual.AssignPropertiesFromDnsConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfigurationStatus, DnsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfigurationStatus runs a test to see if a specific instance of DnsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfigurationStatus(subject DnsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration_Status instances for property testing - lazily instantiated by
// DnsConfigurationStatusGenerator()
var dnsConfigurationStatusGenerator gopter.Gen

// DnsConfigurationStatusGenerator returns a generator of DnsConfiguration_Status instances for property testing.
func DnsConfigurationStatusGenerator() gopter.Gen {
	if dnsConfigurationStatusGenerator != nil {
		return dnsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfigurationStatus(generators)
	dnsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration_Status{}), generators)

	return dnsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties to EncryptionProperties via AssignPropertiesToEncryptionProperties & AssignPropertiesFromEncryptionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperties tests if a specific instance of EncryptionProperties can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperties(subject EncryptionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EncryptionProperties
	err := copied.AssignPropertiesToEncryptionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties
	err = actual.AssignPropertiesFromEncryptionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties runs a test to see if a specific instance of EncryptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties(subject EncryptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties instances for property testing - lazily instantiated by
// EncryptionPropertiesGenerator()
var encryptionPropertiesGenerator gopter.Gen

// EncryptionPropertiesGenerator returns a generator of EncryptionProperties instances for property testing.
func EncryptionPropertiesGenerator() gopter.Gen {
	if encryptionPropertiesGenerator != nil {
		return encryptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties(generators)
	encryptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties{}), generators)

	return encryptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_Status to EncryptionProperties_Status via AssignPropertiesToEncryptionPropertiesStatus & AssignPropertiesFromEncryptionPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertiesStatus, EncryptionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertiesStatus tests if a specific instance of EncryptionProperties_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertiesStatus(subject EncryptionProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EncryptionProperties_Status
	err := copied.AssignPropertiesToEncryptionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_Status
	err = actual.AssignPropertiesFromEncryptionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesStatus, EncryptionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesStatus runs a test to see if a specific instance of EncryptionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesStatus(subject EncryptionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Status instances for property testing - lazily instantiated by
// EncryptionPropertiesStatusGenerator()
var encryptionPropertiesStatusGenerator gopter.Gen

// EncryptionPropertiesStatusGenerator returns a generator of EncryptionProperties_Status instances for property testing.
func EncryptionPropertiesStatusGenerator() gopter.Gen {
	if encryptionPropertiesStatusGenerator != nil {
		return encryptionPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(generators)
	encryptionPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	return encryptionPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageRegistryCredential_Status to ImageRegistryCredential_Status via AssignPropertiesToImageRegistryCredentialStatus & AssignPropertiesFromImageRegistryCredentialStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageRegistryCredentialStatus, ImageRegistryCredentialStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageRegistryCredentialStatus tests if a specific instance of ImageRegistryCredential_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForImageRegistryCredentialStatus(subject ImageRegistryCredential_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ImageRegistryCredential_Status
	err := copied.AssignPropertiesToImageRegistryCredentialStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageRegistryCredential_Status
	err = actual.AssignPropertiesFromImageRegistryCredentialStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageRegistryCredential_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredentialStatus, ImageRegistryCredentialStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredentialStatus runs a test to see if a specific instance of ImageRegistryCredential_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredentialStatus(subject ImageRegistryCredential_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential_Status instances for property testing - lazily instantiated by
// ImageRegistryCredentialStatusGenerator()
var imageRegistryCredentialStatusGenerator gopter.Gen

// ImageRegistryCredentialStatusGenerator returns a generator of ImageRegistryCredential_Status instances for property testing.
func ImageRegistryCredentialStatusGenerator() gopter.Gen {
	if imageRegistryCredentialStatusGenerator != nil {
		return imageRegistryCredentialStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus(generators)
	imageRegistryCredentialStatusGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential_Status{}), generators)

	return imageRegistryCredentialStatusGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InitContainerDefinition_Status to InitContainerDefinition_Status via AssignPropertiesToInitContainerDefinitionStatus & AssignPropertiesFromInitContainerDefinitionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForInitContainerDefinitionStatus, InitContainerDefinitionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInitContainerDefinitionStatus tests if a specific instance of InitContainerDefinition_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForInitContainerDefinitionStatus(subject InitContainerDefinition_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.InitContainerDefinition_Status
	err := copied.AssignPropertiesToInitContainerDefinitionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InitContainerDefinition_Status
	err = actual.AssignPropertiesFromInitContainerDefinitionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InitContainerDefinition_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinitionStatus, InitContainerDefinitionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinitionStatus runs a test to see if a specific instance of InitContainerDefinition_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinitionStatus(subject InitContainerDefinition_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition_Status instances for property testing - lazily instantiated by
// InitContainerDefinitionStatusGenerator()
var initContainerDefinitionStatusGenerator gopter.Gen

// InitContainerDefinitionStatusGenerator returns a generator of InitContainerDefinition_Status instances for property testing.
// We first initialize initContainerDefinitionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinitionStatusGenerator() gopter.Gen {
	if initContainerDefinitionStatusGenerator != nil {
		return initContainerDefinitionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	initContainerDefinitionStatusGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	initContainerDefinitionStatusGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_Status{}), generators)

	return initContainerDefinitionStatusGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(InitContainerPropertiesDefinitionStatusInstanceViewGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountStatusGenerator())
}

func Test_IpAddress_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddress to IpAddress via AssignPropertiesToIpAddress & AssignPropertiesFromIpAddress returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddress tests if a specific instance of IpAddress can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForIpAddress(subject IpAddress) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.IpAddress
	err := copied.AssignPropertiesToIpAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddress
	err = actual.AssignPropertiesFromIpAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress runs a test to see if a specific instance of IpAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress(subject IpAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress instances for property testing - lazily instantiated by IpAddressGenerator()
var ipAddressGenerator gopter.Gen

// IpAddressGenerator returns a generator of IpAddress instances for property testing.
// We first initialize ipAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressGenerator() gopter.Gen {
	if ipAddressGenerator != nil {
		return ipAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	AddRelatedPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	return ipAddressGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.OneConstOf(
		IpAddressDnsNameLabelReusePolicyNoreuse,
		IpAddressDnsNameLabelReusePolicyResourceGroupReuse,
		IpAddressDnsNameLabelReusePolicySubscriptionReuse,
		IpAddressDnsNameLabelReusePolicyTenantReuse,
		IpAddressDnsNameLabelReusePolicyUnsecure))
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddressTypePrivate, IpAddressTypePublic))
}

// AddRelatedPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortGenerator())
}

func Test_IpAddress_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddress_Status to IpAddress_Status via AssignPropertiesToIpAddressStatus & AssignPropertiesFromIpAddressStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressStatus, IpAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressStatus tests if a specific instance of IpAddress_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForIpAddressStatus(subject IpAddress_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.IpAddress_Status
	err := copied.AssignPropertiesToIpAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddress_Status
	err = actual.AssignPropertiesFromIpAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressStatus, IpAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressStatus runs a test to see if a specific instance of IpAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressStatus(subject IpAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress_Status instances for property testing - lazily instantiated by IpAddressStatusGenerator()
var ipAddressStatusGenerator gopter.Gen

// IpAddressStatusGenerator returns a generator of IpAddress_Status instances for property testing.
// We first initialize ipAddressStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressStatusGenerator() gopter.Gen {
	if ipAddressStatusGenerator != nil {
		return ipAddressStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressStatus(generators)
	ipAddressStatusGenerator = gen.Struct(reflect.TypeOf(IpAddress_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressStatus(generators)
	AddRelatedPropertyGeneratorsForIpAddressStatus(generators)
	ipAddressStatusGenerator = gen.Struct(reflect.TypeOf(IpAddress_Status{}), generators)

	return ipAddressStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressStatus(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.OneConstOf(
		IpAddressStatusDnsNameLabelReusePolicyNoreuse,
		IpAddressStatusDnsNameLabelReusePolicyResourceGroupReuse,
		IpAddressStatusDnsNameLabelReusePolicySubscriptionReuse,
		IpAddressStatusDnsNameLabelReusePolicyTenantReuse,
		IpAddressStatusDnsNameLabelReusePolicyUnsecure))
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddressStatusTypePrivate, IpAddressStatusTypePublic))
}

// AddRelatedPropertyGeneratorsForIpAddressStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddressStatus(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortStatusGenerator())
}

func Test_Volume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume to Volume via AssignPropertiesToVolume & AssignPropertiesFromVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolume tests if a specific instance of Volume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolume(subject Volume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Volume
	err := copied.AssignPropertiesToVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume
	err = actual.AssignPropertiesFromVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeGenerator())
}

func Test_Volume_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume_Status to Volume_Status via AssignPropertiesToVolumeStatus & AssignPropertiesFromVolumeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeStatus, VolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeStatus tests if a specific instance of Volume_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeStatus(subject Volume_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Volume_Status
	err := copied.AssignPropertiesToVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume_Status
	err = actual.AssignPropertiesFromVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeStatus, VolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeStatus runs a test to see if a specific instance of Volume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeStatus(subject Volume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_Status instances for property testing - lazily instantiated by VolumeStatusGenerator()
var volumeStatusGenerator gopter.Gen

// VolumeStatusGenerator returns a generator of Volume_Status instances for property testing.
// We first initialize volumeStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeStatusGenerator() gopter.Gen {
	if volumeStatusGenerator != nil {
		return volumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeStatus(generators)
	volumeStatusGenerator = gen.Struct(reflect.TypeOf(Volume_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeStatus(generators)
	AddRelatedPropertyGeneratorsForVolumeStatus(generators)
	volumeStatusGenerator = gen.Struct(reflect.TypeOf(Volume_Status{}), generators)

	return volumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolumeStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolumeStatus(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeStatusGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeStatusGenerator())
}

func Test_AzureFileVolume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFileVolume to AzureFileVolume via AssignPropertiesToAzureFileVolume & AssignPropertiesFromAzureFileVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFileVolume tests if a specific instance of AzureFileVolume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForAzureFileVolume(subject AzureFileVolume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.AzureFileVolume
	err := copied.AssignPropertiesToAzureFileVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFileVolume
	err = actual.AssignPropertiesFromAzureFileVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFileVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume runs a test to see if a specific instance of AzureFileVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume(subject AzureFileVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume instances for property testing - lazily instantiated by AzureFileVolumeGenerator()
var azureFileVolumeGenerator gopter.Gen

// AzureFileVolumeGenerator returns a generator of AzureFileVolume instances for property testing.
func AzureFileVolumeGenerator() gopter.Gen {
	if azureFileVolumeGenerator != nil {
		return azureFileVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume(generators)
	azureFileVolumeGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume{}), generators)

	return azureFileVolumeGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFileVolume_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFileVolume_Status to AzureFileVolume_Status via AssignPropertiesToAzureFileVolumeStatus & AssignPropertiesFromAzureFileVolumeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFileVolumeStatus, AzureFileVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFileVolumeStatus tests if a specific instance of AzureFileVolume_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForAzureFileVolumeStatus(subject AzureFileVolume_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.AzureFileVolume_Status
	err := copied.AssignPropertiesToAzureFileVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFileVolume_Status
	err = actual.AssignPropertiesFromAzureFileVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFileVolume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolumeStatus, AzureFileVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolumeStatus runs a test to see if a specific instance of AzureFileVolume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolumeStatus(subject AzureFileVolume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume_Status instances for property testing - lazily instantiated by
// AzureFileVolumeStatusGenerator()
var azureFileVolumeStatusGenerator gopter.Gen

// AzureFileVolumeStatusGenerator returns a generator of AzureFileVolume_Status instances for property testing.
func AzureFileVolumeStatusGenerator() gopter.Gen {
	if azureFileVolumeStatusGenerator != nil {
		return azureFileVolumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolumeStatus(generators)
	azureFileVolumeStatusGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume_Status{}), generators)

	return azureFileVolumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolumeStatus(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupIdentity_Status_UserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity_Status_UserAssignedIdentities to ContainerGroupIdentity_Status_UserAssignedIdentities via AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities & AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentityStatusUserAssignedIdentities, ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentityStatusUserAssignedIdentities tests if a specific instance of ContainerGroupIdentity_Status_UserAssignedIdentities can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentityStatusUserAssignedIdentities(subject ContainerGroupIdentity_Status_UserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity_Status_UserAssignedIdentities
	err := copied.AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity_Status_UserAssignedIdentities
	err = actual.AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities, ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of ContainerGroupIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities(subject ContainerGroupIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_Status_UserAssignedIdentities instances for property testing - lazily
// instantiated by ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator()
var containerGroupIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator returns a generator of ContainerGroupIdentity_Status_UserAssignedIdentities instances for property testing.
func ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if containerGroupIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return containerGroupIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities(generators)
	containerGroupIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status_UserAssignedIdentities{}), generators)

	return containerGroupIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPort to ContainerPort via AssignPropertiesToContainerPort & AssignPropertiesFromContainerPort returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPort tests if a specific instance of ContainerPort can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPort(subject ContainerPort) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerPort
	err := copied.AssignPropertiesToContainerPort(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPort
	err = actual.AssignPropertiesFromContainerPort(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPort_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort runs a test to see if a specific instance of ContainerPort round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort(subject ContainerPort) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort instances for property testing - lazily instantiated by ContainerPortGenerator()
var containerPortGenerator gopter.Gen

// ContainerPortGenerator returns a generator of ContainerPort instances for property testing.
func ContainerPortGenerator() gopter.Gen {
	if containerPortGenerator != nil {
		return containerPortGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort(generators)
	containerPortGenerator = gen.Struct(reflect.TypeOf(ContainerPort{}), generators)

	return containerPortGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPortProtocolTCP, ContainerPortProtocolUDP))
}

func Test_ContainerPort_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPort_Status to ContainerPort_Status via AssignPropertiesToContainerPortStatus & AssignPropertiesFromContainerPortStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPortStatus, ContainerPortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPortStatus tests if a specific instance of ContainerPort_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPortStatus(subject ContainerPort_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerPort_Status
	err := copied.AssignPropertiesToContainerPortStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPort_Status
	err = actual.AssignPropertiesFromContainerPortStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPort_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPortStatus, ContainerPortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPortStatus runs a test to see if a specific instance of ContainerPort_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPortStatus(subject ContainerPort_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort_Status instances for property testing - lazily instantiated by
// ContainerPortStatusGenerator()
var containerPortStatusGenerator gopter.Gen

// ContainerPortStatusGenerator returns a generator of ContainerPort_Status instances for property testing.
func ContainerPortStatusGenerator() gopter.Gen {
	if containerPortStatusGenerator != nil {
		return containerPortStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPortStatus(generators)
	containerPortStatusGenerator = gen.Struct(reflect.TypeOf(ContainerPort_Status{}), generators)

	return containerPortStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerPortStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPortStatus(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPortStatusProtocolTCP, ContainerPortStatusProtocolUDP))
}

func Test_ContainerProbe_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProbe to ContainerProbe via AssignPropertiesToContainerProbe & AssignPropertiesFromContainerProbe returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerProbe tests if a specific instance of ContainerProbe can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerProbe(subject ContainerProbe) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProbe
	err := copied.AssignPropertiesToContainerProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProbe
	err = actual.AssignPropertiesFromContainerProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe runs a test to see if a specific instance of ContainerProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe(subject ContainerProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe instances for property testing - lazily instantiated by ContainerProbeGenerator()
var containerProbeGenerator gopter.Gen

// ContainerProbeGenerator returns a generator of ContainerProbe instances for property testing.
// We first initialize containerProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeGenerator() gopter.Gen {
	if containerProbeGenerator != nil {
		return containerProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	AddRelatedPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	return containerProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetGenerator())
}

func Test_ContainerProbe_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProbe_Status to ContainerProbe_Status via AssignPropertiesToContainerProbeStatus & AssignPropertiesFromContainerProbeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerProbeStatus, ContainerProbeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerProbeStatus tests if a specific instance of ContainerProbe_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerProbeStatus(subject ContainerProbe_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProbe_Status
	err := copied.AssignPropertiesToContainerProbeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProbe_Status
	err = actual.AssignPropertiesFromContainerProbeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProbe_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbeStatus, ContainerProbeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbeStatus runs a test to see if a specific instance of ContainerProbe_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbeStatus(subject ContainerProbe_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe_Status instances for property testing - lazily instantiated by
// ContainerProbeStatusGenerator()
var containerProbeStatusGenerator gopter.Gen

// ContainerProbeStatusGenerator returns a generator of ContainerProbe_Status instances for property testing.
// We first initialize containerProbeStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeStatusGenerator() gopter.Gen {
	if containerProbeStatusGenerator != nil {
		return containerProbeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeStatus(generators)
	containerProbeStatusGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeStatus(generators)
	AddRelatedPropertyGeneratorsForContainerProbeStatus(generators)
	containerProbeStatusGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_Status{}), generators)

	return containerProbeStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbeStatus(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbeStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbeStatus(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecStatusGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetStatusGenerator())
}

func Test_ContainerProperties_Status_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProperties_Status_InstanceView to ContainerProperties_Status_InstanceView via AssignPropertiesToContainerPropertiesStatusInstanceView & AssignPropertiesFromContainerPropertiesStatusInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPropertiesStatusInstanceView, ContainerPropertiesStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPropertiesStatusInstanceView tests if a specific instance of ContainerProperties_Status_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPropertiesStatusInstanceView(subject ContainerProperties_Status_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProperties_Status_InstanceView
	err := copied.AssignPropertiesToContainerPropertiesStatusInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProperties_Status_InstanceView
	err = actual.AssignPropertiesFromContainerPropertiesStatusInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProperties_Status_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties_Status_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPropertiesStatusInstanceView, ContainerPropertiesStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPropertiesStatusInstanceView runs a test to see if a specific instance of ContainerProperties_Status_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPropertiesStatusInstanceView(subject ContainerProperties_Status_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties_Status_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties_Status_InstanceView instances for property testing - lazily instantiated by
// ContainerPropertiesStatusInstanceViewGenerator()
var containerPropertiesStatusInstanceViewGenerator gopter.Gen

// ContainerPropertiesStatusInstanceViewGenerator returns a generator of ContainerProperties_Status_InstanceView instances for property testing.
// We first initialize containerPropertiesStatusInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerPropertiesStatusInstanceViewGenerator() gopter.Gen {
	if containerPropertiesStatusInstanceViewGenerator != nil {
		return containerPropertiesStatusInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	containerPropertiesStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_Status_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	containerPropertiesStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_Status_InstanceView{}), generators)

	return containerPropertiesStatusInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateStatusGenerator())
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateStatusGenerator())
}

func Test_EnvironmentVariable_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVariable to EnvironmentVariable via AssignPropertiesToEnvironmentVariable & AssignPropertiesFromEnvironmentVariable returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVariable tests if a specific instance of EnvironmentVariable can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EnvironmentVariable
	err := copied.AssignPropertiesToEnvironmentVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVariable
	err = actual.AssignPropertiesFromEnvironmentVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable runs a test to see if a specific instance of EnvironmentVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable instances for property testing - lazily instantiated by
// EnvironmentVariableGenerator()
var environmentVariableGenerator gopter.Gen

// EnvironmentVariableGenerator returns a generator of EnvironmentVariable instances for property testing.
func EnvironmentVariableGenerator() gopter.Gen {
	if environmentVariableGenerator != nil {
		return environmentVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable(generators)
	environmentVariableGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable{}), generators)

	return environmentVariableGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnvironmentVariable_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVariable_Status to EnvironmentVariable_Status via AssignPropertiesToEnvironmentVariableStatus & AssignPropertiesFromEnvironmentVariableStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVariableStatus, EnvironmentVariableStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVariableStatus tests if a specific instance of EnvironmentVariable_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVariableStatus(subject EnvironmentVariable_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EnvironmentVariable_Status
	err := copied.AssignPropertiesToEnvironmentVariableStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVariable_Status
	err = actual.AssignPropertiesFromEnvironmentVariableStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVariable_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariableStatus, EnvironmentVariableStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariableStatus runs a test to see if a specific instance of EnvironmentVariable_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariableStatus(subject EnvironmentVariable_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable_Status instances for property testing - lazily instantiated by
// EnvironmentVariableStatusGenerator()
var environmentVariableStatusGenerator gopter.Gen

// EnvironmentVariableStatusGenerator returns a generator of EnvironmentVariable_Status instances for property testing.
func EnvironmentVariableStatusGenerator() gopter.Gen {
	if environmentVariableStatusGenerator != nil {
		return environmentVariableStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariableStatus(generators)
	environmentVariableStatusGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable_Status{}), generators)

	return environmentVariableStatusGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariableStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariableStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Event_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Event_Status to Event_Status via AssignPropertiesToEventStatus & AssignPropertiesFromEventStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventStatus, EventStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventStatus tests if a specific instance of Event_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEventStatus(subject Event_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Event_Status
	err := copied.AssignPropertiesToEventStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Event_Status
	err = actual.AssignPropertiesFromEventStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Event_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Event_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventStatus, EventStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventStatus runs a test to see if a specific instance of Event_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventStatus(subject Event_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Event_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Event_Status instances for property testing - lazily instantiated by EventStatusGenerator()
var eventStatusGenerator gopter.Gen

// EventStatusGenerator returns a generator of Event_Status instances for property testing.
func EventStatusGenerator() gopter.Gen {
	if eventStatusGenerator != nil {
		return eventStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventStatus(generators)
	eventStatusGenerator = gen.Struct(reflect.TypeOf(Event_Status{}), generators)

	return eventStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventStatus(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["FirstTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["LastTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepoVolume to GitRepoVolume via AssignPropertiesToGitRepoVolume & AssignPropertiesFromGitRepoVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepoVolume tests if a specific instance of GitRepoVolume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGitRepoVolume(subject GitRepoVolume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GitRepoVolume
	err := copied.AssignPropertiesToGitRepoVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepoVolume
	err = actual.AssignPropertiesFromGitRepoVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepoVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume runs a test to see if a specific instance of GitRepoVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume(subject GitRepoVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume instances for property testing - lazily instantiated by GitRepoVolumeGenerator()
var gitRepoVolumeGenerator gopter.Gen

// GitRepoVolumeGenerator returns a generator of GitRepoVolume instances for property testing.
func GitRepoVolumeGenerator() gopter.Gen {
	if gitRepoVolumeGenerator != nil {
		return gitRepoVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume(generators)
	gitRepoVolumeGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume{}), generators)

	return gitRepoVolumeGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepoVolume_Status to GitRepoVolume_Status via AssignPropertiesToGitRepoVolumeStatus & AssignPropertiesFromGitRepoVolumeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepoVolumeStatus, GitRepoVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepoVolumeStatus tests if a specific instance of GitRepoVolume_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGitRepoVolumeStatus(subject GitRepoVolume_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GitRepoVolume_Status
	err := copied.AssignPropertiesToGitRepoVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepoVolume_Status
	err = actual.AssignPropertiesFromGitRepoVolumeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepoVolume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolumeStatus, GitRepoVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolumeStatus runs a test to see if a specific instance of GitRepoVolume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolumeStatus(subject GitRepoVolume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume_Status instances for property testing - lazily instantiated by
// GitRepoVolumeStatusGenerator()
var gitRepoVolumeStatusGenerator gopter.Gen

// GitRepoVolumeStatusGenerator returns a generator of GitRepoVolume_Status instances for property testing.
func GitRepoVolumeStatusGenerator() gopter.Gen {
	if gitRepoVolumeStatusGenerator != nil {
		return gitRepoVolumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolumeStatus(generators)
	gitRepoVolumeStatusGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume_Status{}), generators)

	return gitRepoVolumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolumeStatus(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinition_Status_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InitContainerPropertiesDefinition_Status_InstanceView to InitContainerPropertiesDefinition_Status_InstanceView via AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView & AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForInitContainerPropertiesDefinitionStatusInstanceView, InitContainerPropertiesDefinitionStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInitContainerPropertiesDefinitionStatusInstanceView tests if a specific instance of InitContainerPropertiesDefinition_Status_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForInitContainerPropertiesDefinitionStatusInstanceView(subject InitContainerPropertiesDefinition_Status_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.InitContainerPropertiesDefinition_Status_InstanceView
	err := copied.AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InitContainerPropertiesDefinition_Status_InstanceView
	err = actual.AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InitContainerPropertiesDefinition_Status_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition_Status_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView, InitContainerPropertiesDefinitionStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView runs a test to see if a specific instance of InitContainerPropertiesDefinition_Status_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView(subject InitContainerPropertiesDefinition_Status_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition_Status_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition_Status_InstanceView instances for property testing - lazily
// instantiated by InitContainerPropertiesDefinitionStatusInstanceViewGenerator()
var initContainerPropertiesDefinitionStatusInstanceViewGenerator gopter.Gen

// InitContainerPropertiesDefinitionStatusInstanceViewGenerator returns a generator of InitContainerPropertiesDefinition_Status_InstanceView instances for property testing.
// We first initialize initContainerPropertiesDefinitionStatusInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinitionStatusInstanceViewGenerator() gopter.Gen {
	if initContainerPropertiesDefinitionStatusInstanceViewGenerator != nil {
		return initContainerPropertiesDefinitionStatusInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	initContainerPropertiesDefinitionStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_Status_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	initContainerPropertiesDefinitionStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_Status_InstanceView{}), generators)

	return initContainerPropertiesDefinitionStatusInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateStatusGenerator())
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateStatusGenerator())
}

func Test_LogAnalytics_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalytics to LogAnalytics via AssignPropertiesToLogAnalytics & AssignPropertiesFromLogAnalytics returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalytics tests if a specific instance of LogAnalytics can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForLogAnalytics(subject LogAnalytics) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.LogAnalytics
	err := copied.AssignPropertiesToLogAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalytics
	err = actual.AssignPropertiesFromLogAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalytics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics runs a test to see if a specific instance of LogAnalytics round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics(subject LogAnalytics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics instances for property testing - lazily instantiated by LogAnalyticsGenerator()
var logAnalyticsGenerator gopter.Gen

// LogAnalyticsGenerator returns a generator of LogAnalytics instances for property testing.
func LogAnalyticsGenerator() gopter.Gen {
	if logAnalyticsGenerator != nil {
		return logAnalyticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics(generators)
	logAnalyticsGenerator = gen.Struct(reflect.TypeOf(LogAnalytics{}), generators)

	return logAnalyticsGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalyticsLogTypeContainerInsights, LogAnalyticsLogTypeContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalytics_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalytics_Status to LogAnalytics_Status via AssignPropertiesToLogAnalyticsStatus & AssignPropertiesFromLogAnalyticsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsStatus, LogAnalyticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsStatus tests if a specific instance of LogAnalytics_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsStatus(subject LogAnalytics_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.LogAnalytics_Status
	err := copied.AssignPropertiesToLogAnalyticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalytics_Status
	err = actual.AssignPropertiesFromLogAnalyticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalytics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsStatus, LogAnalyticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsStatus runs a test to see if a specific instance of LogAnalytics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsStatus(subject LogAnalytics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics_Status instances for property testing - lazily instantiated by LogAnalyticsStatusGenerator()
var logAnalyticsStatusGenerator gopter.Gen

// LogAnalyticsStatusGenerator returns a generator of LogAnalytics_Status instances for property testing.
func LogAnalyticsStatusGenerator() gopter.Gen {
	if logAnalyticsStatusGenerator != nil {
		return logAnalyticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsStatus(generators)
	logAnalyticsStatusGenerator = gen.Struct(reflect.TypeOf(LogAnalytics_Status{}), generators)

	return logAnalyticsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsStatus(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalyticsStatusLogTypeContainerInsights, LogAnalyticsStatusLogTypeContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Port to Port via AssignPropertiesToPort & AssignPropertiesFromPort returns original",
		prop.ForAll(RunPropertyAssignmentTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPort tests if a specific instance of Port can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPort(subject Port) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Port
	err := copied.AssignPropertiesToPort(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Port
	err = actual.AssignPropertiesFromPort(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Port_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort runs a test to see if a specific instance of Port round trips to JSON and back losslessly
func RunJSONSerializationTestForPort(subject Port) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port instances for property testing - lazily instantiated by PortGenerator()
var portGenerator gopter.Gen

// PortGenerator returns a generator of Port instances for property testing.
func PortGenerator() gopter.Gen {
	if portGenerator != nil {
		return portGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort(generators)
	portGenerator = gen.Struct(reflect.TypeOf(Port{}), generators)

	return portGenerator
}

// AddIndependentPropertyGeneratorsForPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortProtocolTCP, PortProtocolUDP))
}

func Test_Port_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Port_Status to Port_Status via AssignPropertiesToPortStatus & AssignPropertiesFromPortStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPortStatus, PortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPortStatus tests if a specific instance of Port_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPortStatus(subject Port_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Port_Status
	err := copied.AssignPropertiesToPortStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Port_Status
	err = actual.AssignPropertiesFromPortStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Port_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortStatus, PortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortStatus runs a test to see if a specific instance of Port_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPortStatus(subject Port_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port_Status instances for property testing - lazily instantiated by PortStatusGenerator()
var portStatusGenerator gopter.Gen

// PortStatusGenerator returns a generator of Port_Status instances for property testing.
func PortStatusGenerator() gopter.Gen {
	if portStatusGenerator != nil {
		return portStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortStatus(generators)
	portStatusGenerator = gen.Struct(reflect.TypeOf(Port_Status{}), generators)

	return portStatusGenerator
}

// AddIndependentPropertyGeneratorsForPortStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortStatus(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortStatusProtocolTCP, PortStatusProtocolUDP))
}

func Test_ResourceRequirements_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequirements to ResourceRequirements via AssignPropertiesToResourceRequirements & AssignPropertiesFromResourceRequirements returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequirements tests if a specific instance of ResourceRequirements can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequirements(subject ResourceRequirements) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequirements
	err := copied.AssignPropertiesToResourceRequirements(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequirements
	err = actual.AssignPropertiesFromResourceRequirements(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequirements_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements runs a test to see if a specific instance of ResourceRequirements round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements(subject ResourceRequirements) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements instances for property testing - lazily instantiated by
// ResourceRequirementsGenerator()
var resourceRequirementsGenerator gopter.Gen

// ResourceRequirementsGenerator returns a generator of ResourceRequirements instances for property testing.
func ResourceRequirementsGenerator() gopter.Gen {
	if resourceRequirementsGenerator != nil {
		return resourceRequirementsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements(generators)
	resourceRequirementsGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements{}), generators)

	return resourceRequirementsGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsGenerator())
}

func Test_ResourceRequirements_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequirements_Status to ResourceRequirements_Status via AssignPropertiesToResourceRequirementsStatus & AssignPropertiesFromResourceRequirementsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequirementsStatus, ResourceRequirementsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequirementsStatus tests if a specific instance of ResourceRequirements_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequirementsStatus(subject ResourceRequirements_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequirements_Status
	err := copied.AssignPropertiesToResourceRequirementsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequirements_Status
	err = actual.AssignPropertiesFromResourceRequirementsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequirements_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirementsStatus, ResourceRequirementsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirementsStatus runs a test to see if a specific instance of ResourceRequirements_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirementsStatus(subject ResourceRequirements_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements_Status instances for property testing - lazily instantiated by
// ResourceRequirementsStatusGenerator()
var resourceRequirementsStatusGenerator gopter.Gen

// ResourceRequirementsStatusGenerator returns a generator of ResourceRequirements_Status instances for property testing.
func ResourceRequirementsStatusGenerator() gopter.Gen {
	if resourceRequirementsStatusGenerator != nil {
		return resourceRequirementsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirementsStatus(generators)
	resourceRequirementsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements_Status{}), generators)

	return resourceRequirementsStatusGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirementsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirementsStatus(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsStatusGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsStatusGenerator())
}

func Test_VolumeMount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount to VolumeMount via AssignPropertiesToVolumeMount & AssignPropertiesFromVolumeMount returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMount tests if a specific instance of VolumeMount can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeMount(subject VolumeMount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.VolumeMount
	err := copied.AssignPropertiesToVolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount
	err = actual.AssignPropertiesFromVolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_VolumeMount_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount_Status to VolumeMount_Status via AssignPropertiesToVolumeMountStatus & AssignPropertiesFromVolumeMountStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMountStatus, VolumeMountStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMountStatus tests if a specific instance of VolumeMount_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeMountStatus(subject VolumeMount_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.VolumeMount_Status
	err := copied.AssignPropertiesToVolumeMountStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount_Status
	err = actual.AssignPropertiesFromVolumeMountStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMountStatus, VolumeMountStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMountStatus runs a test to see if a specific instance of VolumeMount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMountStatus(subject VolumeMount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_Status instances for property testing - lazily instantiated by VolumeMountStatusGenerator()
var volumeMountStatusGenerator gopter.Gen

// VolumeMountStatusGenerator returns a generator of VolumeMount_Status instances for property testing.
func VolumeMountStatusGenerator() gopter.Gen {
	if volumeMountStatusGenerator != nil {
		return volumeMountStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMountStatus(generators)
	volumeMountStatusGenerator = gen.Struct(reflect.TypeOf(VolumeMount_Status{}), generators)

	return volumeMountStatusGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMountStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMountStatus(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerExec to ContainerExec via AssignPropertiesToContainerExec & AssignPropertiesFromContainerExec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerExec tests if a specific instance of ContainerExec can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerExec(subject ContainerExec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerExec
	err := copied.AssignPropertiesToContainerExec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerExec
	err = actual.AssignPropertiesFromContainerExec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerExec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec runs a test to see if a specific instance of ContainerExec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec(subject ContainerExec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec instances for property testing - lazily instantiated by ContainerExecGenerator()
var containerExecGenerator gopter.Gen

// ContainerExecGenerator returns a generator of ContainerExec instances for property testing.
func ContainerExecGenerator() gopter.Gen {
	if containerExecGenerator != nil {
		return containerExecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec(generators)
	containerExecGenerator = gen.Struct(reflect.TypeOf(ContainerExec{}), generators)

	return containerExecGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerExec_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerExec_Status to ContainerExec_Status via AssignPropertiesToContainerExecStatus & AssignPropertiesFromContainerExecStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerExecStatus, ContainerExecStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerExecStatus tests if a specific instance of ContainerExec_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerExecStatus(subject ContainerExec_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerExec_Status
	err := copied.AssignPropertiesToContainerExecStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerExec_Status
	err = actual.AssignPropertiesFromContainerExecStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerExec_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExecStatus, ContainerExecStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExecStatus runs a test to see if a specific instance of ContainerExec_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExecStatus(subject ContainerExec_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec_Status instances for property testing - lazily instantiated by
// ContainerExecStatusGenerator()
var containerExecStatusGenerator gopter.Gen

// ContainerExecStatusGenerator returns a generator of ContainerExec_Status instances for property testing.
func ContainerExecStatusGenerator() gopter.Gen {
	if containerExecStatusGenerator != nil {
		return containerExecStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExecStatus(generators)
	containerExecStatusGenerator = gen.Struct(reflect.TypeOf(ContainerExec_Status{}), generators)

	return containerExecStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerExecStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExecStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerHttpGet to ContainerHttpGet via AssignPropertiesToContainerHttpGet & AssignPropertiesFromContainerHttpGet returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerHttpGet tests if a specific instance of ContainerHttpGet can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerHttpGet
	err := copied.AssignPropertiesToContainerHttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerHttpGet
	err = actual.AssignPropertiesFromContainerHttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerHttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet runs a test to see if a specific instance of ContainerHttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet instances for property testing - lazily instantiated by ContainerHttpGetGenerator()
var containerHttpGetGenerator gopter.Gen

// ContainerHttpGetGenerator returns a generator of ContainerHttpGet instances for property testing.
// We first initialize containerHttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetGenerator() gopter.Gen {
	if containerHttpGetGenerator != nil {
		return containerHttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	return containerHttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGetSchemeHttp, ContainerHttpGetSchemeHttps))
}

// AddRelatedPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderGenerator())
}

func Test_ContainerHttpGet_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerHttpGet_Status to ContainerHttpGet_Status via AssignPropertiesToContainerHttpGetStatus & AssignPropertiesFromContainerHttpGetStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerHttpGetStatus, ContainerHttpGetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerHttpGetStatus tests if a specific instance of ContainerHttpGet_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerHttpGetStatus(subject ContainerHttpGet_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerHttpGet_Status
	err := copied.AssignPropertiesToContainerHttpGetStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerHttpGet_Status
	err = actual.AssignPropertiesFromContainerHttpGetStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerHttpGet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGetStatus, ContainerHttpGetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGetStatus runs a test to see if a specific instance of ContainerHttpGet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGetStatus(subject ContainerHttpGet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet_Status instances for property testing - lazily instantiated by
// ContainerHttpGetStatusGenerator()
var containerHttpGetStatusGenerator gopter.Gen

// ContainerHttpGetStatusGenerator returns a generator of ContainerHttpGet_Status instances for property testing.
// We first initialize containerHttpGetStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetStatusGenerator() gopter.Gen {
	if containerHttpGetStatusGenerator != nil {
		return containerHttpGetStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetStatus(generators)
	containerHttpGetStatusGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetStatus(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGetStatus(generators)
	containerHttpGetStatusGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_Status{}), generators)

	return containerHttpGetStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGetStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGetStatus(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGetStatusSchemeHttp, ContainerHttpGetStatusSchemeHttps))
}

// AddRelatedPropertyGeneratorsForContainerHttpGetStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGetStatus(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderStatusGenerator())
}

func Test_ContainerState_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerState_Status to ContainerState_Status via AssignPropertiesToContainerStateStatus & AssignPropertiesFromContainerStateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerStateStatus, ContainerStateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerStateStatus tests if a specific instance of ContainerState_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerStateStatus(subject ContainerState_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerState_Status
	err := copied.AssignPropertiesToContainerStateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerState_Status
	err = actual.AssignPropertiesFromContainerStateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerState_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerState_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerStateStatus, ContainerStateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerStateStatus runs a test to see if a specific instance of ContainerState_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerStateStatus(subject ContainerState_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerState_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerState_Status instances for property testing - lazily instantiated by
// ContainerStateStatusGenerator()
var containerStateStatusGenerator gopter.Gen

// ContainerStateStatusGenerator returns a generator of ContainerState_Status instances for property testing.
func ContainerStateStatusGenerator() gopter.Gen {
	if containerStateStatusGenerator != nil {
		return containerStateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStateStatus(generators)
	containerStateStatusGenerator = gen.Struct(reflect.TypeOf(ContainerState_Status{}), generators)

	return containerStateStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerStateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerStateStatus(gens map[string]gopter.Gen) {
	gens["DetailStatus"] = gen.PtrOf(gen.AlphaString())
	gens["ExitCode"] = gen.PtrOf(gen.Int())
	gens["FinishTime"] = gen.PtrOf(gen.AlphaString())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLimits_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLimits to ResourceLimits via AssignPropertiesToResourceLimits & AssignPropertiesFromResourceLimits returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLimits tests if a specific instance of ResourceLimits can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLimits(subject ResourceLimits) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLimits
	err := copied.AssignPropertiesToResourceLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLimits
	err = actual.AssignPropertiesFromResourceLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits runs a test to see if a specific instance of ResourceLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits(subject ResourceLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits instances for property testing - lazily instantiated by ResourceLimitsGenerator()
var resourceLimitsGenerator gopter.Gen

// ResourceLimitsGenerator returns a generator of ResourceLimits instances for property testing.
// We first initialize resourceLimitsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsGenerator() gopter.Gen {
	if resourceLimitsGenerator != nil {
		return resourceLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	AddRelatedPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	return resourceLimitsGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceLimits_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLimits_Status to ResourceLimits_Status via AssignPropertiesToResourceLimitsStatus & AssignPropertiesFromResourceLimitsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLimitsStatus, ResourceLimitsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLimitsStatus tests if a specific instance of ResourceLimits_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLimitsStatus(subject ResourceLimits_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLimits_Status
	err := copied.AssignPropertiesToResourceLimitsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLimits_Status
	err = actual.AssignPropertiesFromResourceLimitsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLimits_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimitsStatus, ResourceLimitsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimitsStatus runs a test to see if a specific instance of ResourceLimits_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimitsStatus(subject ResourceLimits_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits_Status instances for property testing - lazily instantiated by
// ResourceLimitsStatusGenerator()
var resourceLimitsStatusGenerator gopter.Gen

// ResourceLimitsStatusGenerator returns a generator of ResourceLimits_Status instances for property testing.
// We first initialize resourceLimitsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsStatusGenerator() gopter.Gen {
	if resourceLimitsStatusGenerator != nil {
		return resourceLimitsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsStatus(generators)
	resourceLimitsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsStatus(generators)
	AddRelatedPropertyGeneratorsForResourceLimitsStatus(generators)
	resourceLimitsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_Status{}), generators)

	return resourceLimitsStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimitsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimitsStatus(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimitsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimitsStatus(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceStatusGenerator())
}

func Test_ResourceRequests_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequests to ResourceRequests via AssignPropertiesToResourceRequests & AssignPropertiesFromResourceRequests returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequests tests if a specific instance of ResourceRequests can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequests(subject ResourceRequests) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequests
	err := copied.AssignPropertiesToResourceRequests(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequests
	err = actual.AssignPropertiesFromResourceRequests(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequests_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests runs a test to see if a specific instance of ResourceRequests round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests(subject ResourceRequests) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests instances for property testing - lazily instantiated by ResourceRequestsGenerator()
var resourceRequestsGenerator gopter.Gen

// ResourceRequestsGenerator returns a generator of ResourceRequests instances for property testing.
// We first initialize resourceRequestsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsGenerator() gopter.Gen {
	if resourceRequestsGenerator != nil {
		return resourceRequestsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	AddRelatedPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	return resourceRequestsGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequests_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequests_Status to ResourceRequests_Status via AssignPropertiesToResourceRequestsStatus & AssignPropertiesFromResourceRequestsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequestsStatus, ResourceRequestsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequestsStatus tests if a specific instance of ResourceRequests_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequestsStatus(subject ResourceRequests_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequests_Status
	err := copied.AssignPropertiesToResourceRequestsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequests_Status
	err = actual.AssignPropertiesFromResourceRequestsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequests_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequestsStatus, ResourceRequestsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequestsStatus runs a test to see if a specific instance of ResourceRequests_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequestsStatus(subject ResourceRequests_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests_Status instances for property testing - lazily instantiated by
// ResourceRequestsStatusGenerator()
var resourceRequestsStatusGenerator gopter.Gen

// ResourceRequestsStatusGenerator returns a generator of ResourceRequests_Status instances for property testing.
// We first initialize resourceRequestsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsStatusGenerator() gopter.Gen {
	if resourceRequestsStatusGenerator != nil {
		return resourceRequestsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsStatus(generators)
	resourceRequestsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsStatus(generators)
	AddRelatedPropertyGeneratorsForResourceRequestsStatus(generators)
	resourceRequestsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_Status{}), generators)

	return resourceRequestsStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequestsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequestsStatus(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequestsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequestsStatus(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceStatusGenerator())
}

func Test_GpuResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GpuResource to GpuResource via AssignPropertiesToGpuResource & AssignPropertiesFromGpuResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGpuResource tests if a specific instance of GpuResource can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGpuResource(subject GpuResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GpuResource
	err := copied.AssignPropertiesToGpuResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GpuResource
	err = actual.AssignPropertiesFromGpuResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GpuResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource runs a test to see if a specific instance of GpuResource round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource(subject GpuResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource instances for property testing - lazily instantiated by GpuResourceGenerator()
var gpuResourceGenerator gopter.Gen

// GpuResourceGenerator returns a generator of GpuResource instances for property testing.
func GpuResourceGenerator() gopter.Gen {
	if gpuResourceGenerator != nil {
		return gpuResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource(generators)
	gpuResourceGenerator = gen.Struct(reflect.TypeOf(GpuResource{}), generators)

	return gpuResourceGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResourceSkuK80, GpuResourceSkuP100, GpuResourceSkuV100))
}

func Test_GpuResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GpuResource_Status to GpuResource_Status via AssignPropertiesToGpuResourceStatus & AssignPropertiesFromGpuResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForGpuResourceStatus, GpuResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGpuResourceStatus tests if a specific instance of GpuResource_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGpuResourceStatus(subject GpuResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GpuResource_Status
	err := copied.AssignPropertiesToGpuResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GpuResource_Status
	err = actual.AssignPropertiesFromGpuResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GpuResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResourceStatus, GpuResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResourceStatus runs a test to see if a specific instance of GpuResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResourceStatus(subject GpuResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource_Status instances for property testing - lazily instantiated by GpuResourceStatusGenerator()
var gpuResourceStatusGenerator gopter.Gen

// GpuResourceStatusGenerator returns a generator of GpuResource_Status instances for property testing.
func GpuResourceStatusGenerator() gopter.Gen {
	if gpuResourceStatusGenerator != nil {
		return gpuResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResourceStatus(generators)
	gpuResourceStatusGenerator = gen.Struct(reflect.TypeOf(GpuResource_Status{}), generators)

	return gpuResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForGpuResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResourceStatus(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResourceStatusSkuK80, GpuResourceStatusSkuP100, GpuResourceStatusSkuV100))
}

func Test_HttpHeader_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpHeader to HttpHeader via AssignPropertiesToHttpHeader & AssignPropertiesFromHttpHeader returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpHeader tests if a specific instance of HttpHeader can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForHttpHeader(subject HttpHeader) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.HttpHeader
	err := copied.AssignPropertiesToHttpHeader(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpHeader
	err = actual.AssignPropertiesFromHttpHeader(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpHeader_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader runs a test to see if a specific instance of HttpHeader round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader(subject HttpHeader) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader instances for property testing - lazily instantiated by HttpHeaderGenerator()
var httpHeaderGenerator gopter.Gen

// HttpHeaderGenerator returns a generator of HttpHeader instances for property testing.
func HttpHeaderGenerator() gopter.Gen {
	if httpHeaderGenerator != nil {
		return httpHeaderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader(generators)
	httpHeaderGenerator = gen.Struct(reflect.TypeOf(HttpHeader{}), generators)

	return httpHeaderGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpHeader_Status to HttpHeader_Status via AssignPropertiesToHttpHeaderStatus & AssignPropertiesFromHttpHeaderStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpHeaderStatus, HttpHeaderStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpHeaderStatus tests if a specific instance of HttpHeader_Status can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForHttpHeaderStatus(subject HttpHeader_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.HttpHeader_Status
	err := copied.AssignPropertiesToHttpHeaderStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpHeader_Status
	err = actual.AssignPropertiesFromHttpHeaderStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpHeader_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeaderStatus, HttpHeaderStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeaderStatus runs a test to see if a specific instance of HttpHeader_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeaderStatus(subject HttpHeader_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader_Status instances for property testing - lazily instantiated by HttpHeaderStatusGenerator()
var httpHeaderStatusGenerator gopter.Gen

// HttpHeaderStatusGenerator returns a generator of HttpHeader_Status instances for property testing.
func HttpHeaderStatusGenerator() gopter.Gen {
	if httpHeaderStatusGenerator != nil {
		return httpHeaderStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeaderStatus(generators)
	httpHeaderStatusGenerator = gen.Struct(reflect.TypeOf(HttpHeader_Status{}), generators)

	return httpHeaderStatusGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeaderStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeaderStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
