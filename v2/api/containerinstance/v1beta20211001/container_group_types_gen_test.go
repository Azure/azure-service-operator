// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	v20211001s "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1beta20211001storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroup_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup to hub returns original",
		prop.ForAll(RunResourceConversionTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForContainerGroup tests if a specific instance of ContainerGroup round trips to the hub storage version and back losslessly
func RunResourceConversionTestForContainerGroup(subject ContainerGroup) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20211001s.ContainerGroup
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ContainerGroup
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup to ContainerGroup via AssignPropertiesToContainerGroup & AssignPropertiesFromContainerGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroup tests if a specific instance of ContainerGroup can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroup(subject ContainerGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup
	err := copied.AssignPropertiesToContainerGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup
	err = actual.AssignPropertiesFromContainerGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup runs a test to see if a specific instance of ContainerGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup(subject ContainerGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup instances for property testing - lazily instantiated by ContainerGroupGenerator()
var containerGroupGenerator gopter.Gen

// ContainerGroupGenerator returns a generator of ContainerGroup instances for property testing.
func ContainerGroupGenerator() gopter.Gen {
	if containerGroupGenerator != nil {
		return containerGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroup(generators)
	containerGroupGenerator = gen.Struct(reflect.TypeOf(ContainerGroup{}), generators)

	return containerGroupGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = ContainerGroupsSpecGenerator()
	gens["Status"] = ContainerGroupSTATUSGenerator()
}

func Test_ContainerGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup_STATUS to ContainerGroup_STATUS via AssignPropertiesToContainerGroupSTATUS & AssignPropertiesFromContainerGroupSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSTATUS, ContainerGroupSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSTATUS tests if a specific instance of ContainerGroup_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSTATUS(subject ContainerGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup_STATUS
	err := copied.AssignPropertiesToContainerGroupSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup_STATUS
	err = actual.AssignPropertiesFromContainerGroupSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSTATUS, ContainerGroupSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSTATUS runs a test to see if a specific instance of ContainerGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSTATUS(subject ContainerGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_STATUS instances for property testing - lazily instantiated by
// ContainerGroupSTATUSGenerator()
var containerGroupSTATUSGenerator gopter.Gen

// ContainerGroupSTATUSGenerator returns a generator of ContainerGroup_STATUS instances for property testing.
// We first initialize containerGroupSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupSTATUSGenerator() gopter.Gen {
	if containerGroupSTATUSGenerator != nil {
		return containerGroupSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSTATUS(generators)
	containerGroupSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSTATUS(generators)
	AddRelatedPropertyGeneratorsForContainerGroupSTATUS(generators)
	containerGroupSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS{}), generators)

	return containerGroupSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSTATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSTATUSPropertiesOsType_Linux, ContainerGroupSTATUSPropertiesOsType_Windows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSTATUSPropertiesRestartPolicy_Always, ContainerGroupSTATUSPropertiesRestartPolicy_Never, ContainerGroupSTATUSPropertiesRestartPolicy_OnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSku_STATUS_Dedicated, ContainerGroupSku_STATUS_Standard))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupSTATUS(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerSTATUSGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsSTATUSGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationSTATUSGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesSTATUSGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentitySTATUSGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredentialSTATUSGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinitionSTATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerGroupSTATUSPropertiesInstanceViewGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressSTATUSGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdSTATUSGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeSTATUSGenerator())
}

func Test_ContainerGroups_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec to ContainerGroups_Spec via AssignPropertiesToContainerGroupsSpec & AssignPropertiesFromContainerGroupsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpec, ContainerGroupsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpec tests if a specific instance of ContainerGroups_Spec can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpec(subject ContainerGroups_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec
	err := copied.AssignPropertiesToContainerGroupsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec
	err = actual.AssignPropertiesFromContainerGroupsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpec, ContainerGroupsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpec runs a test to see if a specific instance of ContainerGroups_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpec(subject ContainerGroups_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec instances for property testing - lazily instantiated by
// ContainerGroupsSpecGenerator()
var containerGroupsSpecGenerator gopter.Gen

// ContainerGroupsSpecGenerator returns a generator of ContainerGroups_Spec instances for property testing.
// We first initialize containerGroupsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecGenerator() gopter.Gen {
	if containerGroupsSpecGenerator != nil {
		return containerGroupsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	return containerGroupsSpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesOsType_Linux, ContainerGroupsSpecPropertiesOsType_Windows))
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesRestartPolicy_Always, ContainerGroupsSpecPropertiesRestartPolicy_Never, ContainerGroupsSpecPropertiesRestartPolicy_OnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupsSpecPropertiesSku_Dedicated, ContainerGroupsSpecPropertiesSku_Standard))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGroupsSpecPropertiesContainersGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator())
	gens["InitContainers"] = gen.SliceOf(ContainerGroupsSpecPropertiesInitContainersGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_Container_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Container_STATUS to Container_STATUS via AssignPropertiesToContainerSTATUS & AssignPropertiesFromContainerSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerSTATUS, ContainerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerSTATUS tests if a specific instance of Container_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerSTATUS(subject Container_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Container_STATUS
	err := copied.AssignPropertiesToContainerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Container_STATUS
	err = actual.AssignPropertiesFromContainerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Container_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerSTATUS, ContainerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerSTATUS runs a test to see if a specific instance of Container_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerSTATUS(subject Container_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_STATUS instances for property testing - lazily instantiated by ContainerSTATUSGenerator()
var containerSTATUSGenerator gopter.Gen

// ContainerSTATUSGenerator returns a generator of Container_STATUS instances for property testing.
// We first initialize containerSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerSTATUSGenerator() gopter.Gen {
	if containerSTATUSGenerator != nil {
		return containerSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerSTATUS(generators)
	containerSTATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerSTATUS(generators)
	AddRelatedPropertyGeneratorsForContainerSTATUS(generators)
	containerSTATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	return containerSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerSTATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerSTATUS(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableSTATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerPropertiesSTATUSInstanceViewGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeSTATUSGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortSTATUSGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeSTATUSGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsSTATUSGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountSTATUSGenerator())
}

func Test_ContainerGroup_STATUS_Properties_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroup_STATUS_Properties_InstanceView to ContainerGroup_STATUS_Properties_InstanceView via AssignPropertiesToContainerGroupSTATUSPropertiesInstanceView & AssignPropertiesFromContainerGroupSTATUSPropertiesInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSTATUSPropertiesInstanceView, ContainerGroupSTATUSPropertiesInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSTATUSPropertiesInstanceView tests if a specific instance of ContainerGroup_STATUS_Properties_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSTATUSPropertiesInstanceView(subject ContainerGroup_STATUS_Properties_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroup_STATUS_Properties_InstanceView
	err := copied.AssignPropertiesToContainerGroupSTATUSPropertiesInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroup_STATUS_Properties_InstanceView
	err = actual.AssignPropertiesFromContainerGroupSTATUSPropertiesInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroup_STATUS_Properties_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_STATUS_Properties_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSTATUSPropertiesInstanceView, ContainerGroupSTATUSPropertiesInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSTATUSPropertiesInstanceView runs a test to see if a specific instance of ContainerGroup_STATUS_Properties_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSTATUSPropertiesInstanceView(subject ContainerGroup_STATUS_Properties_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_STATUS_Properties_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_STATUS_Properties_InstanceView instances for property testing - lazily instantiated by
// ContainerGroupSTATUSPropertiesInstanceViewGenerator()
var containerGroupSTATUSPropertiesInstanceViewGenerator gopter.Gen

// ContainerGroupSTATUSPropertiesInstanceViewGenerator returns a generator of ContainerGroup_STATUS_Properties_InstanceView instances for property testing.
// We first initialize containerGroupSTATUSPropertiesInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupSTATUSPropertiesInstanceViewGenerator() gopter.Gen {
	if containerGroupSTATUSPropertiesInstanceViewGenerator != nil {
		return containerGroupSTATUSPropertiesInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView(generators)
	containerGroupSTATUSPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS_Properties_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView(generators)
	containerGroupSTATUSPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS_Properties_InstanceView{}), generators)

	return containerGroupSTATUSPropertiesInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupSTATUSPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["Events"] = gen.SliceOf(EventSTATUSGenerator())
}

func Test_ContainerGroupDiagnostics_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupDiagnostics to ContainerGroupDiagnostics via AssignPropertiesToContainerGroupDiagnostics & AssignPropertiesFromContainerGroupDiagnostics returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupDiagnostics tests if a specific instance of ContainerGroupDiagnostics can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupDiagnostics
	err := copied.AssignPropertiesToContainerGroupDiagnostics(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupDiagnostics
	err = actual.AssignPropertiesFromContainerGroupDiagnostics(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupDiagnostics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics runs a test to see if a specific instance of ContainerGroupDiagnostics round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsGenerator()
var containerGroupDiagnosticsGenerator gopter.Gen

// ContainerGroupDiagnosticsGenerator returns a generator of ContainerGroupDiagnostics instances for property testing.
func ContainerGroupDiagnosticsGenerator() gopter.Gen {
	if containerGroupDiagnosticsGenerator != nil {
		return containerGroupDiagnosticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(generators)
	containerGroupDiagnosticsGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics{}), generators)

	return containerGroupDiagnosticsGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsGenerator())
}

func Test_ContainerGroupDiagnostics_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupDiagnostics_STATUS to ContainerGroupDiagnostics_STATUS via AssignPropertiesToContainerGroupDiagnosticsSTATUS & AssignPropertiesFromContainerGroupDiagnosticsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupDiagnosticsSTATUS, ContainerGroupDiagnosticsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupDiagnosticsSTATUS tests if a specific instance of ContainerGroupDiagnostics_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupDiagnosticsSTATUS(subject ContainerGroupDiagnostics_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupDiagnostics_STATUS
	err := copied.AssignPropertiesToContainerGroupDiagnosticsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupDiagnostics_STATUS
	err = actual.AssignPropertiesFromContainerGroupDiagnosticsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupDiagnostics_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnosticsSTATUS, ContainerGroupDiagnosticsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnosticsSTATUS runs a test to see if a specific instance of ContainerGroupDiagnostics_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnosticsSTATUS(subject ContainerGroupDiagnostics_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics_STATUS instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsSTATUSGenerator()
var containerGroupDiagnosticsSTATUSGenerator gopter.Gen

// ContainerGroupDiagnosticsSTATUSGenerator returns a generator of ContainerGroupDiagnostics_STATUS instances for property testing.
func ContainerGroupDiagnosticsSTATUSGenerator() gopter.Gen {
	if containerGroupDiagnosticsSTATUSGenerator != nil {
		return containerGroupDiagnosticsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsSTATUS(generators)
	containerGroupDiagnosticsSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics_STATUS{}), generators)

	return containerGroupDiagnosticsSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsSTATUS(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsSTATUSGenerator())
}

func Test_ContainerGroupIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity to ContainerGroupIdentity via AssignPropertiesToContainerGroupIdentity & AssignPropertiesFromContainerGroupIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentity tests if a specific instance of ContainerGroupIdentity can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity
	err := copied.AssignPropertiesToContainerGroupIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity
	err = actual.AssignPropertiesFromContainerGroupIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity runs a test to see if a specific instance of ContainerGroupIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity instances for property testing - lazily instantiated by
// ContainerGroupIdentityGenerator()
var containerGroupIdentityGenerator gopter.Gen

// ContainerGroupIdentityGenerator returns a generator of ContainerGroupIdentity instances for property testing.
func ContainerGroupIdentityGenerator() gopter.Gen {
	if containerGroupIdentityGenerator != nil {
		return containerGroupIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	return containerGroupIdentityGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentityType_None,
		ContainerGroupIdentityType_SystemAssigned,
		ContainerGroupIdentityType_SystemAssignedUserAssigned,
		ContainerGroupIdentityType_UserAssigned))
}

func Test_ContainerGroupIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity_STATUS to ContainerGroupIdentity_STATUS via AssignPropertiesToContainerGroupIdentitySTATUS & AssignPropertiesFromContainerGroupIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentitySTATUS, ContainerGroupIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentitySTATUS tests if a specific instance of ContainerGroupIdentity_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentitySTATUS(subject ContainerGroupIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity_STATUS
	err := copied.AssignPropertiesToContainerGroupIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity_STATUS
	err = actual.AssignPropertiesFromContainerGroupIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentitySTATUS, ContainerGroupIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentitySTATUS runs a test to see if a specific instance of ContainerGroupIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentitySTATUS(subject ContainerGroupIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_STATUS instances for property testing - lazily instantiated by
// ContainerGroupIdentitySTATUSGenerator()
var containerGroupIdentitySTATUSGenerator gopter.Gen

// ContainerGroupIdentitySTATUSGenerator returns a generator of ContainerGroupIdentity_STATUS instances for property testing.
// We first initialize containerGroupIdentitySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentitySTATUSGenerator() gopter.Gen {
	if containerGroupIdentitySTATUSGenerator != nil {
		return containerGroupIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUS(generators)
	containerGroupIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUS(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentitySTATUS(generators)
	containerGroupIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_STATUS{}), generators)

	return containerGroupIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentitySTATUSType_None,
		ContainerGroupIdentitySTATUSType_SystemAssigned,
		ContainerGroupIdentitySTATUSType_SystemAssignedUserAssigned,
		ContainerGroupIdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentitySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator())
}

func Test_ContainerGroups_Spec_Properties_Containers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_Containers to ContainerGroups_Spec_Properties_Containers via AssignPropertiesToContainerGroupsSpecPropertiesContainers & AssignPropertiesFromContainerGroupsSpecPropertiesContainers returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers, ContainerGroupsSpecPropertiesContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers tests if a specific instance of ContainerGroups_Spec_Properties_Containers can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesContainers(subject ContainerGroups_Spec_Properties_Containers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_Containers
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_Containers
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_Containers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_Containers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers, ContainerGroupsSpecPropertiesContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_Containers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers(subject ContainerGroups_Spec_Properties_Containers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_Containers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_Containers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesContainersGenerator()
var containerGroupsSpecPropertiesContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesContainersGenerator returns a generator of ContainerGroups_Spec_Properties_Containers instances for property testing.
// We first initialize containerGroupsSpecPropertiesContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesContainersGenerator != nil {
		return containerGroupsSpecPropertiesContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	return containerGroupsSpecPropertiesContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroups_Spec_Properties_ImageRegistryCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_ImageRegistryCredentials to ContainerGroups_Spec_Properties_ImageRegistryCredentials via AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials & AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials, ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials tests if a specific instance of ContainerGroups_Spec_Properties_ImageRegistryCredentials can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesImageRegistryCredentials(subject ContainerGroups_Spec_Properties_ImageRegistryCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_ImageRegistryCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_ImageRegistryCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials, ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials runs a test to see if a specific instance of ContainerGroups_Spec_Properties_ImageRegistryCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesImageRegistryCredentials(subject ContainerGroups_Spec_Properties_ImageRegistryCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_ImageRegistryCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_ImageRegistryCredentials instances for property testing - lazily
// instantiated by ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator()
var containerGroupsSpecPropertiesImageRegistryCredentialsGenerator gopter.Gen

// ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator returns a generator of ContainerGroups_Spec_Properties_ImageRegistryCredentials instances for property testing.
func ContainerGroupsSpecPropertiesImageRegistryCredentialsGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesImageRegistryCredentialsGenerator != nil {
		return containerGroupsSpecPropertiesImageRegistryCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials(generators)
	containerGroupsSpecPropertiesImageRegistryCredentialsGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_ImageRegistryCredentials{}), generators)

	return containerGroupsSpecPropertiesImageRegistryCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesImageRegistryCredentials(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroups_Spec_Properties_InitContainers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroups_Spec_Properties_InitContainers to ContainerGroups_Spec_Properties_InitContainers via AssignPropertiesToContainerGroupsSpecPropertiesInitContainers & AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers, ContainerGroupsSpecPropertiesInitContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers tests if a specific instance of ContainerGroups_Spec_Properties_InitContainers can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupsSpecPropertiesInitContainers(subject ContainerGroups_Spec_Properties_InitContainers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroups_Spec_Properties_InitContainers
	err := copied.AssignPropertiesToContainerGroupsSpecPropertiesInitContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroups_Spec_Properties_InitContainers
	err = actual.AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroups_Spec_Properties_InitContainers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_InitContainers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers, ContainerGroupsSpecPropertiesInitContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_InitContainers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers(subject ContainerGroups_Spec_Properties_InitContainers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_InitContainers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesInitContainersGenerator()
var containerGroupsSpecPropertiesInitContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesInitContainersGenerator returns a generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing.
// We first initialize containerGroupsSpecPropertiesInitContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesInitContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesInitContainersGenerator != nil {
		return containerGroupsSpecPropertiesInitContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	return containerGroupsSpecPropertiesInitContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroupSubnetId_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupSubnetId to ContainerGroupSubnetId via AssignPropertiesToContainerGroupSubnetId & AssignPropertiesFromContainerGroupSubnetId returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSubnetId tests if a specific instance of ContainerGroupSubnetId can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupSubnetId
	err := copied.AssignPropertiesToContainerGroupSubnetId(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupSubnetId
	err = actual.AssignPropertiesFromContainerGroupSubnetId(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupSubnetId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId runs a test to see if a specific instance of ContainerGroupSubnetId round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdGenerator()
var containerGroupSubnetIdGenerator gopter.Gen

// ContainerGroupSubnetIdGenerator returns a generator of ContainerGroupSubnetId instances for property testing.
func ContainerGroupSubnetIdGenerator() gopter.Gen {
	if containerGroupSubnetIdGenerator != nil {
		return containerGroupSubnetIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId(generators)
	containerGroupSubnetIdGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId{}), generators)

	return containerGroupSubnetIdGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupSubnetId_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupSubnetId_STATUS to ContainerGroupSubnetId_STATUS via AssignPropertiesToContainerGroupSubnetIdSTATUS & AssignPropertiesFromContainerGroupSubnetIdSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupSubnetIdSTATUS, ContainerGroupSubnetIdSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupSubnetIdSTATUS tests if a specific instance of ContainerGroupSubnetId_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupSubnetIdSTATUS(subject ContainerGroupSubnetId_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupSubnetId_STATUS
	err := copied.AssignPropertiesToContainerGroupSubnetIdSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupSubnetId_STATUS
	err = actual.AssignPropertiesFromContainerGroupSubnetIdSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupSubnetId_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetIdSTATUS, ContainerGroupSubnetIdSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetIdSTATUS runs a test to see if a specific instance of ContainerGroupSubnetId_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetIdSTATUS(subject ContainerGroupSubnetId_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId_STATUS instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdSTATUSGenerator()
var containerGroupSubnetIdSTATUSGenerator gopter.Gen

// ContainerGroupSubnetIdSTATUSGenerator returns a generator of ContainerGroupSubnetId_STATUS instances for property testing.
func ContainerGroupSubnetIdSTATUSGenerator() gopter.Gen {
	if containerGroupSubnetIdSTATUSGenerator != nil {
		return containerGroupSubnetIdSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetIdSTATUS(generators)
	containerGroupSubnetIdSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId_STATUS{}), generators)

	return containerGroupSubnetIdSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetIdSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetIdSTATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsConfiguration to DnsConfiguration via AssignPropertiesToDnsConfiguration & AssignPropertiesFromDnsConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsConfiguration tests if a specific instance of DnsConfiguration can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForDnsConfiguration(subject DnsConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.DnsConfiguration
	err := copied.AssignPropertiesToDnsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsConfiguration
	err = actual.AssignPropertiesFromDnsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration runs a test to see if a specific instance of DnsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration(subject DnsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration instances for property testing - lazily instantiated by DnsConfigurationGenerator()
var dnsConfigurationGenerator gopter.Gen

// DnsConfigurationGenerator returns a generator of DnsConfiguration instances for property testing.
func DnsConfigurationGenerator() gopter.Gen {
	if dnsConfigurationGenerator != nil {
		return dnsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration(generators)
	dnsConfigurationGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration{}), generators)

	return dnsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsConfiguration_STATUS to DnsConfiguration_STATUS via AssignPropertiesToDnsConfigurationSTATUS & AssignPropertiesFromDnsConfigurationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsConfigurationSTATUS, DnsConfigurationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsConfigurationSTATUS tests if a specific instance of DnsConfiguration_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForDnsConfigurationSTATUS(subject DnsConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.DnsConfiguration_STATUS
	err := copied.AssignPropertiesToDnsConfigurationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsConfiguration_STATUS
	err = actual.AssignPropertiesFromDnsConfigurationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfigurationSTATUS, DnsConfigurationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfigurationSTATUS runs a test to see if a specific instance of DnsConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfigurationSTATUS(subject DnsConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration_STATUS instances for property testing - lazily instantiated by
// DnsConfigurationSTATUSGenerator()
var dnsConfigurationSTATUSGenerator gopter.Gen

// DnsConfigurationSTATUSGenerator returns a generator of DnsConfiguration_STATUS instances for property testing.
func DnsConfigurationSTATUSGenerator() gopter.Gen {
	if dnsConfigurationSTATUSGenerator != nil {
		return dnsConfigurationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfigurationSTATUS(generators)
	dnsConfigurationSTATUSGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration_STATUS{}), generators)

	return dnsConfigurationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfigurationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfigurationSTATUS(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties to EncryptionProperties via AssignPropertiesToEncryptionProperties & AssignPropertiesFromEncryptionProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperties tests if a specific instance of EncryptionProperties can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperties(subject EncryptionProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EncryptionProperties
	err := copied.AssignPropertiesToEncryptionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties
	err = actual.AssignPropertiesFromEncryptionProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties runs a test to see if a specific instance of EncryptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties(subject EncryptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties instances for property testing - lazily instantiated by
// EncryptionPropertiesGenerator()
var encryptionPropertiesGenerator gopter.Gen

// EncryptionPropertiesGenerator returns a generator of EncryptionProperties instances for property testing.
func EncryptionPropertiesGenerator() gopter.Gen {
	if encryptionPropertiesGenerator != nil {
		return encryptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties(generators)
	encryptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties{}), generators)

	return encryptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_STATUS to EncryptionProperties_STATUS via AssignPropertiesToEncryptionPropertiesSTATUS & AssignPropertiesFromEncryptionPropertiesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertiesSTATUS, EncryptionPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertiesSTATUS tests if a specific instance of EncryptionProperties_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertiesSTATUS(subject EncryptionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EncryptionProperties_STATUS
	err := copied.AssignPropertiesToEncryptionPropertiesSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_STATUS
	err = actual.AssignPropertiesFromEncryptionPropertiesSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesSTATUS, EncryptionPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesSTATUS runs a test to see if a specific instance of EncryptionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesSTATUS(subject EncryptionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_STATUS instances for property testing - lazily instantiated by
// EncryptionPropertiesSTATUSGenerator()
var encryptionPropertiesSTATUSGenerator gopter.Gen

// EncryptionPropertiesSTATUSGenerator returns a generator of EncryptionProperties_STATUS instances for property testing.
func EncryptionPropertiesSTATUSGenerator() gopter.Gen {
	if encryptionPropertiesSTATUSGenerator != nil {
		return encryptionPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUS(generators)
	encryptionPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUS{}), generators)

	return encryptionPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUS(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageRegistryCredential_STATUS to ImageRegistryCredential_STATUS via AssignPropertiesToImageRegistryCredentialSTATUS & AssignPropertiesFromImageRegistryCredentialSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageRegistryCredentialSTATUS, ImageRegistryCredentialSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageRegistryCredentialSTATUS tests if a specific instance of ImageRegistryCredential_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForImageRegistryCredentialSTATUS(subject ImageRegistryCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ImageRegistryCredential_STATUS
	err := copied.AssignPropertiesToImageRegistryCredentialSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageRegistryCredential_STATUS
	err = actual.AssignPropertiesFromImageRegistryCredentialSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageRegistryCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredentialSTATUS, ImageRegistryCredentialSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredentialSTATUS runs a test to see if a specific instance of ImageRegistryCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredentialSTATUS(subject ImageRegistryCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential_STATUS instances for property testing - lazily instantiated by
// ImageRegistryCredentialSTATUSGenerator()
var imageRegistryCredentialSTATUSGenerator gopter.Gen

// ImageRegistryCredentialSTATUSGenerator returns a generator of ImageRegistryCredential_STATUS instances for property testing.
func ImageRegistryCredentialSTATUSGenerator() gopter.Gen {
	if imageRegistryCredentialSTATUSGenerator != nil {
		return imageRegistryCredentialSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredentialSTATUS(generators)
	imageRegistryCredentialSTATUSGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential_STATUS{}), generators)

	return imageRegistryCredentialSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredentialSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredentialSTATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InitContainerDefinition_STATUS to InitContainerDefinition_STATUS via AssignPropertiesToInitContainerDefinitionSTATUS & AssignPropertiesFromInitContainerDefinitionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForInitContainerDefinitionSTATUS, InitContainerDefinitionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInitContainerDefinitionSTATUS tests if a specific instance of InitContainerDefinition_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForInitContainerDefinitionSTATUS(subject InitContainerDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.InitContainerDefinition_STATUS
	err := copied.AssignPropertiesToInitContainerDefinitionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InitContainerDefinition_STATUS
	err = actual.AssignPropertiesFromInitContainerDefinitionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InitContainerDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinitionSTATUS, InitContainerDefinitionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinitionSTATUS runs a test to see if a specific instance of InitContainerDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinitionSTATUS(subject InitContainerDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition_STATUS instances for property testing - lazily instantiated by
// InitContainerDefinitionSTATUSGenerator()
var initContainerDefinitionSTATUSGenerator gopter.Gen

// InitContainerDefinitionSTATUSGenerator returns a generator of InitContainerDefinition_STATUS instances for property testing.
// We first initialize initContainerDefinitionSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinitionSTATUSGenerator() gopter.Gen {
	if initContainerDefinitionSTATUSGenerator != nil {
		return initContainerDefinitionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionSTATUS(generators)
	initContainerDefinitionSTATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionSTATUS(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinitionSTATUS(generators)
	initContainerDefinitionSTATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_STATUS{}), generators)

	return initContainerDefinitionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinitionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinitionSTATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinitionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinitionSTATUS(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableSTATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountSTATUSGenerator())
}

func Test_IpAddress_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddress to IpAddress via AssignPropertiesToIpAddress & AssignPropertiesFromIpAddress returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddress tests if a specific instance of IpAddress can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForIpAddress(subject IpAddress) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.IpAddress
	err := copied.AssignPropertiesToIpAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddress
	err = actual.AssignPropertiesFromIpAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress runs a test to see if a specific instance of IpAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress(subject IpAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress instances for property testing - lazily instantiated by IpAddressGenerator()
var ipAddressGenerator gopter.Gen

// IpAddressGenerator returns a generator of IpAddress instances for property testing.
// We first initialize ipAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressGenerator() gopter.Gen {
	if ipAddressGenerator != nil {
		return ipAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	AddRelatedPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	return ipAddressGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.OneConstOf(
		IpAddressDnsNameLabelReusePolicy_Noreuse,
		IpAddressDnsNameLabelReusePolicy_ResourceGroupReuse,
		IpAddressDnsNameLabelReusePolicy_SubscriptionReuse,
		IpAddressDnsNameLabelReusePolicy_TenantReuse,
		IpAddressDnsNameLabelReusePolicy_Unsecure))
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddressType_Private, IpAddressType_Public))
}

// AddRelatedPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortGenerator())
}

func Test_IpAddress_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddress_STATUS to IpAddress_STATUS via AssignPropertiesToIpAddressSTATUS & AssignPropertiesFromIpAddressSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressSTATUS, IpAddressSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressSTATUS tests if a specific instance of IpAddress_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForIpAddressSTATUS(subject IpAddress_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.IpAddress_STATUS
	err := copied.AssignPropertiesToIpAddressSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddress_STATUS
	err = actual.AssignPropertiesFromIpAddressSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressSTATUS, IpAddressSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressSTATUS runs a test to see if a specific instance of IpAddress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressSTATUS(subject IpAddress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress_STATUS instances for property testing - lazily instantiated by IpAddressSTATUSGenerator()
var ipAddressSTATUSGenerator gopter.Gen

// IpAddressSTATUSGenerator returns a generator of IpAddress_STATUS instances for property testing.
// We first initialize ipAddressSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressSTATUSGenerator() gopter.Gen {
	if ipAddressSTATUSGenerator != nil {
		return ipAddressSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressSTATUS(generators)
	ipAddressSTATUSGenerator = gen.Struct(reflect.TypeOf(IpAddress_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressSTATUS(generators)
	AddRelatedPropertyGeneratorsForIpAddressSTATUS(generators)
	ipAddressSTATUSGenerator = gen.Struct(reflect.TypeOf(IpAddress_STATUS{}), generators)

	return ipAddressSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressSTATUS(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.OneConstOf(
		IpAddressSTATUSDnsNameLabelReusePolicy_Noreuse,
		IpAddressSTATUSDnsNameLabelReusePolicy_ResourceGroupReuse,
		IpAddressSTATUSDnsNameLabelReusePolicy_SubscriptionReuse,
		IpAddressSTATUSDnsNameLabelReusePolicy_TenantReuse,
		IpAddressSTATUSDnsNameLabelReusePolicy_Unsecure))
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddressSTATUSType_Private, IpAddressSTATUSType_Public))
}

// AddRelatedPropertyGeneratorsForIpAddressSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddressSTATUS(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortSTATUSGenerator())
}

func Test_Volume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume to Volume via AssignPropertiesToVolume & AssignPropertiesFromVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolume tests if a specific instance of Volume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolume(subject Volume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Volume
	err := copied.AssignPropertiesToVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume
	err = actual.AssignPropertiesFromVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeGenerator())
}

func Test_Volume_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume_STATUS to Volume_STATUS via AssignPropertiesToVolumeSTATUS & AssignPropertiesFromVolumeSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeSTATUS, VolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeSTATUS tests if a specific instance of Volume_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeSTATUS(subject Volume_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Volume_STATUS
	err := copied.AssignPropertiesToVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume_STATUS
	err = actual.AssignPropertiesFromVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeSTATUS, VolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeSTATUS runs a test to see if a specific instance of Volume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeSTATUS(subject Volume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_STATUS instances for property testing - lazily instantiated by VolumeSTATUSGenerator()
var volumeSTATUSGenerator gopter.Gen

// VolumeSTATUSGenerator returns a generator of Volume_STATUS instances for property testing.
// We first initialize volumeSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeSTATUSGenerator() gopter.Gen {
	if volumeSTATUSGenerator != nil {
		return volumeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeSTATUS(generators)
	volumeSTATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeSTATUS(generators)
	AddRelatedPropertyGeneratorsForVolumeSTATUS(generators)
	volumeSTATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	return volumeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolumeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolumeSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolumeSTATUS(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeSTATUSGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeSTATUSGenerator())
}

func Test_AzureFileVolume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFileVolume to AzureFileVolume via AssignPropertiesToAzureFileVolume & AssignPropertiesFromAzureFileVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFileVolume tests if a specific instance of AzureFileVolume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForAzureFileVolume(subject AzureFileVolume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.AzureFileVolume
	err := copied.AssignPropertiesToAzureFileVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFileVolume
	err = actual.AssignPropertiesFromAzureFileVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFileVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume runs a test to see if a specific instance of AzureFileVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume(subject AzureFileVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume instances for property testing - lazily instantiated by AzureFileVolumeGenerator()
var azureFileVolumeGenerator gopter.Gen

// AzureFileVolumeGenerator returns a generator of AzureFileVolume instances for property testing.
func AzureFileVolumeGenerator() gopter.Gen {
	if azureFileVolumeGenerator != nil {
		return azureFileVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume(generators)
	azureFileVolumeGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume{}), generators)

	return azureFileVolumeGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFileVolume_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFileVolume_STATUS to AzureFileVolume_STATUS via AssignPropertiesToAzureFileVolumeSTATUS & AssignPropertiesFromAzureFileVolumeSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFileVolumeSTATUS, AzureFileVolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFileVolumeSTATUS tests if a specific instance of AzureFileVolume_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForAzureFileVolumeSTATUS(subject AzureFileVolume_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.AzureFileVolume_STATUS
	err := copied.AssignPropertiesToAzureFileVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFileVolume_STATUS
	err = actual.AssignPropertiesFromAzureFileVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFileVolume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolumeSTATUS, AzureFileVolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolumeSTATUS runs a test to see if a specific instance of AzureFileVolume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolumeSTATUS(subject AzureFileVolume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume_STATUS instances for property testing - lazily instantiated by
// AzureFileVolumeSTATUSGenerator()
var azureFileVolumeSTATUSGenerator gopter.Gen

// AzureFileVolumeSTATUSGenerator returns a generator of AzureFileVolume_STATUS instances for property testing.
func AzureFileVolumeSTATUSGenerator() gopter.Gen {
	if azureFileVolumeSTATUSGenerator != nil {
		return azureFileVolumeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolumeSTATUS(generators)
	azureFileVolumeSTATUSGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume_STATUS{}), generators)

	return azureFileVolumeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolumeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolumeSTATUS(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupIdentity_STATUS_UserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerGroupIdentity_STATUS_UserAssignedIdentities to ContainerGroupIdentity_STATUS_UserAssignedIdentities via AssignPropertiesToContainerGroupIdentitySTATUSUserAssignedIdentities & AssignPropertiesFromContainerGroupIdentitySTATUSUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerGroupIdentitySTATUSUserAssignedIdentities, ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerGroupIdentitySTATUSUserAssignedIdentities tests if a specific instance of ContainerGroupIdentity_STATUS_UserAssignedIdentities can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerGroupIdentitySTATUSUserAssignedIdentities(subject ContainerGroupIdentity_STATUS_UserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerGroupIdentity_STATUS_UserAssignedIdentities
	err := copied.AssignPropertiesToContainerGroupIdentitySTATUSUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerGroupIdentity_STATUS_UserAssignedIdentities
	err = actual.AssignPropertiesFromContainerGroupIdentitySTATUSUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerGroupIdentity_STATUS_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_STATUS_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentitySTATUSUserAssignedIdentities, ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentitySTATUSUserAssignedIdentities runs a test to see if a specific instance of ContainerGroupIdentity_STATUS_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentitySTATUSUserAssignedIdentities(subject ContainerGroupIdentity_STATUS_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_STATUS_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_STATUS_UserAssignedIdentities instances for property testing - lazily
// instantiated by ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator()
var containerGroupIdentitySTATUSUserAssignedIdentitiesGenerator gopter.Gen

// ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator returns a generator of ContainerGroupIdentity_STATUS_UserAssignedIdentities instances for property testing.
func ContainerGroupIdentitySTATUSUserAssignedIdentitiesGenerator() gopter.Gen {
	if containerGroupIdentitySTATUSUserAssignedIdentitiesGenerator != nil {
		return containerGroupIdentitySTATUSUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUSUserAssignedIdentities(generators)
	containerGroupIdentitySTATUSUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_STATUS_UserAssignedIdentities{}), generators)

	return containerGroupIdentitySTATUSUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUSUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentitySTATUSUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPort to ContainerPort via AssignPropertiesToContainerPort & AssignPropertiesFromContainerPort returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPort tests if a specific instance of ContainerPort can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPort(subject ContainerPort) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerPort
	err := copied.AssignPropertiesToContainerPort(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPort
	err = actual.AssignPropertiesFromContainerPort(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPort_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort runs a test to see if a specific instance of ContainerPort round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort(subject ContainerPort) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort instances for property testing - lazily instantiated by ContainerPortGenerator()
var containerPortGenerator gopter.Gen

// ContainerPortGenerator returns a generator of ContainerPort instances for property testing.
func ContainerPortGenerator() gopter.Gen {
	if containerPortGenerator != nil {
		return containerPortGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort(generators)
	containerPortGenerator = gen.Struct(reflect.TypeOf(ContainerPort{}), generators)

	return containerPortGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPortProtocol_TCP, ContainerPortProtocol_UDP))
}

func Test_ContainerPort_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPort_STATUS to ContainerPort_STATUS via AssignPropertiesToContainerPortSTATUS & AssignPropertiesFromContainerPortSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPortSTATUS, ContainerPortSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPortSTATUS tests if a specific instance of ContainerPort_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPortSTATUS(subject ContainerPort_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerPort_STATUS
	err := copied.AssignPropertiesToContainerPortSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPort_STATUS
	err = actual.AssignPropertiesFromContainerPortSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPort_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPortSTATUS, ContainerPortSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPortSTATUS runs a test to see if a specific instance of ContainerPort_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPortSTATUS(subject ContainerPort_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort_STATUS instances for property testing - lazily instantiated by
// ContainerPortSTATUSGenerator()
var containerPortSTATUSGenerator gopter.Gen

// ContainerPortSTATUSGenerator returns a generator of ContainerPort_STATUS instances for property testing.
func ContainerPortSTATUSGenerator() gopter.Gen {
	if containerPortSTATUSGenerator != nil {
		return containerPortSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPortSTATUS(generators)
	containerPortSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerPort_STATUS{}), generators)

	return containerPortSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerPortSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPortSTATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPortSTATUSProtocol_TCP, ContainerPortSTATUSProtocol_UDP))
}

func Test_ContainerProbe_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProbe to ContainerProbe via AssignPropertiesToContainerProbe & AssignPropertiesFromContainerProbe returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerProbe tests if a specific instance of ContainerProbe can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerProbe(subject ContainerProbe) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProbe
	err := copied.AssignPropertiesToContainerProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProbe
	err = actual.AssignPropertiesFromContainerProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe runs a test to see if a specific instance of ContainerProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe(subject ContainerProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe instances for property testing - lazily instantiated by ContainerProbeGenerator()
var containerProbeGenerator gopter.Gen

// ContainerProbeGenerator returns a generator of ContainerProbe instances for property testing.
// We first initialize containerProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeGenerator() gopter.Gen {
	if containerProbeGenerator != nil {
		return containerProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	AddRelatedPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	return containerProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetGenerator())
}

func Test_ContainerProbe_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProbe_STATUS to ContainerProbe_STATUS via AssignPropertiesToContainerProbeSTATUS & AssignPropertiesFromContainerProbeSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerProbeSTATUS, ContainerProbeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerProbeSTATUS tests if a specific instance of ContainerProbe_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerProbeSTATUS(subject ContainerProbe_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProbe_STATUS
	err := copied.AssignPropertiesToContainerProbeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProbe_STATUS
	err = actual.AssignPropertiesFromContainerProbeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProbe_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbeSTATUS, ContainerProbeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbeSTATUS runs a test to see if a specific instance of ContainerProbe_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbeSTATUS(subject ContainerProbe_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe_STATUS instances for property testing - lazily instantiated by
// ContainerProbeSTATUSGenerator()
var containerProbeSTATUSGenerator gopter.Gen

// ContainerProbeSTATUSGenerator returns a generator of ContainerProbe_STATUS instances for property testing.
// We first initialize containerProbeSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeSTATUSGenerator() gopter.Gen {
	if containerProbeSTATUSGenerator != nil {
		return containerProbeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeSTATUS(generators)
	containerProbeSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeSTATUS(generators)
	AddRelatedPropertyGeneratorsForContainerProbeSTATUS(generators)
	containerProbeSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_STATUS{}), generators)

	return containerProbeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbeSTATUS(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbeSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbeSTATUS(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecSTATUSGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetSTATUSGenerator())
}

func Test_ContainerProperties_STATUS_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerProperties_STATUS_InstanceView to ContainerProperties_STATUS_InstanceView via AssignPropertiesToContainerPropertiesSTATUSInstanceView & AssignPropertiesFromContainerPropertiesSTATUSInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPropertiesSTATUSInstanceView, ContainerPropertiesSTATUSInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPropertiesSTATUSInstanceView tests if a specific instance of ContainerProperties_STATUS_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerPropertiesSTATUSInstanceView(subject ContainerProperties_STATUS_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerProperties_STATUS_InstanceView
	err := copied.AssignPropertiesToContainerPropertiesSTATUSInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerProperties_STATUS_InstanceView
	err = actual.AssignPropertiesFromContainerPropertiesSTATUSInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerProperties_STATUS_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties_STATUS_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPropertiesSTATUSInstanceView, ContainerPropertiesSTATUSInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPropertiesSTATUSInstanceView runs a test to see if a specific instance of ContainerProperties_STATUS_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPropertiesSTATUSInstanceView(subject ContainerProperties_STATUS_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties_STATUS_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties_STATUS_InstanceView instances for property testing - lazily instantiated by
// ContainerPropertiesSTATUSInstanceViewGenerator()
var containerPropertiesSTATUSInstanceViewGenerator gopter.Gen

// ContainerPropertiesSTATUSInstanceViewGenerator returns a generator of ContainerProperties_STATUS_InstanceView instances for property testing.
// We first initialize containerPropertiesSTATUSInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerPropertiesSTATUSInstanceViewGenerator() gopter.Gen {
	if containerPropertiesSTATUSInstanceViewGenerator != nil {
		return containerPropertiesSTATUSInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesSTATUSInstanceView(generators)
	containerPropertiesSTATUSInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_STATUS_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesSTATUSInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerPropertiesSTATUSInstanceView(generators)
	containerPropertiesSTATUSInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_STATUS_InstanceView{}), generators)

	return containerPropertiesSTATUSInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerPropertiesSTATUSInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPropertiesSTATUSInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerPropertiesSTATUSInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerPropertiesSTATUSInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateSTATUSGenerator())
	gens["Events"] = gen.SliceOf(EventSTATUSGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateSTATUSGenerator())
}

func Test_EnvironmentVariable_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVariable to EnvironmentVariable via AssignPropertiesToEnvironmentVariable & AssignPropertiesFromEnvironmentVariable returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVariable tests if a specific instance of EnvironmentVariable can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EnvironmentVariable
	err := copied.AssignPropertiesToEnvironmentVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVariable
	err = actual.AssignPropertiesFromEnvironmentVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable runs a test to see if a specific instance of EnvironmentVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable instances for property testing - lazily instantiated by
// EnvironmentVariableGenerator()
var environmentVariableGenerator gopter.Gen

// EnvironmentVariableGenerator returns a generator of EnvironmentVariable instances for property testing.
func EnvironmentVariableGenerator() gopter.Gen {
	if environmentVariableGenerator != nil {
		return environmentVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable(generators)
	environmentVariableGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable{}), generators)

	return environmentVariableGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnvironmentVariable_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVariable_STATUS to EnvironmentVariable_STATUS via AssignPropertiesToEnvironmentVariableSTATUS & AssignPropertiesFromEnvironmentVariableSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVariableSTATUS, EnvironmentVariableSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVariableSTATUS tests if a specific instance of EnvironmentVariable_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVariableSTATUS(subject EnvironmentVariable_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.EnvironmentVariable_STATUS
	err := copied.AssignPropertiesToEnvironmentVariableSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVariable_STATUS
	err = actual.AssignPropertiesFromEnvironmentVariableSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVariable_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariableSTATUS, EnvironmentVariableSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariableSTATUS runs a test to see if a specific instance of EnvironmentVariable_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariableSTATUS(subject EnvironmentVariable_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable_STATUS instances for property testing - lazily instantiated by
// EnvironmentVariableSTATUSGenerator()
var environmentVariableSTATUSGenerator gopter.Gen

// EnvironmentVariableSTATUSGenerator returns a generator of EnvironmentVariable_STATUS instances for property testing.
func EnvironmentVariableSTATUSGenerator() gopter.Gen {
	if environmentVariableSTATUSGenerator != nil {
		return environmentVariableSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariableSTATUS(generators)
	environmentVariableSTATUSGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable_STATUS{}), generators)

	return environmentVariableSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariableSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariableSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Event_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Event_STATUS to Event_STATUS via AssignPropertiesToEventSTATUS & AssignPropertiesFromEventSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSTATUS, EventSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSTATUS tests if a specific instance of Event_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForEventSTATUS(subject Event_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Event_STATUS
	err := copied.AssignPropertiesToEventSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Event_STATUS
	err = actual.AssignPropertiesFromEventSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Event_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Event_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSTATUS, EventSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSTATUS runs a test to see if a specific instance of Event_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSTATUS(subject Event_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Event_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Event_STATUS instances for property testing - lazily instantiated by EventSTATUSGenerator()
var eventSTATUSGenerator gopter.Gen

// EventSTATUSGenerator returns a generator of Event_STATUS instances for property testing.
func EventSTATUSGenerator() gopter.Gen {
	if eventSTATUSGenerator != nil {
		return eventSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSTATUS(generators)
	eventSTATUSGenerator = gen.Struct(reflect.TypeOf(Event_STATUS{}), generators)

	return eventSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["FirstTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["LastTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepoVolume to GitRepoVolume via AssignPropertiesToGitRepoVolume & AssignPropertiesFromGitRepoVolume returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepoVolume tests if a specific instance of GitRepoVolume can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGitRepoVolume(subject GitRepoVolume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GitRepoVolume
	err := copied.AssignPropertiesToGitRepoVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepoVolume
	err = actual.AssignPropertiesFromGitRepoVolume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepoVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume runs a test to see if a specific instance of GitRepoVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume(subject GitRepoVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume instances for property testing - lazily instantiated by GitRepoVolumeGenerator()
var gitRepoVolumeGenerator gopter.Gen

// GitRepoVolumeGenerator returns a generator of GitRepoVolume instances for property testing.
func GitRepoVolumeGenerator() gopter.Gen {
	if gitRepoVolumeGenerator != nil {
		return gitRepoVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume(generators)
	gitRepoVolumeGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume{}), generators)

	return gitRepoVolumeGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepoVolume_STATUS to GitRepoVolume_STATUS via AssignPropertiesToGitRepoVolumeSTATUS & AssignPropertiesFromGitRepoVolumeSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepoVolumeSTATUS, GitRepoVolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepoVolumeSTATUS tests if a specific instance of GitRepoVolume_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGitRepoVolumeSTATUS(subject GitRepoVolume_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GitRepoVolume_STATUS
	err := copied.AssignPropertiesToGitRepoVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepoVolume_STATUS
	err = actual.AssignPropertiesFromGitRepoVolumeSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepoVolume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolumeSTATUS, GitRepoVolumeSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolumeSTATUS runs a test to see if a specific instance of GitRepoVolume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolumeSTATUS(subject GitRepoVolume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume_STATUS instances for property testing - lazily instantiated by
// GitRepoVolumeSTATUSGenerator()
var gitRepoVolumeSTATUSGenerator gopter.Gen

// GitRepoVolumeSTATUSGenerator returns a generator of GitRepoVolume_STATUS instances for property testing.
func GitRepoVolumeSTATUSGenerator() gopter.Gen {
	if gitRepoVolumeSTATUSGenerator != nil {
		return gitRepoVolumeSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolumeSTATUS(generators)
	gitRepoVolumeSTATUSGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume_STATUS{}), generators)

	return gitRepoVolumeSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolumeSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolumeSTATUS(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinition_STATUS_InstanceView_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InitContainerPropertiesDefinition_STATUS_InstanceView to InitContainerPropertiesDefinition_STATUS_InstanceView via AssignPropertiesToInitContainerPropertiesDefinitionSTATUSInstanceView & AssignPropertiesFromInitContainerPropertiesDefinitionSTATUSInstanceView returns original",
		prop.ForAll(RunPropertyAssignmentTestForInitContainerPropertiesDefinitionSTATUSInstanceView, InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInitContainerPropertiesDefinitionSTATUSInstanceView tests if a specific instance of InitContainerPropertiesDefinition_STATUS_InstanceView can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForInitContainerPropertiesDefinitionSTATUSInstanceView(subject InitContainerPropertiesDefinition_STATUS_InstanceView) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.InitContainerPropertiesDefinition_STATUS_InstanceView
	err := copied.AssignPropertiesToInitContainerPropertiesDefinitionSTATUSInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InitContainerPropertiesDefinition_STATUS_InstanceView
	err = actual.AssignPropertiesFromInitContainerPropertiesDefinitionSTATUSInstanceView(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InitContainerPropertiesDefinition_STATUS_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition_STATUS_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinitionSTATUSInstanceView, InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinitionSTATUSInstanceView runs a test to see if a specific instance of InitContainerPropertiesDefinition_STATUS_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinitionSTATUSInstanceView(subject InitContainerPropertiesDefinition_STATUS_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition_STATUS_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition_STATUS_InstanceView instances for property testing - lazily
// instantiated by InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator()
var initContainerPropertiesDefinitionSTATUSInstanceViewGenerator gopter.Gen

// InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator returns a generator of InitContainerPropertiesDefinition_STATUS_InstanceView instances for property testing.
// We first initialize initContainerPropertiesDefinitionSTATUSInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinitionSTATUSInstanceViewGenerator() gopter.Gen {
	if initContainerPropertiesDefinitionSTATUSInstanceViewGenerator != nil {
		return initContainerPropertiesDefinitionSTATUSInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView(generators)
	initContainerPropertiesDefinitionSTATUSInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_STATUS_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView(generators)
	initContainerPropertiesDefinitionSTATUSInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_STATUS_InstanceView{}), generators)

	return initContainerPropertiesDefinitionSTATUSInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionSTATUSInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateSTATUSGenerator())
	gens["Events"] = gen.SliceOf(EventSTATUSGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateSTATUSGenerator())
}

func Test_LogAnalytics_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalytics to LogAnalytics via AssignPropertiesToLogAnalytics & AssignPropertiesFromLogAnalytics returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalytics tests if a specific instance of LogAnalytics can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForLogAnalytics(subject LogAnalytics) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.LogAnalytics
	err := copied.AssignPropertiesToLogAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalytics
	err = actual.AssignPropertiesFromLogAnalytics(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalytics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics runs a test to see if a specific instance of LogAnalytics round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics(subject LogAnalytics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics instances for property testing - lazily instantiated by LogAnalyticsGenerator()
var logAnalyticsGenerator gopter.Gen

// LogAnalyticsGenerator returns a generator of LogAnalytics instances for property testing.
func LogAnalyticsGenerator() gopter.Gen {
	if logAnalyticsGenerator != nil {
		return logAnalyticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics(generators)
	logAnalyticsGenerator = gen.Struct(reflect.TypeOf(LogAnalytics{}), generators)

	return logAnalyticsGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalyticsLogType_ContainerInsights, LogAnalyticsLogType_ContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalytics_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalytics_STATUS to LogAnalytics_STATUS via AssignPropertiesToLogAnalyticsSTATUS & AssignPropertiesFromLogAnalyticsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsSTATUS, LogAnalyticsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsSTATUS tests if a specific instance of LogAnalytics_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsSTATUS(subject LogAnalytics_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.LogAnalytics_STATUS
	err := copied.AssignPropertiesToLogAnalyticsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalytics_STATUS
	err = actual.AssignPropertiesFromLogAnalyticsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalytics_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsSTATUS, LogAnalyticsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsSTATUS runs a test to see if a specific instance of LogAnalytics_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsSTATUS(subject LogAnalytics_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics_STATUS instances for property testing - lazily instantiated by LogAnalyticsSTATUSGenerator()
var logAnalyticsSTATUSGenerator gopter.Gen

// LogAnalyticsSTATUSGenerator returns a generator of LogAnalytics_STATUS instances for property testing.
func LogAnalyticsSTATUSGenerator() gopter.Gen {
	if logAnalyticsSTATUSGenerator != nil {
		return logAnalyticsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsSTATUS(generators)
	logAnalyticsSTATUSGenerator = gen.Struct(reflect.TypeOf(LogAnalytics_STATUS{}), generators)

	return logAnalyticsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsSTATUS(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalyticsSTATUSLogType_ContainerInsights, LogAnalyticsSTATUSLogType_ContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Port to Port via AssignPropertiesToPort & AssignPropertiesFromPort returns original",
		prop.ForAll(RunPropertyAssignmentTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPort tests if a specific instance of Port can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPort(subject Port) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Port
	err := copied.AssignPropertiesToPort(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Port
	err = actual.AssignPropertiesFromPort(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Port_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort runs a test to see if a specific instance of Port round trips to JSON and back losslessly
func RunJSONSerializationTestForPort(subject Port) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port instances for property testing - lazily instantiated by PortGenerator()
var portGenerator gopter.Gen

// PortGenerator returns a generator of Port instances for property testing.
func PortGenerator() gopter.Gen {
	if portGenerator != nil {
		return portGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort(generators)
	portGenerator = gen.Struct(reflect.TypeOf(Port{}), generators)

	return portGenerator
}

// AddIndependentPropertyGeneratorsForPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortProtocol_TCP, PortProtocol_UDP))
}

func Test_Port_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Port_STATUS to Port_STATUS via AssignPropertiesToPortSTATUS & AssignPropertiesFromPortSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPortSTATUS, PortSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPortSTATUS tests if a specific instance of Port_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPortSTATUS(subject Port_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.Port_STATUS
	err := copied.AssignPropertiesToPortSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Port_STATUS
	err = actual.AssignPropertiesFromPortSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Port_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortSTATUS, PortSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortSTATUS runs a test to see if a specific instance of Port_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPortSTATUS(subject Port_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port_STATUS instances for property testing - lazily instantiated by PortSTATUSGenerator()
var portSTATUSGenerator gopter.Gen

// PortSTATUSGenerator returns a generator of Port_STATUS instances for property testing.
func PortSTATUSGenerator() gopter.Gen {
	if portSTATUSGenerator != nil {
		return portSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortSTATUS(generators)
	portSTATUSGenerator = gen.Struct(reflect.TypeOf(Port_STATUS{}), generators)

	return portSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForPortSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortSTATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(PortSTATUSProtocol_TCP, PortSTATUSProtocol_UDP))
}

func Test_ResourceRequirements_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequirements to ResourceRequirements via AssignPropertiesToResourceRequirements & AssignPropertiesFromResourceRequirements returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequirements tests if a specific instance of ResourceRequirements can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequirements(subject ResourceRequirements) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequirements
	err := copied.AssignPropertiesToResourceRequirements(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequirements
	err = actual.AssignPropertiesFromResourceRequirements(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequirements_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements runs a test to see if a specific instance of ResourceRequirements round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements(subject ResourceRequirements) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements instances for property testing - lazily instantiated by
// ResourceRequirementsGenerator()
var resourceRequirementsGenerator gopter.Gen

// ResourceRequirementsGenerator returns a generator of ResourceRequirements instances for property testing.
func ResourceRequirementsGenerator() gopter.Gen {
	if resourceRequirementsGenerator != nil {
		return resourceRequirementsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements(generators)
	resourceRequirementsGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements{}), generators)

	return resourceRequirementsGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsGenerator())
}

func Test_ResourceRequirements_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequirements_STATUS to ResourceRequirements_STATUS via AssignPropertiesToResourceRequirementsSTATUS & AssignPropertiesFromResourceRequirementsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequirementsSTATUS, ResourceRequirementsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequirementsSTATUS tests if a specific instance of ResourceRequirements_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequirementsSTATUS(subject ResourceRequirements_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequirements_STATUS
	err := copied.AssignPropertiesToResourceRequirementsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequirements_STATUS
	err = actual.AssignPropertiesFromResourceRequirementsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequirements_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirementsSTATUS, ResourceRequirementsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirementsSTATUS runs a test to see if a specific instance of ResourceRequirements_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirementsSTATUS(subject ResourceRequirements_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements_STATUS instances for property testing - lazily instantiated by
// ResourceRequirementsSTATUSGenerator()
var resourceRequirementsSTATUSGenerator gopter.Gen

// ResourceRequirementsSTATUSGenerator returns a generator of ResourceRequirements_STATUS instances for property testing.
func ResourceRequirementsSTATUSGenerator() gopter.Gen {
	if resourceRequirementsSTATUSGenerator != nil {
		return resourceRequirementsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirementsSTATUS(generators)
	resourceRequirementsSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements_STATUS{}), generators)

	return resourceRequirementsSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirementsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirementsSTATUS(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsSTATUSGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsSTATUSGenerator())
}

func Test_VolumeMount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount to VolumeMount via AssignPropertiesToVolumeMount & AssignPropertiesFromVolumeMount returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMount tests if a specific instance of VolumeMount can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeMount(subject VolumeMount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.VolumeMount
	err := copied.AssignPropertiesToVolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount
	err = actual.AssignPropertiesFromVolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_VolumeMount_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount_STATUS to VolumeMount_STATUS via AssignPropertiesToVolumeMountSTATUS & AssignPropertiesFromVolumeMountSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMountSTATUS, VolumeMountSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMountSTATUS tests if a specific instance of VolumeMount_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForVolumeMountSTATUS(subject VolumeMount_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.VolumeMount_STATUS
	err := copied.AssignPropertiesToVolumeMountSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount_STATUS
	err = actual.AssignPropertiesFromVolumeMountSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMountSTATUS, VolumeMountSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMountSTATUS runs a test to see if a specific instance of VolumeMount_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMountSTATUS(subject VolumeMount_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_STATUS instances for property testing - lazily instantiated by VolumeMountSTATUSGenerator()
var volumeMountSTATUSGenerator gopter.Gen

// VolumeMountSTATUSGenerator returns a generator of VolumeMount_STATUS instances for property testing.
func VolumeMountSTATUSGenerator() gopter.Gen {
	if volumeMountSTATUSGenerator != nil {
		return volumeMountSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMountSTATUS(generators)
	volumeMountSTATUSGenerator = gen.Struct(reflect.TypeOf(VolumeMount_STATUS{}), generators)

	return volumeMountSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMountSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMountSTATUS(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerExec to ContainerExec via AssignPropertiesToContainerExec & AssignPropertiesFromContainerExec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerExec tests if a specific instance of ContainerExec can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerExec(subject ContainerExec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerExec
	err := copied.AssignPropertiesToContainerExec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerExec
	err = actual.AssignPropertiesFromContainerExec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerExec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec runs a test to see if a specific instance of ContainerExec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec(subject ContainerExec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec instances for property testing - lazily instantiated by ContainerExecGenerator()
var containerExecGenerator gopter.Gen

// ContainerExecGenerator returns a generator of ContainerExec instances for property testing.
func ContainerExecGenerator() gopter.Gen {
	if containerExecGenerator != nil {
		return containerExecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec(generators)
	containerExecGenerator = gen.Struct(reflect.TypeOf(ContainerExec{}), generators)

	return containerExecGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerExec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerExec_STATUS to ContainerExec_STATUS via AssignPropertiesToContainerExecSTATUS & AssignPropertiesFromContainerExecSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerExecSTATUS, ContainerExecSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerExecSTATUS tests if a specific instance of ContainerExec_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerExecSTATUS(subject ContainerExec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerExec_STATUS
	err := copied.AssignPropertiesToContainerExecSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerExec_STATUS
	err = actual.AssignPropertiesFromContainerExecSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerExec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExecSTATUS, ContainerExecSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExecSTATUS runs a test to see if a specific instance of ContainerExec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExecSTATUS(subject ContainerExec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec_STATUS instances for property testing - lazily instantiated by
// ContainerExecSTATUSGenerator()
var containerExecSTATUSGenerator gopter.Gen

// ContainerExecSTATUSGenerator returns a generator of ContainerExec_STATUS instances for property testing.
func ContainerExecSTATUSGenerator() gopter.Gen {
	if containerExecSTATUSGenerator != nil {
		return containerExecSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExecSTATUS(generators)
	containerExecSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerExec_STATUS{}), generators)

	return containerExecSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerExecSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExecSTATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerHttpGet to ContainerHttpGet via AssignPropertiesToContainerHttpGet & AssignPropertiesFromContainerHttpGet returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerHttpGet tests if a specific instance of ContainerHttpGet can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerHttpGet
	err := copied.AssignPropertiesToContainerHttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerHttpGet
	err = actual.AssignPropertiesFromContainerHttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerHttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet runs a test to see if a specific instance of ContainerHttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet instances for property testing - lazily instantiated by ContainerHttpGetGenerator()
var containerHttpGetGenerator gopter.Gen

// ContainerHttpGetGenerator returns a generator of ContainerHttpGet instances for property testing.
// We first initialize containerHttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetGenerator() gopter.Gen {
	if containerHttpGetGenerator != nil {
		return containerHttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	return containerHttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGetScheme_Http, ContainerHttpGetScheme_Https))
}

// AddRelatedPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderGenerator())
}

func Test_ContainerHttpGet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerHttpGet_STATUS to ContainerHttpGet_STATUS via AssignPropertiesToContainerHttpGetSTATUS & AssignPropertiesFromContainerHttpGetSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerHttpGetSTATUS, ContainerHttpGetSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerHttpGetSTATUS tests if a specific instance of ContainerHttpGet_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerHttpGetSTATUS(subject ContainerHttpGet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerHttpGet_STATUS
	err := copied.AssignPropertiesToContainerHttpGetSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerHttpGet_STATUS
	err = actual.AssignPropertiesFromContainerHttpGetSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerHttpGet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGetSTATUS, ContainerHttpGetSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGetSTATUS runs a test to see if a specific instance of ContainerHttpGet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGetSTATUS(subject ContainerHttpGet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet_STATUS instances for property testing - lazily instantiated by
// ContainerHttpGetSTATUSGenerator()
var containerHttpGetSTATUSGenerator gopter.Gen

// ContainerHttpGetSTATUSGenerator returns a generator of ContainerHttpGet_STATUS instances for property testing.
// We first initialize containerHttpGetSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetSTATUSGenerator() gopter.Gen {
	if containerHttpGetSTATUSGenerator != nil {
		return containerHttpGetSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetSTATUS(generators)
	containerHttpGetSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetSTATUS(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGetSTATUS(generators)
	containerHttpGetSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_STATUS{}), generators)

	return containerHttpGetSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGetSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGetSTATUS(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGetSTATUSScheme_Http, ContainerHttpGetSTATUSScheme_Https))
}

// AddRelatedPropertyGeneratorsForContainerHttpGetSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGetSTATUS(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderSTATUSGenerator())
}

func Test_ContainerState_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerState_STATUS to ContainerState_STATUS via AssignPropertiesToContainerStateSTATUS & AssignPropertiesFromContainerStateSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerStateSTATUS, ContainerStateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerStateSTATUS tests if a specific instance of ContainerState_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForContainerStateSTATUS(subject ContainerState_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ContainerState_STATUS
	err := copied.AssignPropertiesToContainerStateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerState_STATUS
	err = actual.AssignPropertiesFromContainerStateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerStateSTATUS, ContainerStateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerStateSTATUS runs a test to see if a specific instance of ContainerState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerStateSTATUS(subject ContainerState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerState_STATUS instances for property testing - lazily instantiated by
// ContainerStateSTATUSGenerator()
var containerStateSTATUSGenerator gopter.Gen

// ContainerStateSTATUSGenerator returns a generator of ContainerState_STATUS instances for property testing.
func ContainerStateSTATUSGenerator() gopter.Gen {
	if containerStateSTATUSGenerator != nil {
		return containerStateSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStateSTATUS(generators)
	containerStateSTATUSGenerator = gen.Struct(reflect.TypeOf(ContainerState_STATUS{}), generators)

	return containerStateSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerStateSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerStateSTATUS(gens map[string]gopter.Gen) {
	gens["DetailStatus"] = gen.PtrOf(gen.AlphaString())
	gens["ExitCode"] = gen.PtrOf(gen.Int())
	gens["FinishTime"] = gen.PtrOf(gen.AlphaString())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLimits_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLimits to ResourceLimits via AssignPropertiesToResourceLimits & AssignPropertiesFromResourceLimits returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLimits tests if a specific instance of ResourceLimits can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLimits(subject ResourceLimits) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLimits
	err := copied.AssignPropertiesToResourceLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLimits
	err = actual.AssignPropertiesFromResourceLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits runs a test to see if a specific instance of ResourceLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits(subject ResourceLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits instances for property testing - lazily instantiated by ResourceLimitsGenerator()
var resourceLimitsGenerator gopter.Gen

// ResourceLimitsGenerator returns a generator of ResourceLimits instances for property testing.
// We first initialize resourceLimitsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsGenerator() gopter.Gen {
	if resourceLimitsGenerator != nil {
		return resourceLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	AddRelatedPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	return resourceLimitsGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceLimits_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLimits_STATUS to ResourceLimits_STATUS via AssignPropertiesToResourceLimitsSTATUS & AssignPropertiesFromResourceLimitsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLimitsSTATUS, ResourceLimitsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLimitsSTATUS tests if a specific instance of ResourceLimits_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLimitsSTATUS(subject ResourceLimits_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLimits_STATUS
	err := copied.AssignPropertiesToResourceLimitsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLimits_STATUS
	err = actual.AssignPropertiesFromResourceLimitsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLimits_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimitsSTATUS, ResourceLimitsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimitsSTATUS runs a test to see if a specific instance of ResourceLimits_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimitsSTATUS(subject ResourceLimits_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits_STATUS instances for property testing - lazily instantiated by
// ResourceLimitsSTATUSGenerator()
var resourceLimitsSTATUSGenerator gopter.Gen

// ResourceLimitsSTATUSGenerator returns a generator of ResourceLimits_STATUS instances for property testing.
// We first initialize resourceLimitsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsSTATUSGenerator() gopter.Gen {
	if resourceLimitsSTATUSGenerator != nil {
		return resourceLimitsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsSTATUS(generators)
	resourceLimitsSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsSTATUS(generators)
	AddRelatedPropertyGeneratorsForResourceLimitsSTATUS(generators)
	resourceLimitsSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_STATUS{}), generators)

	return resourceLimitsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimitsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimitsSTATUS(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimitsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimitsSTATUS(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceSTATUSGenerator())
}

func Test_ResourceRequests_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequests to ResourceRequests via AssignPropertiesToResourceRequests & AssignPropertiesFromResourceRequests returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequests tests if a specific instance of ResourceRequests can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequests(subject ResourceRequests) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequests
	err := copied.AssignPropertiesToResourceRequests(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequests
	err = actual.AssignPropertiesFromResourceRequests(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequests_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests runs a test to see if a specific instance of ResourceRequests round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests(subject ResourceRequests) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests instances for property testing - lazily instantiated by ResourceRequestsGenerator()
var resourceRequestsGenerator gopter.Gen

// ResourceRequestsGenerator returns a generator of ResourceRequests instances for property testing.
// We first initialize resourceRequestsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsGenerator() gopter.Gen {
	if resourceRequestsGenerator != nil {
		return resourceRequestsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	AddRelatedPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	return resourceRequestsGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequests_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceRequests_STATUS to ResourceRequests_STATUS via AssignPropertiesToResourceRequestsSTATUS & AssignPropertiesFromResourceRequestsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceRequestsSTATUS, ResourceRequestsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceRequestsSTATUS tests if a specific instance of ResourceRequests_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceRequestsSTATUS(subject ResourceRequests_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceRequests_STATUS
	err := copied.AssignPropertiesToResourceRequestsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceRequests_STATUS
	err = actual.AssignPropertiesFromResourceRequestsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceRequests_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequestsSTATUS, ResourceRequestsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequestsSTATUS runs a test to see if a specific instance of ResourceRequests_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequestsSTATUS(subject ResourceRequests_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests_STATUS instances for property testing - lazily instantiated by
// ResourceRequestsSTATUSGenerator()
var resourceRequestsSTATUSGenerator gopter.Gen

// ResourceRequestsSTATUSGenerator returns a generator of ResourceRequests_STATUS instances for property testing.
// We first initialize resourceRequestsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsSTATUSGenerator() gopter.Gen {
	if resourceRequestsSTATUSGenerator != nil {
		return resourceRequestsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsSTATUS(generators)
	resourceRequestsSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsSTATUS(generators)
	AddRelatedPropertyGeneratorsForResourceRequestsSTATUS(generators)
	resourceRequestsSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_STATUS{}), generators)

	return resourceRequestsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequestsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequestsSTATUS(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequestsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequestsSTATUS(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceSTATUSGenerator())
}

func Test_GpuResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GpuResource to GpuResource via AssignPropertiesToGpuResource & AssignPropertiesFromGpuResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGpuResource tests if a specific instance of GpuResource can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGpuResource(subject GpuResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GpuResource
	err := copied.AssignPropertiesToGpuResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GpuResource
	err = actual.AssignPropertiesFromGpuResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GpuResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource runs a test to see if a specific instance of GpuResource round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource(subject GpuResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource instances for property testing - lazily instantiated by GpuResourceGenerator()
var gpuResourceGenerator gopter.Gen

// GpuResourceGenerator returns a generator of GpuResource instances for property testing.
func GpuResourceGenerator() gopter.Gen {
	if gpuResourceGenerator != nil {
		return gpuResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource(generators)
	gpuResourceGenerator = gen.Struct(reflect.TypeOf(GpuResource{}), generators)

	return gpuResourceGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResourceSku_K80, GpuResourceSku_P100, GpuResourceSku_V100))
}

func Test_GpuResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GpuResource_STATUS to GpuResource_STATUS via AssignPropertiesToGpuResourceSTATUS & AssignPropertiesFromGpuResourceSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGpuResourceSTATUS, GpuResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGpuResourceSTATUS tests if a specific instance of GpuResource_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForGpuResourceSTATUS(subject GpuResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.GpuResource_STATUS
	err := copied.AssignPropertiesToGpuResourceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GpuResource_STATUS
	err = actual.AssignPropertiesFromGpuResourceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GpuResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResourceSTATUS, GpuResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResourceSTATUS runs a test to see if a specific instance of GpuResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResourceSTATUS(subject GpuResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource_STATUS instances for property testing - lazily instantiated by GpuResourceSTATUSGenerator()
var gpuResourceSTATUSGenerator gopter.Gen

// GpuResourceSTATUSGenerator returns a generator of GpuResource_STATUS instances for property testing.
func GpuResourceSTATUSGenerator() gopter.Gen {
	if gpuResourceSTATUSGenerator != nil {
		return gpuResourceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResourceSTATUS(generators)
	gpuResourceSTATUSGenerator = gen.Struct(reflect.TypeOf(GpuResource_STATUS{}), generators)

	return gpuResourceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForGpuResourceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResourceSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResourceSTATUSSku_K80, GpuResourceSTATUSSku_P100, GpuResourceSTATUSSku_V100))
}

func Test_HttpHeader_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpHeader to HttpHeader via AssignPropertiesToHttpHeader & AssignPropertiesFromHttpHeader returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpHeader tests if a specific instance of HttpHeader can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForHttpHeader(subject HttpHeader) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.HttpHeader
	err := copied.AssignPropertiesToHttpHeader(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpHeader
	err = actual.AssignPropertiesFromHttpHeader(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpHeader_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader runs a test to see if a specific instance of HttpHeader round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader(subject HttpHeader) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader instances for property testing - lazily instantiated by HttpHeaderGenerator()
var httpHeaderGenerator gopter.Gen

// HttpHeaderGenerator returns a generator of HttpHeader instances for property testing.
func HttpHeaderGenerator() gopter.Gen {
	if httpHeaderGenerator != nil {
		return httpHeaderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader(generators)
	httpHeaderGenerator = gen.Struct(reflect.TypeOf(HttpHeader{}), generators)

	return httpHeaderGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpHeader_STATUS to HttpHeader_STATUS via AssignPropertiesToHttpHeaderSTATUS & AssignPropertiesFromHttpHeaderSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpHeaderSTATUS, HttpHeaderSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpHeaderSTATUS tests if a specific instance of HttpHeader_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForHttpHeaderSTATUS(subject HttpHeader_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.HttpHeader_STATUS
	err := copied.AssignPropertiesToHttpHeaderSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpHeader_STATUS
	err = actual.AssignPropertiesFromHttpHeaderSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpHeader_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeaderSTATUS, HttpHeaderSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeaderSTATUS runs a test to see if a specific instance of HttpHeader_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeaderSTATUS(subject HttpHeader_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader_STATUS instances for property testing - lazily instantiated by HttpHeaderSTATUSGenerator()
var httpHeaderSTATUSGenerator gopter.Gen

// HttpHeaderSTATUSGenerator returns a generator of HttpHeader_STATUS instances for property testing.
func HttpHeaderSTATUSGenerator() gopter.Gen {
	if httpHeaderSTATUSGenerator != nil {
		return httpHeaderSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeaderSTATUS(generators)
	httpHeaderSTATUSGenerator = gen.Struct(reflect.TypeOf(HttpHeader_STATUS{}), generators)

	return httpHeaderSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeaderSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeaderSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
