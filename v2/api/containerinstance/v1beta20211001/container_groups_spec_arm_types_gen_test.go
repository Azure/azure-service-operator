// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroups_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroups_SpecARM, ContainerGroups_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroups_SpecARM runs a test to see if a specific instance of ContainerGroups_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroups_SpecARM(subject ContainerGroups_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_SpecARM instances for property testing - lazily instantiated by
// ContainerGroups_SpecARMGenerator()
var containerGroups_SpecARMGenerator gopter.Gen

// ContainerGroups_SpecARMGenerator returns a generator of ContainerGroups_SpecARM instances for property testing.
// We first initialize containerGroups_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroups_SpecARMGenerator() gopter.Gen {
	if containerGroups_SpecARMGenerator != nil {
		return containerGroups_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_SpecARM(generators)
	containerGroups_SpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_SpecARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroups_SpecARM(generators)
	containerGroups_SpecARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_SpecARM{}), generators)

	return containerGroups_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroups_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroups_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroups_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroups_SpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(ContainerGroups_Spec_PropertiesARMGenerator())
}

func Test_ContainerGroupIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentityARM, ContainerGroupIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentityARM runs a test to see if a specific instance of ContainerGroupIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentityARM(subject ContainerGroupIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentityARM instances for property testing - lazily instantiated by
// ContainerGroupIdentityARMGenerator()
var containerGroupIdentityARMGenerator gopter.Gen

// ContainerGroupIdentityARMGenerator returns a generator of ContainerGroupIdentityARM instances for property testing.
func ContainerGroupIdentityARMGenerator() gopter.Gen {
	if containerGroupIdentityARMGenerator != nil {
		return containerGroupIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityARM(generators)
	containerGroupIdentityARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentityARM{}), generators)

	return containerGroupIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentity_Type_None,
		ContainerGroupIdentity_Type_SystemAssigned,
		ContainerGroupIdentity_Type_SystemAssignedUserAssigned,
		ContainerGroupIdentity_Type_UserAssigned))
}

func Test_ContainerGroups_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroups_Spec_PropertiesARM, ContainerGroups_Spec_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroups_Spec_PropertiesARM runs a test to see if a specific instance of ContainerGroups_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroups_Spec_PropertiesARM(subject ContainerGroups_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_PropertiesARM instances for property testing - lazily instantiated by
// ContainerGroups_Spec_PropertiesARMGenerator()
var containerGroups_Spec_PropertiesARMGenerator gopter.Gen

// ContainerGroups_Spec_PropertiesARMGenerator returns a generator of ContainerGroups_Spec_PropertiesARM instances for property testing.
// We first initialize containerGroups_Spec_PropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroups_Spec_PropertiesARMGenerator() gopter.Gen {
	if containerGroups_Spec_PropertiesARMGenerator != nil {
		return containerGroups_Spec_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_PropertiesARM(generators)
	containerGroups_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_PropertiesARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroups_Spec_PropertiesARM(generators)
	containerGroups_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_PropertiesARM{}), generators)

	return containerGroups_Spec_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroups_Spec_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroups_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroups_Spec_Properties_OsType_Linux, ContainerGroups_Spec_Properties_OsType_Windows))
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroups_Spec_Properties_RestartPolicy_Always, ContainerGroups_Spec_Properties_RestartPolicy_Never, ContainerGroups_Spec_Properties_RestartPolicy_OnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroups_Spec_Properties_Sku_Dedicated, ContainerGroups_Spec_Properties_Sku_Standard))
}

// AddRelatedPropertyGeneratorsForContainerGroups_Spec_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroups_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGroups_Spec_Properties_ContainersARMGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsARMGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationARMGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesARMGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ContainerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator())
	gens["InitContainers"] = gen.SliceOf(ContainerGroups_Spec_Properties_InitContainersARMGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressARMGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdARMGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeARMGenerator())
}

func Test_ContainerGroupDiagnosticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnosticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnosticsARM, ContainerGroupDiagnosticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnosticsARM runs a test to see if a specific instance of ContainerGroupDiagnosticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnosticsARM(subject ContainerGroupDiagnosticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnosticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnosticsARM instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsARMGenerator()
var containerGroupDiagnosticsARMGenerator gopter.Gen

// ContainerGroupDiagnosticsARMGenerator returns a generator of ContainerGroupDiagnosticsARM instances for property testing.
func ContainerGroupDiagnosticsARMGenerator() gopter.Gen {
	if containerGroupDiagnosticsARMGenerator != nil {
		return containerGroupDiagnosticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsARM(generators)
	containerGroupDiagnosticsARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnosticsARM{}), generators)

	return containerGroupDiagnosticsARMGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsARM(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsARMGenerator())
}

func Test_ContainerGroups_Spec_Properties_ContainersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_ContainersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroups_Spec_Properties_ContainersARM, ContainerGroups_Spec_Properties_ContainersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroups_Spec_Properties_ContainersARM runs a test to see if a specific instance of ContainerGroups_Spec_Properties_ContainersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroups_Spec_Properties_ContainersARM(subject ContainerGroups_Spec_Properties_ContainersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_ContainersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_ContainersARM instances for property testing - lazily instantiated by
// ContainerGroups_Spec_Properties_ContainersARMGenerator()
var containerGroups_Spec_Properties_ContainersARMGenerator gopter.Gen

// ContainerGroups_Spec_Properties_ContainersARMGenerator returns a generator of ContainerGroups_Spec_Properties_ContainersARM instances for property testing.
// We first initialize containerGroups_Spec_Properties_ContainersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroups_Spec_Properties_ContainersARMGenerator() gopter.Gen {
	if containerGroups_Spec_Properties_ContainersARMGenerator != nil {
		return containerGroups_Spec_Properties_ContainersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM(generators)
	containerGroups_Spec_Properties_ContainersARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_ContainersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM(generators)
	containerGroups_Spec_Properties_ContainersARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_ContainersARM{}), generators)

	return containerGroups_Spec_Properties_ContainersARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_ContainersARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ContainerPropertiesARMGenerator())
}

func Test_ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM, ContainerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM runs a test to see if a specific instance of ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM(subject ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM instances for property testing - lazily
// instantiated by ContainerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator()
var containerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator gopter.Gen

// ContainerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator returns a generator of ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM instances for property testing.
func ContainerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator() gopter.Gen {
	if containerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator != nil {
		return containerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM(generators)
	containerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM{}), generators)

	return containerGroups_Spec_Properties_ImageRegistryCredentialsARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_ImageRegistryCredentialsARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroups_Spec_Properties_InitContainersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_InitContainersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroups_Spec_Properties_InitContainersARM, ContainerGroups_Spec_Properties_InitContainersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroups_Spec_Properties_InitContainersARM runs a test to see if a specific instance of ContainerGroups_Spec_Properties_InitContainersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroups_Spec_Properties_InitContainersARM(subject ContainerGroups_Spec_Properties_InitContainersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_InitContainersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_InitContainersARM instances for property testing - lazily instantiated
// by ContainerGroups_Spec_Properties_InitContainersARMGenerator()
var containerGroups_Spec_Properties_InitContainersARMGenerator gopter.Gen

// ContainerGroups_Spec_Properties_InitContainersARMGenerator returns a generator of ContainerGroups_Spec_Properties_InitContainersARM instances for property testing.
// We first initialize containerGroups_Spec_Properties_InitContainersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroups_Spec_Properties_InitContainersARMGenerator() gopter.Gen {
	if containerGroups_Spec_Properties_InitContainersARMGenerator != nil {
		return containerGroups_Spec_Properties_InitContainersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM(generators)
	containerGroups_Spec_Properties_InitContainersARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM(generators)
	containerGroups_Spec_Properties_InitContainersARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainersARM{}), generators)

	return containerGroups_Spec_Properties_InitContainersARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroups_Spec_Properties_InitContainersARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InitContainerPropertiesDefinitionARMGenerator())
}

func Test_ContainerGroupSubnetIdARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetIdARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetIdARM, ContainerGroupSubnetIdARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetIdARM runs a test to see if a specific instance of ContainerGroupSubnetIdARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetIdARM(subject ContainerGroupSubnetIdARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetIdARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetIdARM instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdARMGenerator()
var containerGroupSubnetIdARMGenerator gopter.Gen

// ContainerGroupSubnetIdARMGenerator returns a generator of ContainerGroupSubnetIdARM instances for property testing.
func ContainerGroupSubnetIdARMGenerator() gopter.Gen {
	if containerGroupSubnetIdARMGenerator != nil {
		return containerGroupSubnetIdARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetIdARM(generators)
	containerGroupSubnetIdARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetIdARM{}), generators)

	return containerGroupSubnetIdARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetIdARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetIdARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfigurationARM, DnsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfigurationARM runs a test to see if a specific instance of DnsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfigurationARM(subject DnsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfigurationARM instances for property testing - lazily instantiated by
// DnsConfigurationARMGenerator()
var dnsConfigurationARMGenerator gopter.Gen

// DnsConfigurationARMGenerator returns a generator of DnsConfigurationARM instances for property testing.
func DnsConfigurationARMGenerator() gopter.Gen {
	if dnsConfigurationARMGenerator != nil {
		return dnsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfigurationARM(generators)
	dnsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(DnsConfigurationARM{}), generators)

	return dnsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfigurationARM(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesARM, EncryptionPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesARM runs a test to see if a specific instance of EncryptionPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesARM(subject EncryptionPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionPropertiesARM instances for property testing - lazily instantiated by
// EncryptionPropertiesARMGenerator()
var encryptionPropertiesARMGenerator gopter.Gen

// EncryptionPropertiesARMGenerator returns a generator of EncryptionPropertiesARM instances for property testing.
func EncryptionPropertiesARMGenerator() gopter.Gen {
	if encryptionPropertiesARMGenerator != nil {
		return encryptionPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesARM(generators)
	encryptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EncryptionPropertiesARM{}), generators)

	return encryptionPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressARM, IpAddressARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressARM runs a test to see if a specific instance of IpAddressARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressARM(subject IpAddressARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressARM instances for property testing - lazily instantiated by IpAddressARMGenerator()
var ipAddressARMGenerator gopter.Gen

// IpAddressARMGenerator returns a generator of IpAddressARM instances for property testing.
// We first initialize ipAddressARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressARMGenerator() gopter.Gen {
	if ipAddressARMGenerator != nil {
		return ipAddressARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressARM(generators)
	ipAddressARMGenerator = gen.Struct(reflect.TypeOf(IpAddressARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressARM(generators)
	AddRelatedPropertyGeneratorsForIpAddressARM(generators)
	ipAddressARMGenerator = gen.Struct(reflect.TypeOf(IpAddressARM{}), generators)

	return ipAddressARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressARM(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.OneConstOf(
		IpAddress_DnsNameLabelReusePolicy_Noreuse,
		IpAddress_DnsNameLabelReusePolicy_ResourceGroupReuse,
		IpAddress_DnsNameLabelReusePolicy_SubscriptionReuse,
		IpAddress_DnsNameLabelReusePolicy_TenantReuse,
		IpAddress_DnsNameLabelReusePolicy_Unsecure))
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddress_Type_Private, IpAddress_Type_Public))
}

// AddRelatedPropertyGeneratorsForIpAddressARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddressARM(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortARMGenerator())
}

func Test_VolumeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeARM, VolumeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeARM runs a test to see if a specific instance of VolumeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeARM(subject VolumeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeARM instances for property testing - lazily instantiated by VolumeARMGenerator()
var volumeARMGenerator gopter.Gen

// VolumeARMGenerator returns a generator of VolumeARM instances for property testing.
// We first initialize volumeARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeARMGenerator() gopter.Gen {
	if volumeARMGenerator != nil {
		return volumeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeARM(generators)
	volumeARMGenerator = gen.Struct(reflect.TypeOf(VolumeARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeARM(generators)
	AddRelatedPropertyGeneratorsForVolumeARM(generators)
	volumeARMGenerator = gen.Struct(reflect.TypeOf(VolumeARM{}), generators)

	return volumeARMGenerator
}

// AddIndependentPropertyGeneratorsForVolumeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolumeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolumeARM(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeARMGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeARMGenerator())
}

func Test_AzureFileVolumeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolumeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolumeARM, AzureFileVolumeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolumeARM runs a test to see if a specific instance of AzureFileVolumeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolumeARM(subject AzureFileVolumeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolumeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolumeARM instances for property testing - lazily instantiated by AzureFileVolumeARMGenerator()
var azureFileVolumeARMGenerator gopter.Gen

// AzureFileVolumeARMGenerator returns a generator of AzureFileVolumeARM instances for property testing.
func AzureFileVolumeARMGenerator() gopter.Gen {
	if azureFileVolumeARMGenerator != nil {
		return azureFileVolumeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolumeARM(generators)
	azureFileVolumeARMGenerator = gen.Struct(reflect.TypeOf(AzureFileVolumeARM{}), generators)

	return azureFileVolumeARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolumeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolumeARM(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPropertiesARM, ContainerPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPropertiesARM runs a test to see if a specific instance of ContainerPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPropertiesARM(subject ContainerPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPropertiesARM instances for property testing - lazily instantiated by
// ContainerPropertiesARMGenerator()
var containerPropertiesARMGenerator gopter.Gen

// ContainerPropertiesARMGenerator returns a generator of ContainerPropertiesARM instances for property testing.
// We first initialize containerPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerPropertiesARMGenerator() gopter.Gen {
	if containerPropertiesARMGenerator != nil {
		return containerPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesARM(generators)
	containerPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ContainerPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForContainerPropertiesARM(generators)
	containerPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ContainerPropertiesARM{}), generators)

	return containerPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPropertiesARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerPropertiesARM(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableARMGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeARMGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortARMGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeARMGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsARMGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountARMGenerator())
}

func Test_GitRepoVolumeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolumeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolumeARM, GitRepoVolumeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolumeARM runs a test to see if a specific instance of GitRepoVolumeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolumeARM(subject GitRepoVolumeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolumeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolumeARM instances for property testing - lazily instantiated by GitRepoVolumeARMGenerator()
var gitRepoVolumeARMGenerator gopter.Gen

// GitRepoVolumeARMGenerator returns a generator of GitRepoVolumeARM instances for property testing.
func GitRepoVolumeARMGenerator() gopter.Gen {
	if gitRepoVolumeARMGenerator != nil {
		return gitRepoVolumeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolumeARM(generators)
	gitRepoVolumeARMGenerator = gen.Struct(reflect.TypeOf(GitRepoVolumeARM{}), generators)

	return gitRepoVolumeARMGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolumeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolumeARM(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinitionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinitionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinitionARM, InitContainerPropertiesDefinitionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinitionARM runs a test to see if a specific instance of InitContainerPropertiesDefinitionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinitionARM(subject InitContainerPropertiesDefinitionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinitionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinitionARM instances for property testing - lazily instantiated by
// InitContainerPropertiesDefinitionARMGenerator()
var initContainerPropertiesDefinitionARMGenerator gopter.Gen

// InitContainerPropertiesDefinitionARMGenerator returns a generator of InitContainerPropertiesDefinitionARM instances for property testing.
// We first initialize initContainerPropertiesDefinitionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinitionARMGenerator() gopter.Gen {
	if initContainerPropertiesDefinitionARMGenerator != nil {
		return initContainerPropertiesDefinitionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionARM(generators)
	initContainerPropertiesDefinitionARMGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinitionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionARM(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionARM(generators)
	initContainerPropertiesDefinitionARMGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinitionARM{}), generators)

	return initContainerPropertiesDefinitionARMGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionARM(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableARMGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountARMGenerator())
}

func Test_LogAnalyticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsARM, LogAnalyticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsARM runs a test to see if a specific instance of LogAnalyticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsARM(subject LogAnalyticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsARM instances for property testing - lazily instantiated by LogAnalyticsARMGenerator()
var logAnalyticsARMGenerator gopter.Gen

// LogAnalyticsARMGenerator returns a generator of LogAnalyticsARM instances for property testing.
func LogAnalyticsARMGenerator() gopter.Gen {
	if logAnalyticsARMGenerator != nil {
		return logAnalyticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsARM(generators)
	logAnalyticsARMGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsARM{}), generators)

	return logAnalyticsARMGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsARM(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalytics_LogType_ContainerInsights, LogAnalytics_LogType_ContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_PortARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PortARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortARM, PortARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortARM runs a test to see if a specific instance of PortARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPortARM(subject PortARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PortARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PortARM instances for property testing - lazily instantiated by PortARMGenerator()
var portARMGenerator gopter.Gen

// PortARMGenerator returns a generator of PortARM instances for property testing.
func PortARMGenerator() gopter.Gen {
	if portARMGenerator != nil {
		return portARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortARM(generators)
	portARMGenerator = gen.Struct(reflect.TypeOf(PortARM{}), generators)

	return portARMGenerator
}

// AddIndependentPropertyGeneratorsForPortARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortARM(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(Port_Protocol_TCP, Port_Protocol_UDP))
}

func Test_ContainerPortARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPortARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPortARM, ContainerPortARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPortARM runs a test to see if a specific instance of ContainerPortARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPortARM(subject ContainerPortARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPortARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPortARM instances for property testing - lazily instantiated by ContainerPortARMGenerator()
var containerPortARMGenerator gopter.Gen

// ContainerPortARMGenerator returns a generator of ContainerPortARM instances for property testing.
func ContainerPortARMGenerator() gopter.Gen {
	if containerPortARMGenerator != nil {
		return containerPortARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPortARM(generators)
	containerPortARMGenerator = gen.Struct(reflect.TypeOf(ContainerPortARM{}), generators)

	return containerPortARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerPortARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPortARM(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPort_Protocol_TCP, ContainerPort_Protocol_UDP))
}

func Test_ContainerProbeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbeARM, ContainerProbeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbeARM runs a test to see if a specific instance of ContainerProbeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbeARM(subject ContainerProbeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbeARM instances for property testing - lazily instantiated by ContainerProbeARMGenerator()
var containerProbeARMGenerator gopter.Gen

// ContainerProbeARMGenerator returns a generator of ContainerProbeARM instances for property testing.
// We first initialize containerProbeARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeARMGenerator() gopter.Gen {
	if containerProbeARMGenerator != nil {
		return containerProbeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeARM(generators)
	containerProbeARMGenerator = gen.Struct(reflect.TypeOf(ContainerProbeARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeARM(generators)
	AddRelatedPropertyGeneratorsForContainerProbeARM(generators)
	containerProbeARMGenerator = gen.Struct(reflect.TypeOf(ContainerProbeARM{}), generators)

	return containerProbeARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbeARM(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbeARM(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecARMGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetARMGenerator())
}

func Test_EnvironmentVariableARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariableARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariableARM, EnvironmentVariableARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariableARM runs a test to see if a specific instance of EnvironmentVariableARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariableARM(subject EnvironmentVariableARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariableARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariableARM instances for property testing - lazily instantiated by
// EnvironmentVariableARMGenerator()
var environmentVariableARMGenerator gopter.Gen

// EnvironmentVariableARMGenerator returns a generator of EnvironmentVariableARM instances for property testing.
func EnvironmentVariableARMGenerator() gopter.Gen {
	if environmentVariableARMGenerator != nil {
		return environmentVariableARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariableARM(generators)
	environmentVariableARMGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariableARM{}), generators)

	return environmentVariableARMGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariableARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariableARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceRequirementsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirementsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirementsARM, ResourceRequirementsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirementsARM runs a test to see if a specific instance of ResourceRequirementsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirementsARM(subject ResourceRequirementsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirementsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirementsARM instances for property testing - lazily instantiated by
// ResourceRequirementsARMGenerator()
var resourceRequirementsARMGenerator gopter.Gen

// ResourceRequirementsARMGenerator returns a generator of ResourceRequirementsARM instances for property testing.
func ResourceRequirementsARMGenerator() gopter.Gen {
	if resourceRequirementsARMGenerator != nil {
		return resourceRequirementsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirementsARM(generators)
	resourceRequirementsARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequirementsARM{}), generators)

	return resourceRequirementsARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirementsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirementsARM(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsARMGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsARMGenerator())
}

func Test_VolumeMountARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMountARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMountARM, VolumeMountARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMountARM runs a test to see if a specific instance of VolumeMountARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMountARM(subject VolumeMountARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMountARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMountARM instances for property testing - lazily instantiated by VolumeMountARMGenerator()
var volumeMountARMGenerator gopter.Gen

// VolumeMountARMGenerator returns a generator of VolumeMountARM instances for property testing.
func VolumeMountARMGenerator() gopter.Gen {
	if volumeMountARMGenerator != nil {
		return volumeMountARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMountARM(generators)
	volumeMountARMGenerator = gen.Struct(reflect.TypeOf(VolumeMountARM{}), generators)

	return volumeMountARMGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMountARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMountARM(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExecARM, ContainerExecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExecARM runs a test to see if a specific instance of ContainerExecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExecARM(subject ContainerExecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExecARM instances for property testing - lazily instantiated by ContainerExecARMGenerator()
var containerExecARMGenerator gopter.Gen

// ContainerExecARMGenerator returns a generator of ContainerExecARM instances for property testing.
func ContainerExecARMGenerator() gopter.Gen {
	if containerExecARMGenerator != nil {
		return containerExecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExecARM(generators)
	containerExecARMGenerator = gen.Struct(reflect.TypeOf(ContainerExecARM{}), generators)

	return containerExecARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerExecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExecARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGetARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGetARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGetARM, ContainerHttpGetARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGetARM runs a test to see if a specific instance of ContainerHttpGetARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGetARM(subject ContainerHttpGetARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGetARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGetARM instances for property testing - lazily instantiated by
// ContainerHttpGetARMGenerator()
var containerHttpGetARMGenerator gopter.Gen

// ContainerHttpGetARMGenerator returns a generator of ContainerHttpGetARM instances for property testing.
// We first initialize containerHttpGetARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetARMGenerator() gopter.Gen {
	if containerHttpGetARMGenerator != nil {
		return containerHttpGetARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetARM(generators)
	containerHttpGetARMGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGetARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetARM(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGetARM(generators)
	containerHttpGetARMGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGetARM{}), generators)

	return containerHttpGetARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGetARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGetARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGet_Scheme_Http, ContainerHttpGet_Scheme_Https))
}

// AddRelatedPropertyGeneratorsForContainerHttpGetARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGetARM(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderARMGenerator())
}

func Test_ResourceLimitsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimitsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimitsARM, ResourceLimitsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimitsARM runs a test to see if a specific instance of ResourceLimitsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimitsARM(subject ResourceLimitsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimitsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimitsARM instances for property testing - lazily instantiated by ResourceLimitsARMGenerator()
var resourceLimitsARMGenerator gopter.Gen

// ResourceLimitsARMGenerator returns a generator of ResourceLimitsARM instances for property testing.
// We first initialize resourceLimitsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsARMGenerator() gopter.Gen {
	if resourceLimitsARMGenerator != nil {
		return resourceLimitsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsARM(generators)
	resourceLimitsARMGenerator = gen.Struct(reflect.TypeOf(ResourceLimitsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsARM(generators)
	AddRelatedPropertyGeneratorsForResourceLimitsARM(generators)
	resourceLimitsARMGenerator = gen.Struct(reflect.TypeOf(ResourceLimitsARM{}), generators)

	return resourceLimitsARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimitsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimitsARM(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimitsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimitsARM(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceARMGenerator())
}

func Test_ResourceRequestsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequestsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequestsARM, ResourceRequestsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequestsARM runs a test to see if a specific instance of ResourceRequestsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequestsARM(subject ResourceRequestsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequestsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequestsARM instances for property testing - lazily instantiated by
// ResourceRequestsARMGenerator()
var resourceRequestsARMGenerator gopter.Gen

// ResourceRequestsARMGenerator returns a generator of ResourceRequestsARM instances for property testing.
// We first initialize resourceRequestsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsARMGenerator() gopter.Gen {
	if resourceRequestsARMGenerator != nil {
		return resourceRequestsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsARM(generators)
	resourceRequestsARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequestsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsARM(generators)
	AddRelatedPropertyGeneratorsForResourceRequestsARM(generators)
	resourceRequestsARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequestsARM{}), generators)

	return resourceRequestsARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequestsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequestsARM(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequestsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequestsARM(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceARMGenerator())
}

func Test_GpuResourceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResourceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResourceARM, GpuResourceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResourceARM runs a test to see if a specific instance of GpuResourceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResourceARM(subject GpuResourceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResourceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResourceARM instances for property testing - lazily instantiated by GpuResourceARMGenerator()
var gpuResourceARMGenerator gopter.Gen

// GpuResourceARMGenerator returns a generator of GpuResourceARM instances for property testing.
func GpuResourceARMGenerator() gopter.Gen {
	if gpuResourceARMGenerator != nil {
		return gpuResourceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResourceARM(generators)
	gpuResourceARMGenerator = gen.Struct(reflect.TypeOf(GpuResourceARM{}), generators)

	return gpuResourceARMGenerator
}

// AddIndependentPropertyGeneratorsForGpuResourceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResourceARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResource_Sku_K80, GpuResource_Sku_P100, GpuResource_Sku_V100))
}

func Test_HttpHeaderARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeaderARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeaderARM, HttpHeaderARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeaderARM runs a test to see if a specific instance of HttpHeaderARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeaderARM(subject HttpHeaderARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeaderARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeaderARM instances for property testing - lazily instantiated by HttpHeaderARMGenerator()
var httpHeaderARMGenerator gopter.Gen

// HttpHeaderARMGenerator returns a generator of HttpHeaderARM instances for property testing.
func HttpHeaderARMGenerator() gopter.Gen {
	if httpHeaderARMGenerator != nil {
		return httpHeaderARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeaderARM(generators)
	httpHeaderARMGenerator = gen.Struct(reflect.TypeOf(HttpHeaderARM{}), generators)

	return httpHeaderARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeaderARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeaderARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
