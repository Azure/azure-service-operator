// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"fmt"
	v20211001s "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1beta20211001storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/resourceDefinitions/containerGroups
type ContainerGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerGroups_Spec  `json:"spec,omitempty"`
	Status            ContainerGroup_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ContainerGroup{}

// GetConditions returns the conditions of the resource
func (group *ContainerGroup) GetConditions() conditions.Conditions {
	return group.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (group *ContainerGroup) SetConditions(conditions conditions.Conditions) {
	group.Status.Conditions = conditions
}

var _ conversion.Convertible = &ContainerGroup{}

// ConvertFrom populates our ContainerGroup from the provided hub ContainerGroup
func (group *ContainerGroup) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20211001s.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1beta20211001storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignPropertiesFromContainerGroup(source)
}

// ConvertTo populates the provided hub ContainerGroup from our ContainerGroup
func (group *ContainerGroup) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20211001s.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1beta20211001storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignPropertiesToContainerGroup(destination)
}

// +kubebuilder:webhook:path=/mutate-containerinstance-azure-com-v1beta20211001-containergroup,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1beta20211001,name=default.v1beta20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ContainerGroup{}

// Default applies defaults to the ContainerGroup resource
func (group *ContainerGroup) Default() {
	group.defaultImpl()
	var temp interface{} = group
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (group *ContainerGroup) defaultAzureName() {
	if group.Spec.AzureName == "" {
		group.Spec.AzureName = group.Name
	}
}

// defaultImpl applies the code generated defaults to the ContainerGroup resource
func (group *ContainerGroup) defaultImpl() { group.defaultAzureName() }

var _ genruntime.KubernetesResource = &ContainerGroup{}

// AzureName returns the Azure name of the resource
func (group *ContainerGroup) AzureName() string {
	return group.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-10-01"
func (group ContainerGroup) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (group *ContainerGroup) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (group *ContainerGroup) GetSpec() genruntime.ConvertibleSpec {
	return &group.Spec
}

// GetStatus returns the status of this resource
func (group *ContainerGroup) GetStatus() genruntime.ConvertibleStatus {
	return &group.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerInstance/containerGroups"
func (group *ContainerGroup) GetType() string {
	return "Microsoft.ContainerInstance/containerGroups"
}

// NewEmptyStatus returns a new empty (blank) status
func (group *ContainerGroup) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ContainerGroup_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (group *ContainerGroup) Owner() *genruntime.ResourceReference {
	ownerGroup, ownerKind := genruntime.LookupOwnerGroupKind(group.Spec)
	return &genruntime.ResourceReference{
		Group: ownerGroup,
		Kind:  ownerKind,
		Name:  group.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (group *ContainerGroup) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ContainerGroup_Status); ok {
		group.Status = *st
		return nil
	}

	// Convert status to required version
	var st ContainerGroup_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	group.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-containerinstance-azure-com-v1beta20211001-containergroup,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1beta20211001,name=validate.v1beta20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ContainerGroup{}

// ValidateCreate validates the creation of the resource
func (group *ContainerGroup) ValidateCreate() error {
	validations := group.createValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (group *ContainerGroup) ValidateDelete() error {
	validations := group.deleteValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (group *ContainerGroup) ValidateUpdate(old runtime.Object) error {
	validations := group.updateValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (group *ContainerGroup) createValidations() []func() error {
	return []func() error{group.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (group *ContainerGroup) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (group *ContainerGroup) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return group.validateResourceReferences()
		},
		group.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (group *ContainerGroup) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&group.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (group *ContainerGroup) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*ContainerGroup)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, group)
}

// AssignPropertiesFromContainerGroup populates our ContainerGroup from the provided source ContainerGroup
func (group *ContainerGroup) AssignPropertiesFromContainerGroup(source *v20211001s.ContainerGroup) error {

	// ObjectMeta
	group.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ContainerGroups_Spec
	err := spec.AssignPropertiesFromContainerGroupsSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupsSpec() to populate field Spec")
	}
	group.Spec = spec

	// Status
	var status ContainerGroup_Status
	err = status.AssignPropertiesFromContainerGroupStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupStatus() to populate field Status")
	}
	group.Status = status

	// No error
	return nil
}

// AssignPropertiesToContainerGroup populates the provided destination ContainerGroup from our ContainerGroup
func (group *ContainerGroup) AssignPropertiesToContainerGroup(destination *v20211001s.ContainerGroup) error {

	// ObjectMeta
	destination.ObjectMeta = *group.ObjectMeta.DeepCopy()

	// Spec
	var spec v20211001s.ContainerGroups_Spec
	err := group.Spec.AssignPropertiesToContainerGroupsSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToContainerGroupsSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20211001s.ContainerGroup_Status
	err = group.Status.AssignPropertiesToContainerGroupStatus(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToContainerGroupStatus() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (group *ContainerGroup) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: group.Spec.OriginalVersion(),
		Kind:    "ContainerGroup",
	}
}

// +kubebuilder:object:root=true
// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/resourceDefinitions/containerGroups
type ContainerGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerGroup `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-10-01"}
type APIVersion string

const APIVersionValue = APIVersion("2021-10-01")

type ContainerGroup_Status struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Containers: The containers within the container group.
	Containers []Container_Status `json:"containers,omitempty"`

	// Diagnostics: The diagnostic information for a container group.
	Diagnostics *ContainerGroupDiagnostics_Status `json:"diagnostics,omitempty"`

	// DnsConfig: The DNS config information for a container group.
	DnsConfig *DnsConfiguration_Status `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The encryption properties for a container group.
	EncryptionProperties *EncryptionProperties_Status `json:"encryptionProperties,omitempty"`

	// Id: The resource id.
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the container group, if configured.
	Identity *ContainerGroupIdentity_Status `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ImageRegistryCredential_Status `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []InitContainerDefinition_Status `json:"initContainers,omitempty"`

	// InstanceView: The instance view of the container group. Only valid in response.
	InstanceView *ContainerGroup_Status_Properties_InstanceView `json:"instanceView,omitempty"`

	// IpAddress: The IP address type of the container group.
	IpAddress *IpAddress_Status `json:"ipAddress,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// Name: The resource name.
	Name *string `json:"name,omitempty"`

	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroupStatusPropertiesOsType `json:"osType,omitempty"`

	// ProvisioningState: The provisioning state of the container group. This only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	RestartPolicy *ContainerGroupStatusPropertiesRestartPolicy `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroupSku_Status `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId_Status `json:"subnetIds,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume_Status `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ContainerGroup_Status{}

// ConvertStatusFrom populates our ContainerGroup_Status from the provided source
func (group *ContainerGroup_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20211001s.ContainerGroup_Status)
	if ok {
		// Populate our instance from source
		return group.AssignPropertiesFromContainerGroupStatus(src)
	}

	// Convert to an intermediate form
	src = &v20211001s.ContainerGroup_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = group.AssignPropertiesFromContainerGroupStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ContainerGroup_Status
func (group *ContainerGroup_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20211001s.ContainerGroup_Status)
	if ok {
		// Populate destination from our instance
		return group.AssignPropertiesToContainerGroupStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v20211001s.ContainerGroup_Status{}
	err := group.AssignPropertiesToContainerGroupStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ContainerGroup_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ContainerGroup_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroup_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ContainerGroup_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroup_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroup_StatusARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Containers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 Container_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Containers = append(group.Containers, item1)
		}
	}

	// Set property ‘Diagnostics’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics_Status
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			group.Diagnostics = &diagnostics
		}
	}

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration_Status
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			group.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘EncryptionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties_Status
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			group.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		group.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		group.Identity = &identity
	}

	// Set property ‘ImageRegistryCredentials’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ImageRegistryCredential_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.ImageRegistryCredentials = append(group.ImageRegistryCredentials, item1)
		}
	}

	// Set property ‘InitContainers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 InitContainerDefinition_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.InitContainers = append(group.InitContainers, item1)
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerGroup_Status_Properties_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			group.InstanceView = &instanceView
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress_Status
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			group.IpAddress = &ipAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		group.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			osType := *typedInput.Properties.OsType
			group.OsType = &osType
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			group.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RestartPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			restartPolicy := *typedInput.Properties.RestartPolicy
			group.RestartPolicy = &restartPolicy
		}
	}

	// Set property ‘Sku’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			sku := *typedInput.Properties.Sku
			group.Sku = &sku
		}
	}

	// Set property ‘SubnetIds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.SubnetIds = append(group.SubnetIds, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		group.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			group.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		group.Type = &typeVar
	}

	// Set property ‘Volumes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Volumes = append(group.Volumes, item1)
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		group.Zones = append(group.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupStatus populates our ContainerGroup_Status from the provided source ContainerGroup_Status
func (group *ContainerGroup_Status) AssignPropertiesFromContainerGroupStatus(source *v20211001s.ContainerGroup_Status) error {

	// Conditions
	group.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_Status, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_Status
			err := container.AssignPropertiesFromContainerStatus(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerStatus() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		group.Containers = containerList
	} else {
		group.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics_Status
		err := diagnostic.AssignPropertiesFromContainerGroupDiagnosticsStatus(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupDiagnosticsStatus() to populate field Diagnostics")
		}
		group.Diagnostics = &diagnostic
	} else {
		group.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration_Status
		err := dnsConfig.AssignPropertiesFromDnsConfigurationStatus(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDnsConfigurationStatus() to populate field DnsConfig")
		}
		group.DnsConfig = &dnsConfig
	} else {
		group.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties_Status
		err := encryptionProperty.AssignPropertiesFromEncryptionPropertiesStatus(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEncryptionPropertiesStatus() to populate field EncryptionProperties")
		}
		group.EncryptionProperties = &encryptionProperty
	} else {
		group.EncryptionProperties = nil
	}

	// Id
	group.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity_Status
		err := identity.AssignPropertiesFromContainerGroupIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupIdentityStatus() to populate field Identity")
		}
		group.Identity = &identity
	} else {
		group.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ImageRegistryCredential_Status, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ImageRegistryCredential_Status
			err := imageRegistryCredential.AssignPropertiesFromImageRegistryCredentialStatus(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromImageRegistryCredentialStatus() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		group.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		group.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]InitContainerDefinition_Status, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer InitContainerDefinition_Status
			err := initContainer.AssignPropertiesFromInitContainerDefinitionStatus(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInitContainerDefinitionStatus() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		group.InitContainers = initContainerList
	} else {
		group.InitContainers = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerGroup_Status_Properties_InstanceView
		err := instanceView.AssignPropertiesFromContainerGroupStatusPropertiesInstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupStatusPropertiesInstanceView() to populate field InstanceView")
		}
		group.InstanceView = &instanceView
	} else {
		group.InstanceView = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress_Status
		err := ipAddress.AssignPropertiesFromIpAddressStatus(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromIpAddressStatus() to populate field IpAddress")
		}
		group.IpAddress = &ipAddress
	} else {
		group.IpAddress = nil
	}

	// Location
	group.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := ContainerGroupStatusPropertiesOsType(*source.OsType)
		group.OsType = &osType
	} else {
		group.OsType = nil
	}

	// ProvisioningState
	group.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := ContainerGroupStatusPropertiesRestartPolicy(*source.RestartPolicy)
		group.RestartPolicy = &restartPolicy
	} else {
		group.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := ContainerGroupSku_Status(*source.Sku)
		group.Sku = &sku
	} else {
		group.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId_Status, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId_Status
			err := subnetId.AssignPropertiesFromContainerGroupSubnetIdStatus(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupSubnetIdStatus() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		group.SubnetIds = subnetIdList
	} else {
		group.SubnetIds = nil
	}

	// Tags
	group.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	group.Type = genruntime.ClonePointerToString(source.Type)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_Status, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_Status
			err := volume.AssignPropertiesFromVolumeStatus(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolumeStatus() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		group.Volumes = volumeList
	} else {
		group.Volumes = nil
	}

	// Zones
	group.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupStatus populates the provided destination ContainerGroup_Status from our ContainerGroup_Status
func (group *ContainerGroup_Status) AssignPropertiesToContainerGroupStatus(destination *v20211001s.ContainerGroup_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(group.Conditions)

	// Containers
	if group.Containers != nil {
		containerList := make([]v20211001s.Container_Status, len(group.Containers))
		for containerIndex, containerItem := range group.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container v20211001s.Container_Status
			err := containerItem.AssignPropertiesToContainerStatus(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerStatus() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if group.Diagnostics != nil {
		var diagnostic v20211001s.ContainerGroupDiagnostics_Status
		err := group.Diagnostics.AssignPropertiesToContainerGroupDiagnosticsStatus(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerGroupDiagnosticsStatus() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if group.DnsConfig != nil {
		var dnsConfig v20211001s.DnsConfiguration_Status
		err := group.DnsConfig.AssignPropertiesToDnsConfigurationStatus(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDnsConfigurationStatus() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if group.EncryptionProperties != nil {
		var encryptionProperty v20211001s.EncryptionProperties_Status
		err := group.EncryptionProperties.AssignPropertiesToEncryptionPropertiesStatus(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEncryptionPropertiesStatus() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(group.Id)

	// Identity
	if group.Identity != nil {
		var identity v20211001s.ContainerGroupIdentity_Status
		err := group.Identity.AssignPropertiesToContainerGroupIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerGroupIdentityStatus() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if group.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]v20211001s.ImageRegistryCredential_Status, len(group.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range group.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential v20211001s.ImageRegistryCredential_Status
			err := imageRegistryCredentialItem.AssignPropertiesToImageRegistryCredentialStatus(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToImageRegistryCredentialStatus() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if group.InitContainers != nil {
		initContainerList := make([]v20211001s.InitContainerDefinition_Status, len(group.InitContainers))
		for initContainerIndex, initContainerItem := range group.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer v20211001s.InitContainerDefinition_Status
			err := initContainerItem.AssignPropertiesToInitContainerDefinitionStatus(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInitContainerDefinitionStatus() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// InstanceView
	if group.InstanceView != nil {
		var instanceView v20211001s.ContainerGroup_Status_Properties_InstanceView
		err := group.InstanceView.AssignPropertiesToContainerGroupStatusPropertiesInstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerGroupStatusPropertiesInstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// IpAddress
	if group.IpAddress != nil {
		var ipAddress v20211001s.IpAddress_Status
		err := group.IpAddress.AssignPropertiesToIpAddressStatus(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToIpAddressStatus() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(group.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// OsType
	if group.OsType != nil {
		osType := string(*group.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(group.ProvisioningState)

	// RestartPolicy
	if group.RestartPolicy != nil {
		restartPolicy := string(*group.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if group.Sku != nil {
		sku := string(*group.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if group.SubnetIds != nil {
		subnetIdList := make([]v20211001s.ContainerGroupSubnetId_Status, len(group.SubnetIds))
		for subnetIdIndex, subnetIdItem := range group.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId v20211001s.ContainerGroupSubnetId_Status
			err := subnetIdItem.AssignPropertiesToContainerGroupSubnetIdStatus(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupSubnetIdStatus() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(group.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(group.Type)

	// Volumes
	if group.Volumes != nil {
		volumeList := make([]v20211001s.Volume_Status, len(group.Volumes))
		for volumeIndex, volumeItem := range group.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume v20211001s.Volume_Status
			err := volumeItem.AssignPropertiesToVolumeStatus(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolumeStatus() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(group.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Containers: The containers within the container group.
	Containers []ContainerGroups_Spec_Properties_Containers `json:"containers,omitempty"`

	// Diagnostics: Container group diagnostic information.
	Diagnostics *ContainerGroupDiagnostics `json:"diagnostics,omitempty"`

	// DnsConfig: DNS configuration for the container group.
	DnsConfig *DnsConfiguration `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The container group encryption properties.
	EncryptionProperties *EncryptionProperties `json:"encryptionProperties,omitempty"`

	// Identity: Identity for the container group.
	Identity *ContainerGroupIdentity `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ContainerGroups_Spec_Properties_ImageRegistryCredentials `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []ContainerGroups_Spec_Properties_InitContainers `json:"initContainers,omitempty"`

	// IpAddress: IP address for the container group.
	IpAddress *IpAddress `json:"ipAddress,omitempty"`

	// Location: Location to deploy resource to
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroupsSpecPropertiesOsType `json:"osType,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	// .
	RestartPolicy *ContainerGroupsSpecPropertiesRestartPolicy `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroupsSpecPropertiesSku `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId `json:"subnetIds,omitempty"`

	// Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (groups *ContainerGroups_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if groups == nil {
		return nil, nil
	}
	result := &ContainerGroups_SpecARM{}

	// Set property ‘Identity’:
	if groups.Identity != nil {
		identityARM, err := (*groups.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identityARM.(*ContainerGroupIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if groups.Location != nil {
		location := *groups.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if groups.Containers != nil ||
		groups.Diagnostics != nil ||
		groups.DnsConfig != nil ||
		groups.EncryptionProperties != nil ||
		groups.ImageRegistryCredentials != nil ||
		groups.InitContainers != nil ||
		groups.IpAddress != nil ||
		groups.OsType != nil ||
		groups.RestartPolicy != nil ||
		groups.Sku != nil ||
		groups.SubnetIds != nil ||
		groups.Volumes != nil {
		result.Properties = &ContainerGroups_Spec_PropertiesARM{}
	}
	for _, item := range groups.Containers {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Containers = append(result.Properties.Containers, *itemARM.(*ContainerGroups_Spec_Properties_ContainersARM))
	}
	if groups.Diagnostics != nil {
		diagnosticsARM, err := (*groups.Diagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnostics := *diagnosticsARM.(*ContainerGroupDiagnosticsARM)
		result.Properties.Diagnostics = &diagnostics
	}
	if groups.DnsConfig != nil {
		dnsConfigARM, err := (*groups.DnsConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfigARM.(*DnsConfigurationARM)
		result.Properties.DnsConfig = &dnsConfig
	}
	if groups.EncryptionProperties != nil {
		encryptionPropertiesARM, err := (*groups.EncryptionProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionProperties := *encryptionPropertiesARM.(*EncryptionPropertiesARM)
		result.Properties.EncryptionProperties = &encryptionProperties
	}
	for _, item := range groups.ImageRegistryCredentials {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ImageRegistryCredentials = append(result.Properties.ImageRegistryCredentials, *itemARM.(*ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM))
	}
	for _, item := range groups.InitContainers {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InitContainers = append(result.Properties.InitContainers, *itemARM.(*ContainerGroups_Spec_Properties_InitContainersARM))
	}
	if groups.IpAddress != nil {
		ipAddressARM, err := (*groups.IpAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ipAddress := *ipAddressARM.(*IpAddressARM)
		result.Properties.IpAddress = &ipAddress
	}
	if groups.OsType != nil {
		osType := *groups.OsType
		result.Properties.OsType = &osType
	}
	if groups.RestartPolicy != nil {
		restartPolicy := *groups.RestartPolicy
		result.Properties.RestartPolicy = &restartPolicy
	}
	if groups.Sku != nil {
		sku := *groups.Sku
		result.Properties.Sku = &sku
	}
	for _, item := range groups.SubnetIds {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SubnetIds = append(result.Properties.SubnetIds, *itemARM.(*ContainerGroupSubnetIdARM))
	}
	for _, item := range groups.Volumes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Volumes = append(result.Properties.Volumes, *itemARM.(*VolumeARM))
	}

	// Set property ‘Tags’:
	if groups.Tags != nil {
		result.Tags = make(map[string]string, len(groups.Tags))
		for key, value := range groups.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range groups.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (groups *ContainerGroups_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (groups *ContainerGroups_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	groups.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Containers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 ContainerGroups_Spec_Properties_Containers
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.Containers = append(groups.Containers, item1)
		}
	}

	// Set property ‘Diagnostics’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			groups.Diagnostics = &diagnostics
		}
	}

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			groups.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘EncryptionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			groups.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		groups.Identity = &identity
	}

	// Set property ‘ImageRegistryCredentials’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.ImageRegistryCredentials = append(groups.ImageRegistryCredentials, item1)
		}
	}

	// Set property ‘InitContainers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 ContainerGroups_Spec_Properties_InitContainers
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.InitContainers = append(groups.InitContainers, item1)
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			groups.IpAddress = &ipAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		groups.Location = &location
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			osType := *typedInput.Properties.OsType
			groups.OsType = &osType
		}
	}

	// Set property ‘Owner’:
	groups.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘RestartPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			restartPolicy := *typedInput.Properties.RestartPolicy
			groups.RestartPolicy = &restartPolicy
		}
	}

	// Set property ‘Sku’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			sku := *typedInput.Properties.Sku
			groups.Sku = &sku
		}
	}

	// Set property ‘SubnetIds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.SubnetIds = append(groups.SubnetIds, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		groups.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			groups.Tags[key] = value
		}
	}

	// Set property ‘Volumes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.Volumes = append(groups.Volumes, item1)
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		groups.Zones = append(groups.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ContainerGroups_Spec{}

// ConvertSpecFrom populates our ContainerGroups_Spec from the provided source
func (groups *ContainerGroups_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20211001s.ContainerGroups_Spec)
	if ok {
		// Populate our instance from source
		return groups.AssignPropertiesFromContainerGroupsSpec(src)
	}

	// Convert to an intermediate form
	src = &v20211001s.ContainerGroups_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = groups.AssignPropertiesFromContainerGroupsSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ContainerGroups_Spec
func (groups *ContainerGroups_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20211001s.ContainerGroups_Spec)
	if ok {
		// Populate destination from our instance
		return groups.AssignPropertiesToContainerGroupsSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v20211001s.ContainerGroups_Spec{}
	err := groups.AssignPropertiesToContainerGroupsSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromContainerGroupsSpec populates our ContainerGroups_Spec from the provided source ContainerGroups_Spec
func (groups *ContainerGroups_Spec) AssignPropertiesFromContainerGroupsSpec(source *v20211001s.ContainerGroups_Spec) error {

	// AzureName
	groups.AzureName = source.AzureName

	// Containers
	if source.Containers != nil {
		containerList := make([]ContainerGroups_Spec_Properties_Containers, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container ContainerGroups_Spec_Properties_Containers
			err := container.AssignPropertiesFromContainerGroupsSpecPropertiesContainers(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupsSpecPropertiesContainers() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		groups.Containers = containerList
	} else {
		groups.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics
		err := diagnostic.AssignPropertiesFromContainerGroupDiagnostics(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupDiagnostics() to populate field Diagnostics")
		}
		groups.Diagnostics = &diagnostic
	} else {
		groups.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration
		err := dnsConfig.AssignPropertiesFromDnsConfiguration(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDnsConfiguration() to populate field DnsConfig")
		}
		groups.DnsConfig = &dnsConfig
	} else {
		groups.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties
		err := encryptionProperty.AssignPropertiesFromEncryptionProperties(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEncryptionProperties() to populate field EncryptionProperties")
		}
		groups.EncryptionProperties = &encryptionProperty
	} else {
		groups.EncryptionProperties = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity
		err := identity.AssignPropertiesFromContainerGroupIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupIdentity() to populate field Identity")
		}
		groups.Identity = &identity
	} else {
		groups.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ContainerGroups_Spec_Properties_ImageRegistryCredentials, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := imageRegistryCredential.AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		groups.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		groups.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]ContainerGroups_Spec_Properties_InitContainers, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer ContainerGroups_Spec_Properties_InitContainers
			err := initContainer.AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		groups.InitContainers = initContainerList
	} else {
		groups.InitContainers = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress
		err := ipAddress.AssignPropertiesFromIpAddress(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromIpAddress() to populate field IpAddress")
		}
		groups.IpAddress = &ipAddress
	} else {
		groups.IpAddress = nil
	}

	// Location
	groups.Location = genruntime.ClonePointerToString(source.Location)

	// OsType
	if source.OsType != nil {
		osType := ContainerGroupsSpecPropertiesOsType(*source.OsType)
		groups.OsType = &osType
	} else {
		groups.OsType = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		groups.Owner = &owner
	} else {
		groups.Owner = nil
	}

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := ContainerGroupsSpecPropertiesRestartPolicy(*source.RestartPolicy)
		groups.RestartPolicy = &restartPolicy
	} else {
		groups.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := ContainerGroupsSpecPropertiesSku(*source.Sku)
		groups.Sku = &sku
	} else {
		groups.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId
			err := subnetId.AssignPropertiesFromContainerGroupSubnetId(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		groups.SubnetIds = subnetIdList
	} else {
		groups.SubnetIds = nil
	}

	// Tags
	groups.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignPropertiesFromVolume(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		groups.Volumes = volumeList
	} else {
		groups.Volumes = nil
	}

	// Zones
	groups.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupsSpec populates the provided destination ContainerGroups_Spec from our ContainerGroups_Spec
func (groups *ContainerGroups_Spec) AssignPropertiesToContainerGroupsSpec(destination *v20211001s.ContainerGroups_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = groups.AzureName

	// Containers
	if groups.Containers != nil {
		containerList := make([]v20211001s.ContainerGroups_Spec_Properties_Containers, len(groups.Containers))
		for containerIndex, containerItem := range groups.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container v20211001s.ContainerGroups_Spec_Properties_Containers
			err := containerItem.AssignPropertiesToContainerGroupsSpecPropertiesContainers(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupsSpecPropertiesContainers() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if groups.Diagnostics != nil {
		var diagnostic v20211001s.ContainerGroupDiagnostics
		err := groups.Diagnostics.AssignPropertiesToContainerGroupDiagnostics(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerGroupDiagnostics() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if groups.DnsConfig != nil {
		var dnsConfig v20211001s.DnsConfiguration
		err := groups.DnsConfig.AssignPropertiesToDnsConfiguration(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDnsConfiguration() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if groups.EncryptionProperties != nil {
		var encryptionProperty v20211001s.EncryptionProperties
		err := groups.EncryptionProperties.AssignPropertiesToEncryptionProperties(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEncryptionProperties() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Identity
	if groups.Identity != nil {
		var identity v20211001s.ContainerGroupIdentity
		err := groups.Identity.AssignPropertiesToContainerGroupIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerGroupIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if groups.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials, len(groups.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range groups.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := imageRegistryCredentialItem.AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if groups.InitContainers != nil {
		initContainerList := make([]v20211001s.ContainerGroups_Spec_Properties_InitContainers, len(groups.InitContainers))
		for initContainerIndex, initContainerItem := range groups.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer v20211001s.ContainerGroups_Spec_Properties_InitContainers
			err := initContainerItem.AssignPropertiesToContainerGroupsSpecPropertiesInitContainers(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupsSpecPropertiesInitContainers() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// IpAddress
	if groups.IpAddress != nil {
		var ipAddress v20211001s.IpAddress
		err := groups.IpAddress.AssignPropertiesToIpAddress(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToIpAddress() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(groups.Location)

	// OriginalVersion
	destination.OriginalVersion = groups.OriginalVersion()

	// OsType
	if groups.OsType != nil {
		osType := string(*groups.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Owner
	if groups.Owner != nil {
		owner := groups.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RestartPolicy
	if groups.RestartPolicy != nil {
		restartPolicy := string(*groups.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if groups.Sku != nil {
		sku := string(*groups.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if groups.SubnetIds != nil {
		subnetIdList := make([]v20211001s.ContainerGroupSubnetId, len(groups.SubnetIds))
		for subnetIdIndex, subnetIdItem := range groups.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId v20211001s.ContainerGroupSubnetId
			err := subnetIdItem.AssignPropertiesToContainerGroupSubnetId(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(groups.Tags)

	// Volumes
	if groups.Volumes != nil {
		volumeList := make([]v20211001s.Volume, len(groups.Volumes))
		for volumeIndex, volumeItem := range groups.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume v20211001s.Volume
			err := volumeItem.AssignPropertiesToVolume(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(groups.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (groups *ContainerGroups_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (groups *ContainerGroups_Spec) SetAzureName(azureName string) { groups.AzureName = azureName }

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupDiagnostics
type ContainerGroupDiagnostics struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics `json:"logAnalytics,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnostics *ContainerGroupDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnostics == nil {
		return nil, nil
	}
	result := &ContainerGroupDiagnosticsARM{}

	// Set property ‘LogAnalytics’:
	if diagnostics.LogAnalytics != nil {
		logAnalyticsARM, err := (*diagnostics.LogAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logAnalytics := *logAnalyticsARM.(*LogAnalyticsARM)
		result.LogAnalytics = &logAnalytics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupDiagnosticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupDiagnosticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupDiagnosticsARM, got %T", armInput)
	}

	// Set property ‘LogAnalytics’:
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupDiagnostics populates our ContainerGroupDiagnostics from the provided source ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignPropertiesFromContainerGroupDiagnostics(source *v20211001s.ContainerGroupDiagnostics) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics
		err := logAnalytic.AssignPropertiesFromLogAnalytics(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLogAnalytics() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupDiagnostics populates the provided destination ContainerGroupDiagnostics from our ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignPropertiesToContainerGroupDiagnostics(destination *v20211001s.ContainerGroupDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic v20211001s.LogAnalytics
		err := diagnostics.LogAnalytics.AssignPropertiesToLogAnalytics(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLogAnalytics() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupDiagnostics_Status struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics_Status `json:"logAnalytics,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupDiagnostics_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupDiagnostics_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupDiagnostics_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupDiagnostics_StatusARM, got %T", armInput)
	}

	// Set property ‘LogAnalytics’:
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics_Status
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupDiagnosticsStatus populates our ContainerGroupDiagnostics_Status from the provided source ContainerGroupDiagnostics_Status
func (diagnostics *ContainerGroupDiagnostics_Status) AssignPropertiesFromContainerGroupDiagnosticsStatus(source *v20211001s.ContainerGroupDiagnostics_Status) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics_Status
		err := logAnalytic.AssignPropertiesFromLogAnalyticsStatus(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLogAnalyticsStatus() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupDiagnosticsStatus populates the provided destination ContainerGroupDiagnostics_Status from our ContainerGroupDiagnostics_Status
func (diagnostics *ContainerGroupDiagnostics_Status) AssignPropertiesToContainerGroupDiagnosticsStatus(destination *v20211001s.ContainerGroupDiagnostics_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic v20211001s.LogAnalytics_Status
		err := diagnostics.LogAnalytics.AssignPropertiesToLogAnalyticsStatus(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLogAnalyticsStatus() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupIdentity
type ContainerGroupIdentity struct {
	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentityType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ContainerGroupIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ContainerGroupIdentityARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupIdentity populates our ContainerGroupIdentity from the provided source ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignPropertiesFromContainerGroupIdentity(source *v20211001s.ContainerGroupIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ContainerGroupIdentityType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupIdentity populates the provided destination ContainerGroupIdentity from our ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignPropertiesToContainerGroupIdentity(destination *v20211001s.ContainerGroupIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupIdentity_Status struct {
	// PrincipalId: The principal id of the container group identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the container group. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentityStatusType `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the container group. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ContainerGroupIdentity_Status_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ContainerGroupIdentity_Status_UserAssignedIdentities, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ContainerGroupIdentity_Status_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupIdentityStatus populates our ContainerGroupIdentity_Status from the provided source ContainerGroupIdentity_Status
func (identity *ContainerGroupIdentity_Status) AssignPropertiesFromContainerGroupIdentityStatus(source *v20211001s.ContainerGroupIdentity_Status) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ContainerGroupIdentityStatusType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ContainerGroupIdentity_Status_UserAssignedIdentities, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ContainerGroupIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentity.AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupIdentityStatus populates the provided destination ContainerGroupIdentity_Status from our ContainerGroupIdentity_Status
func (identity *ContainerGroupIdentity_Status) AssignPropertiesToContainerGroupIdentityStatus(destination *v20211001s.ContainerGroupIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20211001s.ContainerGroupIdentity_Status_UserAssignedIdentities, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20211001s.ContainerGroupIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentityValue.AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupSku_Status string

const (
	ContainerGroupSku_StatusDedicated = ContainerGroupSku_Status("Dedicated")
	ContainerGroupSku_StatusStandard  = ContainerGroupSku_Status("Standard")
)

type ContainerGroupStatusPropertiesOsType string

const (
	ContainerGroupStatusPropertiesOsTypeLinux   = ContainerGroupStatusPropertiesOsType("Linux")
	ContainerGroupStatusPropertiesOsTypeWindows = ContainerGroupStatusPropertiesOsType("Windows")
)

type ContainerGroupStatusPropertiesRestartPolicy string

const (
	ContainerGroupStatusPropertiesRestartPolicyAlways    = ContainerGroupStatusPropertiesRestartPolicy("Always")
	ContainerGroupStatusPropertiesRestartPolicyNever     = ContainerGroupStatusPropertiesRestartPolicy("Never")
	ContainerGroupStatusPropertiesRestartPolicyOnFailure = ContainerGroupStatusPropertiesRestartPolicy("OnFailure")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupSubnetId
type ContainerGroupSubnetId struct {
	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Reference: Resource ID of virtual network and subnet.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupSubnetId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subnetId *ContainerGroupSubnetId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subnetId == nil {
		return nil, nil
	}
	result := &ContainerGroupSubnetIdARM{}

	// Set property ‘Id’:
	if subnetId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*subnetId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if subnetId.Name != nil {
		name := *subnetId.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupSubnetIdARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupSubnetIdARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupSubnetIdARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupSubnetId populates our ContainerGroupSubnetId from the provided source ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignPropertiesFromContainerGroupSubnetId(source *v20211001s.ContainerGroupSubnetId) error {

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subnetId.Reference = &reference
	} else {
		subnetId.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupSubnetId populates the provided destination ContainerGroupSubnetId from our ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignPropertiesToContainerGroupSubnetId(destination *v20211001s.ContainerGroupSubnetId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Reference
	if subnetId.Reference != nil {
		reference := subnetId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupSubnetId_Status struct {
	// Id: Resource ID of virtual network and subnet.
	Id *string `json:"id,omitempty"`

	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupSubnetId_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupSubnetId_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupSubnetId_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupSubnetId_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetId.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupSubnetIdStatus populates our ContainerGroupSubnetId_Status from the provided source ContainerGroupSubnetId_Status
func (subnetId *ContainerGroupSubnetId_Status) AssignPropertiesFromContainerGroupSubnetIdStatus(source *v20211001s.ContainerGroupSubnetId_Status) error {

	// Id
	subnetId.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupSubnetIdStatus populates the provided destination ContainerGroupSubnetId_Status from our ContainerGroupSubnetId_Status
func (subnetId *ContainerGroupSubnetId_Status) AssignPropertiesToContainerGroupSubnetIdStatus(destination *v20211001s.ContainerGroupSubnetId_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(subnetId.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroup_Status_Properties_InstanceView struct {
	// Events: The events of this container group.
	Events []Event_Status `json:"events,omitempty"`

	// State: The state of the container group. Only valid in response.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroup_Status_Properties_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerGroup_Status_Properties_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroup_Status_Properties_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerGroup_Status_Properties_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroup_Status_Properties_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroup_Status_Properties_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘State’:
	if typedInput.State != nil {
		state := *typedInput.State
		view.State = &state
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupStatusPropertiesInstanceView populates our ContainerGroup_Status_Properties_InstanceView from the provided source ContainerGroup_Status_Properties_InstanceView
func (view *ContainerGroup_Status_Properties_InstanceView) AssignPropertiesFromContainerGroupStatusPropertiesInstanceView(source *v20211001s.ContainerGroup_Status_Properties_InstanceView) error {

	// Events
	if source.Events != nil {
		eventList := make([]Event_Status, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_Status
			err := event.AssignPropertiesFromEventStatus(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// State
	view.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupStatusPropertiesInstanceView populates the provided destination ContainerGroup_Status_Properties_InstanceView from our ContainerGroup_Status_Properties_InstanceView
func (view *ContainerGroup_Status_Properties_InstanceView) AssignPropertiesToContainerGroupStatusPropertiesInstanceView(destination *v20211001s.ContainerGroup_Status_Properties_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_Status, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_Status
			err := eventItem.AssignPropertiesToEventStatus(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(view.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ContainerGroupsSpecPropertiesOsType string

const (
	ContainerGroupsSpecPropertiesOsTypeLinux   = ContainerGroupsSpecPropertiesOsType("Linux")
	ContainerGroupsSpecPropertiesOsTypeWindows = ContainerGroupsSpecPropertiesOsType("Windows")
)

// +kubebuilder:validation:Enum={"Always","Never","OnFailure"}
type ContainerGroupsSpecPropertiesRestartPolicy string

const (
	ContainerGroupsSpecPropertiesRestartPolicyAlways    = ContainerGroupsSpecPropertiesRestartPolicy("Always")
	ContainerGroupsSpecPropertiesRestartPolicyNever     = ContainerGroupsSpecPropertiesRestartPolicy("Never")
	ContainerGroupsSpecPropertiesRestartPolicyOnFailure = ContainerGroupsSpecPropertiesRestartPolicy("OnFailure")
)

// +kubebuilder:validation:Enum={"Dedicated","Standard"}
type ContainerGroupsSpecPropertiesSku string

const (
	ContainerGroupsSpecPropertiesSkuDedicated = ContainerGroupsSpecPropertiesSku("Dedicated")
	ContainerGroupsSpecPropertiesSkuStandard  = ContainerGroupsSpecPropertiesSku("Standard")
)

type ContainerGroups_Spec_Properties_Containers struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// +kubebuilder:validation:Required
	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// LivenessProbe: The container probe, for liveness or readiness
	LivenessProbe *ContainerProbe `json:"livenessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort `json:"ports,omitempty"`

	// ReadinessProbe: The container probe, for liveness or readiness
	ReadinessProbe *ContainerProbe `json:"readinessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Resources: The resource requirements.
	Resources *ResourceRequirements `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_Containers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containers *ContainerGroups_Spec_Properties_Containers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containers == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_ContainersARM{}

	// Set property ‘Name’:
	if containers.Name != nil {
		name := *containers.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if containers.Command != nil ||
		containers.EnvironmentVariables != nil ||
		containers.Image != nil ||
		containers.LivenessProbe != nil ||
		containers.Ports != nil ||
		containers.ReadinessProbe != nil ||
		containers.Resources != nil ||
		containers.VolumeMounts != nil {
		result.Properties = &ContainerPropertiesARM{}
	}
	for _, item := range containers.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range containers.EnvironmentVariables {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *itemARM.(*EnvironmentVariableARM))
	}
	if containers.Image != nil {
		image := *containers.Image
		result.Properties.Image = &image
	}
	if containers.LivenessProbe != nil {
		livenessProbeARM, err := (*containers.LivenessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		livenessProbe := *livenessProbeARM.(*ContainerProbeARM)
		result.Properties.LivenessProbe = &livenessProbe
	}
	for _, item := range containers.Ports {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Ports = append(result.Properties.Ports, *itemARM.(*ContainerPortARM))
	}
	if containers.ReadinessProbe != nil {
		readinessProbeARM, err := (*containers.ReadinessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		readinessProbe := *readinessProbeARM.(*ContainerProbeARM)
		result.Properties.ReadinessProbe = &readinessProbe
	}
	if containers.Resources != nil {
		resourcesARM, err := (*containers.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resourcesARM.(*ResourceRequirementsARM)
		result.Properties.Resources = &resources
	}
	for _, item := range containers.VolumeMounts {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *itemARM.(*VolumeMountARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containers *ContainerGroups_Spec_Properties_Containers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_ContainersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containers *ContainerGroups_Spec_Properties_Containers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_ContainersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_ContainersARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			containers.Command = append(containers.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.EnvironmentVariables = append(containers.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			containers.Image = &image
		}
	}

	// Set property ‘LivenessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			containers.LivenessProbe = &livenessProbe
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		containers.Name = &name
	}

	// Set property ‘Ports’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.Ports = append(containers.Ports, item1)
		}
	}

	// Set property ‘ReadinessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			containers.ReadinessProbe = &readinessProbe
		}
	}

	// Set property ‘Resources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			containers.Resources = &resources
		}
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.VolumeMounts = append(containers.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupsSpecPropertiesContainers populates our ContainerGroups_Spec_Properties_Containers from the provided source ContainerGroups_Spec_Properties_Containers
func (containers *ContainerGroups_Spec_Properties_Containers) AssignPropertiesFromContainerGroupsSpecPropertiesContainers(source *v20211001s.ContainerGroups_Spec_Properties_Containers) error {

	// Command
	containers.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignPropertiesFromEnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		containers.EnvironmentVariables = environmentVariableList
	} else {
		containers.EnvironmentVariables = nil
	}

	// Image
	containers.Image = genruntime.ClonePointerToString(source.Image)

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe
		err := livenessProbe.AssignPropertiesFromContainerProbe(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerProbe() to populate field LivenessProbe")
		}
		containers.LivenessProbe = &livenessProbe
	} else {
		containers.LivenessProbe = nil
	}

	// Name
	containers.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort
			err := port.AssignPropertiesFromContainerPort(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		containers.Ports = portList
	} else {
		containers.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe
		err := readinessProbe.AssignPropertiesFromContainerProbe(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerProbe() to populate field ReadinessProbe")
		}
		containers.ReadinessProbe = &readinessProbe
	} else {
		containers.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements
		err := resource.AssignPropertiesFromResourceRequirements(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceRequirements() to populate field Resources")
		}
		containers.Resources = &resource
	} else {
		containers.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignPropertiesFromVolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		containers.VolumeMounts = volumeMountList
	} else {
		containers.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupsSpecPropertiesContainers populates the provided destination ContainerGroups_Spec_Properties_Containers from our ContainerGroups_Spec_Properties_Containers
func (containers *ContainerGroups_Spec_Properties_Containers) AssignPropertiesToContainerGroupsSpecPropertiesContainers(destination *v20211001s.ContainerGroups_Spec_Properties_Containers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(containers.Command)

	// EnvironmentVariables
	if containers.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable, len(containers.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range containers.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable
			err := environmentVariableItem.AssignPropertiesToEnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(containers.Image)

	// LivenessProbe
	if containers.LivenessProbe != nil {
		var livenessProbe v20211001s.ContainerProbe
		err := containers.LivenessProbe.AssignPropertiesToContainerProbe(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerProbe() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(containers.Name)

	// Ports
	if containers.Ports != nil {
		portList := make([]v20211001s.ContainerPort, len(containers.Ports))
		for portIndex, portItem := range containers.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.ContainerPort
			err := portItem.AssignPropertiesToContainerPort(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if containers.ReadinessProbe != nil {
		var readinessProbe v20211001s.ContainerProbe
		err := containers.ReadinessProbe.AssignPropertiesToContainerProbe(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerProbe() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if containers.Resources != nil {
		var resource v20211001s.ResourceRequirements
		err := containers.Resources.AssignPropertiesToResourceRequirements(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceRequirements() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if containers.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount, len(containers.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range containers.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount
			err := volumeMountItem.AssignPropertiesToVolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec_Properties_ImageRegistryCredentials struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Password: The password for the private registry.
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// +kubebuilder:validation:Required
	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_ImageRegistryCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM{}

	// Set property ‘Identity’:
	if credentials.Identity != nil {
		identity := *credentials.Identity
		result.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if credentials.IdentityUrl != nil {
		identityUrl := *credentials.IdentityUrl
		result.IdentityUrl = &identityUrl
	}

	// Set property ‘Password’:
	if credentials.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.LookupSecret(*credentials.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property ‘Server’:
	if credentials.Server != nil {
		server := *credentials.Server
		result.Server = &server
	}

	// Set property ‘Username’:
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM, got %T", armInput)
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credentials.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credentials.IdentityUrl = &identityUrl
	}

	// no assignment for property ‘Password’

	// Set property ‘Server’:
	if typedInput.Server != nil {
		server := *typedInput.Server
		credentials.Server = &server
	}

	// Set property ‘Username’:
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials populates our ContainerGroups_Spec_Properties_ImageRegistryCredentials from the provided source ContainerGroups_Spec_Properties_ImageRegistryCredentials
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) AssignPropertiesFromContainerGroupsSpecPropertiesImageRegistryCredentials(source *v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials) error {

	// Identity
	credentials.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credentials.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credentials.Password = &password
	} else {
		credentials.Password = nil
	}

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials populates the provided destination ContainerGroups_Spec_Properties_ImageRegistryCredentials from our ContainerGroups_Spec_Properties_ImageRegistryCredentials
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) AssignPropertiesToContainerGroupsSpecPropertiesImageRegistryCredentials(destination *v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credentials.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credentials.IdentityUrl)

	// Password
	if credentials.Password != nil {
		password := credentials.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec_Properties_InitContainers struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_InitContainers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containers *ContainerGroups_Spec_Properties_InitContainers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containers == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_InitContainersARM{}

	// Set property ‘Name’:
	if containers.Name != nil {
		name := *containers.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if containers.Command != nil ||
		containers.EnvironmentVariables != nil ||
		containers.Image != nil ||
		containers.VolumeMounts != nil {
		result.Properties = &InitContainerPropertiesDefinitionARM{}
	}
	for _, item := range containers.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range containers.EnvironmentVariables {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *itemARM.(*EnvironmentVariableARM))
	}
	if containers.Image != nil {
		image := *containers.Image
		result.Properties.Image = &image
	}
	for _, item := range containers.VolumeMounts {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *itemARM.(*VolumeMountARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containers *ContainerGroups_Spec_Properties_InitContainers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_InitContainersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containers *ContainerGroups_Spec_Properties_InitContainers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_InitContainersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_InitContainersARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			containers.Command = append(containers.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.EnvironmentVariables = append(containers.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			containers.Image = &image
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		containers.Name = &name
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.VolumeMounts = append(containers.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers populates our ContainerGroups_Spec_Properties_InitContainers from the provided source ContainerGroups_Spec_Properties_InitContainers
func (containers *ContainerGroups_Spec_Properties_InitContainers) AssignPropertiesFromContainerGroupsSpecPropertiesInitContainers(source *v20211001s.ContainerGroups_Spec_Properties_InitContainers) error {

	// Command
	containers.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignPropertiesFromEnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		containers.EnvironmentVariables = environmentVariableList
	} else {
		containers.EnvironmentVariables = nil
	}

	// Image
	containers.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	containers.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignPropertiesFromVolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		containers.VolumeMounts = volumeMountList
	} else {
		containers.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerGroupsSpecPropertiesInitContainers populates the provided destination ContainerGroups_Spec_Properties_InitContainers from our ContainerGroups_Spec_Properties_InitContainers
func (containers *ContainerGroups_Spec_Properties_InitContainers) AssignPropertiesToContainerGroupsSpecPropertiesInitContainers(destination *v20211001s.ContainerGroups_Spec_Properties_InitContainers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(containers.Command)

	// EnvironmentVariables
	if containers.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable, len(containers.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range containers.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable
			err := environmentVariableItem.AssignPropertiesToEnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(containers.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(containers.Name)

	// VolumeMounts
	if containers.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount, len(containers.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range containers.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount
			err := volumeMountItem.AssignPropertiesToVolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Container_Status struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable_Status `json:"environmentVariables,omitempty"`

	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the container instance. Only valid in response.
	InstanceView *ContainerProperties_Status_InstanceView `json:"instanceView,omitempty"`

	// LivenessProbe: The liveness probe.
	LivenessProbe *ContainerProbe_Status `json:"livenessProbe,omitempty"`

	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort_Status `json:"ports,omitempty"`

	// ReadinessProbe: The readiness probe.
	ReadinessProbe *ContainerProbe_Status `json:"readinessProbe,omitempty"`

	// Resources: The resource requirements of the container instance.
	Resources *ResourceRequirements_Status `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount_Status `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &Container_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Container_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Container_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Container_StatusARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			container.Command = append(container.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.EnvironmentVariables = append(container.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			container.Image = &image
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerProperties_Status_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			container.InstanceView = &instanceView
		}
	}

	// Set property ‘LivenessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe_Status
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			container.LivenessProbe = &livenessProbe
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property ‘Ports’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.Ports = append(container.Ports, item1)
		}
	}

	// Set property ‘ReadinessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe_Status
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			container.ReadinessProbe = &readinessProbe
		}
	}

	// Set property ‘Resources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements_Status
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			container.Resources = &resources
		}
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.VolumeMounts = append(container.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerStatus populates our Container_Status from the provided source Container_Status
func (container *Container_Status) AssignPropertiesFromContainerStatus(source *v20211001s.Container_Status) error {

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_Status, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_Status
			err := environmentVariable.AssignPropertiesFromEnvironmentVariableStatus(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEnvironmentVariableStatus() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		container.EnvironmentVariables = environmentVariableList
	} else {
		container.EnvironmentVariables = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerProperties_Status_InstanceView
		err := instanceView.AssignPropertiesFromContainerPropertiesStatusInstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerPropertiesStatusInstanceView() to populate field InstanceView")
		}
		container.InstanceView = &instanceView
	} else {
		container.InstanceView = nil
	}

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe_Status
		err := livenessProbe.AssignPropertiesFromContainerProbeStatus(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerProbeStatus() to populate field LivenessProbe")
		}
		container.LivenessProbe = &livenessProbe
	} else {
		container.LivenessProbe = nil
	}

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort_Status, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort_Status
			err := port.AssignPropertiesFromContainerPortStatus(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerPortStatus() to populate field Ports")
			}
			portList[portIndex] = port
		}
		container.Ports = portList
	} else {
		container.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe_Status
		err := readinessProbe.AssignPropertiesFromContainerProbeStatus(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerProbeStatus() to populate field ReadinessProbe")
		}
		container.ReadinessProbe = &readinessProbe
	} else {
		container.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements_Status
		err := resource.AssignPropertiesFromResourceRequirementsStatus(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceRequirementsStatus() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_Status, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_Status
			err := volumeMount.AssignPropertiesFromVolumeMountStatus(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolumeMountStatus() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerStatus populates the provided destination Container_Status from our Container_Status
func (container *Container_Status) AssignPropertiesToContainerStatus(destination *v20211001s.Container_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// EnvironmentVariables
	if container.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable_Status, len(container.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range container.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable_Status
			err := environmentVariableItem.AssignPropertiesToEnvironmentVariableStatus(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEnvironmentVariableStatus() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// InstanceView
	if container.InstanceView != nil {
		var instanceView v20211001s.ContainerProperties_Status_InstanceView
		err := container.InstanceView.AssignPropertiesToContainerPropertiesStatusInstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerPropertiesStatusInstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LivenessProbe
	if container.LivenessProbe != nil {
		var livenessProbe v20211001s.ContainerProbe_Status
		err := container.LivenessProbe.AssignPropertiesToContainerProbeStatus(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerProbeStatus() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Ports
	if container.Ports != nil {
		portList := make([]v20211001s.ContainerPort_Status, len(container.Ports))
		for portIndex, portItem := range container.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.ContainerPort_Status
			err := portItem.AssignPropertiesToContainerPortStatus(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerPortStatus() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if container.ReadinessProbe != nil {
		var readinessProbe v20211001s.ContainerProbe_Status
		err := container.ReadinessProbe.AssignPropertiesToContainerProbeStatus(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerProbeStatus() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if container.Resources != nil {
		var resource v20211001s.ResourceRequirements_Status
		err := container.Resources.AssignPropertiesToResourceRequirementsStatus(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceRequirementsStatus() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount_Status, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount_Status
			err := volumeMountItem.AssignPropertiesToVolumeMountStatus(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolumeMountStatus() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/DnsConfiguration
type DnsConfiguration struct {
	// +kubebuilder:validation:Required
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *DnsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &DnsConfigurationARM{}

	// Set property ‘NameServers’:
	for _, item := range configuration.NameServers {
		result.NameServers = append(result.NameServers, item)
	}

	// Set property ‘Options’:
	if configuration.Options != nil {
		options := *configuration.Options
		result.Options = &options
	}

	// Set property ‘SearchDomains’:
	if configuration.SearchDomains != nil {
		searchDomains := *configuration.SearchDomains
		result.SearchDomains = &searchDomains
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfigurationARM, got %T", armInput)
	}

	// Set property ‘NameServers’:
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property ‘Options’:
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property ‘SearchDomains’:
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignPropertiesFromDnsConfiguration populates our DnsConfiguration from the provided source DnsConfiguration
func (configuration *DnsConfiguration) AssignPropertiesFromDnsConfiguration(source *v20211001s.DnsConfiguration) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignPropertiesToDnsConfiguration populates the provided destination DnsConfiguration from our DnsConfiguration
func (configuration *DnsConfiguration) AssignPropertiesToDnsConfiguration(destination *v20211001s.DnsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DnsConfiguration_Status struct {
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘NameServers’:
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property ‘Options’:
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property ‘SearchDomains’:
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignPropertiesFromDnsConfigurationStatus populates our DnsConfiguration_Status from the provided source DnsConfiguration_Status
func (configuration *DnsConfiguration_Status) AssignPropertiesFromDnsConfigurationStatus(source *v20211001s.DnsConfiguration_Status) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignPropertiesToDnsConfigurationStatus populates the provided destination DnsConfiguration_Status from our DnsConfiguration_Status
func (configuration *DnsConfiguration_Status) AssignPropertiesToDnsConfigurationStatus(destination *v20211001s.DnsConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/EncryptionProperties
type EncryptionProperties struct {
	// +kubebuilder:validation:Required
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// +kubebuilder:validation:Required
	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &EncryptionPropertiesARM{}

	// Set property ‘KeyName’:
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if properties.VaultBaseUrl != nil {
		vaultBaseUrl := *properties.VaultBaseUrl
		result.VaultBaseUrl = &vaultBaseUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionPropertiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionPropertiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionPropertiesARM, got %T", armInput)
	}

	// Set property ‘KeyName’:
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionProperties populates our EncryptionProperties from the provided source EncryptionProperties
func (properties *EncryptionProperties) AssignPropertiesFromEncryptionProperties(source *v20211001s.EncryptionProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignPropertiesToEncryptionProperties populates the provided destination EncryptionProperties from our EncryptionProperties
func (properties *EncryptionProperties) AssignPropertiesToEncryptionProperties(destination *v20211001s.EncryptionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionProperties_Status struct {
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionProperties_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionProperties_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionProperties_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionProperties_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyName’:
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionPropertiesStatus populates our EncryptionProperties_Status from the provided source EncryptionProperties_Status
func (properties *EncryptionProperties_Status) AssignPropertiesFromEncryptionPropertiesStatus(source *v20211001s.EncryptionProperties_Status) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignPropertiesToEncryptionPropertiesStatus populates the provided destination EncryptionProperties_Status from our EncryptionProperties_Status
func (properties *EncryptionProperties_Status) AssignPropertiesToEncryptionPropertiesStatus(destination *v20211001s.EncryptionProperties_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImageRegistryCredential_Status struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageRegistryCredential_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *ImageRegistryCredential_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageRegistryCredential_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *ImageRegistryCredential_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageRegistryCredential_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageRegistryCredential_StatusARM, got %T", armInput)
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credential.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credential.IdentityUrl = &identityUrl
	}

	// Set property ‘Server’:
	if typedInput.Server != nil {
		server := *typedInput.Server
		credential.Server = &server
	}

	// Set property ‘Username’:
	if typedInput.Username != nil {
		username := *typedInput.Username
		credential.Username = &username
	}

	// No error
	return nil
}

// AssignPropertiesFromImageRegistryCredentialStatus populates our ImageRegistryCredential_Status from the provided source ImageRegistryCredential_Status
func (credential *ImageRegistryCredential_Status) AssignPropertiesFromImageRegistryCredentialStatus(source *v20211001s.ImageRegistryCredential_Status) error {

	// Identity
	credential.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credential.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Server
	credential.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credential.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignPropertiesToImageRegistryCredentialStatus populates the provided destination ImageRegistryCredential_Status from our ImageRegistryCredential_Status
func (credential *ImageRegistryCredential_Status) AssignPropertiesToImageRegistryCredentialStatus(destination *v20211001s.ImageRegistryCredential_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credential.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credential.IdentityUrl)

	// Server
	destination.Server = genruntime.ClonePointerToString(credential.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credential.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InitContainerDefinition_Status struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable_Status `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the init container. Only valid in response.
	InstanceView *InitContainerPropertiesDefinition_Status_InstanceView `json:"instanceView,omitempty"`

	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount_Status `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerDefinition_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *InitContainerDefinition_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InitContainerDefinition_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *InitContainerDefinition_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InitContainerDefinition_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InitContainerDefinition_StatusARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			definition.Command = append(definition.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.EnvironmentVariables = append(definition.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			definition.Image = &image
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 InitContainerPropertiesDefinition_Status_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			definition.InstanceView = &instanceView
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.VolumeMounts = append(definition.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromInitContainerDefinitionStatus populates our InitContainerDefinition_Status from the provided source InitContainerDefinition_Status
func (definition *InitContainerDefinition_Status) AssignPropertiesFromInitContainerDefinitionStatus(source *v20211001s.InitContainerDefinition_Status) error {

	// Command
	definition.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_Status, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_Status
			err := environmentVariable.AssignPropertiesFromEnvironmentVariableStatus(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEnvironmentVariableStatus() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		definition.EnvironmentVariables = environmentVariableList
	} else {
		definition.EnvironmentVariables = nil
	}

	// Image
	definition.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView InitContainerPropertiesDefinition_Status_InstanceView
		err := instanceView.AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView() to populate field InstanceView")
		}
		definition.InstanceView = &instanceView
	} else {
		definition.InstanceView = nil
	}

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_Status, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_Status
			err := volumeMount.AssignPropertiesFromVolumeMountStatus(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVolumeMountStatus() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		definition.VolumeMounts = volumeMountList
	} else {
		definition.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInitContainerDefinitionStatus populates the provided destination InitContainerDefinition_Status from our InitContainerDefinition_Status
func (definition *InitContainerDefinition_Status) AssignPropertiesToInitContainerDefinitionStatus(destination *v20211001s.InitContainerDefinition_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(definition.Command)

	// EnvironmentVariables
	if definition.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable_Status, len(definition.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range definition.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable_Status
			err := environmentVariableItem.AssignPropertiesToEnvironmentVariableStatus(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEnvironmentVariableStatus() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(definition.Image)

	// InstanceView
	if definition.InstanceView != nil {
		var instanceView v20211001s.InitContainerPropertiesDefinition_Status_InstanceView
		err := definition.InstanceView.AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// VolumeMounts
	if definition.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount_Status, len(definition.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range definition.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount_Status
			err := volumeMountItem.AssignPropertiesToVolumeMountStatus(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVolumeMountStatus() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/IpAddress
type IpAddress struct {
	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// DnsNameLabelReusePolicy: The value representing the security enum.
	DnsNameLabelReusePolicy *IpAddressDnsNameLabelReusePolicy `json:"dnsNameLabelReusePolicy,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// +kubebuilder:validation:Required
	// Ports: The list of ports exposed on the container group.
	Ports []Port `json:"ports,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddressType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &IpAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *IpAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &IpAddressARM{}

	// Set property ‘DnsNameLabel’:
	if address.DnsNameLabel != nil {
		dnsNameLabel := *address.DnsNameLabel
		result.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *address.DnsNameLabelReusePolicy
		result.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Ip’:
	if address.Ip != nil {
		ip := *address.Ip
		result.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range address.Ports {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Ports = append(result.Ports, *itemARM.(*PortARM))
	}

	// Set property ‘Type’:
	if address.Type != nil {
		typeVar := *address.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpAddressARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpAddressARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpAddressARM, got %T", armInput)
	}

	// Set property ‘DnsNameLabel’:
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if typedInput.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *typedInput.DnsNameLabelReusePolicy
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Ip’:
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range typedInput.Ports {
		var item1 Port
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromIpAddress populates our IpAddress from the provided source IpAddress
func (address *IpAddress) AssignPropertiesFromIpAddress(source *v20211001s.IpAddress) error {

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if source.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := IpAddressDnsNameLabelReusePolicy(*source.DnsNameLabelReusePolicy)
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		address.DnsNameLabelReusePolicy = nil
	}

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port
			err := port.AssignPropertiesFromPort(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := IpAddressType(*source.Type)
		address.Type = &typeVar
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIpAddress populates the provided destination IpAddress from our IpAddress
func (address *IpAddress) AssignPropertiesToIpAddress(destination *v20211001s.IpAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := string(*address.DnsNameLabelReusePolicy)
		destination.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		destination.DnsNameLabelReusePolicy = nil
	}

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]v20211001s.Port, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.Port
			err := portItem.AssignPropertiesToPort(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IpAddress_Status struct {
	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// DnsNameLabelReusePolicy: The value representing the security enum.
	DnsNameLabelReusePolicy *IpAddressStatusDnsNameLabelReusePolicy `json:"dnsNameLabelReusePolicy,omitempty"`

	// Fqdn: The FQDN for the IP.
	Fqdn *string `json:"fqdn,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// Ports: The list of ports exposed on the container group.
	Ports []Port_Status `json:"ports,omitempty"`

	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddressStatusType `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &IpAddress_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpAddress_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpAddress_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpAddress_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsNameLabel’:
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if typedInput.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *typedInput.DnsNameLabelReusePolicy
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property ‘Ip’:
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range typedInput.Ports {
		var item1 Port_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromIpAddressStatus populates our IpAddress_Status from the provided source IpAddress_Status
func (address *IpAddress_Status) AssignPropertiesFromIpAddressStatus(source *v20211001s.IpAddress_Status) error {

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if source.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := IpAddressStatusDnsNameLabelReusePolicy(*source.DnsNameLabelReusePolicy)
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		address.DnsNameLabelReusePolicy = nil
	}

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port_Status, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port_Status
			err := port.AssignPropertiesFromPortStatus(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPortStatus() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := IpAddressStatusType(*source.Type)
		address.Type = &typeVar
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIpAddressStatus populates the provided destination IpAddress_Status from our IpAddress_Status
func (address *IpAddress_Status) AssignPropertiesToIpAddressStatus(destination *v20211001s.IpAddress_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := string(*address.DnsNameLabelReusePolicy)
		destination.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		destination.DnsNameLabelReusePolicy = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]v20211001s.Port_Status, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.Port_Status
			err := portItem.AssignPropertiesToPortStatus(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPortStatus() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/Volume
type Volume struct {
	// AzureFile: The properties of the Azure File volume. Azure File shares are mounted as volumes.
	AzureFile *AzureFileVolume `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: Represents a volume that is populated with the contents of a git repository
	GitRepo *GitRepoVolume `json:"gitRepo,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &Volume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *Volume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &VolumeARM{}

	// Set property ‘AzureFile’:
	if volume.AzureFile != nil {
		azureFileARM, err := (*volume.AzureFile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureFile := *azureFileARM.(*AzureFileVolumeARM)
		result.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if volume.EmptyDir != nil {
		result.EmptyDir = make(map[string]v1.JSON, len(volume.EmptyDir))
		for key, value := range volume.EmptyDir {
			result.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if volume.GitRepo != nil {
		gitRepoARM, err := (*volume.GitRepo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gitRepo := *gitRepoARM.(*GitRepoVolumeARM)
		result.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if volume.Name != nil {
		name := *volume.Name
		result.Name = &name
	}

	// Set property ‘Secret’:
	if volume.Secret != nil {
		result.Secret = make(map[string]string, len(volume.Secret))
		for key, value := range volume.Secret {
			result.Secret[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeARM, got %T", armInput)
	}

	// Set property ‘AzureFile’:
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVolume populates our Volume from the provided source Volume
func (volume *Volume) AssignPropertiesFromVolume(source *v20211001s.Volume) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume
		err := azureFile.AssignPropertiesFromAzureFileVolume(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAzureFileVolume() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume
		err := gitRepo.AssignPropertiesFromGitRepoVolume(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGitRepoVolume() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignPropertiesToVolume populates the provided destination Volume from our Volume
func (volume *Volume) AssignPropertiesToVolume(destination *v20211001s.Volume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile v20211001s.AzureFileVolume
		err := volume.AzureFile.AssignPropertiesToAzureFileVolume(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAzureFileVolume() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo v20211001s.GitRepoVolume
		err := volume.GitRepo.AssignPropertiesToGitRepoVolume(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGitRepoVolume() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Volume_Status struct {
	// AzureFile: The Azure File volume.
	AzureFile *AzureFileVolume_Status `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: The git repo volume.
	GitRepo *GitRepoVolume_Status `json:"gitRepo,omitempty"`

	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.FromARMConverter = &Volume_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Volume_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Volume_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Volume_StatusARM, got %T", armInput)
	}

	// Set property ‘AzureFile’:
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume_Status
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume_Status
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVolumeStatus populates our Volume_Status from the provided source Volume_Status
func (volume *Volume_Status) AssignPropertiesFromVolumeStatus(source *v20211001s.Volume_Status) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume_Status
		err := azureFile.AssignPropertiesFromAzureFileVolumeStatus(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAzureFileVolumeStatus() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume_Status
		err := gitRepo.AssignPropertiesFromGitRepoVolumeStatus(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGitRepoVolumeStatus() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignPropertiesToVolumeStatus populates the provided destination Volume_Status from our Volume_Status
func (volume *Volume_Status) AssignPropertiesToVolumeStatus(destination *v20211001s.Volume_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile v20211001s.AzureFileVolume_Status
		err := volume.AzureFile.AssignPropertiesToAzureFileVolumeStatus(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAzureFileVolumeStatus() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo v20211001s.GitRepoVolume_Status
		err := volume.GitRepo.AssignPropertiesToGitRepoVolumeStatus(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGitRepoVolumeStatus() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/AzureFileVolume
type AzureFileVolume struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// +kubebuilder:validation:Required
	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// +kubebuilder:validation:Required
	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFileVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *AzureFileVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &AzureFileVolumeARM{}

	// Set property ‘ReadOnly’:
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		result.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if volume.ShareName != nil {
		shareName := *volume.ShareName
		result.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if volume.StorageAccountKey != nil {
		storageAccountKey := *volume.StorageAccountKey
		result.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if volume.StorageAccountName != nil {
		storageAccountName := *volume.StorageAccountName
		result.StorageAccountName = &storageAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureFileVolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureFileVolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureFileVolumeARM, got %T", armInput)
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignPropertiesFromAzureFileVolume populates our AzureFileVolume from the provided source AzureFileVolume
func (volume *AzureFileVolume) AssignPropertiesFromAzureFileVolume(source *v20211001s.AzureFileVolume) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignPropertiesToAzureFileVolume populates the provided destination AzureFileVolume from our AzureFileVolume
func (volume *AzureFileVolume) AssignPropertiesToAzureFileVolume(destination *v20211001s.AzureFileVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureFileVolume_Status struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFileVolume_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureFileVolume_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureFileVolume_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureFileVolume_StatusARM, got %T", armInput)
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignPropertiesFromAzureFileVolumeStatus populates our AzureFileVolume_Status from the provided source AzureFileVolume_Status
func (volume *AzureFileVolume_Status) AssignPropertiesFromAzureFileVolumeStatus(source *v20211001s.AzureFileVolume_Status) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignPropertiesToAzureFileVolumeStatus populates the provided destination AzureFileVolume_Status from our AzureFileVolume_Status
func (volume *AzureFileVolume_Status) AssignPropertiesToAzureFileVolumeStatus(destination *v20211001s.AzureFileVolume_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupIdentity_Status_UserAssignedIdentities struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupIdentity_Status_UserAssignedIdentities{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ContainerGroupIdentity_Status_UserAssignedIdentities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentity_Status_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ContainerGroupIdentity_Status_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentity_Status_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentity_Status_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities populates our ContainerGroupIdentity_Status_UserAssignedIdentities from the provided source ContainerGroupIdentity_Status_UserAssignedIdentities
func (identities *ContainerGroupIdentity_Status_UserAssignedIdentities) AssignPropertiesFromContainerGroupIdentityStatusUserAssignedIdentities(source *v20211001s.ContainerGroupIdentity_Status_UserAssignedIdentities) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities populates the provided destination ContainerGroupIdentity_Status_UserAssignedIdentities from our ContainerGroupIdentity_Status_UserAssignedIdentities
func (identities *ContainerGroupIdentity_Status_UserAssignedIdentities) AssignPropertiesToContainerGroupIdentityStatusUserAssignedIdentities(destination *v20211001s.ContainerGroupIdentity_Status_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerPort
type ContainerPort struct {
	// +kubebuilder:validation:Required
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPortProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerPort{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *ContainerPort) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &ContainerPortARM{}

	// Set property ‘Port’:
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property ‘Protocol’:
	if port.Protocol != nil {
		protocol := *port.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPortARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPortARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPortARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerPort populates our ContainerPort from the provided source ContainerPort
func (port *ContainerPort) AssignPropertiesFromContainerPort(source *v20211001s.ContainerPort) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ContainerPortProtocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerPort populates the provided destination ContainerPort from our ContainerPort
func (port *ContainerPort) AssignPropertiesToContainerPort(destination *v20211001s.ContainerPort) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerPort_Status struct {
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPortStatusProtocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerPort_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPort_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPort_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPort_StatusARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerPortStatus populates our ContainerPort_Status from the provided source ContainerPort_Status
func (port *ContainerPort_Status) AssignPropertiesFromContainerPortStatus(source *v20211001s.ContainerPort_Status) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ContainerPortStatusProtocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerPortStatus populates the provided destination ContainerPort_Status from our ContainerPort_Status
func (port *ContainerPort_Status) AssignPropertiesToContainerPortStatus(destination *v20211001s.ContainerPort_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerProbe
type ContainerProbe struct {
	// Exec: The container execution command, for liveness or readiness probe
	Exec *ContainerExec `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The container Http Get settings, for liveness or readiness probe
	HttpGet *ContainerHttpGet `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerProbe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *ContainerProbe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &ContainerProbeARM{}

	// Set property ‘Exec’:
	if probe.Exec != nil {
		execARM, err := (*probe.Exec).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		exec := *execARM.(*ContainerExecARM)
		result.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if probe.FailureThreshold != nil {
		failureThreshold := *probe.FailureThreshold
		result.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if probe.HttpGet != nil {
		httpGetARM, err := (*probe.HttpGet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpGet := *httpGetARM.(*ContainerHttpGetARM)
		result.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if probe.InitialDelaySeconds != nil {
		initialDelaySeconds := *probe.InitialDelaySeconds
		result.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if probe.PeriodSeconds != nil {
		periodSeconds := *probe.PeriodSeconds
		result.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if probe.SuccessThreshold != nil {
		successThreshold := *probe.SuccessThreshold
		result.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if probe.TimeoutSeconds != nil {
		timeoutSeconds := *probe.TimeoutSeconds
		result.TimeoutSeconds = &timeoutSeconds
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProbeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProbeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProbeARM, got %T", armInput)
	}

	// Set property ‘Exec’:
	if typedInput.Exec != nil {
		var exec1 ContainerExec
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerProbe populates our ContainerProbe from the provided source ContainerProbe
func (probe *ContainerProbe) AssignPropertiesFromContainerProbe(source *v20211001s.ContainerProbe) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec
		err := exec.AssignPropertiesFromContainerExec(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerExec() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet
		err := httpGet.AssignPropertiesFromContainerHttpGet(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerHttpGet() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignPropertiesToContainerProbe populates the provided destination ContainerProbe from our ContainerProbe
func (probe *ContainerProbe) AssignPropertiesToContainerProbe(destination *v20211001s.ContainerProbe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec v20211001s.ContainerExec
		err := probe.Exec.AssignPropertiesToContainerExec(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerExec() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet v20211001s.ContainerHttpGet
		err := probe.HttpGet.AssignPropertiesToContainerHttpGet(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerHttpGet() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerProbe_Status struct {
	// Exec: The execution command to probe
	Exec *ContainerExec_Status `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The Http Get settings to probe
	HttpGet *ContainerHttpGet_Status `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProbe_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProbe_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProbe_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProbe_StatusARM, got %T", armInput)
	}

	// Set property ‘Exec’:
	if typedInput.Exec != nil {
		var exec1 ContainerExec_Status
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet_Status
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerProbeStatus populates our ContainerProbe_Status from the provided source ContainerProbe_Status
func (probe *ContainerProbe_Status) AssignPropertiesFromContainerProbeStatus(source *v20211001s.ContainerProbe_Status) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec_Status
		err := exec.AssignPropertiesFromContainerExecStatus(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerExecStatus() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet_Status
		err := httpGet.AssignPropertiesFromContainerHttpGetStatus(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerHttpGetStatus() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignPropertiesToContainerProbeStatus populates the provided destination ContainerProbe_Status from our ContainerProbe_Status
func (probe *ContainerProbe_Status) AssignPropertiesToContainerProbeStatus(destination *v20211001s.ContainerProbe_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec v20211001s.ContainerExec_Status
		err := probe.Exec.AssignPropertiesToContainerExecStatus(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerExecStatus() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet v20211001s.ContainerHttpGet_Status
		err := probe.HttpGet.AssignPropertiesToContainerHttpGetStatus(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerHttpGetStatus() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerProperties_Status_InstanceView struct {
	// CurrentState: Current container instance state.
	CurrentState *ContainerState_Status `json:"currentState,omitempty"`

	// Events: The events of the container instance.
	Events []Event_Status `json:"events,omitempty"`

	// PreviousState: Previous container instance state.
	PreviousState *ContainerState_Status `json:"previousState,omitempty"`

	// RestartCount: The number of times that the container instance has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProperties_Status_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerProperties_Status_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProperties_Status_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerProperties_Status_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProperties_Status_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProperties_Status_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘CurrentState’:
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_Status
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘PreviousState’:
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_Status
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property ‘RestartCount’:
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerPropertiesStatusInstanceView populates our ContainerProperties_Status_InstanceView from the provided source ContainerProperties_Status_InstanceView
func (view *ContainerProperties_Status_InstanceView) AssignPropertiesFromContainerPropertiesStatusInstanceView(source *v20211001s.ContainerProperties_Status_InstanceView) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_Status
		err := currentState.AssignPropertiesFromContainerStateStatus(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerStateStatus() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_Status, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_Status
			err := event.AssignPropertiesFromEventStatus(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_Status
		err := previousState.AssignPropertiesFromContainerStateStatus(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerStateStatus() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignPropertiesToContainerPropertiesStatusInstanceView populates the provided destination ContainerProperties_Status_InstanceView from our ContainerProperties_Status_InstanceView
func (view *ContainerProperties_Status_InstanceView) AssignPropertiesToContainerPropertiesStatusInstanceView(destination *v20211001s.ContainerProperties_Status_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState v20211001s.ContainerState_Status
		err := view.CurrentState.AssignPropertiesToContainerStateStatus(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerStateStatus() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_Status, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_Status
			err := eventItem.AssignPropertiesToEventStatus(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState v20211001s.ContainerState_Status
		err := view.PreviousState.AssignPropertiesToContainerStateStatus(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerStateStatus() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/EnvironmentVariable
type EnvironmentVariable struct {
	// +kubebuilder:validation:Required
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// SecureValue: The value of the secure environment variable.
	SecureValue *string `json:"secureValue,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnvironmentVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *EnvironmentVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &EnvironmentVariableARM{}

	// Set property ‘Name’:
	if variable.Name != nil {
		name := *variable.Name
		result.Name = &name
	}

	// Set property ‘SecureValue’:
	if variable.SecureValue != nil {
		secureValue := *variable.SecureValue
		result.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if variable.Value != nil {
		value := *variable.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EnvironmentVariableARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EnvironmentVariableARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EnvironmentVariableARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// Set property ‘SecureValue’:
	if typedInput.SecureValue != nil {
		secureValue := *typedInput.SecureValue
		variable.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromEnvironmentVariable populates our EnvironmentVariable from the provided source EnvironmentVariable
func (variable *EnvironmentVariable) AssignPropertiesFromEnvironmentVariable(source *v20211001s.EnvironmentVariable) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// SecureValue
	variable.SecureValue = genruntime.ClonePointerToString(source.SecureValue)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToEnvironmentVariable populates the provided destination EnvironmentVariable from our EnvironmentVariable
func (variable *EnvironmentVariable) AssignPropertiesToEnvironmentVariable(destination *v20211001s.EnvironmentVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// SecureValue
	destination.SecureValue = genruntime.ClonePointerToString(variable.SecureValue)

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EnvironmentVariable_Status struct {
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// SecureValue: The value of the secure environment variable.
	SecureValue *string `json:"secureValue,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnvironmentVariable_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EnvironmentVariable_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EnvironmentVariable_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EnvironmentVariable_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// Set property ‘SecureValue’:
	if typedInput.SecureValue != nil {
		secureValue := *typedInput.SecureValue
		variable.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromEnvironmentVariableStatus populates our EnvironmentVariable_Status from the provided source EnvironmentVariable_Status
func (variable *EnvironmentVariable_Status) AssignPropertiesFromEnvironmentVariableStatus(source *v20211001s.EnvironmentVariable_Status) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// SecureValue
	variable.SecureValue = genruntime.ClonePointerToString(source.SecureValue)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToEnvironmentVariableStatus populates the provided destination EnvironmentVariable_Status from our EnvironmentVariable_Status
func (variable *EnvironmentVariable_Status) AssignPropertiesToEnvironmentVariableStatus(destination *v20211001s.EnvironmentVariable_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// SecureValue
	destination.SecureValue = genruntime.ClonePointerToString(variable.SecureValue)

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Event_Status struct {
	// Count: The count of the event.
	Count *int `json:"count,omitempty"`

	// FirstTimestamp: The date-time of the earliest logged event.
	FirstTimestamp *string `json:"firstTimestamp,omitempty"`

	// LastTimestamp: The date-time of the latest logged event.
	LastTimestamp *string `json:"lastTimestamp,omitempty"`

	// Message: The event message.
	Message *string `json:"message,omitempty"`

	// Name: The event name.
	Name *string `json:"name,omitempty"`

	// Type: The event type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Event_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (event *Event_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Event_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (event *Event_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Event_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Event_StatusARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		event.Count = &count
	}

	// Set property ‘FirstTimestamp’:
	if typedInput.FirstTimestamp != nil {
		firstTimestamp := *typedInput.FirstTimestamp
		event.FirstTimestamp = &firstTimestamp
	}

	// Set property ‘LastTimestamp’:
	if typedInput.LastTimestamp != nil {
		lastTimestamp := *typedInput.LastTimestamp
		event.LastTimestamp = &lastTimestamp
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		event.Message = &message
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		event.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		event.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromEventStatus populates our Event_Status from the provided source Event_Status
func (event *Event_Status) AssignPropertiesFromEventStatus(source *v20211001s.Event_Status) error {

	// Count
	event.Count = genruntime.ClonePointerToInt(source.Count)

	// FirstTimestamp
	event.FirstTimestamp = genruntime.ClonePointerToString(source.FirstTimestamp)

	// LastTimestamp
	event.LastTimestamp = genruntime.ClonePointerToString(source.LastTimestamp)

	// Message
	event.Message = genruntime.ClonePointerToString(source.Message)

	// Name
	event.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	event.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToEventStatus populates the provided destination Event_Status from our Event_Status
func (event *Event_Status) AssignPropertiesToEventStatus(destination *v20211001s.Event_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(event.Count)

	// FirstTimestamp
	destination.FirstTimestamp = genruntime.ClonePointerToString(event.FirstTimestamp)

	// LastTimestamp
	destination.LastTimestamp = genruntime.ClonePointerToString(event.LastTimestamp)

	// Message
	destination.Message = genruntime.ClonePointerToString(event.Message)

	// Name
	destination.Name = genruntime.ClonePointerToString(event.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(event.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/GitRepoVolume
type GitRepoVolume struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// +kubebuilder:validation:Required
	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.ARMTransformer = &GitRepoVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *GitRepoVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &GitRepoVolumeARM{}

	// Set property ‘Directory’:
	if volume.Directory != nil {
		directory := *volume.Directory
		result.Directory = &directory
	}

	// Set property ‘Repository’:
	if volume.Repository != nil {
		repository := *volume.Repository
		result.Repository = &repository
	}

	// Set property ‘Revision’:
	if volume.Revision != nil {
		revision := *volume.Revision
		result.Revision = &revision
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitRepoVolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitRepoVolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitRepoVolumeARM, got %T", armInput)
	}

	// Set property ‘Directory’:
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property ‘Repository’:
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property ‘Revision’:
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignPropertiesFromGitRepoVolume populates our GitRepoVolume from the provided source GitRepoVolume
func (volume *GitRepoVolume) AssignPropertiesFromGitRepoVolume(source *v20211001s.GitRepoVolume) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignPropertiesToGitRepoVolume populates the provided destination GitRepoVolume from our GitRepoVolume
func (volume *GitRepoVolume) AssignPropertiesToGitRepoVolume(destination *v20211001s.GitRepoVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GitRepoVolume_Status struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.FromARMConverter = &GitRepoVolume_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitRepoVolume_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitRepoVolume_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitRepoVolume_StatusARM, got %T", armInput)
	}

	// Set property ‘Directory’:
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property ‘Repository’:
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property ‘Revision’:
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignPropertiesFromGitRepoVolumeStatus populates our GitRepoVolume_Status from the provided source GitRepoVolume_Status
func (volume *GitRepoVolume_Status) AssignPropertiesFromGitRepoVolumeStatus(source *v20211001s.GitRepoVolume_Status) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignPropertiesToGitRepoVolumeStatus populates the provided destination GitRepoVolume_Status from our GitRepoVolume_Status
func (volume *GitRepoVolume_Status) AssignPropertiesToGitRepoVolumeStatus(destination *v20211001s.GitRepoVolume_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InitContainerPropertiesDefinition_Status_InstanceView struct {
	// CurrentState: The current state of the init container.
	CurrentState *ContainerState_Status `json:"currentState,omitempty"`

	// Events: The events of the init container.
	Events []Event_Status `json:"events,omitempty"`

	// PreviousState: The previous state of the init container.
	PreviousState *ContainerState_Status `json:"previousState,omitempty"`

	// RestartCount: The number of times that the init container has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerPropertiesDefinition_Status_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *InitContainerPropertiesDefinition_Status_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InitContainerPropertiesDefinition_Status_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *InitContainerPropertiesDefinition_Status_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InitContainerPropertiesDefinition_Status_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InitContainerPropertiesDefinition_Status_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘CurrentState’:
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_Status
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘PreviousState’:
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_Status
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property ‘RestartCount’:
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView populates our InitContainerPropertiesDefinition_Status_InstanceView from the provided source InitContainerPropertiesDefinition_Status_InstanceView
func (view *InitContainerPropertiesDefinition_Status_InstanceView) AssignPropertiesFromInitContainerPropertiesDefinitionStatusInstanceView(source *v20211001s.InitContainerPropertiesDefinition_Status_InstanceView) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_Status
		err := currentState.AssignPropertiesFromContainerStateStatus(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerStateStatus() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_Status, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_Status
			err := event.AssignPropertiesFromEventStatus(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_Status
		err := previousState.AssignPropertiesFromContainerStateStatus(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerStateStatus() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView populates the provided destination InitContainerPropertiesDefinition_Status_InstanceView from our InitContainerPropertiesDefinition_Status_InstanceView
func (view *InitContainerPropertiesDefinition_Status_InstanceView) AssignPropertiesToInitContainerPropertiesDefinitionStatusInstanceView(destination *v20211001s.InitContainerPropertiesDefinition_Status_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState v20211001s.ContainerState_Status
		err := view.CurrentState.AssignPropertiesToContainerStateStatus(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerStateStatus() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_Status, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_Status
			err := eventItem.AssignPropertiesToEventStatus(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToEventStatus() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState v20211001s.ContainerState_Status
		err := view.PreviousState.AssignPropertiesToContainerStateStatus(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerStateStatus() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Noreuse","ResourceGroupReuse","SubscriptionReuse","TenantReuse","Unsecure"}
type IpAddressDnsNameLabelReusePolicy string

const (
	IpAddressDnsNameLabelReusePolicyNoreuse            = IpAddressDnsNameLabelReusePolicy("Noreuse")
	IpAddressDnsNameLabelReusePolicyResourceGroupReuse = IpAddressDnsNameLabelReusePolicy("ResourceGroupReuse")
	IpAddressDnsNameLabelReusePolicySubscriptionReuse  = IpAddressDnsNameLabelReusePolicy("SubscriptionReuse")
	IpAddressDnsNameLabelReusePolicyTenantReuse        = IpAddressDnsNameLabelReusePolicy("TenantReuse")
	IpAddressDnsNameLabelReusePolicyUnsecure           = IpAddressDnsNameLabelReusePolicy("Unsecure")
)

type IpAddressStatusDnsNameLabelReusePolicy string

const (
	IpAddressStatusDnsNameLabelReusePolicyNoreuse            = IpAddressStatusDnsNameLabelReusePolicy("Noreuse")
	IpAddressStatusDnsNameLabelReusePolicyResourceGroupReuse = IpAddressStatusDnsNameLabelReusePolicy("ResourceGroupReuse")
	IpAddressStatusDnsNameLabelReusePolicySubscriptionReuse  = IpAddressStatusDnsNameLabelReusePolicy("SubscriptionReuse")
	IpAddressStatusDnsNameLabelReusePolicyTenantReuse        = IpAddressStatusDnsNameLabelReusePolicy("TenantReuse")
	IpAddressStatusDnsNameLabelReusePolicyUnsecure           = IpAddressStatusDnsNameLabelReusePolicy("Unsecure")
)

type IpAddressStatusType string

const (
	IpAddressStatusTypePrivate = IpAddressStatusType("Private")
	IpAddressStatusTypePublic  = IpAddressStatusType("Public")
)

// +kubebuilder:validation:Enum={"Private","Public"}
type IpAddressType string

const (
	IpAddressTypePrivate = IpAddressType("Private")
	IpAddressTypePublic  = IpAddressType("Public")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/LogAnalytics
type LogAnalytics struct {
	// LogType: The log type to be used.
	LogType *LogAnalyticsLogType `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceKey: The workspace key for log analytics
	WorkspaceKey *string `json:"workspaceKey,omitempty"`

	// WorkspaceResourceReference: The workspace resource id for log analytics
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &LogAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *LogAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &LogAnalyticsARM{}

	// Set property ‘LogType’:
	if analytics.LogType != nil {
		logType := *analytics.LogType
		result.LogType = &logType
	}

	// Set property ‘Metadata’:
	if analytics.Metadata != nil {
		result.Metadata = make(map[string]string, len(analytics.Metadata))
		for key, value := range analytics.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if analytics.WorkspaceId != nil {
		workspaceId := *analytics.WorkspaceId
		result.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if analytics.WorkspaceKey != nil {
		workspaceKey := *analytics.WorkspaceKey
		result.WorkspaceKey = &workspaceKey
	}

	// Set property ‘WorkspaceResourceId’:
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*analytics.WorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		workspaceResourceReference := workspaceResourceReferenceARMID
		result.WorkspaceResourceId = &workspaceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LogAnalyticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LogAnalyticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LogAnalyticsARM, got %T", armInput)
	}

	// Set property ‘LogType’:
	if typedInput.LogType != nil {
		logType := *typedInput.LogType
		analytics.LogType = &logType
	}

	// Set property ‘Metadata’:
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if typedInput.WorkspaceKey != nil {
		workspaceKey := *typedInput.WorkspaceKey
		analytics.WorkspaceKey = &workspaceKey
	}

	// no assignment for property ‘WorkspaceResourceReference’

	// No error
	return nil
}

// AssignPropertiesFromLogAnalytics populates our LogAnalytics from the provided source LogAnalytics
func (analytics *LogAnalytics) AssignPropertiesFromLogAnalytics(source *v20211001s.LogAnalytics) error {

	// LogType
	if source.LogType != nil {
		logType := LogAnalyticsLogType(*source.LogType)
		analytics.LogType = &logType
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceKey
	analytics.WorkspaceKey = genruntime.ClonePointerToString(source.WorkspaceKey)

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		analytics.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		analytics.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLogAnalytics populates the provided destination LogAnalytics from our LogAnalytics
func (analytics *LogAnalytics) AssignPropertiesToLogAnalytics(destination *v20211001s.LogAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// WorkspaceKey
	destination.WorkspaceKey = genruntime.ClonePointerToString(analytics.WorkspaceKey)

	// WorkspaceResourceReference
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReference := analytics.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LogAnalytics_Status struct {
	// LogType: The log type to be used.
	LogType *LogAnalyticsStatusLogType `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceKey: The workspace key for log analytics
	WorkspaceKey *string `json:"workspaceKey,omitempty"`

	// WorkspaceResourceId: The workspace resource id for log analytics
	WorkspaceResourceId *string `json:"workspaceResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &LogAnalytics_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LogAnalytics_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LogAnalytics_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LogAnalytics_StatusARM, got %T", armInput)
	}

	// Set property ‘LogType’:
	if typedInput.LogType != nil {
		logType := *typedInput.LogType
		analytics.LogType = &logType
	}

	// Set property ‘Metadata’:
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if typedInput.WorkspaceKey != nil {
		workspaceKey := *typedInput.WorkspaceKey
		analytics.WorkspaceKey = &workspaceKey
	}

	// Set property ‘WorkspaceResourceId’:
	if typedInput.WorkspaceResourceId != nil {
		workspaceResourceId := *typedInput.WorkspaceResourceId
		analytics.WorkspaceResourceId = &workspaceResourceId
	}

	// No error
	return nil
}

// AssignPropertiesFromLogAnalyticsStatus populates our LogAnalytics_Status from the provided source LogAnalytics_Status
func (analytics *LogAnalytics_Status) AssignPropertiesFromLogAnalyticsStatus(source *v20211001s.LogAnalytics_Status) error {

	// LogType
	if source.LogType != nil {
		logType := LogAnalyticsStatusLogType(*source.LogType)
		analytics.LogType = &logType
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceKey
	analytics.WorkspaceKey = genruntime.ClonePointerToString(source.WorkspaceKey)

	// WorkspaceResourceId
	analytics.WorkspaceResourceId = genruntime.ClonePointerToString(source.WorkspaceResourceId)

	// No error
	return nil
}

// AssignPropertiesToLogAnalyticsStatus populates the provided destination LogAnalytics_Status from our LogAnalytics_Status
func (analytics *LogAnalytics_Status) AssignPropertiesToLogAnalyticsStatus(destination *v20211001s.LogAnalytics_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// WorkspaceKey
	destination.WorkspaceKey = genruntime.ClonePointerToString(analytics.WorkspaceKey)

	// WorkspaceResourceId
	destination.WorkspaceResourceId = genruntime.ClonePointerToString(analytics.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/Port
type Port struct {
	// +kubebuilder:validation:Required
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *PortProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &Port{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *Port) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &PortARM{}

	// Set property ‘Port’:
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property ‘Protocol’:
	if port.Protocol != nil {
		protocol := *port.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PortARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PortARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PortARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromPort populates our Port from the provided source Port
func (port *Port) AssignPropertiesFromPort(source *v20211001s.Port) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := PortProtocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPort populates the provided destination Port from our Port
func (port *Port) AssignPropertiesToPort(destination *v20211001s.Port) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Port_Status struct {
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *PortStatusProtocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &Port_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Port_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Port_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Port_StatusARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromPortStatus populates our Port_Status from the provided source Port_Status
func (port *Port_Status) AssignPropertiesFromPortStatus(source *v20211001s.Port_Status) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := PortStatusProtocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPortStatus populates the provided destination Port_Status from our Port_Status
func (port *Port_Status) AssignPropertiesToPortStatus(destination *v20211001s.Port_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceRequirements
type ResourceRequirements struct {
	// Limits: The resource limits.
	Limits *ResourceLimits `json:"limits,omitempty"`

	// +kubebuilder:validation:Required
	// Requests: The resource requests.
	Requests *ResourceRequests `json:"requests,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequirements{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requirements *ResourceRequirements) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requirements == nil {
		return nil, nil
	}
	result := &ResourceRequirementsARM{}

	// Set property ‘Limits’:
	if requirements.Limits != nil {
		limitsARM, err := (*requirements.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limitsARM.(*ResourceLimitsARM)
		result.Limits = &limits
	}

	// Set property ‘Requests’:
	if requirements.Requests != nil {
		requestsARM, err := (*requirements.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requestsARM.(*ResourceRequestsARM)
		result.Requests = &requests
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequirementsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequirementsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequirementsARM, got %T", armInput)
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 ResourceLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 ResourceRequests
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceRequirements populates our ResourceRequirements from the provided source ResourceRequirements
func (requirements *ResourceRequirements) AssignPropertiesFromResourceRequirements(source *v20211001s.ResourceRequirements) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits
		err := limit.AssignPropertiesFromResourceLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceLimits() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests
		err := request.AssignPropertiesFromResourceRequests(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceRequests() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceRequirements populates the provided destination ResourceRequirements from our ResourceRequirements
func (requirements *ResourceRequirements) AssignPropertiesToResourceRequirements(destination *v20211001s.ResourceRequirements) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit v20211001s.ResourceLimits
		err := requirements.Limits.AssignPropertiesToResourceLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request v20211001s.ResourceRequests
		err := requirements.Requests.AssignPropertiesToResourceRequests(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceRequests() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceRequirements_Status struct {
	// Limits: The resource limits of this container instance.
	Limits *ResourceLimits_Status `json:"limits,omitempty"`

	// Requests: The resource requests of this container instance.
	Requests *ResourceRequests_Status `json:"requests,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequirements_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequirements_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequirements_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequirements_StatusARM, got %T", armInput)
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 ResourceLimits_Status
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 ResourceRequests_Status
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceRequirementsStatus populates our ResourceRequirements_Status from the provided source ResourceRequirements_Status
func (requirements *ResourceRequirements_Status) AssignPropertiesFromResourceRequirementsStatus(source *v20211001s.ResourceRequirements_Status) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits_Status
		err := limit.AssignPropertiesFromResourceLimitsStatus(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceLimitsStatus() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests_Status
		err := request.AssignPropertiesFromResourceRequestsStatus(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceRequestsStatus() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceRequirementsStatus populates the provided destination ResourceRequirements_Status from our ResourceRequirements_Status
func (requirements *ResourceRequirements_Status) AssignPropertiesToResourceRequirementsStatus(destination *v20211001s.ResourceRequirements_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit v20211001s.ResourceLimits_Status
		err := requirements.Limits.AssignPropertiesToResourceLimitsStatus(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceLimitsStatus() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request v20211001s.ResourceRequests_Status
		err := requirements.Requests.AssignPropertiesToResourceRequestsStatus(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceRequestsStatus() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/VolumeMount
type VolumeMount struct {
	// +kubebuilder:validation:Required
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeMount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mount *VolumeMount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mount == nil {
		return nil, nil
	}
	result := &VolumeMountARM{}

	// Set property ‘MountPath’:
	if mount.MountPath != nil {
		mountPath := *mount.MountPath
		result.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if mount.Name != nil {
		name := *mount.Name
		result.Name = &name
	}

	// Set property ‘ReadOnly’:
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		result.ReadOnly = &readOnly
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeMountARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeMountARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeMountARM, got %T", armInput)
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignPropertiesFromVolumeMount populates our VolumeMount from the provided source VolumeMount
func (mount *VolumeMount) AssignPropertiesFromVolumeMount(source *v20211001s.VolumeMount) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVolumeMount populates the provided destination VolumeMount from our VolumeMount
func (mount *VolumeMount) AssignPropertiesToVolumeMount(destination *v20211001s.VolumeMount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VolumeMount_Status struct {
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeMount_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeMount_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeMount_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeMount_StatusARM, got %T", armInput)
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignPropertiesFromVolumeMountStatus populates our VolumeMount_Status from the provided source VolumeMount_Status
func (mount *VolumeMount_Status) AssignPropertiesFromVolumeMountStatus(source *v20211001s.VolumeMount_Status) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVolumeMountStatus populates the provided destination VolumeMount_Status from our VolumeMount_Status
func (mount *VolumeMount_Status) AssignPropertiesToVolumeMountStatus(destination *v20211001s.VolumeMount_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerExec
type ContainerExec struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerExec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exec *ContainerExec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exec == nil {
		return nil, nil
	}
	result := &ContainerExecARM{}

	// Set property ‘Command’:
	for _, item := range exec.Command {
		result.Command = append(result.Command, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerExecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerExecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerExecARM, got %T", armInput)
	}

	// Set property ‘Command’:
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerExec populates our ContainerExec from the provided source ContainerExec
func (exec *ContainerExec) AssignPropertiesFromContainerExec(source *v20211001s.ContainerExec) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignPropertiesToContainerExec populates the provided destination ContainerExec from our ContainerExec
func (exec *ContainerExec) AssignPropertiesToContainerExec(destination *v20211001s.ContainerExec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerExec_Status struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerExec_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerExec_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerExec_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerExec_StatusARM, got %T", armInput)
	}

	// Set property ‘Command’:
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerExecStatus populates our ContainerExec_Status from the provided source ContainerExec_Status
func (exec *ContainerExec_Status) AssignPropertiesFromContainerExecStatus(source *v20211001s.ContainerExec_Status) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignPropertiesToContainerExecStatus populates the provided destination ContainerExec_Status from our ContainerExec_Status
func (exec *ContainerExec_Status) AssignPropertiesToContainerExecStatus(destination *v20211001s.ContainerExec_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerHttpGet
type ContainerHttpGet struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// +kubebuilder:validation:Required
	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGetScheme `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerHttpGet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (httpGet *ContainerHttpGet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if httpGet == nil {
		return nil, nil
	}
	result := &ContainerHttpGetARM{}

	// Set property ‘HttpHeaders’:
	for _, item := range httpGet.HttpHeaders {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpHeaders = append(result.HttpHeaders, *itemARM.(*HttpHeaderARM))
	}

	// Set property ‘Path’:
	if httpGet.Path != nil {
		path := *httpGet.Path
		result.Path = &path
	}

	// Set property ‘Port’:
	if httpGet.Port != nil {
		port := *httpGet.Port
		result.Port = &port
	}

	// Set property ‘Scheme’:
	if httpGet.Scheme != nil {
		scheme := *httpGet.Scheme
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerHttpGetARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerHttpGetARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerHttpGetARM, got %T", armInput)
	}

	// Set property ‘HttpHeaders’:
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property ‘Scheme’:
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerHttpGet populates our ContainerHttpGet from the provided source ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignPropertiesFromContainerHttpGet(source *v20211001s.ContainerHttpGet) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader
			err := httpHeader.AssignPropertiesFromHttpHeader(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := ContainerHttpGetScheme(*source.Scheme)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerHttpGet populates the provided destination ContainerHttpGet from our ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignPropertiesToContainerHttpGet(destination *v20211001s.ContainerHttpGet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]v20211001s.HttpHeader, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader v20211001s.HttpHeader
			err := httpHeaderItem.AssignPropertiesToHttpHeader(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerHttpGet_Status struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader_Status `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGetStatusScheme `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerHttpGet_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerHttpGet_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerHttpGet_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerHttpGet_StatusARM, got %T", armInput)
	}

	// Set property ‘HttpHeaders’:
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property ‘Scheme’:
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerHttpGetStatus populates our ContainerHttpGet_Status from the provided source ContainerHttpGet_Status
func (httpGet *ContainerHttpGet_Status) AssignPropertiesFromContainerHttpGetStatus(source *v20211001s.ContainerHttpGet_Status) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader_Status, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader_Status
			err := httpHeader.AssignPropertiesFromHttpHeaderStatus(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpHeaderStatus() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := ContainerHttpGetStatusScheme(*source.Scheme)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerHttpGetStatus populates the provided destination ContainerHttpGet_Status from our ContainerHttpGet_Status
func (httpGet *ContainerHttpGet_Status) AssignPropertiesToContainerHttpGetStatus(destination *v20211001s.ContainerHttpGet_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]v20211001s.HttpHeader_Status, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader v20211001s.HttpHeader_Status
			err := httpHeaderItem.AssignPropertiesToHttpHeaderStatus(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpHeaderStatus() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"TCP","UDP"}
type ContainerPortProtocol string

const (
	ContainerPortProtocolTCP = ContainerPortProtocol("TCP")
	ContainerPortProtocolUDP = ContainerPortProtocol("UDP")
)

type ContainerPortStatusProtocol string

const (
	ContainerPortStatusProtocolTCP = ContainerPortStatusProtocol("TCP")
	ContainerPortStatusProtocolUDP = ContainerPortStatusProtocol("UDP")
)

type ContainerState_Status struct {
	// DetailStatus: The human-readable status of the container instance state.
	DetailStatus *string `json:"detailStatus,omitempty"`

	// ExitCode: The container instance exit codes correspond to those from the `docker run` command.
	ExitCode *int `json:"exitCode,omitempty"`

	// FinishTime: The date-time when the container instance state finished.
	FinishTime *string `json:"finishTime,omitempty"`

	// StartTime: The date-time when the container instance state started.
	StartTime *string `json:"startTime,omitempty"`

	// State: The state of the container instance.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerState_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *ContainerState_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerState_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *ContainerState_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerState_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerState_StatusARM, got %T", armInput)
	}

	// Set property ‘DetailStatus’:
	if typedInput.DetailStatus != nil {
		detailStatus := *typedInput.DetailStatus
		state.DetailStatus = &detailStatus
	}

	// Set property ‘ExitCode’:
	if typedInput.ExitCode != nil {
		exitCode := *typedInput.ExitCode
		state.ExitCode = &exitCode
	}

	// Set property ‘FinishTime’:
	if typedInput.FinishTime != nil {
		finishTime := *typedInput.FinishTime
		state.FinishTime = &finishTime
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		state.StartTime = &startTime
	}

	// Set property ‘State’:
	if typedInput.State != nil {
		state1 := *typedInput.State
		state.State = &state1
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerStateStatus populates our ContainerState_Status from the provided source ContainerState_Status
func (state *ContainerState_Status) AssignPropertiesFromContainerStateStatus(source *v20211001s.ContainerState_Status) error {

	// DetailStatus
	state.DetailStatus = genruntime.ClonePointerToString(source.DetailStatus)

	// ExitCode
	state.ExitCode = genruntime.ClonePointerToInt(source.ExitCode)

	// FinishTime
	state.FinishTime = genruntime.ClonePointerToString(source.FinishTime)

	// StartTime
	state.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// State
	state.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignPropertiesToContainerStateStatus populates the provided destination ContainerState_Status from our ContainerState_Status
func (state *ContainerState_Status) AssignPropertiesToContainerStateStatus(destination *v20211001s.ContainerState_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DetailStatus
	destination.DetailStatus = genruntime.ClonePointerToString(state.DetailStatus)

	// ExitCode
	destination.ExitCode = genruntime.ClonePointerToInt(state.ExitCode)

	// FinishTime
	destination.FinishTime = genruntime.ClonePointerToString(state.FinishTime)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(state.StartTime)

	// State
	destination.State = genruntime.ClonePointerToString(state.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ContainerInsights","ContainerInstanceLogs"}
type LogAnalyticsLogType string

const (
	LogAnalyticsLogTypeContainerInsights     = LogAnalyticsLogType("ContainerInsights")
	LogAnalyticsLogTypeContainerInstanceLogs = LogAnalyticsLogType("ContainerInstanceLogs")
)

type LogAnalyticsStatusLogType string

const (
	LogAnalyticsStatusLogTypeContainerInsights     = LogAnalyticsStatusLogType("ContainerInsights")
	LogAnalyticsStatusLogTypeContainerInstanceLogs = LogAnalyticsStatusLogType("ContainerInstanceLogs")
)

// +kubebuilder:validation:Enum={"TCP","UDP"}
type PortProtocol string

const (
	PortProtocolTCP = PortProtocol("TCP")
	PortProtocolUDP = PortProtocol("UDP")
)

type PortStatusProtocol string

const (
	PortStatusProtocolTCP = PortStatusProtocol("TCP")
	PortStatusProtocolUDP = PortStatusProtocol("UDP")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceLimits
type ResourceLimits struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU resource.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *ResourceLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &ResourceLimitsARM{}

	// Set property ‘Cpu’:
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		result.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if limits.Gpu != nil {
		gpuARM, err := (*limits.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpuARM.(*GpuResourceARM)
		result.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceLimitsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceLimitsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceLimitsARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceLimits populates our ResourceLimits from the provided source ResourceLimits
func (limits *ResourceLimits) AssignPropertiesFromResourceLimits(source *v20211001s.ResourceLimits) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignPropertiesFromGpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGpuResource() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceLimits populates the provided destination ResourceLimits from our ResourceLimits
func (limits *ResourceLimits) AssignPropertiesToResourceLimits(destination *v20211001s.ResourceLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu v20211001s.GpuResource
		err := limits.Gpu.AssignPropertiesToGpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceLimits_Status struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU limit of this container instance.
	Gpu *GpuResource_Status `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceLimits_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceLimits_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceLimits_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceLimits_StatusARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_Status
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceLimitsStatus populates our ResourceLimits_Status from the provided source ResourceLimits_Status
func (limits *ResourceLimits_Status) AssignPropertiesFromResourceLimitsStatus(source *v20211001s.ResourceLimits_Status) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_Status
		err := gpu.AssignPropertiesFromGpuResourceStatus(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGpuResourceStatus() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceLimitsStatus populates the provided destination ResourceLimits_Status from our ResourceLimits_Status
func (limits *ResourceLimits_Status) AssignPropertiesToResourceLimitsStatus(destination *v20211001s.ResourceLimits_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu v20211001s.GpuResource_Status
		err := limits.Gpu.AssignPropertiesToGpuResourceStatus(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGpuResourceStatus() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceRequests
type ResourceRequests struct {
	// +kubebuilder:validation:Required
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU resource.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// +kubebuilder:validation:Required
	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequests{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requests *ResourceRequests) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requests == nil {
		return nil, nil
	}
	result := &ResourceRequestsARM{}

	// Set property ‘Cpu’:
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		result.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if requests.Gpu != nil {
		gpuARM, err := (*requests.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpuARM.(*GpuResourceARM)
		result.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequestsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequestsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequestsARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceRequests populates our ResourceRequests from the provided source ResourceRequests
func (requests *ResourceRequests) AssignPropertiesFromResourceRequests(source *v20211001s.ResourceRequests) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignPropertiesFromGpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGpuResource() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceRequests populates the provided destination ResourceRequests from our ResourceRequests
func (requests *ResourceRequests) AssignPropertiesToResourceRequests(destination *v20211001s.ResourceRequests) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu v20211001s.GpuResource
		err := requests.Gpu.AssignPropertiesToGpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceRequests_Status struct {
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU request of this container instance.
	Gpu *GpuResource_Status `json:"gpu,omitempty"`

	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequests_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequests_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequests_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequests_StatusARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_Status
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceRequestsStatus populates our ResourceRequests_Status from the provided source ResourceRequests_Status
func (requests *ResourceRequests_Status) AssignPropertiesFromResourceRequestsStatus(source *v20211001s.ResourceRequests_Status) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_Status
		err := gpu.AssignPropertiesFromGpuResourceStatus(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromGpuResourceStatus() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceRequestsStatus populates the provided destination ResourceRequests_Status from our ResourceRequests_Status
func (requests *ResourceRequests_Status) AssignPropertiesToResourceRequestsStatus(destination *v20211001s.ResourceRequests_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu v20211001s.GpuResource_Status
		err := requests.Gpu.AssignPropertiesToGpuResourceStatus(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToGpuResourceStatus() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","https"}
type ContainerHttpGetScheme string

const (
	ContainerHttpGetSchemeHttp  = ContainerHttpGetScheme("http")
	ContainerHttpGetSchemeHttps = ContainerHttpGetScheme("https")
)

type ContainerHttpGetStatusScheme string

const (
	ContainerHttpGetStatusSchemeHttp  = ContainerHttpGetStatusScheme("http")
	ContainerHttpGetStatusSchemeHttps = ContainerHttpGetStatusScheme("https")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/GpuResource
type GpuResource struct {
	// +kubebuilder:validation:Required
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: The SKU of the GPU resource.
	Sku *GpuResourceSku `json:"sku,omitempty"`
}

var _ genruntime.ARMTransformer = &GpuResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *GpuResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &GpuResourceARM{}

	// Set property ‘Count’:
	if resource.Count != nil {
		count := *resource.Count
		result.Count = &count
	}

	// Set property ‘Sku’:
	if resource.Sku != nil {
		sku := *resource.Sku
		result.Sku = &sku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GpuResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GpuResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GpuResourceARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignPropertiesFromGpuResource populates our GpuResource from the provided source GpuResource
func (resource *GpuResource) AssignPropertiesFromGpuResource(source *v20211001s.GpuResource) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := GpuResourceSku(*source.Sku)
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignPropertiesToGpuResource populates the provided destination GpuResource from our GpuResource
func (resource *GpuResource) AssignPropertiesToGpuResource(destination *v20211001s.GpuResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GpuResource_Status struct {
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// Sku: The SKU of the GPU resource.
	Sku *GpuResourceStatusSku `json:"sku,omitempty"`
}

var _ genruntime.FromARMConverter = &GpuResource_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GpuResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GpuResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GpuResource_StatusARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignPropertiesFromGpuResourceStatus populates our GpuResource_Status from the provided source GpuResource_Status
func (resource *GpuResource_Status) AssignPropertiesFromGpuResourceStatus(source *v20211001s.GpuResource_Status) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := GpuResourceStatusSku(*source.Sku)
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignPropertiesToGpuResourceStatus populates the provided destination GpuResource_Status from our GpuResource_Status
func (resource *GpuResource_Status) AssignPropertiesToGpuResourceStatus(destination *v20211001s.GpuResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/HttpHeader
type HttpHeader struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpHeader{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (header *HttpHeader) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if header == nil {
		return nil, nil
	}
	result := &HttpHeaderARM{}

	// Set property ‘Name’:
	if header.Name != nil {
		name := *header.Name
		result.Name = &name
	}

	// Set property ‘Value’:
	if header.Value != nil {
		value := *header.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpHeaderARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpHeaderARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpHeaderARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromHttpHeader populates our HttpHeader from the provided source HttpHeader
func (header *HttpHeader) AssignPropertiesFromHttpHeader(source *v20211001s.HttpHeader) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToHttpHeader populates the provided destination HttpHeader from our HttpHeader
func (header *HttpHeader) AssignPropertiesToHttpHeader(destination *v20211001s.HttpHeader) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HttpHeader_Status struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpHeader_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpHeader_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpHeader_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpHeader_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromHttpHeaderStatus populates our HttpHeader_Status from the provided source HttpHeader_Status
func (header *HttpHeader_Status) AssignPropertiesFromHttpHeaderStatus(source *v20211001s.HttpHeader_Status) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToHttpHeaderStatus populates the provided destination HttpHeader_Status from our HttpHeader_Status
func (header *HttpHeader_Status) AssignPropertiesToHttpHeaderStatus(destination *v20211001s.HttpHeader_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"K80","P100","V100"}
type GpuResourceSku string

const (
	GpuResourceSkuK80  = GpuResourceSku("K80")
	GpuResourceSkuP100 = GpuResourceSku("P100")
	GpuResourceSkuV100 = GpuResourceSku("V100")
)

type GpuResourceStatusSku string

const (
	GpuResourceStatusSkuK80  = GpuResourceStatusSku("K80")
	GpuResourceStatusSkuP100 = GpuResourceStatusSku("P100")
	GpuResourceStatusSkuV100 = GpuResourceStatusSku("V100")
)

func init() {
	SchemeBuilder.Register(&ContainerGroup{}, &ContainerGroupList{})
}
