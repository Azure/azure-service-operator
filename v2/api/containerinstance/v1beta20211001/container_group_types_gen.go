// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"fmt"
	v20211001s "github.com/Azure/azure-service-operator/v2/api/containerinstance/v1beta20211001storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/resourceDefinitions/containerGroups
type ContainerGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerGroups_Spec  `json:"spec,omitempty"`
	Status            ContainerGroup_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ContainerGroup{}

// GetConditions returns the conditions of the resource
func (group *ContainerGroup) GetConditions() conditions.Conditions {
	return group.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (group *ContainerGroup) SetConditions(conditions conditions.Conditions) {
	group.Status.Conditions = conditions
}

var _ conversion.Convertible = &ContainerGroup{}

// ConvertFrom populates our ContainerGroup from the provided hub ContainerGroup
func (group *ContainerGroup) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20211001s.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1beta20211001storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignProperties_From_ContainerGroup(source)
}

// ConvertTo populates the provided hub ContainerGroup from our ContainerGroup
func (group *ContainerGroup) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20211001s.ContainerGroup)
	if !ok {
		return fmt.Errorf("expected containerinstance/v1beta20211001storage/ContainerGroup but received %T instead", hub)
	}

	return group.AssignProperties_To_ContainerGroup(destination)
}

// +kubebuilder:webhook:path=/mutate-containerinstance-azure-com-v1beta20211001-containergroup,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1beta20211001,name=default.v1beta20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ContainerGroup{}

// Default applies defaults to the ContainerGroup resource
func (group *ContainerGroup) Default() {
	group.defaultImpl()
	var temp interface{} = group
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (group *ContainerGroup) defaultAzureName() {
	if group.Spec.AzureName == "" {
		group.Spec.AzureName = group.Name
	}
}

// defaultImpl applies the code generated defaults to the ContainerGroup resource
func (group *ContainerGroup) defaultImpl() { group.defaultAzureName() }

var _ genruntime.KubernetesResource = &ContainerGroup{}

// AzureName returns the Azure name of the resource
func (group *ContainerGroup) AzureName() string {
	return group.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-10-01"
func (group ContainerGroup) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (group *ContainerGroup) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (group *ContainerGroup) GetSpec() genruntime.ConvertibleSpec {
	return &group.Spec
}

// GetStatus returns the status of this resource
func (group *ContainerGroup) GetStatus() genruntime.ConvertibleStatus {
	return &group.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerInstance/containerGroups"
func (group *ContainerGroup) GetType() string {
	return "Microsoft.ContainerInstance/containerGroups"
}

// NewEmptyStatus returns a new empty (blank) status
func (group *ContainerGroup) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ContainerGroup_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (group *ContainerGroup) Owner() *genruntime.ResourceReference {
	ownerGroup, ownerKind := genruntime.LookupOwnerGroupKind(group.Spec)
	return &genruntime.ResourceReference{
		Group: ownerGroup,
		Kind:  ownerKind,
		Name:  group.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (group *ContainerGroup) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ContainerGroup_STATUS); ok {
		group.Status = *st
		return nil
	}

	// Convert status to required version
	var st ContainerGroup_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	group.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-containerinstance-azure-com-v1beta20211001-containergroup,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=containerinstance.azure.com,resources=containergroups,verbs=create;update,versions=v1beta20211001,name=validate.v1beta20211001.containergroups.containerinstance.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ContainerGroup{}

// ValidateCreate validates the creation of the resource
func (group *ContainerGroup) ValidateCreate() error {
	validations := group.createValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (group *ContainerGroup) ValidateDelete() error {
	validations := group.deleteValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (group *ContainerGroup) ValidateUpdate(old runtime.Object) error {
	validations := group.updateValidations()
	var temp interface{} = group
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (group *ContainerGroup) createValidations() []func() error {
	return []func() error{group.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (group *ContainerGroup) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (group *ContainerGroup) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return group.validateResourceReferences()
		},
		group.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (group *ContainerGroup) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&group.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (group *ContainerGroup) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*ContainerGroup)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, group)
}

// AssignProperties_From_ContainerGroup populates our ContainerGroup from the provided source ContainerGroup
func (group *ContainerGroup) AssignProperties_From_ContainerGroup(source *v20211001s.ContainerGroup) error {

	// ObjectMeta
	group.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ContainerGroups_Spec
	err := spec.AssignProperties_From_ContainerGroups_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ContainerGroups_Spec() to populate field Spec")
	}
	group.Spec = spec

	// Status
	var status ContainerGroup_STATUS
	err = status.AssignProperties_From_ContainerGroup_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ContainerGroup_STATUS() to populate field Status")
	}
	group.Status = status

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup populates the provided destination ContainerGroup from our ContainerGroup
func (group *ContainerGroup) AssignProperties_To_ContainerGroup(destination *v20211001s.ContainerGroup) error {

	// ObjectMeta
	destination.ObjectMeta = *group.ObjectMeta.DeepCopy()

	// Spec
	var spec v20211001s.ContainerGroups_Spec
	err := group.Spec.AssignProperties_To_ContainerGroups_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ContainerGroups_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20211001s.ContainerGroup_STATUS
	err = group.Status.AssignProperties_To_ContainerGroup_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ContainerGroup_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (group *ContainerGroup) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: group.Spec.OriginalVersion(),
		Kind:    "ContainerGroup",
	}
}

// +kubebuilder:object:root=true
// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/resourceDefinitions/containerGroups
type ContainerGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerGroup `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-10-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-10-01")

type ContainerGroup_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Containers: The containers within the container group.
	Containers []Container_STATUS `json:"containers,omitempty"`

	// Diagnostics: The diagnostic information for a container group.
	Diagnostics *ContainerGroupDiagnostics_STATUS `json:"diagnostics,omitempty"`

	// DnsConfig: The DNS config information for a container group.
	DnsConfig *DnsConfiguration_STATUS `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The encryption properties for a container group.
	EncryptionProperties *EncryptionProperties_STATUS `json:"encryptionProperties,omitempty"`

	// Id: The resource id.
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the container group, if configured.
	Identity *ContainerGroupIdentity_STATUS `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ImageRegistryCredential_STATUS `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []InitContainerDefinition_STATUS `json:"initContainers,omitempty"`

	// InstanceView: The instance view of the container group. Only valid in response.
	InstanceView *ContainerGroup_STATUS_Properties_InstanceView `json:"instanceView,omitempty"`

	// IpAddress: The IP address type of the container group.
	IpAddress *IpAddress_STATUS `json:"ipAddress,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// Name: The resource name.
	Name *string `json:"name,omitempty"`

	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroup_STATUS_Properties_OsType `json:"osType,omitempty"`

	// ProvisioningState: The provisioning state of the container group. This only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	RestartPolicy *ContainerGroup_STATUS_Properties_RestartPolicy `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroupSku_STATUS `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId_STATUS `json:"subnetIds,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume_STATUS `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ContainerGroup_STATUS{}

// ConvertStatusFrom populates our ContainerGroup_STATUS from the provided source
func (group *ContainerGroup_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20211001s.ContainerGroup_STATUS)
	if ok {
		// Populate our instance from source
		return group.AssignProperties_From_ContainerGroup_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20211001s.ContainerGroup_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = group.AssignProperties_From_ContainerGroup_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20211001s.ContainerGroup_STATUS)
	if ok {
		// Populate destination from our instance
		return group.AssignProperties_To_ContainerGroup_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20211001s.ContainerGroup_STATUS{}
	err := group.AssignProperties_To_ContainerGroup_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ContainerGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ContainerGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroup_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ContainerGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroup_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroup_STATUSARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Containers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 Container_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Containers = append(group.Containers, item1)
		}
	}

	// Set property ‘Diagnostics’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics_STATUS
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			group.Diagnostics = &diagnostics
		}
	}

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration_STATUS
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			group.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘EncryptionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties_STATUS
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			group.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		group.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		group.Identity = &identity
	}

	// Set property ‘ImageRegistryCredentials’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ImageRegistryCredential_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.ImageRegistryCredentials = append(group.ImageRegistryCredentials, item1)
		}
	}

	// Set property ‘InitContainers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 InitContainerDefinition_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.InitContainers = append(group.InitContainers, item1)
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerGroup_STATUS_Properties_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			group.InstanceView = &instanceView
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress_STATUS
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			group.IpAddress = &ipAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		group.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			osType := *typedInput.Properties.OsType
			group.OsType = &osType
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			group.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RestartPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			restartPolicy := *typedInput.Properties.RestartPolicy
			group.RestartPolicy = &restartPolicy
		}
	}

	// Set property ‘Sku’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			sku := *typedInput.Properties.Sku
			group.Sku = &sku
		}
	}

	// Set property ‘SubnetIds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.SubnetIds = append(group.SubnetIds, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		group.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			group.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		group.Type = &typeVar
	}

	// Set property ‘Volumes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Volumes = append(group.Volumes, item1)
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		group.Zones = append(group.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroup_STATUS populates our ContainerGroup_STATUS from the provided source ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) AssignProperties_From_ContainerGroup_STATUS(source *v20211001s.ContainerGroup_STATUS) error {

	// Conditions
	group.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		group.Containers = containerList
	} else {
		group.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics_STATUS
		err := diagnostic.AssignProperties_From_ContainerGroupDiagnostics_STATUS(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupDiagnostics_STATUS() to populate field Diagnostics")
		}
		group.Diagnostics = &diagnostic
	} else {
		group.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration_STATUS
		err := dnsConfig.AssignProperties_From_DnsConfiguration_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfiguration_STATUS() to populate field DnsConfig")
		}
		group.DnsConfig = &dnsConfig
	} else {
		group.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties_STATUS
		err := encryptionProperty.AssignProperties_From_EncryptionProperties_STATUS(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperties_STATUS() to populate field EncryptionProperties")
		}
		group.EncryptionProperties = &encryptionProperty
	} else {
		group.EncryptionProperties = nil
	}

	// Id
	group.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity_STATUS
		err := identity.AssignProperties_From_ContainerGroupIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupIdentity_STATUS() to populate field Identity")
		}
		group.Identity = &identity
	} else {
		group.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ImageRegistryCredential_STATUS, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ImageRegistryCredential_STATUS
			err := imageRegistryCredential.AssignProperties_From_ImageRegistryCredential_STATUS(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ImageRegistryCredential_STATUS() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		group.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		group.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]InitContainerDefinition_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer InitContainerDefinition_STATUS
			err := initContainer.AssignProperties_From_InitContainerDefinition_STATUS(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InitContainerDefinition_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		group.InitContainers = initContainerList
	} else {
		group.InitContainers = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerGroup_STATUS_Properties_InstanceView
		err := instanceView.AssignProperties_From_ContainerGroup_STATUS_Properties_InstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroup_STATUS_Properties_InstanceView() to populate field InstanceView")
		}
		group.InstanceView = &instanceView
	} else {
		group.InstanceView = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress_STATUS
		err := ipAddress.AssignProperties_From_IpAddress_STATUS(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IpAddress_STATUS() to populate field IpAddress")
		}
		group.IpAddress = &ipAddress
	} else {
		group.IpAddress = nil
	}

	// Location
	group.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := ContainerGroup_STATUS_Properties_OsType(*source.OsType)
		group.OsType = &osType
	} else {
		group.OsType = nil
	}

	// ProvisioningState
	group.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := ContainerGroup_STATUS_Properties_RestartPolicy(*source.RestartPolicy)
		group.RestartPolicy = &restartPolicy
	} else {
		group.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := ContainerGroupSku_STATUS(*source.Sku)
		group.Sku = &sku
	} else {
		group.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId_STATUS, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId_STATUS
			err := subnetId.AssignProperties_From_ContainerGroupSubnetId_STATUS(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupSubnetId_STATUS() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		group.SubnetIds = subnetIdList
	} else {
		group.SubnetIds = nil
	}

	// Tags
	group.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	group.Type = genruntime.ClonePointerToString(source.Type)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		group.Volumes = volumeList
	} else {
		group.Volumes = nil
	}

	// Zones
	group.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup_STATUS populates the provided destination ContainerGroup_STATUS from our ContainerGroup_STATUS
func (group *ContainerGroup_STATUS) AssignProperties_To_ContainerGroup_STATUS(destination *v20211001s.ContainerGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(group.Conditions)

	// Containers
	if group.Containers != nil {
		containerList := make([]v20211001s.Container_STATUS, len(group.Containers))
		for containerIndex, containerItem := range group.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container v20211001s.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if group.Diagnostics != nil {
		var diagnostic v20211001s.ContainerGroupDiagnostics_STATUS
		err := group.Diagnostics.AssignProperties_To_ContainerGroupDiagnostics_STATUS(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupDiagnostics_STATUS() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if group.DnsConfig != nil {
		var dnsConfig v20211001s.DnsConfiguration_STATUS
		err := group.DnsConfig.AssignProperties_To_DnsConfiguration_STATUS(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfiguration_STATUS() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if group.EncryptionProperties != nil {
		var encryptionProperty v20211001s.EncryptionProperties_STATUS
		err := group.EncryptionProperties.AssignProperties_To_EncryptionProperties_STATUS(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperties_STATUS() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(group.Id)

	// Identity
	if group.Identity != nil {
		var identity v20211001s.ContainerGroupIdentity_STATUS
		err := group.Identity.AssignProperties_To_ContainerGroupIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if group.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]v20211001s.ImageRegistryCredential_STATUS, len(group.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range group.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential v20211001s.ImageRegistryCredential_STATUS
			err := imageRegistryCredentialItem.AssignProperties_To_ImageRegistryCredential_STATUS(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ImageRegistryCredential_STATUS() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if group.InitContainers != nil {
		initContainerList := make([]v20211001s.InitContainerDefinition_STATUS, len(group.InitContainers))
		for initContainerIndex, initContainerItem := range group.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer v20211001s.InitContainerDefinition_STATUS
			err := initContainerItem.AssignProperties_To_InitContainerDefinition_STATUS(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InitContainerDefinition_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// InstanceView
	if group.InstanceView != nil {
		var instanceView v20211001s.ContainerGroup_STATUS_Properties_InstanceView
		err := group.InstanceView.AssignProperties_To_ContainerGroup_STATUS_Properties_InstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroup_STATUS_Properties_InstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// IpAddress
	if group.IpAddress != nil {
		var ipAddress v20211001s.IpAddress_STATUS
		err := group.IpAddress.AssignProperties_To_IpAddress_STATUS(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IpAddress_STATUS() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(group.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// OsType
	if group.OsType != nil {
		osType := string(*group.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(group.ProvisioningState)

	// RestartPolicy
	if group.RestartPolicy != nil {
		restartPolicy := string(*group.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if group.Sku != nil {
		sku := string(*group.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if group.SubnetIds != nil {
		subnetIdList := make([]v20211001s.ContainerGroupSubnetId_STATUS, len(group.SubnetIds))
		for subnetIdIndex, subnetIdItem := range group.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId v20211001s.ContainerGroupSubnetId_STATUS
			err := subnetIdItem.AssignProperties_To_ContainerGroupSubnetId_STATUS(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupSubnetId_STATUS() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(group.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(group.Type)

	// Volumes
	if group.Volumes != nil {
		volumeList := make([]v20211001s.Volume_STATUS, len(group.Volumes))
		for volumeIndex, volumeItem := range group.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume v20211001s.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(group.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Containers: The containers within the container group.
	Containers []ContainerGroups_Spec_Properties_Containers `json:"containers,omitempty"`

	// Diagnostics: Container group diagnostic information.
	Diagnostics *ContainerGroupDiagnostics `json:"diagnostics,omitempty"`

	// DnsConfig: DNS configuration for the container group.
	DnsConfig *DnsConfiguration `json:"dnsConfig,omitempty"`

	// EncryptionProperties: The container group encryption properties.
	EncryptionProperties *EncryptionProperties `json:"encryptionProperties,omitempty"`

	// Identity: Identity for the container group.
	Identity *ContainerGroupIdentity `json:"identity,omitempty"`

	// ImageRegistryCredentials: The image registry credentials by which the container group is created from.
	ImageRegistryCredentials []ContainerGroups_Spec_Properties_ImageRegistryCredentials `json:"imageRegistryCredentials,omitempty"`

	// InitContainers: The init containers for a container group.
	InitContainers []ContainerGroups_Spec_Properties_InitContainers `json:"initContainers,omitempty"`

	// IpAddress: IP address for the container group.
	IpAddress *IpAddress `json:"ipAddress,omitempty"`

	// Location: Location to deploy resource to
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// OsType: The operating system type required by the containers in the container group.
	OsType *ContainerGroups_Spec_Properties_OsType `json:"osType,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// RestartPolicy: Restart policy for all containers within the container group.
	// - `Always` Always restart
	// - `OnFailure` Restart on failure
	// - `Never` Never restart
	// .
	RestartPolicy *ContainerGroups_Spec_Properties_RestartPolicy `json:"restartPolicy,omitempty"`

	// Sku: The SKU for a container group.
	Sku *ContainerGroups_Spec_Properties_Sku `json:"sku,omitempty"`

	// SubnetIds: The subnet resource IDs for a container group.
	SubnetIds []ContainerGroupSubnetId `json:"subnetIds,omitempty"`

	// Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	// Volumes: The list of volumes that can be mounted by containers in this container group.
	Volumes []Volume `json:"volumes,omitempty"`

	// Zones: The zones for the container group.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (groups *ContainerGroups_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if groups == nil {
		return nil, nil
	}
	result := &ContainerGroups_SpecARM{}

	// Set property ‘Identity’:
	if groups.Identity != nil {
		identityARM, err := (*groups.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identityARM.(*ContainerGroupIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if groups.Location != nil {
		location := *groups.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if groups.Containers != nil ||
		groups.Diagnostics != nil ||
		groups.DnsConfig != nil ||
		groups.EncryptionProperties != nil ||
		groups.ImageRegistryCredentials != nil ||
		groups.InitContainers != nil ||
		groups.IpAddress != nil ||
		groups.OsType != nil ||
		groups.RestartPolicy != nil ||
		groups.Sku != nil ||
		groups.SubnetIds != nil ||
		groups.Volumes != nil {
		result.Properties = &ContainerGroups_Spec_PropertiesARM{}
	}
	for _, item := range groups.Containers {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Containers = append(result.Properties.Containers, *itemARM.(*ContainerGroups_Spec_Properties_ContainersARM))
	}
	if groups.Diagnostics != nil {
		diagnosticsARM, err := (*groups.Diagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnostics := *diagnosticsARM.(*ContainerGroupDiagnosticsARM)
		result.Properties.Diagnostics = &diagnostics
	}
	if groups.DnsConfig != nil {
		dnsConfigARM, err := (*groups.DnsConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfigARM.(*DnsConfigurationARM)
		result.Properties.DnsConfig = &dnsConfig
	}
	if groups.EncryptionProperties != nil {
		encryptionPropertiesARM, err := (*groups.EncryptionProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionProperties := *encryptionPropertiesARM.(*EncryptionPropertiesARM)
		result.Properties.EncryptionProperties = &encryptionProperties
	}
	for _, item := range groups.ImageRegistryCredentials {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ImageRegistryCredentials = append(result.Properties.ImageRegistryCredentials, *itemARM.(*ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM))
	}
	for _, item := range groups.InitContainers {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InitContainers = append(result.Properties.InitContainers, *itemARM.(*ContainerGroups_Spec_Properties_InitContainersARM))
	}
	if groups.IpAddress != nil {
		ipAddressARM, err := (*groups.IpAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ipAddress := *ipAddressARM.(*IpAddressARM)
		result.Properties.IpAddress = &ipAddress
	}
	if groups.OsType != nil {
		osType := *groups.OsType
		result.Properties.OsType = &osType
	}
	if groups.RestartPolicy != nil {
		restartPolicy := *groups.RestartPolicy
		result.Properties.RestartPolicy = &restartPolicy
	}
	if groups.Sku != nil {
		sku := *groups.Sku
		result.Properties.Sku = &sku
	}
	for _, item := range groups.SubnetIds {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SubnetIds = append(result.Properties.SubnetIds, *itemARM.(*ContainerGroupSubnetIdARM))
	}
	for _, item := range groups.Volumes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Volumes = append(result.Properties.Volumes, *itemARM.(*VolumeARM))
	}

	// Set property ‘Tags’:
	if groups.Tags != nil {
		result.Tags = make(map[string]string, len(groups.Tags))
		for key, value := range groups.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range groups.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (groups *ContainerGroups_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (groups *ContainerGroups_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	groups.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Containers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Containers {
			var item1 ContainerGroups_Spec_Properties_Containers
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.Containers = append(groups.Containers, item1)
		}
	}

	// Set property ‘Diagnostics’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Diagnostics != nil {
			var diagnostics1 ContainerGroupDiagnostics
			err := diagnostics1.PopulateFromARM(owner, *typedInput.Properties.Diagnostics)
			if err != nil {
				return err
			}
			diagnostics := diagnostics1
			groups.Diagnostics = &diagnostics
		}
	}

	// Set property ‘DnsConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfiguration
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			groups.DnsConfig = &dnsConfig
		}
	}

	// Set property ‘EncryptionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionProperties != nil {
			var encryptionProperties1 EncryptionProperties
			err := encryptionProperties1.PopulateFromARM(owner, *typedInput.Properties.EncryptionProperties)
			if err != nil {
				return err
			}
			encryptionProperties := encryptionProperties1
			groups.EncryptionProperties = &encryptionProperties
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ContainerGroupIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		groups.Identity = &identity
	}

	// Set property ‘ImageRegistryCredentials’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ImageRegistryCredentials {
			var item1 ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.ImageRegistryCredentials = append(groups.ImageRegistryCredentials, item1)
		}
	}

	// Set property ‘InitContainers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InitContainers {
			var item1 ContainerGroups_Spec_Properties_InitContainers
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.InitContainers = append(groups.InitContainers, item1)
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			var ipAddress1 IpAddress
			err := ipAddress1.PopulateFromARM(owner, *typedInput.Properties.IpAddress)
			if err != nil {
				return err
			}
			ipAddress := ipAddress1
			groups.IpAddress = &ipAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		groups.Location = &location
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			osType := *typedInput.Properties.OsType
			groups.OsType = &osType
		}
	}

	// Set property ‘Owner’:
	groups.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘RestartPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestartPolicy != nil {
			restartPolicy := *typedInput.Properties.RestartPolicy
			groups.RestartPolicy = &restartPolicy
		}
	}

	// Set property ‘Sku’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			sku := *typedInput.Properties.Sku
			groups.Sku = &sku
		}
	}

	// Set property ‘SubnetIds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SubnetIds {
			var item1 ContainerGroupSubnetId
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.SubnetIds = append(groups.SubnetIds, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		groups.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			groups.Tags[key] = value
		}
	}

	// Set property ‘Volumes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Volumes {
			var item1 Volume
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			groups.Volumes = append(groups.Volumes, item1)
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		groups.Zones = append(groups.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ContainerGroups_Spec{}

// ConvertSpecFrom populates our ContainerGroups_Spec from the provided source
func (groups *ContainerGroups_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20211001s.ContainerGroups_Spec)
	if ok {
		// Populate our instance from source
		return groups.AssignProperties_From_ContainerGroups_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20211001s.ContainerGroups_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = groups.AssignProperties_From_ContainerGroups_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ContainerGroups_Spec
func (groups *ContainerGroups_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20211001s.ContainerGroups_Spec)
	if ok {
		// Populate destination from our instance
		return groups.AssignProperties_To_ContainerGroups_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20211001s.ContainerGroups_Spec{}
	err := groups.AssignProperties_To_ContainerGroups_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ContainerGroups_Spec populates our ContainerGroups_Spec from the provided source ContainerGroups_Spec
func (groups *ContainerGroups_Spec) AssignProperties_From_ContainerGroups_Spec(source *v20211001s.ContainerGroups_Spec) error {

	// AzureName
	groups.AzureName = source.AzureName

	// Containers
	if source.Containers != nil {
		containerList := make([]ContainerGroups_Spec_Properties_Containers, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container ContainerGroups_Spec_Properties_Containers
			err := container.AssignProperties_From_ContainerGroups_Spec_Properties_Containers(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroups_Spec_Properties_Containers() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		groups.Containers = containerList
	} else {
		groups.Containers = nil
	}

	// Diagnostics
	if source.Diagnostics != nil {
		var diagnostic ContainerGroupDiagnostics
		err := diagnostic.AssignProperties_From_ContainerGroupDiagnostics(source.Diagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupDiagnostics() to populate field Diagnostics")
		}
		groups.Diagnostics = &diagnostic
	} else {
		groups.Diagnostics = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfiguration
		err := dnsConfig.AssignProperties_From_DnsConfiguration(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfiguration() to populate field DnsConfig")
		}
		groups.DnsConfig = &dnsConfig
	} else {
		groups.DnsConfig = nil
	}

	// EncryptionProperties
	if source.EncryptionProperties != nil {
		var encryptionProperty EncryptionProperties
		err := encryptionProperty.AssignProperties_From_EncryptionProperties(source.EncryptionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperties() to populate field EncryptionProperties")
		}
		groups.EncryptionProperties = &encryptionProperty
	} else {
		groups.EncryptionProperties = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ContainerGroupIdentity
		err := identity.AssignProperties_From_ContainerGroupIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupIdentity() to populate field Identity")
		}
		groups.Identity = &identity
	} else {
		groups.Identity = nil
	}

	// ImageRegistryCredentials
	if source.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]ContainerGroups_Spec_Properties_ImageRegistryCredentials, len(source.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range source.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := imageRegistryCredential.AssignProperties_From_ContainerGroups_Spec_Properties_ImageRegistryCredentials(&imageRegistryCredentialItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroups_Spec_Properties_ImageRegistryCredentials() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		groups.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		groups.ImageRegistryCredentials = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]ContainerGroups_Spec_Properties_InitContainers, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer ContainerGroups_Spec_Properties_InitContainers
			err := initContainer.AssignProperties_From_ContainerGroups_Spec_Properties_InitContainers(&initContainerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroups_Spec_Properties_InitContainers() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		groups.InitContainers = initContainerList
	} else {
		groups.InitContainers = nil
	}

	// IpAddress
	if source.IpAddress != nil {
		var ipAddress IpAddress
		err := ipAddress.AssignProperties_From_IpAddress(source.IpAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IpAddress() to populate field IpAddress")
		}
		groups.IpAddress = &ipAddress
	} else {
		groups.IpAddress = nil
	}

	// Location
	groups.Location = genruntime.ClonePointerToString(source.Location)

	// OsType
	if source.OsType != nil {
		osType := ContainerGroups_Spec_Properties_OsType(*source.OsType)
		groups.OsType = &osType
	} else {
		groups.OsType = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		groups.Owner = &owner
	} else {
		groups.Owner = nil
	}

	// RestartPolicy
	if source.RestartPolicy != nil {
		restartPolicy := ContainerGroups_Spec_Properties_RestartPolicy(*source.RestartPolicy)
		groups.RestartPolicy = &restartPolicy
	} else {
		groups.RestartPolicy = nil
	}

	// Sku
	if source.Sku != nil {
		sku := ContainerGroups_Spec_Properties_Sku(*source.Sku)
		groups.Sku = &sku
	} else {
		groups.Sku = nil
	}

	// SubnetIds
	if source.SubnetIds != nil {
		subnetIdList := make([]ContainerGroupSubnetId, len(source.SubnetIds))
		for subnetIdIndex, subnetIdItem := range source.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId ContainerGroupSubnetId
			err := subnetId.AssignProperties_From_ContainerGroupSubnetId(&subnetIdItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		groups.SubnetIds = subnetIdList
	} else {
		groups.SubnetIds = nil
	}

	// Tags
	groups.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		groups.Volumes = volumeList
	} else {
		groups.Volumes = nil
	}

	// Zones
	groups.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroups_Spec populates the provided destination ContainerGroups_Spec from our ContainerGroups_Spec
func (groups *ContainerGroups_Spec) AssignProperties_To_ContainerGroups_Spec(destination *v20211001s.ContainerGroups_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = groups.AzureName

	// Containers
	if groups.Containers != nil {
		containerList := make([]v20211001s.ContainerGroups_Spec_Properties_Containers, len(groups.Containers))
		for containerIndex, containerItem := range groups.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container v20211001s.ContainerGroups_Spec_Properties_Containers
			err := containerItem.AssignProperties_To_ContainerGroups_Spec_Properties_Containers(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroups_Spec_Properties_Containers() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// Diagnostics
	if groups.Diagnostics != nil {
		var diagnostic v20211001s.ContainerGroupDiagnostics
		err := groups.Diagnostics.AssignProperties_To_ContainerGroupDiagnostics(&diagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupDiagnostics() to populate field Diagnostics")
		}
		destination.Diagnostics = &diagnostic
	} else {
		destination.Diagnostics = nil
	}

	// DnsConfig
	if groups.DnsConfig != nil {
		var dnsConfig v20211001s.DnsConfiguration
		err := groups.DnsConfig.AssignProperties_To_DnsConfiguration(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfiguration() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// EncryptionProperties
	if groups.EncryptionProperties != nil {
		var encryptionProperty v20211001s.EncryptionProperties
		err := groups.EncryptionProperties.AssignProperties_To_EncryptionProperties(&encryptionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperties() to populate field EncryptionProperties")
		}
		destination.EncryptionProperties = &encryptionProperty
	} else {
		destination.EncryptionProperties = nil
	}

	// Identity
	if groups.Identity != nil {
		var identity v20211001s.ContainerGroupIdentity
		err := groups.Identity.AssignProperties_To_ContainerGroupIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageRegistryCredentials
	if groups.ImageRegistryCredentials != nil {
		imageRegistryCredentialList := make([]v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials, len(groups.ImageRegistryCredentials))
		for imageRegistryCredentialIndex, imageRegistryCredentialItem := range groups.ImageRegistryCredentials {
			// Shadow the loop variable to avoid aliasing
			imageRegistryCredentialItem := imageRegistryCredentialItem
			var imageRegistryCredential v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials
			err := imageRegistryCredentialItem.AssignProperties_To_ContainerGroups_Spec_Properties_ImageRegistryCredentials(&imageRegistryCredential)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroups_Spec_Properties_ImageRegistryCredentials() to populate field ImageRegistryCredentials")
			}
			imageRegistryCredentialList[imageRegistryCredentialIndex] = imageRegistryCredential
		}
		destination.ImageRegistryCredentials = imageRegistryCredentialList
	} else {
		destination.ImageRegistryCredentials = nil
	}

	// InitContainers
	if groups.InitContainers != nil {
		initContainerList := make([]v20211001s.ContainerGroups_Spec_Properties_InitContainers, len(groups.InitContainers))
		for initContainerIndex, initContainerItem := range groups.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer v20211001s.ContainerGroups_Spec_Properties_InitContainers
			err := initContainerItem.AssignProperties_To_ContainerGroups_Spec_Properties_InitContainers(&initContainer)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroups_Spec_Properties_InitContainers() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// IpAddress
	if groups.IpAddress != nil {
		var ipAddress v20211001s.IpAddress
		err := groups.IpAddress.AssignProperties_To_IpAddress(&ipAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IpAddress() to populate field IpAddress")
		}
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(groups.Location)

	// OriginalVersion
	destination.OriginalVersion = groups.OriginalVersion()

	// OsType
	if groups.OsType != nil {
		osType := string(*groups.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Owner
	if groups.Owner != nil {
		owner := groups.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RestartPolicy
	if groups.RestartPolicy != nil {
		restartPolicy := string(*groups.RestartPolicy)
		destination.RestartPolicy = &restartPolicy
	} else {
		destination.RestartPolicy = nil
	}

	// Sku
	if groups.Sku != nil {
		sku := string(*groups.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SubnetIds
	if groups.SubnetIds != nil {
		subnetIdList := make([]v20211001s.ContainerGroupSubnetId, len(groups.SubnetIds))
		for subnetIdIndex, subnetIdItem := range groups.SubnetIds {
			// Shadow the loop variable to avoid aliasing
			subnetIdItem := subnetIdItem
			var subnetId v20211001s.ContainerGroupSubnetId
			err := subnetIdItem.AssignProperties_To_ContainerGroupSubnetId(&subnetId)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupSubnetId() to populate field SubnetIds")
			}
			subnetIdList[subnetIdIndex] = subnetId
		}
		destination.SubnetIds = subnetIdList
	} else {
		destination.SubnetIds = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(groups.Tags)

	// Volumes
	if groups.Volumes != nil {
		volumeList := make([]v20211001s.Volume, len(groups.Volumes))
		for volumeIndex, volumeItem := range groups.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume v20211001s.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(groups.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (groups *ContainerGroups_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (groups *ContainerGroups_Spec) SetAzureName(azureName string) { groups.AzureName = azureName }

type Container_STATUS struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable_STATUS `json:"environmentVariables,omitempty"`

	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the container instance. Only valid in response.
	InstanceView *ContainerProperties_STATUS_InstanceView `json:"instanceView,omitempty"`

	// LivenessProbe: The liveness probe.
	LivenessProbe *ContainerProbe_STATUS `json:"livenessProbe,omitempty"`

	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort_STATUS `json:"ports,omitempty"`

	// ReadinessProbe: The readiness probe.
	ReadinessProbe *ContainerProbe_STATUS `json:"readinessProbe,omitempty"`

	// Resources: The resource requirements of the container instance.
	Resources *ResourceRequirements_STATUS `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &Container_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Container_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Container_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Container_STATUSARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			container.Command = append(container.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.EnvironmentVariables = append(container.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			container.Image = &image
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 ContainerProperties_STATUS_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			container.InstanceView = &instanceView
		}
	}

	// Set property ‘LivenessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe_STATUS
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			container.LivenessProbe = &livenessProbe
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property ‘Ports’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.Ports = append(container.Ports, item1)
		}
	}

	// Set property ‘ReadinessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe_STATUS
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			container.ReadinessProbe = &readinessProbe
		}
	}

	// Set property ‘Resources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements_STATUS
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			container.Resources = &resources
		}
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			container.VolumeMounts = append(container.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Container_STATUS populates our Container_STATUS from the provided source Container_STATUS
func (container *Container_STATUS) AssignProperties_From_Container_STATUS(source *v20211001s.Container_STATUS) error {

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_STATUS, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_STATUS
			err := environmentVariable.AssignProperties_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		container.EnvironmentVariables = environmentVariableList
	} else {
		container.EnvironmentVariables = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView ContainerProperties_STATUS_InstanceView
		err := instanceView.AssignProperties_From_ContainerProperties_STATUS_InstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProperties_STATUS_InstanceView() to populate field InstanceView")
		}
		container.InstanceView = &instanceView
	} else {
		container.InstanceView = nil
	}

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe_STATUS
		err := livenessProbe.AssignProperties_From_ContainerProbe_STATUS(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe_STATUS() to populate field LivenessProbe")
		}
		container.LivenessProbe = &livenessProbe
	} else {
		container.LivenessProbe = nil
	}

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort_STATUS, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort_STATUS
			err := port.AssignProperties_From_ContainerPort_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerPort_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		container.Ports = portList
	} else {
		container.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe_STATUS
		err := readinessProbe.AssignProperties_From_ContainerProbe_STATUS(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe_STATUS() to populate field ReadinessProbe")
		}
		container.ReadinessProbe = &readinessProbe
	} else {
		container.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements_STATUS
		err := resource.AssignProperties_From_ResourceRequirements_STATUS(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequirements_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Container_STATUS populates the provided destination Container_STATUS from our Container_STATUS
func (container *Container_STATUS) AssignProperties_To_Container_STATUS(destination *v20211001s.Container_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// EnvironmentVariables
	if container.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable_STATUS, len(container.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range container.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable_STATUS
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable_STATUS(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// InstanceView
	if container.InstanceView != nil {
		var instanceView v20211001s.ContainerProperties_STATUS_InstanceView
		err := container.InstanceView.AssignProperties_To_ContainerProperties_STATUS_InstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProperties_STATUS_InstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LivenessProbe
	if container.LivenessProbe != nil {
		var livenessProbe v20211001s.ContainerProbe_STATUS
		err := container.LivenessProbe.AssignProperties_To_ContainerProbe_STATUS(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe_STATUS() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Ports
	if container.Ports != nil {
		portList := make([]v20211001s.ContainerPort_STATUS, len(container.Ports))
		for portIndex, portItem := range container.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.ContainerPort_STATUS
			err := portItem.AssignProperties_To_ContainerPort_STATUS(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerPort_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if container.ReadinessProbe != nil {
		var readinessProbe v20211001s.ContainerProbe_STATUS
		err := container.ReadinessProbe.AssignProperties_To_ContainerProbe_STATUS(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe_STATUS() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if container.Resources != nil {
		var resource v20211001s.ResourceRequirements_STATUS
		err := container.Resources.AssignProperties_To_ResourceRequirements_STATUS(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequirements_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroup_STATUS_Properties_InstanceView struct {
	// Events: The events of this container group.
	Events []Event_STATUS `json:"events,omitempty"`

	// State: The state of the container group. Only valid in response.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroup_STATUS_Properties_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerGroup_STATUS_Properties_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroup_STATUS_Properties_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerGroup_STATUS_Properties_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroup_STATUS_Properties_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroup_STATUS_Properties_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘State’:
	if typedInput.State != nil {
		state := *typedInput.State
		view.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroup_STATUS_Properties_InstanceView populates our ContainerGroup_STATUS_Properties_InstanceView from the provided source ContainerGroup_STATUS_Properties_InstanceView
func (view *ContainerGroup_STATUS_Properties_InstanceView) AssignProperties_From_ContainerGroup_STATUS_Properties_InstanceView(source *v20211001s.ContainerGroup_STATUS_Properties_InstanceView) error {

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// State
	view.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroup_STATUS_Properties_InstanceView populates the provided destination ContainerGroup_STATUS_Properties_InstanceView from our ContainerGroup_STATUS_Properties_InstanceView
func (view *ContainerGroup_STATUS_Properties_InstanceView) AssignProperties_To_ContainerGroup_STATUS_Properties_InstanceView(destination *v20211001s.ContainerGroup_STATUS_Properties_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(view.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroup_STATUS_Properties_OsType string

const (
	ContainerGroup_STATUS_Properties_OsType_Linux   = ContainerGroup_STATUS_Properties_OsType("Linux")
	ContainerGroup_STATUS_Properties_OsType_Windows = ContainerGroup_STATUS_Properties_OsType("Windows")
)

type ContainerGroup_STATUS_Properties_RestartPolicy string

const (
	ContainerGroup_STATUS_Properties_RestartPolicy_Always    = ContainerGroup_STATUS_Properties_RestartPolicy("Always")
	ContainerGroup_STATUS_Properties_RestartPolicy_Never     = ContainerGroup_STATUS_Properties_RestartPolicy("Never")
	ContainerGroup_STATUS_Properties_RestartPolicy_OnFailure = ContainerGroup_STATUS_Properties_RestartPolicy("OnFailure")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupDiagnostics
type ContainerGroupDiagnostics struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics `json:"logAnalytics,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnostics *ContainerGroupDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnostics == nil {
		return nil, nil
	}
	result := &ContainerGroupDiagnosticsARM{}

	// Set property ‘LogAnalytics’:
	if diagnostics.LogAnalytics != nil {
		logAnalyticsARM, err := (*diagnostics.LogAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logAnalytics := *logAnalyticsARM.(*LogAnalyticsARM)
		result.LogAnalytics = &logAnalytics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupDiagnosticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupDiagnosticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupDiagnosticsARM, got %T", armInput)
	}

	// Set property ‘LogAnalytics’:
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupDiagnostics populates our ContainerGroupDiagnostics from the provided source ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignProperties_From_ContainerGroupDiagnostics(source *v20211001s.ContainerGroupDiagnostics) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics
		err := logAnalytic.AssignProperties_From_LogAnalytics(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LogAnalytics() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupDiagnostics populates the provided destination ContainerGroupDiagnostics from our ContainerGroupDiagnostics
func (diagnostics *ContainerGroupDiagnostics) AssignProperties_To_ContainerGroupDiagnostics(destination *v20211001s.ContainerGroupDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic v20211001s.LogAnalytics
		err := diagnostics.LogAnalytics.AssignProperties_To_LogAnalytics(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LogAnalytics() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupDiagnostics_STATUS struct {
	// LogAnalytics: Container group log analytics information.
	LogAnalytics *LogAnalytics_STATUS `json:"logAnalytics,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupDiagnostics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *ContainerGroupDiagnostics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupDiagnostics_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *ContainerGroupDiagnostics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupDiagnostics_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupDiagnostics_STATUSARM, got %T", armInput)
	}

	// Set property ‘LogAnalytics’:
	if typedInput.LogAnalytics != nil {
		var logAnalytics1 LogAnalytics_STATUS
		err := logAnalytics1.PopulateFromARM(owner, *typedInput.LogAnalytics)
		if err != nil {
			return err
		}
		logAnalytics := logAnalytics1
		diagnostics.LogAnalytics = &logAnalytics
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupDiagnostics_STATUS populates our ContainerGroupDiagnostics_STATUS from the provided source ContainerGroupDiagnostics_STATUS
func (diagnostics *ContainerGroupDiagnostics_STATUS) AssignProperties_From_ContainerGroupDiagnostics_STATUS(source *v20211001s.ContainerGroupDiagnostics_STATUS) error {

	// LogAnalytics
	if source.LogAnalytics != nil {
		var logAnalytic LogAnalytics_STATUS
		err := logAnalytic.AssignProperties_From_LogAnalytics_STATUS(source.LogAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LogAnalytics_STATUS() to populate field LogAnalytics")
		}
		diagnostics.LogAnalytics = &logAnalytic
	} else {
		diagnostics.LogAnalytics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupDiagnostics_STATUS populates the provided destination ContainerGroupDiagnostics_STATUS from our ContainerGroupDiagnostics_STATUS
func (diagnostics *ContainerGroupDiagnostics_STATUS) AssignProperties_To_ContainerGroupDiagnostics_STATUS(destination *v20211001s.ContainerGroupDiagnostics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalytics
	if diagnostics.LogAnalytics != nil {
		var logAnalytic v20211001s.LogAnalytics_STATUS
		err := diagnostics.LogAnalytics.AssignProperties_To_LogAnalytics_STATUS(&logAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LogAnalytics_STATUS() to populate field LogAnalytics")
		}
		destination.LogAnalytics = &logAnalytic
	} else {
		destination.LogAnalytics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupIdentity
type ContainerGroupIdentity struct {
	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ContainerGroupIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ContainerGroupIdentityARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupIdentity populates our ContainerGroupIdentity from the provided source ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignProperties_From_ContainerGroupIdentity(source *v20211001s.ContainerGroupIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ContainerGroupIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupIdentity populates the provided destination ContainerGroupIdentity from our ContainerGroupIdentity
func (identity *ContainerGroupIdentity) AssignProperties_To_ContainerGroupIdentity(destination *v20211001s.ContainerGroupIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupIdentity_STATUS struct {
	// PrincipalId: The principal id of the container group identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the container group. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// container group.
	Type *ContainerGroupIdentity_STATUS_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the container group. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ContainerGroupIdentity_STATUS_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ContainerGroupIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentity_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ContainerGroupIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentity_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentity_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ContainerGroupIdentity_STATUS_UserAssignedIdentities, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ContainerGroupIdentity_STATUS_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupIdentity_STATUS populates our ContainerGroupIdentity_STATUS from the provided source ContainerGroupIdentity_STATUS
func (identity *ContainerGroupIdentity_STATUS) AssignProperties_From_ContainerGroupIdentity_STATUS(source *v20211001s.ContainerGroupIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ContainerGroupIdentity_STATUS_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ContainerGroupIdentity_STATUS_UserAssignedIdentities, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ContainerGroupIdentity_STATUS_UserAssignedIdentities
			err := userAssignedIdentity.AssignProperties_From_ContainerGroupIdentity_STATUS_UserAssignedIdentities(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerGroupIdentity_STATUS_UserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupIdentity_STATUS populates the provided destination ContainerGroupIdentity_STATUS from our ContainerGroupIdentity_STATUS
func (identity *ContainerGroupIdentity_STATUS) AssignProperties_To_ContainerGroupIdentity_STATUS(destination *v20211001s.ContainerGroupIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20211001s.ContainerGroupIdentity_STATUS_UserAssignedIdentities, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20211001s.ContainerGroupIdentity_STATUS_UserAssignedIdentities
			err := userAssignedIdentityValue.AssignProperties_To_ContainerGroupIdentity_STATUS_UserAssignedIdentities(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerGroupIdentity_STATUS_UserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec_Properties_Containers struct {
	// Command: The commands to execute within the container instance in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the container instance.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// +kubebuilder:validation:Required
	// Image: The name of the image used to create the container instance.
	Image *string `json:"image,omitempty"`

	// LivenessProbe: The container probe, for liveness or readiness
	LivenessProbe *ContainerProbe `json:"livenessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The user-provided name of the container instance.
	Name *string `json:"name,omitempty"`

	// Ports: The exposed ports on the container instance.
	Ports []ContainerPort `json:"ports,omitempty"`

	// ReadinessProbe: The container probe, for liveness or readiness
	ReadinessProbe *ContainerProbe `json:"readinessProbe,omitempty"`

	// +kubebuilder:validation:Required
	// Resources: The resource requirements.
	Resources *ResourceRequirements `json:"resources,omitempty"`

	// VolumeMounts: The volume mounts available to the container instance.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_Containers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containers *ContainerGroups_Spec_Properties_Containers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containers == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_ContainersARM{}

	// Set property ‘Name’:
	if containers.Name != nil {
		name := *containers.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if containers.Command != nil ||
		containers.EnvironmentVariables != nil ||
		containers.Image != nil ||
		containers.LivenessProbe != nil ||
		containers.Ports != nil ||
		containers.ReadinessProbe != nil ||
		containers.Resources != nil ||
		containers.VolumeMounts != nil {
		result.Properties = &ContainerPropertiesARM{}
	}
	for _, item := range containers.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range containers.EnvironmentVariables {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *itemARM.(*EnvironmentVariableARM))
	}
	if containers.Image != nil {
		image := *containers.Image
		result.Properties.Image = &image
	}
	if containers.LivenessProbe != nil {
		livenessProbeARM, err := (*containers.LivenessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		livenessProbe := *livenessProbeARM.(*ContainerProbeARM)
		result.Properties.LivenessProbe = &livenessProbe
	}
	for _, item := range containers.Ports {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Ports = append(result.Properties.Ports, *itemARM.(*ContainerPortARM))
	}
	if containers.ReadinessProbe != nil {
		readinessProbeARM, err := (*containers.ReadinessProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		readinessProbe := *readinessProbeARM.(*ContainerProbeARM)
		result.Properties.ReadinessProbe = &readinessProbe
	}
	if containers.Resources != nil {
		resourcesARM, err := (*containers.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resourcesARM.(*ResourceRequirementsARM)
		result.Properties.Resources = &resources
	}
	for _, item := range containers.VolumeMounts {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *itemARM.(*VolumeMountARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containers *ContainerGroups_Spec_Properties_Containers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_ContainersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containers *ContainerGroups_Spec_Properties_Containers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_ContainersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_ContainersARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			containers.Command = append(containers.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.EnvironmentVariables = append(containers.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			containers.Image = &image
		}
	}

	// Set property ‘LivenessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LivenessProbe != nil {
			var livenessProbe1 ContainerProbe
			err := livenessProbe1.PopulateFromARM(owner, *typedInput.Properties.LivenessProbe)
			if err != nil {
				return err
			}
			livenessProbe := livenessProbe1
			containers.LivenessProbe = &livenessProbe
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		containers.Name = &name
	}

	// Set property ‘Ports’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Ports {
			var item1 ContainerPort
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.Ports = append(containers.Ports, item1)
		}
	}

	// Set property ‘ReadinessProbe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadinessProbe != nil {
			var readinessProbe1 ContainerProbe
			err := readinessProbe1.PopulateFromARM(owner, *typedInput.Properties.ReadinessProbe)
			if err != nil {
				return err
			}
			readinessProbe := readinessProbe1
			containers.ReadinessProbe = &readinessProbe
		}
	}

	// Set property ‘Resources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Resources != nil {
			var resources1 ResourceRequirements
			err := resources1.PopulateFromARM(owner, *typedInput.Properties.Resources)
			if err != nil {
				return err
			}
			resources := resources1
			containers.Resources = &resources
		}
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.VolumeMounts = append(containers.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroups_Spec_Properties_Containers populates our ContainerGroups_Spec_Properties_Containers from the provided source ContainerGroups_Spec_Properties_Containers
func (containers *ContainerGroups_Spec_Properties_Containers) AssignProperties_From_ContainerGroups_Spec_Properties_Containers(source *v20211001s.ContainerGroups_Spec_Properties_Containers) error {

	// Command
	containers.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignProperties_From_EnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		containers.EnvironmentVariables = environmentVariableList
	} else {
		containers.EnvironmentVariables = nil
	}

	// Image
	containers.Image = genruntime.ClonePointerToString(source.Image)

	// LivenessProbe
	if source.LivenessProbe != nil {
		var livenessProbe ContainerProbe
		err := livenessProbe.AssignProperties_From_ContainerProbe(source.LivenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe() to populate field LivenessProbe")
		}
		containers.LivenessProbe = &livenessProbe
	} else {
		containers.LivenessProbe = nil
	}

	// Name
	containers.Name = genruntime.ClonePointerToString(source.Name)

	// Ports
	if source.Ports != nil {
		portList := make([]ContainerPort, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port ContainerPort
			err := port.AssignProperties_From_ContainerPort(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		containers.Ports = portList
	} else {
		containers.Ports = nil
	}

	// ReadinessProbe
	if source.ReadinessProbe != nil {
		var readinessProbe ContainerProbe
		err := readinessProbe.AssignProperties_From_ContainerProbe(source.ReadinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerProbe() to populate field ReadinessProbe")
		}
		containers.ReadinessProbe = &readinessProbe
	} else {
		containers.ReadinessProbe = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ResourceRequirements
		err := resource.AssignProperties_From_ResourceRequirements(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequirements() to populate field Resources")
		}
		containers.Resources = &resource
	} else {
		containers.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		containers.VolumeMounts = volumeMountList
	} else {
		containers.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroups_Spec_Properties_Containers populates the provided destination ContainerGroups_Spec_Properties_Containers from our ContainerGroups_Spec_Properties_Containers
func (containers *ContainerGroups_Spec_Properties_Containers) AssignProperties_To_ContainerGroups_Spec_Properties_Containers(destination *v20211001s.ContainerGroups_Spec_Properties_Containers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(containers.Command)

	// EnvironmentVariables
	if containers.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable, len(containers.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range containers.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(containers.Image)

	// LivenessProbe
	if containers.LivenessProbe != nil {
		var livenessProbe v20211001s.ContainerProbe
		err := containers.LivenessProbe.AssignProperties_To_ContainerProbe(&livenessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe() to populate field LivenessProbe")
		}
		destination.LivenessProbe = &livenessProbe
	} else {
		destination.LivenessProbe = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(containers.Name)

	// Ports
	if containers.Ports != nil {
		portList := make([]v20211001s.ContainerPort, len(containers.Ports))
		for portIndex, portItem := range containers.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.ContainerPort
			err := portItem.AssignProperties_To_ContainerPort(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerPort() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// ReadinessProbe
	if containers.ReadinessProbe != nil {
		var readinessProbe v20211001s.ContainerProbe
		err := containers.ReadinessProbe.AssignProperties_To_ContainerProbe(&readinessProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerProbe() to populate field ReadinessProbe")
		}
		destination.ReadinessProbe = &readinessProbe
	} else {
		destination.ReadinessProbe = nil
	}

	// Resources
	if containers.Resources != nil {
		var resource v20211001s.ResourceRequirements
		err := containers.Resources.AssignProperties_To_ResourceRequirements(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequirements() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if containers.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount, len(containers.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range containers.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec_Properties_ImageRegistryCredentials struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Password: The password for the private registry.
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// +kubebuilder:validation:Required
	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_ImageRegistryCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM{}

	// Set property ‘Identity’:
	if credentials.Identity != nil {
		identity := *credentials.Identity
		result.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if credentials.IdentityUrl != nil {
		identityUrl := *credentials.IdentityUrl
		result.IdentityUrl = &identityUrl
	}

	// Set property ‘Password’:
	if credentials.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.LookupSecret(*credentials.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property ‘Server’:
	if credentials.Server != nil {
		server := *credentials.Server
		result.Server = &server
	}

	// Set property ‘Username’:
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_ImageRegistryCredentialsARM, got %T", armInput)
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credentials.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credentials.IdentityUrl = &identityUrl
	}

	// no assignment for property ‘Password’

	// Set property ‘Server’:
	if typedInput.Server != nil {
		server := *typedInput.Server
		credentials.Server = &server
	}

	// Set property ‘Username’:
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroups_Spec_Properties_ImageRegistryCredentials populates our ContainerGroups_Spec_Properties_ImageRegistryCredentials from the provided source ContainerGroups_Spec_Properties_ImageRegistryCredentials
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) AssignProperties_From_ContainerGroups_Spec_Properties_ImageRegistryCredentials(source *v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials) error {

	// Identity
	credentials.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credentials.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credentials.Password = &password
	} else {
		credentials.Password = nil
	}

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroups_Spec_Properties_ImageRegistryCredentials populates the provided destination ContainerGroups_Spec_Properties_ImageRegistryCredentials from our ContainerGroups_Spec_Properties_ImageRegistryCredentials
func (credentials *ContainerGroups_Spec_Properties_ImageRegistryCredentials) AssignProperties_To_ContainerGroups_Spec_Properties_ImageRegistryCredentials(destination *v20211001s.ContainerGroups_Spec_Properties_ImageRegistryCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credentials.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credentials.IdentityUrl)

	// Password
	if credentials.Password != nil {
		password := credentials.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroups_Spec_Properties_InitContainers struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroups_Spec_Properties_InitContainers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containers *ContainerGroups_Spec_Properties_InitContainers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containers == nil {
		return nil, nil
	}
	result := &ContainerGroups_Spec_Properties_InitContainersARM{}

	// Set property ‘Name’:
	if containers.Name != nil {
		name := *containers.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if containers.Command != nil ||
		containers.EnvironmentVariables != nil ||
		containers.Image != nil ||
		containers.VolumeMounts != nil {
		result.Properties = &InitContainerPropertiesDefinitionARM{}
	}
	for _, item := range containers.Command {
		result.Properties.Command = append(result.Properties.Command, item)
	}
	for _, item := range containers.EnvironmentVariables {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.EnvironmentVariables = append(result.Properties.EnvironmentVariables, *itemARM.(*EnvironmentVariableARM))
	}
	if containers.Image != nil {
		image := *containers.Image
		result.Properties.Image = &image
	}
	for _, item := range containers.VolumeMounts {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VolumeMounts = append(result.Properties.VolumeMounts, *itemARM.(*VolumeMountARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containers *ContainerGroups_Spec_Properties_InitContainers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroups_Spec_Properties_InitContainersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containers *ContainerGroups_Spec_Properties_InitContainers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroups_Spec_Properties_InitContainersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroups_Spec_Properties_InitContainersARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			containers.Command = append(containers.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.EnvironmentVariables = append(containers.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			containers.Image = &image
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		containers.Name = &name
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			containers.VolumeMounts = append(containers.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroups_Spec_Properties_InitContainers populates our ContainerGroups_Spec_Properties_InitContainers from the provided source ContainerGroups_Spec_Properties_InitContainers
func (containers *ContainerGroups_Spec_Properties_InitContainers) AssignProperties_From_ContainerGroups_Spec_Properties_InitContainers(source *v20211001s.ContainerGroups_Spec_Properties_InitContainers) error {

	// Command
	containers.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignProperties_From_EnvironmentVariable(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		containers.EnvironmentVariables = environmentVariableList
	} else {
		containers.EnvironmentVariables = nil
	}

	// Image
	containers.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	containers.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		containers.VolumeMounts = volumeMountList
	} else {
		containers.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroups_Spec_Properties_InitContainers populates the provided destination ContainerGroups_Spec_Properties_InitContainers from our ContainerGroups_Spec_Properties_InitContainers
func (containers *ContainerGroups_Spec_Properties_InitContainers) AssignProperties_To_ContainerGroups_Spec_Properties_InitContainers(destination *v20211001s.ContainerGroups_Spec_Properties_InitContainers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(containers.Command)

	// EnvironmentVariables
	if containers.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable, len(containers.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range containers.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(containers.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(containers.Name)

	// VolumeMounts
	if containers.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount, len(containers.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range containers.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ContainerGroups_Spec_Properties_OsType string

const (
	ContainerGroups_Spec_Properties_OsType_Linux   = ContainerGroups_Spec_Properties_OsType("Linux")
	ContainerGroups_Spec_Properties_OsType_Windows = ContainerGroups_Spec_Properties_OsType("Windows")
)

// +kubebuilder:validation:Enum={"Always","Never","OnFailure"}
type ContainerGroups_Spec_Properties_RestartPolicy string

const (
	ContainerGroups_Spec_Properties_RestartPolicy_Always    = ContainerGroups_Spec_Properties_RestartPolicy("Always")
	ContainerGroups_Spec_Properties_RestartPolicy_Never     = ContainerGroups_Spec_Properties_RestartPolicy("Never")
	ContainerGroups_Spec_Properties_RestartPolicy_OnFailure = ContainerGroups_Spec_Properties_RestartPolicy("OnFailure")
)

// +kubebuilder:validation:Enum={"Dedicated","Standard"}
type ContainerGroups_Spec_Properties_Sku string

const (
	ContainerGroups_Spec_Properties_Sku_Dedicated = ContainerGroups_Spec_Properties_Sku("Dedicated")
	ContainerGroups_Spec_Properties_Sku_Standard  = ContainerGroups_Spec_Properties_Sku("Standard")
)

type ContainerGroupSku_STATUS string

const (
	ContainerGroupSku_STATUS_Dedicated = ContainerGroupSku_STATUS("Dedicated")
	ContainerGroupSku_STATUS_Standard  = ContainerGroupSku_STATUS("Standard")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerGroupSubnetId
type ContainerGroupSubnetId struct {
	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Reference: Resource ID of virtual network and subnet.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerGroupSubnetId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subnetId *ContainerGroupSubnetId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subnetId == nil {
		return nil, nil
	}
	result := &ContainerGroupSubnetIdARM{}

	// Set property ‘Id’:
	if subnetId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*subnetId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if subnetId.Name != nil {
		name := *subnetId.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupSubnetIdARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupSubnetIdARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupSubnetIdARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupSubnetId populates our ContainerGroupSubnetId from the provided source ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignProperties_From_ContainerGroupSubnetId(source *v20211001s.ContainerGroupSubnetId) error {

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subnetId.Reference = &reference
	} else {
		subnetId.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupSubnetId populates the provided destination ContainerGroupSubnetId from our ContainerGroupSubnetId
func (subnetId *ContainerGroupSubnetId) AssignProperties_To_ContainerGroupSubnetId(destination *v20211001s.ContainerGroupSubnetId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Reference
	if subnetId.Reference != nil {
		reference := subnetId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupSubnetId_STATUS struct {
	// Id: Resource ID of virtual network and subnet.
	Id *string `json:"id,omitempty"`

	// Name: Friendly name for the subnet.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupSubnetId_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetId *ContainerGroupSubnetId_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupSubnetId_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetId *ContainerGroupSubnetId_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupSubnetId_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupSubnetId_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetId.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnetId.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupSubnetId_STATUS populates our ContainerGroupSubnetId_STATUS from the provided source ContainerGroupSubnetId_STATUS
func (subnetId *ContainerGroupSubnetId_STATUS) AssignProperties_From_ContainerGroupSubnetId_STATUS(source *v20211001s.ContainerGroupSubnetId_STATUS) error {

	// Id
	subnetId.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	subnetId.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupSubnetId_STATUS populates the provided destination ContainerGroupSubnetId_STATUS from our ContainerGroupSubnetId_STATUS
func (subnetId *ContainerGroupSubnetId_STATUS) AssignProperties_To_ContainerGroupSubnetId_STATUS(destination *v20211001s.ContainerGroupSubnetId_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(subnetId.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(subnetId.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/DnsConfiguration
type DnsConfiguration struct {
	// +kubebuilder:validation:Required
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *DnsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &DnsConfigurationARM{}

	// Set property ‘NameServers’:
	for _, item := range configuration.NameServers {
		result.NameServers = append(result.NameServers, item)
	}

	// Set property ‘Options’:
	if configuration.Options != nil {
		options := *configuration.Options
		result.Options = &options
	}

	// Set property ‘SearchDomains’:
	if configuration.SearchDomains != nil {
		searchDomains := *configuration.SearchDomains
		result.SearchDomains = &searchDomains
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfigurationARM, got %T", armInput)
	}

	// Set property ‘NameServers’:
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property ‘Options’:
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property ‘SearchDomains’:
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfiguration populates our DnsConfiguration from the provided source DnsConfiguration
func (configuration *DnsConfiguration) AssignProperties_From_DnsConfiguration(source *v20211001s.DnsConfiguration) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignProperties_To_DnsConfiguration populates the provided destination DnsConfiguration from our DnsConfiguration
func (configuration *DnsConfiguration) AssignProperties_To_DnsConfiguration(destination *v20211001s.DnsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DnsConfiguration_STATUS struct {
	// NameServers: The DNS servers for the container group.
	NameServers []string `json:"nameServers,omitempty"`

	// Options: The DNS options for the container group.
	Options *string `json:"options,omitempty"`

	// SearchDomains: The DNS search domains for hostname lookup in the container group.
	SearchDomains *string `json:"searchDomains,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DnsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DnsConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DnsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DnsConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DnsConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘NameServers’:
	for _, item := range typedInput.NameServers {
		configuration.NameServers = append(configuration.NameServers, item)
	}

	// Set property ‘Options’:
	if typedInput.Options != nil {
		options := *typedInput.Options
		configuration.Options = &options
	}

	// Set property ‘SearchDomains’:
	if typedInput.SearchDomains != nil {
		searchDomains := *typedInput.SearchDomains
		configuration.SearchDomains = &searchDomains
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfiguration_STATUS populates our DnsConfiguration_STATUS from the provided source DnsConfiguration_STATUS
func (configuration *DnsConfiguration_STATUS) AssignProperties_From_DnsConfiguration_STATUS(source *v20211001s.DnsConfiguration_STATUS) error {

	// NameServers
	configuration.NameServers = genruntime.CloneSliceOfString(source.NameServers)

	// Options
	configuration.Options = genruntime.ClonePointerToString(source.Options)

	// SearchDomains
	configuration.SearchDomains = genruntime.ClonePointerToString(source.SearchDomains)

	// No error
	return nil
}

// AssignProperties_To_DnsConfiguration_STATUS populates the provided destination DnsConfiguration_STATUS from our DnsConfiguration_STATUS
func (configuration *DnsConfiguration_STATUS) AssignProperties_To_DnsConfiguration_STATUS(destination *v20211001s.DnsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NameServers
	destination.NameServers = genruntime.CloneSliceOfString(configuration.NameServers)

	// Options
	destination.Options = genruntime.ClonePointerToString(configuration.Options)

	// SearchDomains
	destination.SearchDomains = genruntime.ClonePointerToString(configuration.SearchDomains)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/EncryptionProperties
type EncryptionProperties struct {
	// +kubebuilder:validation:Required
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// +kubebuilder:validation:Required
	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &EncryptionPropertiesARM{}

	// Set property ‘KeyName’:
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if properties.VaultBaseUrl != nil {
		vaultBaseUrl := *properties.VaultBaseUrl
		result.VaultBaseUrl = &vaultBaseUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionPropertiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionPropertiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionPropertiesARM, got %T", armInput)
	}

	// Set property ‘KeyName’:
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties populates our EncryptionProperties from the provided source EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_From_EncryptionProperties(source *v20211001s.EncryptionProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties populates the provided destination EncryptionProperties from our EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_To_EncryptionProperties(destination *v20211001s.EncryptionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionProperties_STATUS struct {
	// KeyName: The encryption key name.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVersion: The encryption key version.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// VaultBaseUrl: The keyvault base url.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionProperties_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionProperties_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionProperties_STATUSARM, got %T", armInput)
	}

	// Set property ‘KeyName’:
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property ‘KeyVersion’:
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property ‘VaultBaseUrl’:
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		properties.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties_STATUS populates our EncryptionProperties_STATUS from the provided source EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_From_EncryptionProperties_STATUS(source *v20211001s.EncryptionProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	properties.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties_STATUS populates the provided destination EncryptionProperties_STATUS from our EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_To_EncryptionProperties_STATUS(destination *v20211001s.EncryptionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(properties.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImageRegistryCredential_STATUS struct {
	// Identity: The identity for the private registry.
	Identity *string `json:"identity,omitempty"`

	// IdentityUrl: The identity URL for the private registry.
	IdentityUrl *string `json:"identityUrl,omitempty"`

	// Server: The Docker image registry server without a protocol such as "http" and "https".
	Server *string `json:"server,omitempty"`

	// Username: The username for the private registry.
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageRegistryCredential_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credential *ImageRegistryCredential_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageRegistryCredential_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credential *ImageRegistryCredential_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageRegistryCredential_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageRegistryCredential_STATUSARM, got %T", armInput)
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credential.Identity = &identity
	}

	// Set property ‘IdentityUrl’:
	if typedInput.IdentityUrl != nil {
		identityUrl := *typedInput.IdentityUrl
		credential.IdentityUrl = &identityUrl
	}

	// Set property ‘Server’:
	if typedInput.Server != nil {
		server := *typedInput.Server
		credential.Server = &server
	}

	// Set property ‘Username’:
	if typedInput.Username != nil {
		username := *typedInput.Username
		credential.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_ImageRegistryCredential_STATUS populates our ImageRegistryCredential_STATUS from the provided source ImageRegistryCredential_STATUS
func (credential *ImageRegistryCredential_STATUS) AssignProperties_From_ImageRegistryCredential_STATUS(source *v20211001s.ImageRegistryCredential_STATUS) error {

	// Identity
	credential.Identity = genruntime.ClonePointerToString(source.Identity)

	// IdentityUrl
	credential.IdentityUrl = genruntime.ClonePointerToString(source.IdentityUrl)

	// Server
	credential.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credential.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_ImageRegistryCredential_STATUS populates the provided destination ImageRegistryCredential_STATUS from our ImageRegistryCredential_STATUS
func (credential *ImageRegistryCredential_STATUS) AssignProperties_To_ImageRegistryCredential_STATUS(destination *v20211001s.ImageRegistryCredential_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credential.Identity)

	// IdentityUrl
	destination.IdentityUrl = genruntime.ClonePointerToString(credential.IdentityUrl)

	// Server
	destination.Server = genruntime.ClonePointerToString(credential.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credential.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InitContainerDefinition_STATUS struct {
	// Command: The command to execute within the init container in exec form.
	Command []string `json:"command,omitempty"`

	// EnvironmentVariables: The environment variables to set in the init container.
	EnvironmentVariables []EnvironmentVariable_STATUS `json:"environmentVariables,omitempty"`

	// Image: The image of the init container.
	Image *string `json:"image,omitempty"`

	// InstanceView: The instance view of the init container. Only valid in response.
	InstanceView *InitContainerPropertiesDefinition_STATUS_InstanceView `json:"instanceView,omitempty"`

	// Name: The name for the init container.
	Name *string `json:"name,omitempty"`

	// VolumeMounts: The volume mounts available to the init container.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *InitContainerDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InitContainerDefinition_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *InitContainerDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InitContainerDefinition_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InitContainerDefinition_STATUSARM, got %T", armInput)
	}

	// Set property ‘Command’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Command {
			definition.Command = append(definition.Command, item)
		}
	}

	// Set property ‘EnvironmentVariables’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnvironmentVariables {
			var item1 EnvironmentVariable_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.EnvironmentVariables = append(definition.EnvironmentVariables, item1)
		}
	}

	// Set property ‘Image’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Image != nil {
			image := *typedInput.Properties.Image
			definition.Image = &image
		}
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 InitContainerPropertiesDefinition_STATUS_InstanceView
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			definition.InstanceView = &instanceView
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property ‘VolumeMounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VolumeMounts {
			var item1 VolumeMount_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			definition.VolumeMounts = append(definition.VolumeMounts, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InitContainerDefinition_STATUS populates our InitContainerDefinition_STATUS from the provided source InitContainerDefinition_STATUS
func (definition *InitContainerDefinition_STATUS) AssignProperties_From_InitContainerDefinition_STATUS(source *v20211001s.InitContainerDefinition_STATUS) error {

	// Command
	definition.Command = genruntime.CloneSliceOfString(source.Command)

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableList := make([]EnvironmentVariable_STATUS, len(source.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable EnvironmentVariable_STATUS
			err := environmentVariable.AssignProperties_From_EnvironmentVariable_STATUS(&environmentVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		definition.EnvironmentVariables = environmentVariableList
	} else {
		definition.EnvironmentVariables = nil
	}

	// Image
	definition.Image = genruntime.ClonePointerToString(source.Image)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView InitContainerPropertiesDefinition_STATUS_InstanceView
		err := instanceView.AssignProperties_From_InitContainerPropertiesDefinition_STATUS_InstanceView(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InitContainerPropertiesDefinition_STATUS_InstanceView() to populate field InstanceView")
		}
		definition.InstanceView = &instanceView
	} else {
		definition.InstanceView = nil
	}

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		definition.VolumeMounts = volumeMountList
	} else {
		definition.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InitContainerDefinition_STATUS populates the provided destination InitContainerDefinition_STATUS from our InitContainerDefinition_STATUS
func (definition *InitContainerDefinition_STATUS) AssignProperties_To_InitContainerDefinition_STATUS(destination *v20211001s.InitContainerDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(definition.Command)

	// EnvironmentVariables
	if definition.EnvironmentVariables != nil {
		environmentVariableList := make([]v20211001s.EnvironmentVariable_STATUS, len(definition.EnvironmentVariables))
		for environmentVariableIndex, environmentVariableItem := range definition.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableItem := environmentVariableItem
			var environmentVariable v20211001s.EnvironmentVariable_STATUS
			err := environmentVariableItem.AssignProperties_To_EnvironmentVariable_STATUS(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableList[environmentVariableIndex] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableList
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(definition.Image)

	// InstanceView
	if definition.InstanceView != nil {
		var instanceView v20211001s.InitContainerPropertiesDefinition_STATUS_InstanceView
		err := definition.InstanceView.AssignProperties_To_InitContainerPropertiesDefinition_STATUS_InstanceView(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InitContainerPropertiesDefinition_STATUS_InstanceView() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// VolumeMounts
	if definition.VolumeMounts != nil {
		volumeMountList := make([]v20211001s.VolumeMount_STATUS, len(definition.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range definition.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount v20211001s.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/IpAddress
type IpAddress struct {
	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// DnsNameLabelReusePolicy: The value representing the security enum.
	DnsNameLabelReusePolicy *IpAddress_DnsNameLabelReusePolicy `json:"dnsNameLabelReusePolicy,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// +kubebuilder:validation:Required
	// Ports: The list of ports exposed on the container group.
	Ports []Port `json:"ports,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddress_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &IpAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *IpAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &IpAddressARM{}

	// Set property ‘DnsNameLabel’:
	if address.DnsNameLabel != nil {
		dnsNameLabel := *address.DnsNameLabel
		result.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *address.DnsNameLabelReusePolicy
		result.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Ip’:
	if address.Ip != nil {
		ip := *address.Ip
		result.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range address.Ports {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Ports = append(result.Ports, *itemARM.(*PortARM))
	}

	// Set property ‘Type’:
	if address.Type != nil {
		typeVar := *address.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpAddressARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpAddressARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpAddressARM, got %T", armInput)
	}

	// Set property ‘DnsNameLabel’:
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if typedInput.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *typedInput.DnsNameLabelReusePolicy
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Ip’:
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range typedInput.Ports {
		var item1 Port
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IpAddress populates our IpAddress from the provided source IpAddress
func (address *IpAddress) AssignProperties_From_IpAddress(source *v20211001s.IpAddress) error {

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if source.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := IpAddress_DnsNameLabelReusePolicy(*source.DnsNameLabelReusePolicy)
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		address.DnsNameLabelReusePolicy = nil
	}

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port
			err := port.AssignProperties_From_Port(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Port() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := IpAddress_Type(*source.Type)
		address.Type = &typeVar
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpAddress populates the provided destination IpAddress from our IpAddress
func (address *IpAddress) AssignProperties_To_IpAddress(destination *v20211001s.IpAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := string(*address.DnsNameLabelReusePolicy)
		destination.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		destination.DnsNameLabelReusePolicy = nil
	}

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]v20211001s.Port, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.Port
			err := portItem.AssignProperties_To_Port(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Port() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IpAddress_STATUS struct {
	// DnsNameLabel: The Dns name label for the IP.
	DnsNameLabel *string `json:"dnsNameLabel,omitempty"`

	// DnsNameLabelReusePolicy: The value representing the security enum.
	DnsNameLabelReusePolicy *IpAddress_STATUS_DnsNameLabelReusePolicy `json:"dnsNameLabelReusePolicy,omitempty"`

	// Fqdn: The FQDN for the IP.
	Fqdn *string `json:"fqdn,omitempty"`

	// Ip: The IP exposed to the public internet.
	Ip *string `json:"ip,omitempty"`

	// Ports: The list of ports exposed on the container group.
	Ports []Port_STATUS `json:"ports,omitempty"`

	// Type: Specifies if the IP is exposed to the public internet or private VNET.
	Type *IpAddress_STATUS_Type `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &IpAddress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *IpAddress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpAddress_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *IpAddress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpAddress_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpAddress_STATUSARM, got %T", armInput)
	}

	// Set property ‘DnsNameLabel’:
	if typedInput.DnsNameLabel != nil {
		dnsNameLabel := *typedInput.DnsNameLabel
		address.DnsNameLabel = &dnsNameLabel
	}

	// Set property ‘DnsNameLabelReusePolicy’:
	if typedInput.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := *typedInput.DnsNameLabelReusePolicy
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property ‘Ip’:
	if typedInput.Ip != nil {
		ip := *typedInput.Ip
		address.Ip = &ip
	}

	// Set property ‘Ports’:
	for _, item := range typedInput.Ports {
		var item1 Port_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		address.Ports = append(address.Ports, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		address.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IpAddress_STATUS populates our IpAddress_STATUS from the provided source IpAddress_STATUS
func (address *IpAddress_STATUS) AssignProperties_From_IpAddress_STATUS(source *v20211001s.IpAddress_STATUS) error {

	// DnsNameLabel
	address.DnsNameLabel = genruntime.ClonePointerToString(source.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if source.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := IpAddress_STATUS_DnsNameLabelReusePolicy(*source.DnsNameLabelReusePolicy)
		address.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		address.DnsNameLabelReusePolicy = nil
	}

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// Ip
	address.Ip = genruntime.ClonePointerToString(source.Ip)

	// Ports
	if source.Ports != nil {
		portList := make([]Port_STATUS, len(source.Ports))
		for portIndex, portItem := range source.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port Port_STATUS
			err := port.AssignProperties_From_Port_STATUS(&portItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Port_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		address.Ports = portList
	} else {
		address.Ports = nil
	}

	// Type
	if source.Type != nil {
		typeVar := IpAddress_STATUS_Type(*source.Type)
		address.Type = &typeVar
	} else {
		address.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpAddress_STATUS populates the provided destination IpAddress_STATUS from our IpAddress_STATUS
func (address *IpAddress_STATUS) AssignProperties_To_IpAddress_STATUS(destination *v20211001s.IpAddress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsNameLabel
	destination.DnsNameLabel = genruntime.ClonePointerToString(address.DnsNameLabel)

	// DnsNameLabelReusePolicy
	if address.DnsNameLabelReusePolicy != nil {
		dnsNameLabelReusePolicy := string(*address.DnsNameLabelReusePolicy)
		destination.DnsNameLabelReusePolicy = &dnsNameLabelReusePolicy
	} else {
		destination.DnsNameLabelReusePolicy = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// Ip
	destination.Ip = genruntime.ClonePointerToString(address.Ip)

	// Ports
	if address.Ports != nil {
		portList := make([]v20211001s.Port_STATUS, len(address.Ports))
		for portIndex, portItem := range address.Ports {
			// Shadow the loop variable to avoid aliasing
			portItem := portItem
			var port v20211001s.Port_STATUS
			err := portItem.AssignProperties_To_Port_STATUS(&port)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Port_STATUS() to populate field Ports")
			}
			portList[portIndex] = port
		}
		destination.Ports = portList
	} else {
		destination.Ports = nil
	}

	// Type
	if address.Type != nil {
		typeVar := string(*address.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/Volume
type Volume struct {
	// AzureFile: The properties of the Azure File volume. Azure File shares are mounted as volumes.
	AzureFile *AzureFileVolume `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: Represents a volume that is populated with the contents of a git repository
	GitRepo *GitRepoVolume `json:"gitRepo,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &Volume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *Volume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &VolumeARM{}

	// Set property ‘AzureFile’:
	if volume.AzureFile != nil {
		azureFileARM, err := (*volume.AzureFile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureFile := *azureFileARM.(*AzureFileVolumeARM)
		result.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if volume.EmptyDir != nil {
		result.EmptyDir = make(map[string]v1.JSON, len(volume.EmptyDir))
		for key, value := range volume.EmptyDir {
			result.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if volume.GitRepo != nil {
		gitRepoARM, err := (*volume.GitRepo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gitRepo := *gitRepoARM.(*GitRepoVolumeARM)
		result.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if volume.Name != nil {
		name := *volume.Name
		result.Name = &name
	}

	// Set property ‘Secret’:
	if volume.Secret != nil {
		result.Secret = make(map[string]string, len(volume.Secret))
		for key, value := range volume.Secret {
			result.Secret[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeARM, got %T", armInput)
	}

	// Set property ‘AzureFile’:
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Volume populates our Volume from the provided source Volume
func (volume *Volume) AssignProperties_From_Volume(source *v20211001s.Volume) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume
		err := azureFile.AssignProperties_From_AzureFileVolume(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureFileVolume() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume
		err := gitRepo.AssignProperties_From_GitRepoVolume(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepoVolume() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignProperties_To_Volume populates the provided destination Volume from our Volume
func (volume *Volume) AssignProperties_To_Volume(destination *v20211001s.Volume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile v20211001s.AzureFileVolume
		err := volume.AzureFile.AssignProperties_To_AzureFileVolume(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureFileVolume() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo v20211001s.GitRepoVolume
		err := volume.GitRepo.AssignProperties_To_GitRepoVolume(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepoVolume() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Volume_STATUS struct {
	// AzureFile: The Azure File volume.
	AzureFile *AzureFileVolume_STATUS `json:"azureFile,omitempty"`

	// EmptyDir: The empty directory volume.
	EmptyDir map[string]v1.JSON `json:"emptyDir,omitempty"`

	// GitRepo: The git repo volume.
	GitRepo *GitRepoVolume_STATUS `json:"gitRepo,omitempty"`

	// Name: The name of the volume.
	Name *string `json:"name,omitempty"`

	// Secret: The secret volume.
	Secret map[string]string `json:"secret,omitempty"`
}

var _ genruntime.FromARMConverter = &Volume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Volume_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Volume_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Volume_STATUSARM, got %T", armInput)
	}

	// Set property ‘AzureFile’:
	if typedInput.AzureFile != nil {
		var azureFile1 AzureFileVolume_STATUS
		err := azureFile1.PopulateFromARM(owner, *typedInput.AzureFile)
		if err != nil {
			return err
		}
		azureFile := azureFile1
		volume.AzureFile = &azureFile
	}

	// Set property ‘EmptyDir’:
	if typedInput.EmptyDir != nil {
		volume.EmptyDir = make(map[string]v1.JSON, len(typedInput.EmptyDir))
		for key, value := range typedInput.EmptyDir {
			volume.EmptyDir[key] = *value.DeepCopy()
		}
	}

	// Set property ‘GitRepo’:
	if typedInput.GitRepo != nil {
		var gitRepo1 GitRepoVolume_STATUS
		err := gitRepo1.PopulateFromARM(owner, *typedInput.GitRepo)
		if err != nil {
			return err
		}
		gitRepo := gitRepo1
		volume.GitRepo = &gitRepo
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		volume.Secret = make(map[string]string, len(typedInput.Secret))
		for key, value := range typedInput.Secret {
			volume.Secret[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Volume_STATUS populates our Volume_STATUS from the provided source Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_From_Volume_STATUS(source *v20211001s.Volume_STATUS) error {

	// AzureFile
	if source.AzureFile != nil {
		var azureFile AzureFileVolume_STATUS
		err := azureFile.AssignProperties_From_AzureFileVolume_STATUS(source.AzureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureFileVolume_STATUS() to populate field AzureFile")
		}
		volume.AzureFile = &azureFile
	} else {
		volume.AzureFile = nil
	}

	// EmptyDir
	if source.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(source.EmptyDir))
		for emptyDirKey, emptyDirValue := range source.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		volume.EmptyDir = emptyDirMap
	} else {
		volume.EmptyDir = nil
	}

	// GitRepo
	if source.GitRepo != nil {
		var gitRepo GitRepoVolume_STATUS
		err := gitRepo.AssignProperties_From_GitRepoVolume_STATUS(source.GitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitRepoVolume_STATUS() to populate field GitRepo")
		}
		volume.GitRepo = &gitRepo
	} else {
		volume.GitRepo = nil
	}

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secret
	volume.Secret = genruntime.CloneMapOfStringToString(source.Secret)

	// No error
	return nil
}

// AssignProperties_To_Volume_STATUS populates the provided destination Volume_STATUS from our Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_To_Volume_STATUS(destination *v20211001s.Volume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureFile
	if volume.AzureFile != nil {
		var azureFile v20211001s.AzureFileVolume_STATUS
		err := volume.AzureFile.AssignProperties_To_AzureFileVolume_STATUS(&azureFile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureFileVolume_STATUS() to populate field AzureFile")
		}
		destination.AzureFile = &azureFile
	} else {
		destination.AzureFile = nil
	}

	// EmptyDir
	if volume.EmptyDir != nil {
		emptyDirMap := make(map[string]v1.JSON, len(volume.EmptyDir))
		for emptyDirKey, emptyDirValue := range volume.EmptyDir {
			// Shadow the loop variable to avoid aliasing
			emptyDirValue := emptyDirValue
			emptyDirMap[emptyDirKey] = *emptyDirValue.DeepCopy()
		}
		destination.EmptyDir = emptyDirMap
	} else {
		destination.EmptyDir = nil
	}

	// GitRepo
	if volume.GitRepo != nil {
		var gitRepo v20211001s.GitRepoVolume_STATUS
		err := volume.GitRepo.AssignProperties_To_GitRepoVolume_STATUS(&gitRepo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitRepoVolume_STATUS() to populate field GitRepo")
		}
		destination.GitRepo = &gitRepo
	} else {
		destination.GitRepo = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secret
	destination.Secret = genruntime.CloneMapOfStringToString(volume.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/AzureFileVolume
type AzureFileVolume struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// +kubebuilder:validation:Required
	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// +kubebuilder:validation:Required
	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFileVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *AzureFileVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &AzureFileVolumeARM{}

	// Set property ‘ReadOnly’:
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		result.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if volume.ShareName != nil {
		shareName := *volume.ShareName
		result.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if volume.StorageAccountKey != nil {
		storageAccountKey := *volume.StorageAccountKey
		result.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if volume.StorageAccountName != nil {
		storageAccountName := *volume.StorageAccountName
		result.StorageAccountName = &storageAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureFileVolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureFileVolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureFileVolumeARM, got %T", armInput)
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFileVolume populates our AzureFileVolume from the provided source AzureFileVolume
func (volume *AzureFileVolume) AssignProperties_From_AzureFileVolume(source *v20211001s.AzureFileVolume) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignProperties_To_AzureFileVolume populates the provided destination AzureFileVolume from our AzureFileVolume
func (volume *AzureFileVolume) AssignProperties_To_AzureFileVolume(destination *v20211001s.AzureFileVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureFileVolume_STATUS struct {
	// ReadOnly: The flag indicating whether the Azure File shared mounted as a volume is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// ShareName: The name of the Azure File share to be mounted as a volume.
	ShareName *string `json:"shareName,omitempty"`

	// StorageAccountKey: The storage account access key used to access the Azure File share.
	StorageAccountKey *string `json:"storageAccountKey,omitempty"`

	// StorageAccountName: The name of the storage account that contains the Azure File share.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFileVolume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *AzureFileVolume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureFileVolume_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *AzureFileVolume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureFileVolume_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureFileVolume_STATUSARM, got %T", armInput)
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		volume.ReadOnly = &readOnly
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		volume.ShareName = &shareName
	}

	// Set property ‘StorageAccountKey’:
	if typedInput.StorageAccountKey != nil {
		storageAccountKey := *typedInput.StorageAccountKey
		volume.StorageAccountKey = &storageAccountKey
	}

	// Set property ‘StorageAccountName’:
	if typedInput.StorageAccountName != nil {
		storageAccountName := *typedInput.StorageAccountName
		volume.StorageAccountName = &storageAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFileVolume_STATUS populates our AzureFileVolume_STATUS from the provided source AzureFileVolume_STATUS
func (volume *AzureFileVolume_STATUS) AssignProperties_From_AzureFileVolume_STATUS(source *v20211001s.AzureFileVolume_STATUS) error {

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		volume.ReadOnly = &readOnly
	} else {
		volume.ReadOnly = nil
	}

	// ShareName
	volume.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// StorageAccountKey
	volume.StorageAccountKey = genruntime.ClonePointerToString(source.StorageAccountKey)

	// StorageAccountName
	volume.StorageAccountName = genruntime.ClonePointerToString(source.StorageAccountName)

	// No error
	return nil
}

// AssignProperties_To_AzureFileVolume_STATUS populates the provided destination AzureFileVolume_STATUS from our AzureFileVolume_STATUS
func (volume *AzureFileVolume_STATUS) AssignProperties_To_AzureFileVolume_STATUS(destination *v20211001s.AzureFileVolume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ReadOnly
	if volume.ReadOnly != nil {
		readOnly := *volume.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(volume.ShareName)

	// StorageAccountKey
	destination.StorageAccountKey = genruntime.ClonePointerToString(volume.StorageAccountKey)

	// StorageAccountName
	destination.StorageAccountName = genruntime.ClonePointerToString(volume.StorageAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerGroupIdentity_STATUS_UserAssignedIdentities struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerGroupIdentity_STATUS_UserAssignedIdentities{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ContainerGroupIdentity_STATUS_UserAssignedIdentities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerGroupIdentity_STATUS_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ContainerGroupIdentity_STATUS_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerGroupIdentity_STATUS_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerGroupIdentity_STATUS_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerGroupIdentity_STATUS_UserAssignedIdentities populates our ContainerGroupIdentity_STATUS_UserAssignedIdentities from the provided source ContainerGroupIdentity_STATUS_UserAssignedIdentities
func (identities *ContainerGroupIdentity_STATUS_UserAssignedIdentities) AssignProperties_From_ContainerGroupIdentity_STATUS_UserAssignedIdentities(source *v20211001s.ContainerGroupIdentity_STATUS_UserAssignedIdentities) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ContainerGroupIdentity_STATUS_UserAssignedIdentities populates the provided destination ContainerGroupIdentity_STATUS_UserAssignedIdentities from our ContainerGroupIdentity_STATUS_UserAssignedIdentities
func (identities *ContainerGroupIdentity_STATUS_UserAssignedIdentities) AssignProperties_To_ContainerGroupIdentity_STATUS_UserAssignedIdentities(destination *v20211001s.ContainerGroupIdentity_STATUS_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerPort
type ContainerPort struct {
	// +kubebuilder:validation:Required
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPort_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerPort{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *ContainerPort) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &ContainerPortARM{}

	// Set property ‘Port’:
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property ‘Protocol’:
	if port.Protocol != nil {
		protocol := *port.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPortARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPortARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPortARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerPort populates our ContainerPort from the provided source ContainerPort
func (port *ContainerPort) AssignProperties_From_ContainerPort(source *v20211001s.ContainerPort) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ContainerPort_Protocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerPort populates the provided destination ContainerPort from our ContainerPort
func (port *ContainerPort) AssignProperties_To_ContainerPort(destination *v20211001s.ContainerPort) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerPort_STATUS struct {
	// Port: The port number exposed within the container group.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *ContainerPort_STATUS_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerPort_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *ContainerPort_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPort_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *ContainerPort_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPort_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPort_STATUSARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerPort_STATUS populates our ContainerPort_STATUS from the provided source ContainerPort_STATUS
func (port *ContainerPort_STATUS) AssignProperties_From_ContainerPort_STATUS(source *v20211001s.ContainerPort_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ContainerPort_STATUS_Protocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerPort_STATUS populates the provided destination ContainerPort_STATUS from our ContainerPort_STATUS
func (port *ContainerPort_STATUS) AssignProperties_To_ContainerPort_STATUS(destination *v20211001s.ContainerPort_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerProbe
type ContainerProbe struct {
	// Exec: The container execution command, for liveness or readiness probe
	Exec *ContainerExec `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The container Http Get settings, for liveness or readiness probe
	HttpGet *ContainerHttpGet `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerProbe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *ContainerProbe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &ContainerProbeARM{}

	// Set property ‘Exec’:
	if probe.Exec != nil {
		execARM, err := (*probe.Exec).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		exec := *execARM.(*ContainerExecARM)
		result.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if probe.FailureThreshold != nil {
		failureThreshold := *probe.FailureThreshold
		result.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if probe.HttpGet != nil {
		httpGetARM, err := (*probe.HttpGet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpGet := *httpGetARM.(*ContainerHttpGetARM)
		result.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if probe.InitialDelaySeconds != nil {
		initialDelaySeconds := *probe.InitialDelaySeconds
		result.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if probe.PeriodSeconds != nil {
		periodSeconds := *probe.PeriodSeconds
		result.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if probe.SuccessThreshold != nil {
		successThreshold := *probe.SuccessThreshold
		result.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if probe.TimeoutSeconds != nil {
		timeoutSeconds := *probe.TimeoutSeconds
		result.TimeoutSeconds = &timeoutSeconds
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProbeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProbeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProbeARM, got %T", armInput)
	}

	// Set property ‘Exec’:
	if typedInput.Exec != nil {
		var exec1 ContainerExec
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProbe populates our ContainerProbe from the provided source ContainerProbe
func (probe *ContainerProbe) AssignProperties_From_ContainerProbe(source *v20211001s.ContainerProbe) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec
		err := exec.AssignProperties_From_ContainerExec(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerExec() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet
		err := httpGet.AssignProperties_From_ContainerHttpGet(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerHttpGet() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerProbe populates the provided destination ContainerProbe from our ContainerProbe
func (probe *ContainerProbe) AssignProperties_To_ContainerProbe(destination *v20211001s.ContainerProbe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec v20211001s.ContainerExec
		err := probe.Exec.AssignProperties_To_ContainerExec(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerExec() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet v20211001s.ContainerHttpGet
		err := probe.HttpGet.AssignProperties_To_ContainerHttpGet(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerHttpGet() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerProbe_STATUS struct {
	// Exec: The execution command to probe
	Exec *ContainerExec_STATUS `json:"exec,omitempty"`

	// FailureThreshold: The failure threshold.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: The Http Get settings to probe
	HttpGet *ContainerHttpGet_STATUS `json:"httpGet,omitempty"`

	// InitialDelaySeconds: The initial delay seconds.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: The period seconds.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: The success threshold.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TimeoutSeconds: The timeout seconds.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProbe_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerProbe_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProbe_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerProbe_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProbe_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProbe_STATUSARM, got %T", armInput)
	}

	// Set property ‘Exec’:
	if typedInput.Exec != nil {
		var exec1 ContainerExec_STATUS
		err := exec1.PopulateFromARM(owner, *typedInput.Exec)
		if err != nil {
			return err
		}
		exec := exec1
		probe.Exec = &exec
	}

	// Set property ‘FailureThreshold’:
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property ‘HttpGet’:
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerHttpGet_STATUS
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property ‘InitialDelaySeconds’:
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property ‘PeriodSeconds’:
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property ‘SuccessThreshold’:
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property ‘TimeoutSeconds’:
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProbe_STATUS populates our ContainerProbe_STATUS from the provided source ContainerProbe_STATUS
func (probe *ContainerProbe_STATUS) AssignProperties_From_ContainerProbe_STATUS(source *v20211001s.ContainerProbe_STATUS) error {

	// Exec
	if source.Exec != nil {
		var exec ContainerExec_STATUS
		err := exec.AssignProperties_From_ContainerExec_STATUS(source.Exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerExec_STATUS() to populate field Exec")
		}
		probe.Exec = &exec
	} else {
		probe.Exec = nil
	}

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerHttpGet_STATUS
		err := httpGet.AssignProperties_From_ContainerHttpGet_STATUS(source.HttpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerHttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerProbe_STATUS populates the provided destination ContainerProbe_STATUS from our ContainerProbe_STATUS
func (probe *ContainerProbe_STATUS) AssignProperties_To_ContainerProbe_STATUS(destination *v20211001s.ContainerProbe_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exec
	if probe.Exec != nil {
		var exec v20211001s.ContainerExec_STATUS
		err := probe.Exec.AssignProperties_To_ContainerExec_STATUS(&exec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerExec_STATUS() to populate field Exec")
		}
		destination.Exec = &exec
	} else {
		destination.Exec = nil
	}

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet v20211001s.ContainerHttpGet_STATUS
		err := probe.HttpGet.AssignProperties_To_ContainerHttpGet_STATUS(&httpGet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerHttpGet_STATUS() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerProperties_STATUS_InstanceView struct {
	// CurrentState: Current container instance state.
	CurrentState *ContainerState_STATUS `json:"currentState,omitempty"`

	// Events: The events of the container instance.
	Events []Event_STATUS `json:"events,omitempty"`

	// PreviousState: Previous container instance state.
	PreviousState *ContainerState_STATUS `json:"previousState,omitempty"`

	// RestartCount: The number of times that the container instance has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerProperties_STATUS_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *ContainerProperties_STATUS_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerProperties_STATUS_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *ContainerProperties_STATUS_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerProperties_STATUS_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerProperties_STATUS_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘CurrentState’:
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_STATUS
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘PreviousState’:
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_STATUS
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property ‘RestartCount’:
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerProperties_STATUS_InstanceView populates our ContainerProperties_STATUS_InstanceView from the provided source ContainerProperties_STATUS_InstanceView
func (view *ContainerProperties_STATUS_InstanceView) AssignProperties_From_ContainerProperties_STATUS_InstanceView(source *v20211001s.ContainerProperties_STATUS_InstanceView) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_STATUS
		err := currentState.AssignProperties_From_ContainerState_STATUS(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_STATUS
		err := previousState.AssignProperties_From_ContainerState_STATUS(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignProperties_To_ContainerProperties_STATUS_InstanceView populates the provided destination ContainerProperties_STATUS_InstanceView from our ContainerProperties_STATUS_InstanceView
func (view *ContainerProperties_STATUS_InstanceView) AssignProperties_To_ContainerProperties_STATUS_InstanceView(destination *v20211001s.ContainerProperties_STATUS_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState v20211001s.ContainerState_STATUS
		err := view.CurrentState.AssignProperties_To_ContainerState_STATUS(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState v20211001s.ContainerState_STATUS
		err := view.PreviousState.AssignProperties_To_ContainerState_STATUS(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/EnvironmentVariable
type EnvironmentVariable struct {
	// +kubebuilder:validation:Required
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// SecureValue: The value of the secure environment variable.
	SecureValue *string `json:"secureValue,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnvironmentVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *EnvironmentVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &EnvironmentVariableARM{}

	// Set property ‘Name’:
	if variable.Name != nil {
		name := *variable.Name
		result.Name = &name
	}

	// Set property ‘SecureValue’:
	if variable.SecureValue != nil {
		secureValue := *variable.SecureValue
		result.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if variable.Value != nil {
		value := *variable.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EnvironmentVariableARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EnvironmentVariableARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EnvironmentVariableARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// Set property ‘SecureValue’:
	if typedInput.SecureValue != nil {
		secureValue := *typedInput.SecureValue
		variable.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable populates our EnvironmentVariable from the provided source EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_From_EnvironmentVariable(source *v20211001s.EnvironmentVariable) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// SecureValue
	variable.SecureValue = genruntime.ClonePointerToString(source.SecureValue)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable populates the provided destination EnvironmentVariable from our EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_To_EnvironmentVariable(destination *v20211001s.EnvironmentVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// SecureValue
	destination.SecureValue = genruntime.ClonePointerToString(variable.SecureValue)

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EnvironmentVariable_STATUS struct {
	// Name: The name of the environment variable.
	Name *string `json:"name,omitempty"`

	// SecureValue: The value of the secure environment variable.
	SecureValue *string `json:"secureValue,omitempty"`

	// Value: The value of the environment variable.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnvironmentVariable_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EnvironmentVariable_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EnvironmentVariable_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EnvironmentVariable_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		variable.Name = &name
	}

	// Set property ‘SecureValue’:
	if typedInput.SecureValue != nil {
		secureValue := *typedInput.SecureValue
		variable.SecureValue = &secureValue
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable_STATUS populates our EnvironmentVariable_STATUS from the provided source EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_From_EnvironmentVariable_STATUS(source *v20211001s.EnvironmentVariable_STATUS) error {

	// Name
	variable.Name = genruntime.ClonePointerToString(source.Name)

	// SecureValue
	variable.SecureValue = genruntime.ClonePointerToString(source.SecureValue)

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable_STATUS populates the provided destination EnvironmentVariable_STATUS from our EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_To_EnvironmentVariable_STATUS(destination *v20211001s.EnvironmentVariable_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(variable.Name)

	// SecureValue
	destination.SecureValue = genruntime.ClonePointerToString(variable.SecureValue)

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Event_STATUS struct {
	// Count: The count of the event.
	Count *int `json:"count,omitempty"`

	// FirstTimestamp: The date-time of the earliest logged event.
	FirstTimestamp *string `json:"firstTimestamp,omitempty"`

	// LastTimestamp: The date-time of the latest logged event.
	LastTimestamp *string `json:"lastTimestamp,omitempty"`

	// Message: The event message.
	Message *string `json:"message,omitempty"`

	// Name: The event name.
	Name *string `json:"name,omitempty"`

	// Type: The event type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Event_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (event *Event_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Event_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (event *Event_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Event_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Event_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		event.Count = &count
	}

	// Set property ‘FirstTimestamp’:
	if typedInput.FirstTimestamp != nil {
		firstTimestamp := *typedInput.FirstTimestamp
		event.FirstTimestamp = &firstTimestamp
	}

	// Set property ‘LastTimestamp’:
	if typedInput.LastTimestamp != nil {
		lastTimestamp := *typedInput.LastTimestamp
		event.LastTimestamp = &lastTimestamp
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		event.Message = &message
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		event.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		event.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Event_STATUS populates our Event_STATUS from the provided source Event_STATUS
func (event *Event_STATUS) AssignProperties_From_Event_STATUS(source *v20211001s.Event_STATUS) error {

	// Count
	event.Count = genruntime.ClonePointerToInt(source.Count)

	// FirstTimestamp
	event.FirstTimestamp = genruntime.ClonePointerToString(source.FirstTimestamp)

	// LastTimestamp
	event.LastTimestamp = genruntime.ClonePointerToString(source.LastTimestamp)

	// Message
	event.Message = genruntime.ClonePointerToString(source.Message)

	// Name
	event.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	event.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Event_STATUS populates the provided destination Event_STATUS from our Event_STATUS
func (event *Event_STATUS) AssignProperties_To_Event_STATUS(destination *v20211001s.Event_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(event.Count)

	// FirstTimestamp
	destination.FirstTimestamp = genruntime.ClonePointerToString(event.FirstTimestamp)

	// LastTimestamp
	destination.LastTimestamp = genruntime.ClonePointerToString(event.LastTimestamp)

	// Message
	destination.Message = genruntime.ClonePointerToString(event.Message)

	// Name
	destination.Name = genruntime.ClonePointerToString(event.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(event.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/GitRepoVolume
type GitRepoVolume struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// +kubebuilder:validation:Required
	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.ARMTransformer = &GitRepoVolume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *GitRepoVolume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &GitRepoVolumeARM{}

	// Set property ‘Directory’:
	if volume.Directory != nil {
		directory := *volume.Directory
		result.Directory = &directory
	}

	// Set property ‘Repository’:
	if volume.Repository != nil {
		repository := *volume.Repository
		result.Repository = &repository
	}

	// Set property ‘Revision’:
	if volume.Revision != nil {
		revision := *volume.Revision
		result.Revision = &revision
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitRepoVolumeARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitRepoVolumeARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitRepoVolumeARM, got %T", armInput)
	}

	// Set property ‘Directory’:
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property ‘Repository’:
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property ‘Revision’:
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepoVolume populates our GitRepoVolume from the provided source GitRepoVolume
func (volume *GitRepoVolume) AssignProperties_From_GitRepoVolume(source *v20211001s.GitRepoVolume) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignProperties_To_GitRepoVolume populates the provided destination GitRepoVolume from our GitRepoVolume
func (volume *GitRepoVolume) AssignProperties_To_GitRepoVolume(destination *v20211001s.GitRepoVolume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GitRepoVolume_STATUS struct {
	// Directory: Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be
	// the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the
	// given name.
	Directory *string `json:"directory,omitempty"`

	// Repository: Repository URL
	Repository *string `json:"repository,omitempty"`

	// Revision: Commit hash for the specified revision.
	Revision *string `json:"revision,omitempty"`
}

var _ genruntime.FromARMConverter = &GitRepoVolume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *GitRepoVolume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitRepoVolume_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *GitRepoVolume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitRepoVolume_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitRepoVolume_STATUSARM, got %T", armInput)
	}

	// Set property ‘Directory’:
	if typedInput.Directory != nil {
		directory := *typedInput.Directory
		volume.Directory = &directory
	}

	// Set property ‘Repository’:
	if typedInput.Repository != nil {
		repository := *typedInput.Repository
		volume.Repository = &repository
	}

	// Set property ‘Revision’:
	if typedInput.Revision != nil {
		revision := *typedInput.Revision
		volume.Revision = &revision
	}

	// No error
	return nil
}

// AssignProperties_From_GitRepoVolume_STATUS populates our GitRepoVolume_STATUS from the provided source GitRepoVolume_STATUS
func (volume *GitRepoVolume_STATUS) AssignProperties_From_GitRepoVolume_STATUS(source *v20211001s.GitRepoVolume_STATUS) error {

	// Directory
	volume.Directory = genruntime.ClonePointerToString(source.Directory)

	// Repository
	volume.Repository = genruntime.ClonePointerToString(source.Repository)

	// Revision
	volume.Revision = genruntime.ClonePointerToString(source.Revision)

	// No error
	return nil
}

// AssignProperties_To_GitRepoVolume_STATUS populates the provided destination GitRepoVolume_STATUS from our GitRepoVolume_STATUS
func (volume *GitRepoVolume_STATUS) AssignProperties_To_GitRepoVolume_STATUS(destination *v20211001s.GitRepoVolume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Directory
	destination.Directory = genruntime.ClonePointerToString(volume.Directory)

	// Repository
	destination.Repository = genruntime.ClonePointerToString(volume.Repository)

	// Revision
	destination.Revision = genruntime.ClonePointerToString(volume.Revision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InitContainerPropertiesDefinition_STATUS_InstanceView struct {
	// CurrentState: The current state of the init container.
	CurrentState *ContainerState_STATUS `json:"currentState,omitempty"`

	// Events: The events of the init container.
	Events []Event_STATUS `json:"events,omitempty"`

	// PreviousState: The previous state of the init container.
	PreviousState *ContainerState_STATUS `json:"previousState,omitempty"`

	// RestartCount: The number of times that the init container has been restarted.
	RestartCount *int `json:"restartCount,omitempty"`
}

var _ genruntime.FromARMConverter = &InitContainerPropertiesDefinition_STATUS_InstanceView{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *InitContainerPropertiesDefinition_STATUS_InstanceView) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InitContainerPropertiesDefinition_STATUS_InstanceViewARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *InitContainerPropertiesDefinition_STATUS_InstanceView) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InitContainerPropertiesDefinition_STATUS_InstanceViewARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InitContainerPropertiesDefinition_STATUS_InstanceViewARM, got %T", armInput)
	}

	// Set property ‘CurrentState’:
	if typedInput.CurrentState != nil {
		var currentState1 ContainerState_STATUS
		err := currentState1.PopulateFromARM(owner, *typedInput.CurrentState)
		if err != nil {
			return err
		}
		currentState := currentState1
		view.CurrentState = &currentState
	}

	// Set property ‘Events’:
	for _, item := range typedInput.Events {
		var item1 Event_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Events = append(view.Events, item1)
	}

	// Set property ‘PreviousState’:
	if typedInput.PreviousState != nil {
		var previousState1 ContainerState_STATUS
		err := previousState1.PopulateFromARM(owner, *typedInput.PreviousState)
		if err != nil {
			return err
		}
		previousState := previousState1
		view.PreviousState = &previousState
	}

	// Set property ‘RestartCount’:
	if typedInput.RestartCount != nil {
		restartCount := *typedInput.RestartCount
		view.RestartCount = &restartCount
	}

	// No error
	return nil
}

// AssignProperties_From_InitContainerPropertiesDefinition_STATUS_InstanceView populates our InitContainerPropertiesDefinition_STATUS_InstanceView from the provided source InitContainerPropertiesDefinition_STATUS_InstanceView
func (view *InitContainerPropertiesDefinition_STATUS_InstanceView) AssignProperties_From_InitContainerPropertiesDefinition_STATUS_InstanceView(source *v20211001s.InitContainerPropertiesDefinition_STATUS_InstanceView) error {

	// CurrentState
	if source.CurrentState != nil {
		var currentState ContainerState_STATUS
		err := currentState.AssignProperties_From_ContainerState_STATUS(source.CurrentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field CurrentState")
		}
		view.CurrentState = &currentState
	} else {
		view.CurrentState = nil
	}

	// Events
	if source.Events != nil {
		eventList := make([]Event_STATUS, len(source.Events))
		for eventIndex, eventItem := range source.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event Event_STATUS
			err := event.AssignProperties_From_Event_STATUS(&eventItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		view.Events = eventList
	} else {
		view.Events = nil
	}

	// PreviousState
	if source.PreviousState != nil {
		var previousState ContainerState_STATUS
		err := previousState.AssignProperties_From_ContainerState_STATUS(source.PreviousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerState_STATUS() to populate field PreviousState")
		}
		view.PreviousState = &previousState
	} else {
		view.PreviousState = nil
	}

	// RestartCount
	view.RestartCount = genruntime.ClonePointerToInt(source.RestartCount)

	// No error
	return nil
}

// AssignProperties_To_InitContainerPropertiesDefinition_STATUS_InstanceView populates the provided destination InitContainerPropertiesDefinition_STATUS_InstanceView from our InitContainerPropertiesDefinition_STATUS_InstanceView
func (view *InitContainerPropertiesDefinition_STATUS_InstanceView) AssignProperties_To_InitContainerPropertiesDefinition_STATUS_InstanceView(destination *v20211001s.InitContainerPropertiesDefinition_STATUS_InstanceView) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentState
	if view.CurrentState != nil {
		var currentState v20211001s.ContainerState_STATUS
		err := view.CurrentState.AssignProperties_To_ContainerState_STATUS(&currentState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field CurrentState")
		}
		destination.CurrentState = &currentState
	} else {
		destination.CurrentState = nil
	}

	// Events
	if view.Events != nil {
		eventList := make([]v20211001s.Event_STATUS, len(view.Events))
		for eventIndex, eventItem := range view.Events {
			// Shadow the loop variable to avoid aliasing
			eventItem := eventItem
			var event v20211001s.Event_STATUS
			err := eventItem.AssignProperties_To_Event_STATUS(&event)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Event_STATUS() to populate field Events")
			}
			eventList[eventIndex] = event
		}
		destination.Events = eventList
	} else {
		destination.Events = nil
	}

	// PreviousState
	if view.PreviousState != nil {
		var previousState v20211001s.ContainerState_STATUS
		err := view.PreviousState.AssignProperties_To_ContainerState_STATUS(&previousState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerState_STATUS() to populate field PreviousState")
		}
		destination.PreviousState = &previousState
	} else {
		destination.PreviousState = nil
	}

	// RestartCount
	destination.RestartCount = genruntime.ClonePointerToInt(view.RestartCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Noreuse","ResourceGroupReuse","SubscriptionReuse","TenantReuse","Unsecure"}
type IpAddress_DnsNameLabelReusePolicy string

const (
	IpAddress_DnsNameLabelReusePolicy_Noreuse            = IpAddress_DnsNameLabelReusePolicy("Noreuse")
	IpAddress_DnsNameLabelReusePolicy_ResourceGroupReuse = IpAddress_DnsNameLabelReusePolicy("ResourceGroupReuse")
	IpAddress_DnsNameLabelReusePolicy_SubscriptionReuse  = IpAddress_DnsNameLabelReusePolicy("SubscriptionReuse")
	IpAddress_DnsNameLabelReusePolicy_TenantReuse        = IpAddress_DnsNameLabelReusePolicy("TenantReuse")
	IpAddress_DnsNameLabelReusePolicy_Unsecure           = IpAddress_DnsNameLabelReusePolicy("Unsecure")
)

type IpAddress_STATUS_DnsNameLabelReusePolicy string

const (
	IpAddress_STATUS_DnsNameLabelReusePolicy_Noreuse            = IpAddress_STATUS_DnsNameLabelReusePolicy("Noreuse")
	IpAddress_STATUS_DnsNameLabelReusePolicy_ResourceGroupReuse = IpAddress_STATUS_DnsNameLabelReusePolicy("ResourceGroupReuse")
	IpAddress_STATUS_DnsNameLabelReusePolicy_SubscriptionReuse  = IpAddress_STATUS_DnsNameLabelReusePolicy("SubscriptionReuse")
	IpAddress_STATUS_DnsNameLabelReusePolicy_TenantReuse        = IpAddress_STATUS_DnsNameLabelReusePolicy("TenantReuse")
	IpAddress_STATUS_DnsNameLabelReusePolicy_Unsecure           = IpAddress_STATUS_DnsNameLabelReusePolicy("Unsecure")
)

type IpAddress_STATUS_Type string

const (
	IpAddress_STATUS_Type_Private = IpAddress_STATUS_Type("Private")
	IpAddress_STATUS_Type_Public  = IpAddress_STATUS_Type("Public")
)

// +kubebuilder:validation:Enum={"Private","Public"}
type IpAddress_Type string

const (
	IpAddress_Type_Private = IpAddress_Type("Private")
	IpAddress_Type_Public  = IpAddress_Type("Public")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/LogAnalytics
type LogAnalytics struct {
	// LogType: The log type to be used.
	LogType *LogAnalytics_LogType `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// +kubebuilder:validation:Required
	// WorkspaceKey: The workspace key for log analytics
	WorkspaceKey *string `json:"workspaceKey,omitempty"`

	// WorkspaceResourceReference: The workspace resource id for log analytics
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &LogAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *LogAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &LogAnalyticsARM{}

	// Set property ‘LogType’:
	if analytics.LogType != nil {
		logType := *analytics.LogType
		result.LogType = &logType
	}

	// Set property ‘Metadata’:
	if analytics.Metadata != nil {
		result.Metadata = make(map[string]string, len(analytics.Metadata))
		for key, value := range analytics.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if analytics.WorkspaceId != nil {
		workspaceId := *analytics.WorkspaceId
		result.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if analytics.WorkspaceKey != nil {
		workspaceKey := *analytics.WorkspaceKey
		result.WorkspaceKey = &workspaceKey
	}

	// Set property ‘WorkspaceResourceId’:
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*analytics.WorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		workspaceResourceReference := workspaceResourceReferenceARMID
		result.WorkspaceResourceId = &workspaceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LogAnalyticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LogAnalyticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LogAnalyticsARM, got %T", armInput)
	}

	// Set property ‘LogType’:
	if typedInput.LogType != nil {
		logType := *typedInput.LogType
		analytics.LogType = &logType
	}

	// Set property ‘Metadata’:
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if typedInput.WorkspaceKey != nil {
		workspaceKey := *typedInput.WorkspaceKey
		analytics.WorkspaceKey = &workspaceKey
	}

	// no assignment for property ‘WorkspaceResourceReference’

	// No error
	return nil
}

// AssignProperties_From_LogAnalytics populates our LogAnalytics from the provided source LogAnalytics
func (analytics *LogAnalytics) AssignProperties_From_LogAnalytics(source *v20211001s.LogAnalytics) error {

	// LogType
	if source.LogType != nil {
		logType := LogAnalytics_LogType(*source.LogType)
		analytics.LogType = &logType
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceKey
	analytics.WorkspaceKey = genruntime.ClonePointerToString(source.WorkspaceKey)

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		analytics.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		analytics.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalytics populates the provided destination LogAnalytics from our LogAnalytics
func (analytics *LogAnalytics) AssignProperties_To_LogAnalytics(destination *v20211001s.LogAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// WorkspaceKey
	destination.WorkspaceKey = genruntime.ClonePointerToString(analytics.WorkspaceKey)

	// WorkspaceResourceReference
	if analytics.WorkspaceResourceReference != nil {
		workspaceResourceReference := analytics.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LogAnalytics_STATUS struct {
	// LogType: The log type to be used.
	LogType *LogAnalytics_STATUS_LogType `json:"logType,omitempty"`

	// Metadata: Metadata for log analytics.
	Metadata map[string]string `json:"metadata,omitempty"`

	// WorkspaceId: The workspace id for log analytics
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceKey: The workspace key for log analytics
	WorkspaceKey *string `json:"workspaceKey,omitempty"`

	// WorkspaceResourceId: The workspace resource id for log analytics
	WorkspaceResourceId *string `json:"workspaceResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &LogAnalytics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *LogAnalytics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LogAnalytics_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *LogAnalytics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LogAnalytics_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LogAnalytics_STATUSARM, got %T", armInput)
	}

	// Set property ‘LogType’:
	if typedInput.LogType != nil {
		logType := *typedInput.LogType
		analytics.LogType = &logType
	}

	// Set property ‘Metadata’:
	if typedInput.Metadata != nil {
		analytics.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			analytics.Metadata[key] = value
		}
	}

	// Set property ‘WorkspaceId’:
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		analytics.WorkspaceId = &workspaceId
	}

	// Set property ‘WorkspaceKey’:
	if typedInput.WorkspaceKey != nil {
		workspaceKey := *typedInput.WorkspaceKey
		analytics.WorkspaceKey = &workspaceKey
	}

	// Set property ‘WorkspaceResourceId’:
	if typedInput.WorkspaceResourceId != nil {
		workspaceResourceId := *typedInput.WorkspaceResourceId
		analytics.WorkspaceResourceId = &workspaceResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_LogAnalytics_STATUS populates our LogAnalytics_STATUS from the provided source LogAnalytics_STATUS
func (analytics *LogAnalytics_STATUS) AssignProperties_From_LogAnalytics_STATUS(source *v20211001s.LogAnalytics_STATUS) error {

	// LogType
	if source.LogType != nil {
		logType := LogAnalytics_STATUS_LogType(*source.LogType)
		analytics.LogType = &logType
	} else {
		analytics.LogType = nil
	}

	// Metadata
	analytics.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// WorkspaceId
	analytics.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceKey
	analytics.WorkspaceKey = genruntime.ClonePointerToString(source.WorkspaceKey)

	// WorkspaceResourceId
	analytics.WorkspaceResourceId = genruntime.ClonePointerToString(source.WorkspaceResourceId)

	// No error
	return nil
}

// AssignProperties_To_LogAnalytics_STATUS populates the provided destination LogAnalytics_STATUS from our LogAnalytics_STATUS
func (analytics *LogAnalytics_STATUS) AssignProperties_To_LogAnalytics_STATUS(destination *v20211001s.LogAnalytics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogType
	if analytics.LogType != nil {
		logType := string(*analytics.LogType)
		destination.LogType = &logType
	} else {
		destination.LogType = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(analytics.Metadata)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(analytics.WorkspaceId)

	// WorkspaceKey
	destination.WorkspaceKey = genruntime.ClonePointerToString(analytics.WorkspaceKey)

	// WorkspaceResourceId
	destination.WorkspaceResourceId = genruntime.ClonePointerToString(analytics.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/Port
type Port struct {
	// +kubebuilder:validation:Required
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *Port_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &Port{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (port *Port) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if port == nil {
		return nil, nil
	}
	result := &PortARM{}

	// Set property ‘Port’:
	if port.Port != nil {
		port1 := *port.Port
		result.Port = &port1
	}

	// Set property ‘Protocol’:
	if port.Protocol != nil {
		protocol := *port.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PortARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PortARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PortARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_Port populates our Port from the provided source Port
func (port *Port) AssignProperties_From_Port(source *v20211001s.Port) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := Port_Protocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Port populates the provided destination Port from our Port
func (port *Port) AssignProperties_To_Port(destination *v20211001s.Port) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Port_STATUS struct {
	// Port: The port number.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol associated with the port.
	Protocol *Port_STATUS_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &Port_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (port *Port_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Port_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (port *Port_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Port_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Port_STATUSARM, got %T", armInput)
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port1 := *typedInput.Port
		port.Port = &port1
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		port.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_Port_STATUS populates our Port_STATUS from the provided source Port_STATUS
func (port *Port_STATUS) AssignProperties_From_Port_STATUS(source *v20211001s.Port_STATUS) error {

	// Port
	port.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := Port_STATUS_Protocol(*source.Protocol)
		port.Protocol = &protocol
	} else {
		port.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Port_STATUS populates the provided destination Port_STATUS from our Port_STATUS
func (port *Port_STATUS) AssignProperties_To_Port_STATUS(destination *v20211001s.Port_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(port.Port)

	// Protocol
	if port.Protocol != nil {
		protocol := string(*port.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceRequirements
type ResourceRequirements struct {
	// Limits: The resource limits.
	Limits *ResourceLimits `json:"limits,omitempty"`

	// +kubebuilder:validation:Required
	// Requests: The resource requests.
	Requests *ResourceRequests `json:"requests,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequirements{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requirements *ResourceRequirements) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requirements == nil {
		return nil, nil
	}
	result := &ResourceRequirementsARM{}

	// Set property ‘Limits’:
	if requirements.Limits != nil {
		limitsARM, err := (*requirements.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limitsARM.(*ResourceLimitsARM)
		result.Limits = &limits
	}

	// Set property ‘Requests’:
	if requirements.Requests != nil {
		requestsARM, err := (*requirements.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requestsARM.(*ResourceRequestsARM)
		result.Requests = &requests
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequirementsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequirementsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequirementsARM, got %T", armInput)
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 ResourceLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 ResourceRequests
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequirements populates our ResourceRequirements from the provided source ResourceRequirements
func (requirements *ResourceRequirements) AssignProperties_From_ResourceRequirements(source *v20211001s.ResourceRequirements) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits
		err := limit.AssignProperties_From_ResourceLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceLimits() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests
		err := request.AssignProperties_From_ResourceRequests(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequests() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequirements populates the provided destination ResourceRequirements from our ResourceRequirements
func (requirements *ResourceRequirements) AssignProperties_To_ResourceRequirements(destination *v20211001s.ResourceRequirements) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit v20211001s.ResourceLimits
		err := requirements.Limits.AssignProperties_To_ResourceLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request v20211001s.ResourceRequests
		err := requirements.Requests.AssignProperties_To_ResourceRequests(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequests() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceRequirements_STATUS struct {
	// Limits: The resource limits of this container instance.
	Limits *ResourceLimits_STATUS `json:"limits,omitempty"`

	// Requests: The resource requests of this container instance.
	Requests *ResourceRequests_STATUS `json:"requests,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequirements_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requirements *ResourceRequirements_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequirements_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requirements *ResourceRequirements_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequirements_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequirements_STATUSARM, got %T", armInput)
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 ResourceLimits_STATUS
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		requirements.Limits = &limits
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 ResourceRequests_STATUS
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		requirements.Requests = &requests
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequirements_STATUS populates our ResourceRequirements_STATUS from the provided source ResourceRequirements_STATUS
func (requirements *ResourceRequirements_STATUS) AssignProperties_From_ResourceRequirements_STATUS(source *v20211001s.ResourceRequirements_STATUS) error {

	// Limits
	if source.Limits != nil {
		var limit ResourceLimits_STATUS
		err := limit.AssignProperties_From_ResourceLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceLimits_STATUS() to populate field Limits")
		}
		requirements.Limits = &limit
	} else {
		requirements.Limits = nil
	}

	// Requests
	if source.Requests != nil {
		var request ResourceRequests_STATUS
		err := request.AssignProperties_From_ResourceRequests_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceRequests_STATUS() to populate field Requests")
		}
		requirements.Requests = &request
	} else {
		requirements.Requests = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequirements_STATUS populates the provided destination ResourceRequirements_STATUS from our ResourceRequirements_STATUS
func (requirements *ResourceRequirements_STATUS) AssignProperties_To_ResourceRequirements_STATUS(destination *v20211001s.ResourceRequirements_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	if requirements.Limits != nil {
		var limit v20211001s.ResourceLimits_STATUS
		err := requirements.Limits.AssignProperties_To_ResourceLimits_STATUS(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceLimits_STATUS() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// Requests
	if requirements.Requests != nil {
		var request v20211001s.ResourceRequests_STATUS
		err := requirements.Requests.AssignProperties_To_ResourceRequests_STATUS(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceRequests_STATUS() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/VolumeMount
type VolumeMount struct {
	// +kubebuilder:validation:Required
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeMount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mount *VolumeMount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mount == nil {
		return nil, nil
	}
	result := &VolumeMountARM{}

	// Set property ‘MountPath’:
	if mount.MountPath != nil {
		mountPath := *mount.MountPath
		result.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if mount.Name != nil {
		name := *mount.Name
		result.Name = &name
	}

	// Set property ‘ReadOnly’:
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		result.ReadOnly = &readOnly
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeMountARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeMountARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeMountARM, got %T", armInput)
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount populates our VolumeMount from the provided source VolumeMount
func (mount *VolumeMount) AssignProperties_From_VolumeMount(source *v20211001s.VolumeMount) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount populates the provided destination VolumeMount from our VolumeMount
func (mount *VolumeMount) AssignProperties_To_VolumeMount(destination *v20211001s.VolumeMount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VolumeMount_STATUS struct {
	// MountPath: The path within the container where the volume should be mounted. Must not contain colon (:).
	MountPath *string `json:"mountPath,omitempty"`

	// Name: The name of the volume mount.
	Name *string `json:"name,omitempty"`

	// ReadOnly: The flag indicating whether the volume mount is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeMount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VolumeMount_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VolumeMount_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VolumeMount_STATUSARM, got %T", armInput)
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		mount.Name = &name
	}

	// Set property ‘ReadOnly’:
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		mount.ReadOnly = &readOnly
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount_STATUS populates our VolumeMount_STATUS from the provided source VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_From_VolumeMount_STATUS(source *v20211001s.VolumeMount_STATUS) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// Name
	mount.Name = genruntime.ClonePointerToString(source.Name)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		mount.ReadOnly = &readOnly
	} else {
		mount.ReadOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount_STATUS populates the provided destination VolumeMount_STATUS from our VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_To_VolumeMount_STATUS(destination *v20211001s.VolumeMount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// Name
	destination.Name = genruntime.ClonePointerToString(mount.Name)

	// ReadOnly
	if mount.ReadOnly != nil {
		readOnly := *mount.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerExec
type ContainerExec struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerExec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exec *ContainerExec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exec == nil {
		return nil, nil
	}
	result := &ContainerExecARM{}

	// Set property ‘Command’:
	for _, item := range exec.Command {
		result.Command = append(result.Command, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerExecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerExecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerExecARM, got %T", armInput)
	}

	// Set property ‘Command’:
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerExec populates our ContainerExec from the provided source ContainerExec
func (exec *ContainerExec) AssignProperties_From_ContainerExec(source *v20211001s.ContainerExec) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignProperties_To_ContainerExec populates the provided destination ContainerExec from our ContainerExec
func (exec *ContainerExec) AssignProperties_To_ContainerExec(destination *v20211001s.ContainerExec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerExec_STATUS struct {
	// Command: The commands to execute within the container.
	Command []string `json:"command,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerExec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exec *ContainerExec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerExec_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exec *ContainerExec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerExec_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerExec_STATUSARM, got %T", armInput)
	}

	// Set property ‘Command’:
	for _, item := range typedInput.Command {
		exec.Command = append(exec.Command, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerExec_STATUS populates our ContainerExec_STATUS from the provided source ContainerExec_STATUS
func (exec *ContainerExec_STATUS) AssignProperties_From_ContainerExec_STATUS(source *v20211001s.ContainerExec_STATUS) error {

	// Command
	exec.Command = genruntime.CloneSliceOfString(source.Command)

	// No error
	return nil
}

// AssignProperties_To_ContainerExec_STATUS populates the provided destination ContainerExec_STATUS from our ContainerExec_STATUS
func (exec *ContainerExec_STATUS) AssignProperties_To_ContainerExec_STATUS(destination *v20211001s.ContainerExec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Command
	destination.Command = genruntime.CloneSliceOfString(exec.Command)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ContainerHttpGet
type ContainerHttpGet struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// +kubebuilder:validation:Required
	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGet_Scheme `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerHttpGet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (httpGet *ContainerHttpGet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if httpGet == nil {
		return nil, nil
	}
	result := &ContainerHttpGetARM{}

	// Set property ‘HttpHeaders’:
	for _, item := range httpGet.HttpHeaders {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpHeaders = append(result.HttpHeaders, *itemARM.(*HttpHeaderARM))
	}

	// Set property ‘Path’:
	if httpGet.Path != nil {
		path := *httpGet.Path
		result.Path = &path
	}

	// Set property ‘Port’:
	if httpGet.Port != nil {
		port := *httpGet.Port
		result.Port = &port
	}

	// Set property ‘Scheme’:
	if httpGet.Scheme != nil {
		scheme := *httpGet.Scheme
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerHttpGetARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerHttpGetARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerHttpGetARM, got %T", armInput)
	}

	// Set property ‘HttpHeaders’:
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property ‘Scheme’:
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerHttpGet populates our ContainerHttpGet from the provided source ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignProperties_From_ContainerHttpGet(source *v20211001s.ContainerHttpGet) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader
			err := httpHeader.AssignProperties_From_HttpHeader(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := ContainerHttpGet_Scheme(*source.Scheme)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerHttpGet populates the provided destination ContainerHttpGet from our ContainerHttpGet
func (httpGet *ContainerHttpGet) AssignProperties_To_ContainerHttpGet(destination *v20211001s.ContainerHttpGet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]v20211001s.HttpHeader, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader v20211001s.HttpHeader
			err := httpHeaderItem.AssignProperties_To_HttpHeader(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpHeader() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerHttpGet_STATUS struct {
	// HttpHeaders: The HTTP headers.
	HttpHeaders []HttpHeader_STATUS `json:"httpHeaders,omitempty"`

	// Path: The path to probe.
	Path *string `json:"path,omitempty"`

	// Port: The port number to probe.
	Port *int `json:"port,omitempty"`

	// Scheme: The scheme.
	Scheme *ContainerHttpGet_STATUS_Scheme `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerHttpGet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerHttpGet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerHttpGet_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerHttpGet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerHttpGet_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerHttpGet_STATUSARM, got %T", armInput)
	}

	// Set property ‘HttpHeaders’:
	for _, item := range typedInput.HttpHeaders {
		var item1 HttpHeader_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property ‘Port’:
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property ‘Scheme’:
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerHttpGet_STATUS populates our ContainerHttpGet_STATUS from the provided source ContainerHttpGet_STATUS
func (httpGet *ContainerHttpGet_STATUS) AssignProperties_From_ContainerHttpGet_STATUS(source *v20211001s.ContainerHttpGet_STATUS) error {

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]HttpHeader_STATUS, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader HttpHeader_STATUS
			err := httpHeader.AssignProperties_From_HttpHeader_STATUS(&httpHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpHeader_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := ContainerHttpGet_STATUS_Scheme(*source.Scheme)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerHttpGet_STATUS populates the provided destination ContainerHttpGet_STATUS from our ContainerHttpGet_STATUS
func (httpGet *ContainerHttpGet_STATUS) AssignProperties_To_ContainerHttpGet_STATUS(destination *v20211001s.ContainerHttpGet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]v20211001s.HttpHeader_STATUS, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader v20211001s.HttpHeader_STATUS
			err := httpHeaderItem.AssignProperties_To_HttpHeader_STATUS(&httpHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpHeader_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"TCP","UDP"}
type ContainerPort_Protocol string

const (
	ContainerPort_Protocol_TCP = ContainerPort_Protocol("TCP")
	ContainerPort_Protocol_UDP = ContainerPort_Protocol("UDP")
)

type ContainerPort_STATUS_Protocol string

const (
	ContainerPort_STATUS_Protocol_TCP = ContainerPort_STATUS_Protocol("TCP")
	ContainerPort_STATUS_Protocol_UDP = ContainerPort_STATUS_Protocol("UDP")
)

type ContainerState_STATUS struct {
	// DetailStatus: The human-readable status of the container instance state.
	DetailStatus *string `json:"detailStatus,omitempty"`

	// ExitCode: The container instance exit codes correspond to those from the `docker run` command.
	ExitCode *int `json:"exitCode,omitempty"`

	// FinishTime: The date-time when the container instance state finished.
	FinishTime *string `json:"finishTime,omitempty"`

	// StartTime: The date-time when the container instance state started.
	StartTime *string `json:"startTime,omitempty"`

	// State: The state of the container instance.
	State *string `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *ContainerState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerState_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *ContainerState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerState_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerState_STATUSARM, got %T", armInput)
	}

	// Set property ‘DetailStatus’:
	if typedInput.DetailStatus != nil {
		detailStatus := *typedInput.DetailStatus
		state.DetailStatus = &detailStatus
	}

	// Set property ‘ExitCode’:
	if typedInput.ExitCode != nil {
		exitCode := *typedInput.ExitCode
		state.ExitCode = &exitCode
	}

	// Set property ‘FinishTime’:
	if typedInput.FinishTime != nil {
		finishTime := *typedInput.FinishTime
		state.FinishTime = &finishTime
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		state.StartTime = &startTime
	}

	// Set property ‘State’:
	if typedInput.State != nil {
		state1 := *typedInput.State
		state.State = &state1
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerState_STATUS populates our ContainerState_STATUS from the provided source ContainerState_STATUS
func (state *ContainerState_STATUS) AssignProperties_From_ContainerState_STATUS(source *v20211001s.ContainerState_STATUS) error {

	// DetailStatus
	state.DetailStatus = genruntime.ClonePointerToString(source.DetailStatus)

	// ExitCode
	state.ExitCode = genruntime.ClonePointerToInt(source.ExitCode)

	// FinishTime
	state.FinishTime = genruntime.ClonePointerToString(source.FinishTime)

	// StartTime
	state.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// State
	state.State = genruntime.ClonePointerToString(source.State)

	// No error
	return nil
}

// AssignProperties_To_ContainerState_STATUS populates the provided destination ContainerState_STATUS from our ContainerState_STATUS
func (state *ContainerState_STATUS) AssignProperties_To_ContainerState_STATUS(destination *v20211001s.ContainerState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DetailStatus
	destination.DetailStatus = genruntime.ClonePointerToString(state.DetailStatus)

	// ExitCode
	destination.ExitCode = genruntime.ClonePointerToInt(state.ExitCode)

	// FinishTime
	destination.FinishTime = genruntime.ClonePointerToString(state.FinishTime)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(state.StartTime)

	// State
	destination.State = genruntime.ClonePointerToString(state.State)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ContainerInsights","ContainerInstanceLogs"}
type LogAnalytics_LogType string

const (
	LogAnalytics_LogType_ContainerInsights     = LogAnalytics_LogType("ContainerInsights")
	LogAnalytics_LogType_ContainerInstanceLogs = LogAnalytics_LogType("ContainerInstanceLogs")
)

type LogAnalytics_STATUS_LogType string

const (
	LogAnalytics_STATUS_LogType_ContainerInsights     = LogAnalytics_STATUS_LogType("ContainerInsights")
	LogAnalytics_STATUS_LogType_ContainerInstanceLogs = LogAnalytics_STATUS_LogType("ContainerInstanceLogs")
)

// +kubebuilder:validation:Enum={"TCP","UDP"}
type Port_Protocol string

const (
	Port_Protocol_TCP = Port_Protocol("TCP")
	Port_Protocol_UDP = Port_Protocol("UDP")
)

type Port_STATUS_Protocol string

const (
	Port_STATUS_Protocol_TCP = Port_STATUS_Protocol("TCP")
	Port_STATUS_Protocol_UDP = Port_STATUS_Protocol("UDP")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceLimits
type ResourceLimits struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU resource.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *ResourceLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &ResourceLimitsARM{}

	// Set property ‘Cpu’:
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		result.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if limits.Gpu != nil {
		gpuARM, err := (*limits.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpuARM.(*GpuResourceARM)
		result.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceLimitsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceLimitsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceLimitsARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceLimits populates our ResourceLimits from the provided source ResourceLimits
func (limits *ResourceLimits) AssignProperties_From_ResourceLimits(source *v20211001s.ResourceLimits) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignProperties_From_GpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceLimits populates the provided destination ResourceLimits from our ResourceLimits
func (limits *ResourceLimits) AssignProperties_To_ResourceLimits(destination *v20211001s.ResourceLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu v20211001s.GpuResource
		err := limits.Gpu.AssignProperties_To_GpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceLimits_STATUS struct {
	// Cpu: The CPU limit of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU limit of this container instance.
	Gpu *GpuResource_STATUS `json:"gpu,omitempty"`

	// MemoryInGB: The memory limit in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceLimits_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *ResourceLimits_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceLimits_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *ResourceLimits_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceLimits_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceLimits_STATUSARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		limits.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_STATUS
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		limits.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceLimits_STATUS populates our ResourceLimits_STATUS from the provided source ResourceLimits_STATUS
func (limits *ResourceLimits_STATUS) AssignProperties_From_ResourceLimits_STATUS(source *v20211001s.ResourceLimits_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		limits.Cpu = &cpu
	} else {
		limits.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_STATUS
		err := gpu.AssignProperties_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource_STATUS() to populate field Gpu")
		}
		limits.Gpu = &gpu
	} else {
		limits.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		limits.MemoryInGB = &memoryInGB
	} else {
		limits.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceLimits_STATUS populates the provided destination ResourceLimits_STATUS from our ResourceLimits_STATUS
func (limits *ResourceLimits_STATUS) AssignProperties_To_ResourceLimits_STATUS(destination *v20211001s.ResourceLimits_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if limits.Cpu != nil {
		cpu := *limits.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if limits.Gpu != nil {
		var gpu v20211001s.GpuResource_STATUS
		err := limits.Gpu.AssignProperties_To_GpuResource_STATUS(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource_STATUS() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if limits.MemoryInGB != nil {
		memoryInGB := *limits.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/ResourceRequests
type ResourceRequests struct {
	// +kubebuilder:validation:Required
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU resource.
	Gpu *GpuResource `json:"gpu,omitempty"`

	// +kubebuilder:validation:Required
	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceRequests{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (requests *ResourceRequests) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if requests == nil {
		return nil, nil
	}
	result := &ResourceRequestsARM{}

	// Set property ‘Cpu’:
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		result.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if requests.Gpu != nil {
		gpuARM, err := (*requests.Gpu).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpu := *gpuARM.(*GpuResourceARM)
		result.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		result.MemoryInGB = &memoryInGB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequestsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequestsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequestsARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequests populates our ResourceRequests from the provided source ResourceRequests
func (requests *ResourceRequests) AssignProperties_From_ResourceRequests(source *v20211001s.ResourceRequests) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource
		err := gpu.AssignProperties_From_GpuResource(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequests populates the provided destination ResourceRequests from our ResourceRequests
func (requests *ResourceRequests) AssignProperties_To_ResourceRequests(destination *v20211001s.ResourceRequests) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu v20211001s.GpuResource
		err := requests.Gpu.AssignProperties_To_GpuResource(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceRequests_STATUS struct {
	// Cpu: The CPU request of this container instance.
	Cpu *float64 `json:"cpu,omitempty"`

	// Gpu: The GPU request of this container instance.
	Gpu *GpuResource_STATUS `json:"gpu,omitempty"`

	// MemoryInGB: The memory request in GB of this container instance.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceRequests_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (requests *ResourceRequests_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceRequests_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (requests *ResourceRequests_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceRequests_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceRequests_STATUSARM, got %T", armInput)
	}

	// Set property ‘Cpu’:
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		requests.Cpu = &cpu
	}

	// Set property ‘Gpu’:
	if typedInput.Gpu != nil {
		var gpu1 GpuResource_STATUS
		err := gpu1.PopulateFromARM(owner, *typedInput.Gpu)
		if err != nil {
			return err
		}
		gpu := gpu1
		requests.Gpu = &gpu
	}

	// Set property ‘MemoryInGB’:
	if typedInput.MemoryInGB != nil {
		memoryInGB := *typedInput.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceRequests_STATUS populates our ResourceRequests_STATUS from the provided source ResourceRequests_STATUS
func (requests *ResourceRequests_STATUS) AssignProperties_From_ResourceRequests_STATUS(source *v20211001s.ResourceRequests_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		requests.Cpu = &cpu
	} else {
		requests.Cpu = nil
	}

	// Gpu
	if source.Gpu != nil {
		var gpu GpuResource_STATUS
		err := gpu.AssignProperties_From_GpuResource_STATUS(source.Gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GpuResource_STATUS() to populate field Gpu")
		}
		requests.Gpu = &gpu
	} else {
		requests.Gpu = nil
	}

	// MemoryInGB
	if source.MemoryInGB != nil {
		memoryInGB := *source.MemoryInGB
		requests.MemoryInGB = &memoryInGB
	} else {
		requests.MemoryInGB = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceRequests_STATUS populates the provided destination ResourceRequests_STATUS from our ResourceRequests_STATUS
func (requests *ResourceRequests_STATUS) AssignProperties_To_ResourceRequests_STATUS(destination *v20211001s.ResourceRequests_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if requests.Cpu != nil {
		cpu := *requests.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Gpu
	if requests.Gpu != nil {
		var gpu v20211001s.GpuResource_STATUS
		err := requests.Gpu.AssignProperties_To_GpuResource_STATUS(&gpu)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GpuResource_STATUS() to populate field Gpu")
		}
		destination.Gpu = &gpu
	} else {
		destination.Gpu = nil
	}

	// MemoryInGB
	if requests.MemoryInGB != nil {
		memoryInGB := *requests.MemoryInGB
		destination.MemoryInGB = &memoryInGB
	} else {
		destination.MemoryInGB = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","https"}
type ContainerHttpGet_Scheme string

const (
	ContainerHttpGet_Scheme_Http  = ContainerHttpGet_Scheme("http")
	ContainerHttpGet_Scheme_Https = ContainerHttpGet_Scheme("https")
)

type ContainerHttpGet_STATUS_Scheme string

const (
	ContainerHttpGet_STATUS_Scheme_Http  = ContainerHttpGet_STATUS_Scheme("http")
	ContainerHttpGet_STATUS_Scheme_Https = ContainerHttpGet_STATUS_Scheme("https")
)

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/GpuResource
type GpuResource struct {
	// +kubebuilder:validation:Required
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: The SKU of the GPU resource.
	Sku *GpuResource_Sku `json:"sku,omitempty"`
}

var _ genruntime.ARMTransformer = &GpuResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *GpuResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &GpuResourceARM{}

	// Set property ‘Count’:
	if resource.Count != nil {
		count := *resource.Count
		result.Count = &count
	}

	// Set property ‘Sku’:
	if resource.Sku != nil {
		sku := *resource.Sku
		result.Sku = &sku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GpuResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GpuResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GpuResourceARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_GpuResource populates our GpuResource from the provided source GpuResource
func (resource *GpuResource) AssignProperties_From_GpuResource(source *v20211001s.GpuResource) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := GpuResource_Sku(*source.Sku)
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GpuResource populates the provided destination GpuResource from our GpuResource
func (resource *GpuResource) AssignProperties_To_GpuResource(destination *v20211001s.GpuResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GpuResource_STATUS struct {
	// Count: The count of the GPU resource.
	Count *int `json:"count,omitempty"`

	// Sku: The SKU of the GPU resource.
	Sku *GpuResource_STATUS_Sku `json:"sku,omitempty"`
}

var _ genruntime.FromARMConverter = &GpuResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *GpuResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GpuResource_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *GpuResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GpuResource_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GpuResource_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		resource.Count = &count
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		resource.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_GpuResource_STATUS populates our GpuResource_STATUS from the provided source GpuResource_STATUS
func (resource *GpuResource_STATUS) AssignProperties_From_GpuResource_STATUS(source *v20211001s.GpuResource_STATUS) error {

	// Count
	resource.Count = genruntime.ClonePointerToInt(source.Count)

	// Sku
	if source.Sku != nil {
		sku := GpuResource_STATUS_Sku(*source.Sku)
		resource.Sku = &sku
	} else {
		resource.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GpuResource_STATUS populates the provided destination GpuResource_STATUS from our GpuResource_STATUS
func (resource *GpuResource_STATUS) AssignProperties_To_GpuResource_STATUS(destination *v20211001s.GpuResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(resource.Count)

	// Sku
	if resource.Sku != nil {
		sku := string(*resource.Sku)
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2021-10-01/Microsoft.ContainerInstance.json#/definitions/HttpHeader
type HttpHeader struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpHeader{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (header *HttpHeader) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if header == nil {
		return nil, nil
	}
	result := &HttpHeaderARM{}

	// Set property ‘Name’:
	if header.Name != nil {
		name := *header.Name
		result.Name = &name
	}

	// Set property ‘Value’:
	if header.Value != nil {
		value := *header.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpHeaderARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpHeaderARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpHeaderARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HttpHeader populates our HttpHeader from the provided source HttpHeader
func (header *HttpHeader) AssignProperties_From_HttpHeader(source *v20211001s.HttpHeader) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HttpHeader populates the provided destination HttpHeader from our HttpHeader
func (header *HttpHeader) AssignProperties_To_HttpHeader(destination *v20211001s.HttpHeader) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HttpHeader_STATUS struct {
	// Name: The header name.
	Name *string `json:"name,omitempty"`

	// Value: The header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpHeader_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (header *HttpHeader_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpHeader_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (header *HttpHeader_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpHeader_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpHeader_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		header.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		header.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HttpHeader_STATUS populates our HttpHeader_STATUS from the provided source HttpHeader_STATUS
func (header *HttpHeader_STATUS) AssignProperties_From_HttpHeader_STATUS(source *v20211001s.HttpHeader_STATUS) error {

	// Name
	header.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	header.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HttpHeader_STATUS populates the provided destination HttpHeader_STATUS from our HttpHeader_STATUS
func (header *HttpHeader_STATUS) AssignProperties_To_HttpHeader_STATUS(destination *v20211001s.HttpHeader_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(header.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(header.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"K80","P100","V100"}
type GpuResource_Sku string

const (
	GpuResource_Sku_K80  = GpuResource_Sku("K80")
	GpuResource_Sku_P100 = GpuResource_Sku("P100")
	GpuResource_Sku_V100 = GpuResource_Sku("V100")
)

type GpuResource_STATUS_Sku string

const (
	GpuResource_STATUS_Sku_K80  = GpuResource_STATUS_Sku("K80")
	GpuResource_STATUS_Sku_P100 = GpuResource_STATUS_Sku("P100")
	GpuResource_STATUS_Sku_V100 = GpuResource_STATUS_Sku("V100")
)

func init() {
	SchemeBuilder.Register(&ContainerGroup{}, &ContainerGroupList{})
}
