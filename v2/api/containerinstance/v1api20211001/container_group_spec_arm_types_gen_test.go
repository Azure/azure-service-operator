// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroup_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Spec_ARM, ContainerGroup_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Spec_ARM runs a test to see if a specific instance of ContainerGroup_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Spec_ARM(subject ContainerGroup_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Spec_ARM instances for property testing - lazily instantiated by
// ContainerGroup_Spec_ARMGenerator()
var containerGroup_Spec_ARMGenerator gopter.Gen

// ContainerGroup_Spec_ARMGenerator returns a generator of ContainerGroup_Spec_ARM instances for property testing.
// We first initialize containerGroup_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Spec_ARMGenerator() gopter.Gen {
	if containerGroup_Spec_ARMGenerator != nil {
		return containerGroup_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec_ARM(generators)
	containerGroup_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Spec_ARM(generators)
	containerGroup_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec_ARM{}), generators)

	return containerGroup_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(ContainerGroup_Properties_Spec_ARMGenerator())
}

func Test_ContainerGroup_Properties_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Spec_ARM, ContainerGroup_Properties_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Spec_ARM runs a test to see if a specific instance of ContainerGroup_Properties_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Spec_ARM(subject ContainerGroup_Properties_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Spec_ARM instances for property testing - lazily instantiated by
// ContainerGroup_Properties_Spec_ARMGenerator()
var containerGroup_Properties_Spec_ARMGenerator gopter.Gen

// ContainerGroup_Properties_Spec_ARMGenerator returns a generator of ContainerGroup_Properties_Spec_ARM instances for property testing.
// We first initialize containerGroup_Properties_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Properties_Spec_ARMGenerator() gopter.Gen {
	if containerGroup_Properties_Spec_ARMGenerator != nil {
		return containerGroup_Properties_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec_ARM(generators)
	containerGroup_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec_ARM(generators)
	containerGroup_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Spec_ARM{}), generators)

	return containerGroup_Properties_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroup_Properties_OsType_Spec_Linux, ContainerGroup_Properties_OsType_Spec_Windows))
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroup_Properties_RestartPolicy_Spec_Always, ContainerGroup_Properties_RestartPolicy_Spec_Never, ContainerGroup_Properties_RestartPolicy_Spec_OnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSku_Dedicated, ContainerGroupSku_Standard))
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(Container_ARMGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnostics_ARMGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfiguration_ARMGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionProperties_ARMGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredential_ARMGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinition_ARMGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddress_ARMGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetId_ARMGenerator())
	gens["Volumes"] = gen.SliceOf(Volume_ARMGenerator())
}

func Test_ContainerGroupIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity_ARM, ContainerGroupIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity_ARM runs a test to see if a specific instance of ContainerGroupIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity_ARM(subject ContainerGroupIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_ARM instances for property testing - lazily instantiated by
// ContainerGroupIdentity_ARMGenerator()
var containerGroupIdentity_ARMGenerator gopter.Gen

// ContainerGroupIdentity_ARMGenerator returns a generator of ContainerGroupIdentity_ARM instances for property testing.
// We first initialize containerGroupIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentity_ARMGenerator() gopter.Gen {
	if containerGroupIdentity_ARMGenerator != nil {
		return containerGroupIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity_ARM(generators)
	containerGroupIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentity_ARM(generators)
	containerGroupIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_ARM{}), generators)

	return containerGroupIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentity_Type_None,
		ContainerGroupIdentity_Type_SystemAssigned,
		ContainerGroupIdentity_Type_SystemAssignedUserAssigned,
		ContainerGroupIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityDetails_ARMGenerator())
}

func Test_Container_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer_ARM, Container_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer_ARM runs a test to see if a specific instance of Container_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer_ARM(subject Container_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_ARM instances for property testing - lazily instantiated by Container_ARMGenerator()
var container_ARMGenerator gopter.Gen

// Container_ARMGenerator returns a generator of Container_ARM instances for property testing.
// We first initialize container_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Container_ARMGenerator() gopter.Gen {
	if container_ARMGenerator != nil {
		return container_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_ARM(generators)
	container_ARMGenerator = gen.Struct(reflect.TypeOf(Container_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_ARM(generators)
	AddRelatedPropertyGeneratorsForContainer_ARM(generators)
	container_ARMGenerator = gen.Struct(reflect.TypeOf(Container_ARM{}), generators)

	return container_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainer_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ContainerProperties_ARMGenerator())
}

func Test_ContainerGroupDiagnostics_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics_ARM, ContainerGroupDiagnostics_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics_ARM runs a test to see if a specific instance of ContainerGroupDiagnostics_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics_ARM(subject ContainerGroupDiagnostics_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics_ARM instances for property testing - lazily instantiated by
// ContainerGroupDiagnostics_ARMGenerator()
var containerGroupDiagnostics_ARMGenerator gopter.Gen

// ContainerGroupDiagnostics_ARMGenerator returns a generator of ContainerGroupDiagnostics_ARM instances for property testing.
func ContainerGroupDiagnostics_ARMGenerator() gopter.Gen {
	if containerGroupDiagnostics_ARMGenerator != nil {
		return containerGroupDiagnostics_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_ARM(generators)
	containerGroupDiagnostics_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics_ARM{}), generators)

	return containerGroupDiagnostics_ARMGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_ARM(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalytics_ARMGenerator())
}

func Test_ContainerGroupSubnetId_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId_ARM, ContainerGroupSubnetId_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId_ARM runs a test to see if a specific instance of ContainerGroupSubnetId_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId_ARM(subject ContainerGroupSubnetId_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId_ARM instances for property testing - lazily instantiated by
// ContainerGroupSubnetId_ARMGenerator()
var containerGroupSubnetId_ARMGenerator gopter.Gen

// ContainerGroupSubnetId_ARMGenerator returns a generator of ContainerGroupSubnetId_ARM instances for property testing.
func ContainerGroupSubnetId_ARMGenerator() gopter.Gen {
	if containerGroupSubnetId_ARMGenerator != nil {
		return containerGroupSubnetId_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId_ARM(generators)
	containerGroupSubnetId_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId_ARM{}), generators)

	return containerGroupSubnetId_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration_ARM, DnsConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration_ARM runs a test to see if a specific instance of DnsConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration_ARM(subject DnsConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration_ARM instances for property testing - lazily instantiated by
// DnsConfiguration_ARMGenerator()
var dnsConfiguration_ARMGenerator gopter.Gen

// DnsConfiguration_ARMGenerator returns a generator of DnsConfiguration_ARM instances for property testing.
func DnsConfiguration_ARMGenerator() gopter.Gen {
	if dnsConfiguration_ARMGenerator != nil {
		return dnsConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration_ARM(generators)
	dnsConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration_ARM{}), generators)

	return dnsConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_ARM, EncryptionProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_ARM runs a test to see if a specific instance of EncryptionProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_ARM(subject EncryptionProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_ARM instances for property testing - lazily instantiated by
// EncryptionProperties_ARMGenerator()
var encryptionProperties_ARMGenerator gopter.Gen

// EncryptionProperties_ARMGenerator returns a generator of EncryptionProperties_ARM instances for property testing.
func EncryptionProperties_ARMGenerator() gopter.Gen {
	if encryptionProperties_ARMGenerator != nil {
		return encryptionProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_ARM(generators)
	encryptionProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_ARM{}), generators)

	return encryptionProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_ARM(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredential_ARM, ImageRegistryCredential_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredential_ARM runs a test to see if a specific instance of ImageRegistryCredential_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredential_ARM(subject ImageRegistryCredential_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential_ARM instances for property testing - lazily instantiated by
// ImageRegistryCredential_ARMGenerator()
var imageRegistryCredential_ARMGenerator gopter.Gen

// ImageRegistryCredential_ARMGenerator returns a generator of ImageRegistryCredential_ARM instances for property testing.
func ImageRegistryCredential_ARMGenerator() gopter.Gen {
	if imageRegistryCredential_ARMGenerator != nil {
		return imageRegistryCredential_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredential_ARM(generators)
	imageRegistryCredential_ARMGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential_ARM{}), generators)

	return imageRegistryCredential_ARMGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredential_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredential_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinition_ARM, InitContainerDefinition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinition_ARM runs a test to see if a specific instance of InitContainerDefinition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinition_ARM(subject InitContainerDefinition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition_ARM instances for property testing - lazily instantiated by
// InitContainerDefinition_ARMGenerator()
var initContainerDefinition_ARMGenerator gopter.Gen

// InitContainerDefinition_ARMGenerator returns a generator of InitContainerDefinition_ARM instances for property testing.
// We first initialize initContainerDefinition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinition_ARMGenerator() gopter.Gen {
	if initContainerDefinition_ARMGenerator != nil {
		return initContainerDefinition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition_ARM(generators)
	initContainerDefinition_ARMGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition_ARM(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinition_ARM(generators)
	initContainerDefinition_ARMGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_ARM{}), generators)

	return initContainerDefinition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinition_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InitContainerPropertiesDefinition_ARMGenerator())
}

func Test_IpAddress_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress_ARM, IpAddress_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress_ARM runs a test to see if a specific instance of IpAddress_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress_ARM(subject IpAddress_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress_ARM instances for property testing - lazily instantiated by IpAddress_ARMGenerator()
var ipAddress_ARMGenerator gopter.Gen

// IpAddress_ARMGenerator returns a generator of IpAddress_ARM instances for property testing.
// We first initialize ipAddress_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddress_ARMGenerator() gopter.Gen {
	if ipAddress_ARMGenerator != nil {
		return ipAddress_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress_ARM(generators)
	ipAddress_ARMGenerator = gen.Struct(reflect.TypeOf(IpAddress_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress_ARM(generators)
	AddRelatedPropertyGeneratorsForIpAddress_ARM(generators)
	ipAddress_ARMGenerator = gen.Struct(reflect.TypeOf(IpAddress_ARM{}), generators)

	return ipAddress_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress_ARM(gens map[string]gopter.Gen) {
	gens["AutoGeneratedDomainNameLabelScope"] = gen.PtrOf(gen.OneConstOf(
		IpAddress_AutoGeneratedDomainNameLabelScope_Noreuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_ResourceGroupReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_SubscriptionReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_TenantReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_Unsecure))
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddress_Type_Private, IpAddress_Type_Public))
}

// AddRelatedPropertyGeneratorsForIpAddress_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress_ARM(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(Port_ARMGenerator())
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}

func Test_Volume_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume_ARM, Volume_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume_ARM runs a test to see if a specific instance of Volume_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume_ARM(subject Volume_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_ARM instances for property testing - lazily instantiated by Volume_ARMGenerator()
var volume_ARMGenerator gopter.Gen

// Volume_ARMGenerator returns a generator of Volume_ARM instances for property testing.
// We first initialize volume_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Volume_ARMGenerator() gopter.Gen {
	if volume_ARMGenerator != nil {
		return volume_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_ARM(generators)
	volume_ARMGenerator = gen.Struct(reflect.TypeOf(Volume_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_ARM(generators)
	AddRelatedPropertyGeneratorsForVolume_ARM(generators)
	volume_ARMGenerator = gen.Struct(reflect.TypeOf(Volume_ARM{}), generators)

	return volume_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVolume_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume_ARM(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolume_ARMGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolume_ARMGenerator())
}

func Test_AzureFileVolume_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume_ARM, AzureFileVolume_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume_ARM runs a test to see if a specific instance of AzureFileVolume_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume_ARM(subject AzureFileVolume_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume_ARM instances for property testing - lazily instantiated by
// AzureFileVolume_ARMGenerator()
var azureFileVolume_ARMGenerator gopter.Gen

// AzureFileVolume_ARMGenerator returns a generator of AzureFileVolume_ARM instances for property testing.
func AzureFileVolume_ARMGenerator() gopter.Gen {
	if azureFileVolume_ARMGenerator != nil {
		return azureFileVolume_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume_ARM(generators)
	azureFileVolume_ARMGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume_ARM{}), generators)

	return azureFileVolume_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume_ARM(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProperties_ARM, ContainerProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProperties_ARM runs a test to see if a specific instance of ContainerProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProperties_ARM(subject ContainerProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties_ARM instances for property testing - lazily instantiated by
// ContainerProperties_ARMGenerator()
var containerProperties_ARMGenerator gopter.Gen

// ContainerProperties_ARMGenerator returns a generator of ContainerProperties_ARM instances for property testing.
// We first initialize containerProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProperties_ARMGenerator() gopter.Gen {
	if containerProperties_ARMGenerator != nil {
		return containerProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties_ARM(generators)
	containerProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerProperties_ARM(generators)
	containerProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_ARM{}), generators)

	return containerProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProperties_ARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariable_ARMGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbe_ARMGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPort_ARMGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbe_ARMGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirements_ARMGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_ARMGenerator())
}

func Test_GitRepoVolume_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume_ARM, GitRepoVolume_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume_ARM runs a test to see if a specific instance of GitRepoVolume_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume_ARM(subject GitRepoVolume_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume_ARM instances for property testing - lazily instantiated by GitRepoVolume_ARMGenerator()
var gitRepoVolume_ARMGenerator gopter.Gen

// GitRepoVolume_ARMGenerator returns a generator of GitRepoVolume_ARM instances for property testing.
func GitRepoVolume_ARMGenerator() gopter.Gen {
	if gitRepoVolume_ARMGenerator != nil {
		return gitRepoVolume_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume_ARM(generators)
	gitRepoVolume_ARMGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume_ARM{}), generators)

	return gitRepoVolume_ARMGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume_ARM(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinition_ARM, InitContainerPropertiesDefinition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinition_ARM runs a test to see if a specific instance of InitContainerPropertiesDefinition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinition_ARM(subject InitContainerPropertiesDefinition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition_ARM instances for property testing - lazily instantiated by
// InitContainerPropertiesDefinition_ARMGenerator()
var initContainerPropertiesDefinition_ARMGenerator gopter.Gen

// InitContainerPropertiesDefinition_ARMGenerator returns a generator of InitContainerPropertiesDefinition_ARM instances for property testing.
// We first initialize initContainerPropertiesDefinition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinition_ARMGenerator() gopter.Gen {
	if initContainerPropertiesDefinition_ARMGenerator != nil {
		return initContainerPropertiesDefinition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_ARM(generators)
	initContainerPropertiesDefinition_ARMGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_ARM(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_ARM(generators)
	initContainerPropertiesDefinition_ARMGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_ARM{}), generators)

	return initContainerPropertiesDefinition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_ARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_ARM(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariable_ARMGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_ARMGenerator())
}

func Test_LogAnalytics_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics_ARM, LogAnalytics_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics_ARM runs a test to see if a specific instance of LogAnalytics_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics_ARM(subject LogAnalytics_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics_ARM instances for property testing - lazily instantiated by LogAnalytics_ARMGenerator()
var logAnalytics_ARMGenerator gopter.Gen

// LogAnalytics_ARMGenerator returns a generator of LogAnalytics_ARM instances for property testing.
func LogAnalytics_ARMGenerator() gopter.Gen {
	if logAnalytics_ARMGenerator != nil {
		return logAnalytics_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics_ARM(generators)
	logAnalytics_ARMGenerator = gen.Struct(reflect.TypeOf(LogAnalytics_ARM{}), generators)

	return logAnalytics_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics_ARM(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalytics_LogType_ContainerInsights, LogAnalytics_LogType_ContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.AlphaString()
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort_ARM, Port_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort_ARM runs a test to see if a specific instance of Port_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPort_ARM(subject Port_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port_ARM instances for property testing - lazily instantiated by Port_ARMGenerator()
var port_ARMGenerator gopter.Gen

// Port_ARMGenerator returns a generator of Port_ARM instances for property testing.
func Port_ARMGenerator() gopter.Gen {
	if port_ARMGenerator != nil {
		return port_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort_ARM(generators)
	port_ARMGenerator = gen.Struct(reflect.TypeOf(Port_ARM{}), generators)

	return port_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPort_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort_ARM(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(Port_Protocol_TCP, Port_Protocol_UDP))
}

func Test_ContainerPort_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort_ARM, ContainerPort_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort_ARM runs a test to see if a specific instance of ContainerPort_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort_ARM(subject ContainerPort_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort_ARM instances for property testing - lazily instantiated by ContainerPort_ARMGenerator()
var containerPort_ARMGenerator gopter.Gen

// ContainerPort_ARMGenerator returns a generator of ContainerPort_ARM instances for property testing.
func ContainerPort_ARMGenerator() gopter.Gen {
	if containerPort_ARMGenerator != nil {
		return containerPort_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort_ARM(generators)
	containerPort_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerPort_ARM{}), generators)

	return containerPort_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort_ARM(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPort_Protocol_TCP, ContainerPort_Protocol_UDP))
}

func Test_ContainerProbe_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe_ARM, ContainerProbe_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe_ARM runs a test to see if a specific instance of ContainerProbe_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe_ARM(subject ContainerProbe_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe_ARM instances for property testing - lazily instantiated by ContainerProbe_ARMGenerator()
var containerProbe_ARMGenerator gopter.Gen

// ContainerProbe_ARMGenerator returns a generator of ContainerProbe_ARM instances for property testing.
// We first initialize containerProbe_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbe_ARMGenerator() gopter.Gen {
	if containerProbe_ARMGenerator != nil {
		return containerProbe_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe_ARM(generators)
	containerProbe_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerProbe_ARM(generators)
	containerProbe_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_ARM{}), generators)

	return containerProbe_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe_ARM(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe_ARM(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExec_ARMGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGet_ARMGenerator())
}

func Test_EnvironmentVariable_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable_ARM, EnvironmentVariable_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable_ARM runs a test to see if a specific instance of EnvironmentVariable_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable_ARM(subject EnvironmentVariable_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable_ARM instances for property testing - lazily instantiated by
// EnvironmentVariable_ARMGenerator()
var environmentVariable_ARMGenerator gopter.Gen

// EnvironmentVariable_ARMGenerator returns a generator of EnvironmentVariable_ARM instances for property testing.
func EnvironmentVariable_ARMGenerator() gopter.Gen {
	if environmentVariable_ARMGenerator != nil {
		return environmentVariable_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable_ARM(generators)
	environmentVariable_ARMGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable_ARM{}), generators)

	return environmentVariable_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceRequirements_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements_ARM, ResourceRequirements_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements_ARM runs a test to see if a specific instance of ResourceRequirements_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements_ARM(subject ResourceRequirements_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements_ARM instances for property testing - lazily instantiated by
// ResourceRequirements_ARMGenerator()
var resourceRequirements_ARMGenerator gopter.Gen

// ResourceRequirements_ARMGenerator returns a generator of ResourceRequirements_ARM instances for property testing.
func ResourceRequirements_ARMGenerator() gopter.Gen {
	if resourceRequirements_ARMGenerator != nil {
		return resourceRequirements_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements_ARM(generators)
	resourceRequirements_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements_ARM{}), generators)

	return resourceRequirements_ARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements_ARM(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimits_ARMGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequests_ARMGenerator())
}

func Test_VolumeMount_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount_ARM, VolumeMount_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount_ARM runs a test to see if a specific instance of VolumeMount_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount_ARM(subject VolumeMount_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_ARM instances for property testing - lazily instantiated by VolumeMount_ARMGenerator()
var volumeMount_ARMGenerator gopter.Gen

// VolumeMount_ARMGenerator returns a generator of VolumeMount_ARM instances for property testing.
func VolumeMount_ARMGenerator() gopter.Gen {
	if volumeMount_ARMGenerator != nil {
		return volumeMount_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount_ARM(generators)
	volumeMount_ARMGenerator = gen.Struct(reflect.TypeOf(VolumeMount_ARM{}), generators)

	return volumeMount_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount_ARM(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec_ARM, ContainerExec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec_ARM runs a test to see if a specific instance of ContainerExec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec_ARM(subject ContainerExec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec_ARM instances for property testing - lazily instantiated by ContainerExec_ARMGenerator()
var containerExec_ARMGenerator gopter.Gen

// ContainerExec_ARMGenerator returns a generator of ContainerExec_ARM instances for property testing.
func ContainerExec_ARMGenerator() gopter.Gen {
	if containerExec_ARMGenerator != nil {
		return containerExec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec_ARM(generators)
	containerExec_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerExec_ARM{}), generators)

	return containerExec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec_ARM(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet_ARM, ContainerHttpGet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet_ARM runs a test to see if a specific instance of ContainerHttpGet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet_ARM(subject ContainerHttpGet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet_ARM instances for property testing - lazily instantiated by
// ContainerHttpGet_ARMGenerator()
var containerHttpGet_ARMGenerator gopter.Gen

// ContainerHttpGet_ARMGenerator returns a generator of ContainerHttpGet_ARM instances for property testing.
// We first initialize containerHttpGet_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGet_ARMGenerator() gopter.Gen {
	if containerHttpGet_ARMGenerator != nil {
		return containerHttpGet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet_ARM(generators)
	containerHttpGet_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet_ARM(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet_ARM(generators)
	containerHttpGet_ARMGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_ARM{}), generators)

	return containerHttpGet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet_ARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGet_Scheme_Http, ContainerHttpGet_Scheme_Https))
}

// AddRelatedPropertyGeneratorsForContainerHttpGet_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet_ARM(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeader_ARMGenerator())
}

func Test_ResourceLimits_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits_ARM, ResourceLimits_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits_ARM runs a test to see if a specific instance of ResourceLimits_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits_ARM(subject ResourceLimits_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits_ARM instances for property testing - lazily instantiated by ResourceLimits_ARMGenerator()
var resourceLimits_ARMGenerator gopter.Gen

// ResourceLimits_ARMGenerator returns a generator of ResourceLimits_ARM instances for property testing.
// We first initialize resourceLimits_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimits_ARMGenerator() gopter.Gen {
	if resourceLimits_ARMGenerator != nil {
		return resourceLimits_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits_ARM(generators)
	resourceLimits_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits_ARM(generators)
	AddRelatedPropertyGeneratorsForResourceLimits_ARM(generators)
	resourceLimits_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_ARM{}), generators)

	return resourceLimits_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits_ARM(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits_ARM(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResource_ARMGenerator())
}

func Test_ResourceRequests_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests_ARM, ResourceRequests_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests_ARM runs a test to see if a specific instance of ResourceRequests_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests_ARM(subject ResourceRequests_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests_ARM instances for property testing - lazily instantiated by
// ResourceRequests_ARMGenerator()
var resourceRequests_ARMGenerator gopter.Gen

// ResourceRequests_ARMGenerator returns a generator of ResourceRequests_ARM instances for property testing.
// We first initialize resourceRequests_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequests_ARMGenerator() gopter.Gen {
	if resourceRequests_ARMGenerator != nil {
		return resourceRequests_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests_ARM(generators)
	resourceRequests_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests_ARM(generators)
	AddRelatedPropertyGeneratorsForResourceRequests_ARM(generators)
	resourceRequests_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_ARM{}), generators)

	return resourceRequests_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests_ARM(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests_ARM(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResource_ARMGenerator())
}

func Test_GpuResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource_ARM, GpuResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource_ARM runs a test to see if a specific instance of GpuResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource_ARM(subject GpuResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource_ARM instances for property testing - lazily instantiated by GpuResource_ARMGenerator()
var gpuResource_ARMGenerator gopter.Gen

// GpuResource_ARMGenerator returns a generator of GpuResource_ARM instances for property testing.
func GpuResource_ARMGenerator() gopter.Gen {
	if gpuResource_ARMGenerator != nil {
		return gpuResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource_ARM(generators)
	gpuResource_ARMGenerator = gen.Struct(reflect.TypeOf(GpuResource_ARM{}), generators)

	return gpuResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResource_Sku_K80, GpuResource_Sku_P100, GpuResource_Sku_V100))
}

func Test_HttpHeader_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader_ARM, HttpHeader_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader_ARM runs a test to see if a specific instance of HttpHeader_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader_ARM(subject HttpHeader_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader_ARM instances for property testing - lazily instantiated by HttpHeader_ARMGenerator()
var httpHeader_ARMGenerator gopter.Gen

// HttpHeader_ARMGenerator returns a generator of HttpHeader_ARM instances for property testing.
func HttpHeader_ARMGenerator() gopter.Gen {
	if httpHeader_ARMGenerator != nil {
		return httpHeader_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader_ARM(generators)
	httpHeader_ARMGenerator = gen.Struct(reflect.TypeOf(HttpHeader_ARM{}), generators)

	return httpHeader_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
