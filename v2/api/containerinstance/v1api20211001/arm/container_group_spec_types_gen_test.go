// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AzureFileVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume runs a test to see if a specific instance of AzureFileVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume(subject AzureFileVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume instances for property testing - lazily instantiated by AzureFileVolumeGenerator()
var azureFileVolumeGenerator gopter.Gen

// AzureFileVolumeGenerator returns a generator of AzureFileVolume instances for property testing.
func AzureFileVolumeGenerator() gopter.Gen {
	if azureFileVolumeGenerator != nil {
		return azureFileVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume(generators)
	azureFileVolumeGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume{}), generators)

	return azureFileVolumeGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Container_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer, ContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer runs a test to see if a specific instance of Container round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer(subject Container) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container instances for property testing - lazily instantiated by ContainerGenerator()
var containerGenerator gopter.Gen

// ContainerGenerator returns a generator of Container instances for property testing.
// We first initialize containerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGenerator() gopter.Gen {
	if containerGenerator != nil {
		return containerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	AddRelatedPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	return containerGenerator
}

// AddIndependentPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ContainerPropertiesGenerator())
}

func Test_ContainerExec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec runs a test to see if a specific instance of ContainerExec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec(subject ContainerExec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec instances for property testing - lazily instantiated by ContainerExecGenerator()
var containerExecGenerator gopter.Gen

// ContainerExecGenerator returns a generator of ContainerExec instances for property testing.
func ContainerExecGenerator() gopter.Gen {
	if containerExecGenerator != nil {
		return containerExecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec(generators)
	containerExecGenerator = gen.Struct(reflect.TypeOf(ContainerExec{}), generators)

	return containerExecGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerGroupDiagnostics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics runs a test to see if a specific instance of ContainerGroupDiagnostics round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsGenerator()
var containerGroupDiagnosticsGenerator gopter.Gen

// ContainerGroupDiagnosticsGenerator returns a generator of ContainerGroupDiagnostics instances for property testing.
func ContainerGroupDiagnosticsGenerator() gopter.Gen {
	if containerGroupDiagnosticsGenerator != nil {
		return containerGroupDiagnosticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(generators)
	containerGroupDiagnosticsGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics{}), generators)

	return containerGroupDiagnosticsGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsGenerator())
}

func Test_ContainerGroupIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity runs a test to see if a specific instance of ContainerGroupIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity instances for property testing - lazily instantiated by
// ContainerGroupIdentityGenerator()
var containerGroupIdentityGenerator gopter.Gen

// ContainerGroupIdentityGenerator returns a generator of ContainerGroupIdentity instances for property testing.
// We first initialize containerGroupIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentityGenerator() gopter.Gen {
	if containerGroupIdentityGenerator != nil {
		return containerGroupIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	return containerGroupIdentityGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ContainerGroupIdentity_Type_None,
		ContainerGroupIdentity_Type_SystemAssigned,
		ContainerGroupIdentity_Type_SystemAssignedUserAssigned,
		ContainerGroupIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_ContainerGroupSubnetId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId runs a test to see if a specific instance of ContainerGroupSubnetId round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdGenerator()
var containerGroupSubnetIdGenerator gopter.Gen

// ContainerGroupSubnetIdGenerator returns a generator of ContainerGroupSubnetId instances for property testing.
func ContainerGroupSubnetIdGenerator() gopter.Gen {
	if containerGroupSubnetIdGenerator != nil {
		return containerGroupSubnetIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId(generators)
	containerGroupSubnetIdGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId{}), generators)

	return containerGroupSubnetIdGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Properties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Spec, ContainerGroup_Properties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Spec runs a test to see if a specific instance of ContainerGroup_Properties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Spec(subject ContainerGroup_Properties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Spec instances for property testing - lazily instantiated by
// ContainerGroup_Properties_SpecGenerator()
var containerGroup_Properties_SpecGenerator gopter.Gen

// ContainerGroup_Properties_SpecGenerator returns a generator of ContainerGroup_Properties_Spec instances for property testing.
// We first initialize containerGroup_Properties_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Properties_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_SpecGenerator != nil {
		return containerGroup_Properties_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec(generators)
	containerGroup_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec(generators)
	containerGroup_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Spec{}), generators)

	return containerGroup_Properties_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_Spec(gens map[string]gopter.Gen) {
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ContainerGroup_Properties_OsType_Spec_Linux, ContainerGroup_Properties_OsType_Spec_Windows))
	gens["RestartPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerGroup_Properties_RestartPolicy_Spec_Always, ContainerGroup_Properties_RestartPolicy_Spec_Never, ContainerGroup_Properties_RestartPolicy_Spec_OnFailure))
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(ContainerGroupSku_Dedicated, ContainerGroupSku_Standard))
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_Spec(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredentialGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinitionGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_ContainerGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Spec, ContainerGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Spec runs a test to see if a specific instance of ContainerGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Spec(subject ContainerGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Spec instances for property testing - lazily instantiated by
// ContainerGroup_SpecGenerator()
var containerGroup_SpecGenerator gopter.Gen

// ContainerGroup_SpecGenerator returns a generator of ContainerGroup_Spec instances for property testing.
// We first initialize containerGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_SpecGenerator() gopter.Gen {
	if containerGroup_SpecGenerator != nil {
		return containerGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec(generators)
	containerGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Spec(generators)
	containerGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec{}), generators)

	return containerGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityGenerator())
	gens["Properties"] = gen.PtrOf(ContainerGroup_Properties_SpecGenerator())
}

func Test_ContainerHttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet runs a test to see if a specific instance of ContainerHttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet instances for property testing - lazily instantiated by ContainerHttpGetGenerator()
var containerHttpGetGenerator gopter.Gen

// ContainerHttpGetGenerator returns a generator of ContainerHttpGet instances for property testing.
// We first initialize containerHttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetGenerator() gopter.Gen {
	if containerHttpGetGenerator != nil {
		return containerHttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	return containerHttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerHttpGet_Scheme_Http, ContainerHttpGet_Scheme_Https))
}

// AddRelatedPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderGenerator())
}

func Test_ContainerPort_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort runs a test to see if a specific instance of ContainerPort round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort(subject ContainerPort) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort instances for property testing - lazily instantiated by ContainerPortGenerator()
var containerPortGenerator gopter.Gen

// ContainerPortGenerator returns a generator of ContainerPort instances for property testing.
func ContainerPortGenerator() gopter.Gen {
	if containerPortGenerator != nil {
		return containerPortGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort(generators)
	containerPortGenerator = gen.Struct(reflect.TypeOf(ContainerPort{}), generators)

	return containerPortGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ContainerPort_Protocol_TCP, ContainerPort_Protocol_UDP))
}

func Test_ContainerProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe runs a test to see if a specific instance of ContainerProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe(subject ContainerProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe instances for property testing - lazily instantiated by ContainerProbeGenerator()
var containerProbeGenerator gopter.Gen

// ContainerProbeGenerator returns a generator of ContainerProbe instances for property testing.
// We first initialize containerProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeGenerator() gopter.Gen {
	if containerProbeGenerator != nil {
		return containerProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	AddRelatedPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	return containerProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetGenerator())
}

func Test_ContainerProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProperties, ContainerPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProperties runs a test to see if a specific instance of ContainerProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProperties(subject ContainerProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties instances for property testing - lazily instantiated by
// ContainerPropertiesGenerator()
var containerPropertiesGenerator gopter.Gen

// ContainerPropertiesGenerator returns a generator of ContainerProperties instances for property testing.
// We first initialize containerPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerPropertiesGenerator() gopter.Gen {
	if containerPropertiesGenerator != nil {
		return containerPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties(generators)
	containerPropertiesGenerator = gen.Struct(reflect.TypeOf(ContainerProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties(generators)
	AddRelatedPropertyGeneratorsForContainerProperties(generators)
	containerPropertiesGenerator = gen.Struct(reflect.TypeOf(ContainerProperties{}), generators)

	return containerPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForContainerProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProperties(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProperties(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_DnsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration runs a test to see if a specific instance of DnsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration(subject DnsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration instances for property testing - lazily instantiated by DnsConfigurationGenerator()
var dnsConfigurationGenerator gopter.Gen

// DnsConfigurationGenerator returns a generator of DnsConfiguration instances for property testing.
func DnsConfigurationGenerator() gopter.Gen {
	if dnsConfigurationGenerator != nil {
		return dnsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration(generators)
	dnsConfigurationGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration{}), generators)

	return dnsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties runs a test to see if a specific instance of EncryptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties(subject EncryptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties instances for property testing - lazily instantiated by
// EncryptionPropertiesGenerator()
var encryptionPropertiesGenerator gopter.Gen

// EncryptionPropertiesGenerator returns a generator of EncryptionProperties instances for property testing.
func EncryptionPropertiesGenerator() gopter.Gen {
	if encryptionPropertiesGenerator != nil {
		return encryptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties(generators)
	encryptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties{}), generators)

	return encryptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnvironmentVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable runs a test to see if a specific instance of EnvironmentVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable instances for property testing - lazily instantiated by
// EnvironmentVariableGenerator()
var environmentVariableGenerator gopter.Gen

// EnvironmentVariableGenerator returns a generator of EnvironmentVariable instances for property testing.
func EnvironmentVariableGenerator() gopter.Gen {
	if environmentVariableGenerator != nil {
		return environmentVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable(generators)
	environmentVariableGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable{}), generators)

	return environmentVariableGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume runs a test to see if a specific instance of GitRepoVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume(subject GitRepoVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume instances for property testing - lazily instantiated by GitRepoVolumeGenerator()
var gitRepoVolumeGenerator gopter.Gen

// GitRepoVolumeGenerator returns a generator of GitRepoVolume instances for property testing.
func GitRepoVolumeGenerator() gopter.Gen {
	if gitRepoVolumeGenerator != nil {
		return gitRepoVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume(generators)
	gitRepoVolumeGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume{}), generators)

	return gitRepoVolumeGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_GpuResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource runs a test to see if a specific instance of GpuResource round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource(subject GpuResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource instances for property testing - lazily instantiated by GpuResourceGenerator()
var gpuResourceGenerator gopter.Gen

// GpuResourceGenerator returns a generator of GpuResource instances for property testing.
func GpuResourceGenerator() gopter.Gen {
	if gpuResourceGenerator != nil {
		return gpuResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource(generators)
	gpuResourceGenerator = gen.Struct(reflect.TypeOf(GpuResource{}), generators)

	return gpuResourceGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.OneConstOf(GpuResource_Sku_K80, GpuResource_Sku_P100, GpuResource_Sku_V100))
}

func Test_HttpHeader_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader runs a test to see if a specific instance of HttpHeader round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader(subject HttpHeader) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader instances for property testing - lazily instantiated by HttpHeaderGenerator()
var httpHeaderGenerator gopter.Gen

// HttpHeaderGenerator returns a generator of HttpHeader instances for property testing.
func HttpHeaderGenerator() gopter.Gen {
	if httpHeaderGenerator != nil {
		return httpHeaderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader(generators)
	httpHeaderGenerator = gen.Struct(reflect.TypeOf(HttpHeader{}), generators)

	return httpHeaderGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredential, ImageRegistryCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredential runs a test to see if a specific instance of ImageRegistryCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredential(subject ImageRegistryCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential instances for property testing - lazily instantiated by
// ImageRegistryCredentialGenerator()
var imageRegistryCredentialGenerator gopter.Gen

// ImageRegistryCredentialGenerator returns a generator of ImageRegistryCredential instances for property testing.
func ImageRegistryCredentialGenerator() gopter.Gen {
	if imageRegistryCredentialGenerator != nil {
		return imageRegistryCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredential(generators)
	imageRegistryCredentialGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential{}), generators)

	return imageRegistryCredentialGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredential is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredential(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinition, InitContainerDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinition runs a test to see if a specific instance of InitContainerDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinition(subject InitContainerDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition instances for property testing - lazily instantiated by
// InitContainerDefinitionGenerator()
var initContainerDefinitionGenerator gopter.Gen

// InitContainerDefinitionGenerator returns a generator of InitContainerDefinition instances for property testing.
// We first initialize initContainerDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinitionGenerator() gopter.Gen {
	if initContainerDefinitionGenerator != nil {
		return initContainerDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition(generators)
	initContainerDefinitionGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinition(generators)
	initContainerDefinitionGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition{}), generators)

	return initContainerDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinition(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InitContainerPropertiesDefinitionGenerator())
}

func Test_InitContainerPropertiesDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinition, InitContainerPropertiesDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinition runs a test to see if a specific instance of InitContainerPropertiesDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinition(subject InitContainerPropertiesDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition instances for property testing - lazily instantiated by
// InitContainerPropertiesDefinitionGenerator()
var initContainerPropertiesDefinitionGenerator gopter.Gen

// InitContainerPropertiesDefinitionGenerator returns a generator of InitContainerPropertiesDefinition instances for property testing.
// We first initialize initContainerPropertiesDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinitionGenerator() gopter.Gen {
	if initContainerPropertiesDefinitionGenerator != nil {
		return initContainerPropertiesDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition(generators)
	initContainerPropertiesDefinitionGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition(generators)
	initContainerPropertiesDefinitionGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition{}), generators)

	return initContainerPropertiesDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_IpAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress runs a test to see if a specific instance of IpAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress(subject IpAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress instances for property testing - lazily instantiated by IpAddressGenerator()
var ipAddressGenerator gopter.Gen

// IpAddressGenerator returns a generator of IpAddress instances for property testing.
// We first initialize ipAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressGenerator() gopter.Gen {
	if ipAddressGenerator != nil {
		return ipAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	AddRelatedPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	return ipAddressGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["AutoGeneratedDomainNameLabelScope"] = gen.PtrOf(gen.OneConstOf(
		IpAddress_AutoGeneratedDomainNameLabelScope_Noreuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_ResourceGroupReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_SubscriptionReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_TenantReuse,
		IpAddress_AutoGeneratedDomainNameLabelScope_Unsecure))
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(IpAddress_Type_Private, IpAddress_Type_Public))
}

// AddRelatedPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortGenerator())
}

func Test_LogAnalytics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics runs a test to see if a specific instance of LogAnalytics round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics(subject LogAnalytics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics instances for property testing - lazily instantiated by LogAnalyticsGenerator()
var logAnalyticsGenerator gopter.Gen

// LogAnalyticsGenerator returns a generator of LogAnalytics instances for property testing.
func LogAnalyticsGenerator() gopter.Gen {
	if logAnalyticsGenerator != nil {
		return logAnalyticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics(generators)
	logAnalyticsGenerator = gen.Struct(reflect.TypeOf(LogAnalytics{}), generators)

	return logAnalyticsGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.OneConstOf(LogAnalytics_LogType_ContainerInsights, LogAnalytics_LogType_ContainerInstanceLogs))
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort runs a test to see if a specific instance of Port round trips to JSON and back losslessly
func RunJSONSerializationTestForPort(subject Port) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port instances for property testing - lazily instantiated by PortGenerator()
var portGenerator gopter.Gen

// PortGenerator returns a generator of Port instances for property testing.
func PortGenerator() gopter.Gen {
	if portGenerator != nil {
		return portGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort(generators)
	portGenerator = gen.Struct(reflect.TypeOf(Port{}), generators)

	return portGenerator
}

// AddIndependentPropertyGeneratorsForPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(Port_Protocol_TCP, Port_Protocol_UDP))
}

func Test_ResourceLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits runs a test to see if a specific instance of ResourceLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits(subject ResourceLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits instances for property testing - lazily instantiated by ResourceLimitsGenerator()
var resourceLimitsGenerator gopter.Gen

// ResourceLimitsGenerator returns a generator of ResourceLimits instances for property testing.
// We first initialize resourceLimitsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsGenerator() gopter.Gen {
	if resourceLimitsGenerator != nil {
		return resourceLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	AddRelatedPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	return resourceLimitsGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequests_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests runs a test to see if a specific instance of ResourceRequests round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests(subject ResourceRequests) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests instances for property testing - lazily instantiated by ResourceRequestsGenerator()
var resourceRequestsGenerator gopter.Gen

// ResourceRequestsGenerator returns a generator of ResourceRequests instances for property testing.
// We first initialize resourceRequestsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsGenerator() gopter.Gen {
	if resourceRequestsGenerator != nil {
		return resourceRequestsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	AddRelatedPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	return resourceRequestsGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequirements_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements runs a test to see if a specific instance of ResourceRequirements round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements(subject ResourceRequirements) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements instances for property testing - lazily instantiated by
// ResourceRequirementsGenerator()
var resourceRequirementsGenerator gopter.Gen

// ResourceRequirementsGenerator returns a generator of ResourceRequirements instances for property testing.
func ResourceRequirementsGenerator() gopter.Gen {
	if resourceRequirementsGenerator != nil {
		return resourceRequirementsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements(generators)
	resourceRequirementsGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements{}), generators)

	return resourceRequirementsGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsGenerator())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeGenerator())
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}
