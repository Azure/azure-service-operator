// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup runs a test to see if a specific instance of ContainerGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup(subject ContainerGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup instances for property testing - lazily instantiated by ContainerGroupGenerator()
var containerGroupGenerator gopter.Gen

// ContainerGroupGenerator returns a generator of ContainerGroup instances for property testing.
func ContainerGroupGenerator() gopter.Gen {
	if containerGroupGenerator != nil {
		return containerGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroup(generators)
	containerGroupGenerator = gen.Struct(reflect.TypeOf(ContainerGroup{}), generators)

	return containerGroupGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = ContainerGroup_SpecGenerator()
	gens["Status"] = ContainerGroup_STATUSGenerator()
}

func Test_ContainerGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Spec, ContainerGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Spec runs a test to see if a specific instance of ContainerGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Spec(subject ContainerGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Spec instances for property testing - lazily instantiated by
// ContainerGroup_SpecGenerator()
var containerGroup_SpecGenerator gopter.Gen

// ContainerGroup_SpecGenerator returns a generator of ContainerGroup_Spec instances for property testing.
// We first initialize containerGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_SpecGenerator() gopter.Gen {
	if containerGroup_SpecGenerator != nil {
		return containerGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec(generators)
	containerGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Spec(generators)
	containerGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Spec{}), generators)

	return containerGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Spec(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGroup_Properties_Containers_SpecGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroup_Properties_Diagnostics_SpecGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ContainerGroup_Properties_ImageRegistryCredentials_SpecGenerator())
	gens["InitContainers"] = gen.SliceOf(ContainerGroup_Properties_InitContainers_SpecGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_ContainerGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_STATUS, ContainerGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_STATUS runs a test to see if a specific instance of ContainerGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_STATUS(subject ContainerGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_STATUS instances for property testing - lazily instantiated by
// ContainerGroup_STATUSGenerator()
var containerGroup_STATUSGenerator gopter.Gen

// ContainerGroup_STATUSGenerator returns a generator of ContainerGroup_STATUS instances for property testing.
// We first initialize containerGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_STATUSGenerator() gopter.Gen {
	if containerGroup_STATUSGenerator != nil {
		return containerGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_STATUS(generators)
	containerGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_STATUS(generators)
	containerGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_STATUS{}), generators)

	return containerGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(Container_STATUSGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnostics_STATUSGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfiguration_STATUSGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionProperties_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentity_STATUSGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredential_STATUSGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinition_STATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerGroup_Properties_InstanceView_STATUSGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddress_STATUSGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetId_STATUSGenerator())
	gens["Volumes"] = gen.SliceOf(Volume_STATUSGenerator())
}

func Test_Container_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer_STATUS, Container_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer_STATUS runs a test to see if a specific instance of Container_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer_STATUS(subject Container_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_STATUS instances for property testing - lazily instantiated by Container_STATUSGenerator()
var container_STATUSGenerator gopter.Gen

// Container_STATUSGenerator returns a generator of Container_STATUS instances for property testing.
// We first initialize container_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Container_STATUSGenerator() gopter.Gen {
	if container_STATUSGenerator != nil {
		return container_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_STATUS(generators)
	container_STATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainer_STATUS(generators)
	container_STATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	return container_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainer_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer_STATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer_STATUS(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariable_STATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerProperties_InstanceView_STATUSGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbe_STATUSGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPort_STATUSGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbe_STATUSGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirements_STATUSGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_STATUSGenerator())
}

func Test_ContainerGroup_Properties_Containers_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Containers_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Containers_Spec, ContainerGroup_Properties_Containers_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Containers_Spec runs a test to see if a specific instance of ContainerGroup_Properties_Containers_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Containers_Spec(subject ContainerGroup_Properties_Containers_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Containers_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Containers_Spec instances for property testing - lazily instantiated by
// ContainerGroup_Properties_Containers_SpecGenerator()
var containerGroup_Properties_Containers_SpecGenerator gopter.Gen

// ContainerGroup_Properties_Containers_SpecGenerator returns a generator of ContainerGroup_Properties_Containers_Spec instances for property testing.
// We first initialize containerGroup_Properties_Containers_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Properties_Containers_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_Containers_SpecGenerator != nil {
		return containerGroup_Properties_Containers_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Spec(generators)
	containerGroup_Properties_Containers_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Containers_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_Containers_Spec(generators)
	containerGroup_Properties_Containers_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Containers_Spec{}), generators)

	return containerGroup_Properties_Containers_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Spec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_Containers_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_Containers_Spec(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroup_Properties_Diagnostics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Diagnostics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_Spec, ContainerGroup_Properties_Diagnostics_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_Spec runs a test to see if a specific instance of ContainerGroup_Properties_Diagnostics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_Spec(subject ContainerGroup_Properties_Diagnostics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Diagnostics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Diagnostics_Spec instances for property testing - lazily instantiated by
// ContainerGroup_Properties_Diagnostics_SpecGenerator()
var containerGroup_Properties_Diagnostics_SpecGenerator gopter.Gen

// ContainerGroup_Properties_Diagnostics_SpecGenerator returns a generator of ContainerGroup_Properties_Diagnostics_Spec instances for property testing.
func ContainerGroup_Properties_Diagnostics_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_Diagnostics_SpecGenerator != nil {
		return containerGroup_Properties_Diagnostics_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_Diagnostics_Spec(generators)
	containerGroup_Properties_Diagnostics_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Diagnostics_Spec{}), generators)

	return containerGroup_Properties_Diagnostics_SpecGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_Diagnostics_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_Diagnostics_Spec(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(ContainerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator())
}

func Test_ContainerGroup_Properties_ImageRegistryCredentials_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_ImageRegistryCredentials_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_ImageRegistryCredentials_Spec, ContainerGroup_Properties_ImageRegistryCredentials_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_ImageRegistryCredentials_Spec runs a test to see if a specific instance of ContainerGroup_Properties_ImageRegistryCredentials_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_ImageRegistryCredentials_Spec(subject ContainerGroup_Properties_ImageRegistryCredentials_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_ImageRegistryCredentials_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_ImageRegistryCredentials_Spec instances for property testing - lazily
// instantiated by ContainerGroup_Properties_ImageRegistryCredentials_SpecGenerator()
var containerGroup_Properties_ImageRegistryCredentials_SpecGenerator gopter.Gen

// ContainerGroup_Properties_ImageRegistryCredentials_SpecGenerator returns a generator of ContainerGroup_Properties_ImageRegistryCredentials_Spec instances for property testing.
func ContainerGroup_Properties_ImageRegistryCredentials_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_ImageRegistryCredentials_SpecGenerator != nil {
		return containerGroup_Properties_ImageRegistryCredentials_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_ImageRegistryCredentials_Spec(generators)
	containerGroup_Properties_ImageRegistryCredentials_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_ImageRegistryCredentials_Spec{}), generators)

	return containerGroup_Properties_ImageRegistryCredentials_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_ImageRegistryCredentials_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_ImageRegistryCredentials_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Properties_InitContainers_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_InitContainers_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Spec, ContainerGroup_Properties_InitContainers_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Spec runs a test to see if a specific instance of ContainerGroup_Properties_InitContainers_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Spec(subject ContainerGroup_Properties_InitContainers_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_InitContainers_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_InitContainers_Spec instances for property testing - lazily instantiated by
// ContainerGroup_Properties_InitContainers_SpecGenerator()
var containerGroup_Properties_InitContainers_SpecGenerator gopter.Gen

// ContainerGroup_Properties_InitContainers_SpecGenerator returns a generator of ContainerGroup_Properties_InitContainers_Spec instances for property testing.
// We first initialize containerGroup_Properties_InitContainers_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Properties_InitContainers_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_InitContainers_SpecGenerator != nil {
		return containerGroup_Properties_InitContainers_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec(generators)
	containerGroup_Properties_InitContainers_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_InitContainers_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec(generators)
	containerGroup_Properties_InitContainers_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_InitContainers_Spec{}), generators)

	return containerGroup_Properties_InitContainers_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_InitContainers_Spec(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroup_Properties_InstanceView_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_InstanceView_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_InstanceView_STATUS, ContainerGroup_Properties_InstanceView_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_InstanceView_STATUS runs a test to see if a specific instance of ContainerGroup_Properties_InstanceView_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_InstanceView_STATUS(subject ContainerGroup_Properties_InstanceView_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_InstanceView_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_InstanceView_STATUS instances for property testing - lazily instantiated by
// ContainerGroup_Properties_InstanceView_STATUSGenerator()
var containerGroup_Properties_InstanceView_STATUSGenerator gopter.Gen

// ContainerGroup_Properties_InstanceView_STATUSGenerator returns a generator of ContainerGroup_Properties_InstanceView_STATUS instances for property testing.
// We first initialize containerGroup_Properties_InstanceView_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroup_Properties_InstanceView_STATUSGenerator() gopter.Gen {
	if containerGroup_Properties_InstanceView_STATUSGenerator != nil {
		return containerGroup_Properties_InstanceView_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS(generators)
	containerGroup_Properties_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_InstanceView_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS(generators)
	containerGroup_Properties_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_InstanceView_STATUS{}), generators)

	return containerGroup_Properties_InstanceView_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup_Properties_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["Events"] = gen.SliceOf(Event_STATUSGenerator())
}

func Test_ContainerGroupDiagnostics_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics_STATUS, ContainerGroupDiagnostics_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics_STATUS runs a test to see if a specific instance of ContainerGroupDiagnostics_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics_STATUS(subject ContainerGroupDiagnostics_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics_STATUS instances for property testing - lazily instantiated by
// ContainerGroupDiagnostics_STATUSGenerator()
var containerGroupDiagnostics_STATUSGenerator gopter.Gen

// ContainerGroupDiagnostics_STATUSGenerator returns a generator of ContainerGroupDiagnostics_STATUS instances for property testing.
func ContainerGroupDiagnostics_STATUSGenerator() gopter.Gen {
	if containerGroupDiagnostics_STATUSGenerator != nil {
		return containerGroupDiagnostics_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_STATUS(generators)
	containerGroupDiagnostics_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics_STATUS{}), generators)

	return containerGroupDiagnostics_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics_STATUS(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalytics_STATUSGenerator())
}

func Test_ContainerGroupIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity runs a test to see if a specific instance of ContainerGroupIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity instances for property testing - lazily instantiated by
// ContainerGroupIdentityGenerator()
var containerGroupIdentityGenerator gopter.Gen

// ContainerGroupIdentityGenerator returns a generator of ContainerGroupIdentity instances for property testing.
func ContainerGroupIdentityGenerator() gopter.Gen {
	if containerGroupIdentityGenerator != nil {
		return containerGroupIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	return containerGroupIdentityGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity_STATUS, ContainerGroupIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity_STATUS runs a test to see if a specific instance of ContainerGroupIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity_STATUS(subject ContainerGroupIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_STATUS instances for property testing - lazily instantiated by
// ContainerGroupIdentity_STATUSGenerator()
var containerGroupIdentity_STATUSGenerator gopter.Gen

// ContainerGroupIdentity_STATUSGenerator returns a generator of ContainerGroupIdentity_STATUS instances for property testing.
// We first initialize containerGroupIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentity_STATUSGenerator() gopter.Gen {
	if containerGroupIdentity_STATUSGenerator != nil {
		return containerGroupIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity_STATUS(generators)
	containerGroupIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentity_STATUS(generators)
	containerGroupIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_STATUS{}), generators)

	return containerGroupIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentities_STATUSGenerator())
}

func Test_ContainerGroupSubnetId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId runs a test to see if a specific instance of ContainerGroupSubnetId round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdGenerator()
var containerGroupSubnetIdGenerator gopter.Gen

// ContainerGroupSubnetIdGenerator returns a generator of ContainerGroupSubnetId instances for property testing.
func ContainerGroupSubnetIdGenerator() gopter.Gen {
	if containerGroupSubnetIdGenerator != nil {
		return containerGroupSubnetIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId(generators)
	containerGroupSubnetIdGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId{}), generators)

	return containerGroupSubnetIdGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupSubnetId_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId_STATUS, ContainerGroupSubnetId_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId_STATUS runs a test to see if a specific instance of ContainerGroupSubnetId_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId_STATUS(subject ContainerGroupSubnetId_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId_STATUS instances for property testing - lazily instantiated by
// ContainerGroupSubnetId_STATUSGenerator()
var containerGroupSubnetId_STATUSGenerator gopter.Gen

// ContainerGroupSubnetId_STATUSGenerator returns a generator of ContainerGroupSubnetId_STATUS instances for property testing.
func ContainerGroupSubnetId_STATUSGenerator() gopter.Gen {
	if containerGroupSubnetId_STATUSGenerator != nil {
		return containerGroupSubnetId_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId_STATUS(generators)
	containerGroupSubnetId_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId_STATUS{}), generators)

	return containerGroupSubnetId_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration runs a test to see if a specific instance of DnsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration(subject DnsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration instances for property testing - lazily instantiated by DnsConfigurationGenerator()
var dnsConfigurationGenerator gopter.Gen

// DnsConfigurationGenerator returns a generator of DnsConfiguration instances for property testing.
func DnsConfigurationGenerator() gopter.Gen {
	if dnsConfigurationGenerator != nil {
		return dnsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration(generators)
	dnsConfigurationGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration{}), generators)

	return dnsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration_STATUS, DnsConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration_STATUS runs a test to see if a specific instance of DnsConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration_STATUS(subject DnsConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration_STATUS instances for property testing - lazily instantiated by
// DnsConfiguration_STATUSGenerator()
var dnsConfiguration_STATUSGenerator gopter.Gen

// DnsConfiguration_STATUSGenerator returns a generator of DnsConfiguration_STATUS instances for property testing.
func DnsConfiguration_STATUSGenerator() gopter.Gen {
	if dnsConfiguration_STATUSGenerator != nil {
		return dnsConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration_STATUS(generators)
	dnsConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration_STATUS{}), generators)

	return dnsConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties runs a test to see if a specific instance of EncryptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties(subject EncryptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties instances for property testing - lazily instantiated by
// EncryptionPropertiesGenerator()
var encryptionPropertiesGenerator gopter.Gen

// EncryptionPropertiesGenerator returns a generator of EncryptionProperties instances for property testing.
func EncryptionPropertiesGenerator() gopter.Gen {
	if encryptionPropertiesGenerator != nil {
		return encryptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties(generators)
	encryptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties{}), generators)

	return encryptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_STATUS, EncryptionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_STATUS runs a test to see if a specific instance of EncryptionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_STATUS(subject EncryptionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_STATUS instances for property testing - lazily instantiated by
// EncryptionProperties_STATUSGenerator()
var encryptionProperties_STATUSGenerator gopter.Gen

// EncryptionProperties_STATUSGenerator returns a generator of EncryptionProperties_STATUS instances for property testing.
func EncryptionProperties_STATUSGenerator() gopter.Gen {
	if encryptionProperties_STATUSGenerator != nil {
		return encryptionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_STATUS(generators)
	encryptionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUS{}), generators)

	return encryptionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredential_STATUS, ImageRegistryCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredential_STATUS runs a test to see if a specific instance of ImageRegistryCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredential_STATUS(subject ImageRegistryCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential_STATUS instances for property testing - lazily instantiated by
// ImageRegistryCredential_STATUSGenerator()
var imageRegistryCredential_STATUSGenerator gopter.Gen

// ImageRegistryCredential_STATUSGenerator returns a generator of ImageRegistryCredential_STATUS instances for property testing.
func ImageRegistryCredential_STATUSGenerator() gopter.Gen {
	if imageRegistryCredential_STATUSGenerator != nil {
		return imageRegistryCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredential_STATUS(generators)
	imageRegistryCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential_STATUS{}), generators)

	return imageRegistryCredential_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredential_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinition_STATUS, InitContainerDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinition_STATUS runs a test to see if a specific instance of InitContainerDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinition_STATUS(subject InitContainerDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition_STATUS instances for property testing - lazily instantiated by
// InitContainerDefinition_STATUSGenerator()
var initContainerDefinition_STATUSGenerator gopter.Gen

// InitContainerDefinition_STATUSGenerator returns a generator of InitContainerDefinition_STATUS instances for property testing.
// We first initialize initContainerDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinition_STATUSGenerator() gopter.Gen {
	if initContainerDefinition_STATUSGenerator != nil {
		return initContainerDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition_STATUS(generators)
	initContainerDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinition_STATUS(generators)
	initContainerDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_STATUS{}), generators)

	return initContainerDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariable_STATUSGenerator())
	gens["InstanceView"] = gen.PtrOf(InitContainerPropertiesDefinition_InstanceView_STATUSGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_STATUSGenerator())
}

func Test_IpAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress runs a test to see if a specific instance of IpAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress(subject IpAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress instances for property testing - lazily instantiated by IpAddressGenerator()
var ipAddressGenerator gopter.Gen

// IpAddressGenerator returns a generator of IpAddress instances for property testing.
// We first initialize ipAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressGenerator() gopter.Gen {
	if ipAddressGenerator != nil {
		return ipAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	AddRelatedPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	return ipAddressGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["AutoGeneratedDomainNameLabelScope"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortGenerator())
}

func Test_IpAddress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress_STATUS, IpAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress_STATUS runs a test to see if a specific instance of IpAddress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress_STATUS(subject IpAddress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress_STATUS instances for property testing - lazily instantiated by IpAddress_STATUSGenerator()
var ipAddress_STATUSGenerator gopter.Gen

// IpAddress_STATUSGenerator returns a generator of IpAddress_STATUS instances for property testing.
// We first initialize ipAddress_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddress_STATUSGenerator() gopter.Gen {
	if ipAddress_STATUSGenerator != nil {
		return ipAddress_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress_STATUS(generators)
	ipAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(IpAddress_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress_STATUS(generators)
	AddRelatedPropertyGeneratorsForIpAddress_STATUS(generators)
	ipAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(IpAddress_STATUS{}), generators)

	return ipAddress_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress_STATUS(gens map[string]gopter.Gen) {
	gens["AutoGeneratedDomainNameLabelScope"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIpAddress_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress_STATUS(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(Port_STATUSGenerator())
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeGenerator())
}

func Test_Volume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume_STATUS, Volume_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume_STATUS runs a test to see if a specific instance of Volume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume_STATUS(subject Volume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_STATUS instances for property testing - lazily instantiated by Volume_STATUSGenerator()
var volume_STATUSGenerator gopter.Gen

// Volume_STATUSGenerator returns a generator of Volume_STATUS instances for property testing.
// We first initialize volume_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Volume_STATUSGenerator() gopter.Gen {
	if volume_STATUSGenerator != nil {
		return volume_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_STATUS(generators)
	volume_STATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_STATUS(generators)
	AddRelatedPropertyGeneratorsForVolume_STATUS(generators)
	volume_STATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	return volume_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolume_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume_STATUS(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolume_STATUSGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolume_STATUSGenerator())
}

func Test_AzureFileVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume runs a test to see if a specific instance of AzureFileVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume(subject AzureFileVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume instances for property testing - lazily instantiated by AzureFileVolumeGenerator()
var azureFileVolumeGenerator gopter.Gen

// AzureFileVolumeGenerator returns a generator of AzureFileVolume instances for property testing.
func AzureFileVolumeGenerator() gopter.Gen {
	if azureFileVolumeGenerator != nil {
		return azureFileVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume(generators)
	azureFileVolumeGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume{}), generators)

	return azureFileVolumeGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFileVolume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume_STATUS, AzureFileVolume_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume_STATUS runs a test to see if a specific instance of AzureFileVolume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume_STATUS(subject AzureFileVolume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume_STATUS instances for property testing - lazily instantiated by
// AzureFileVolume_STATUSGenerator()
var azureFileVolume_STATUSGenerator gopter.Gen

// AzureFileVolume_STATUSGenerator returns a generator of AzureFileVolume_STATUS instances for property testing.
func AzureFileVolume_STATUSGenerator() gopter.Gen {
	if azureFileVolume_STATUSGenerator != nil {
		return azureFileVolume_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume_STATUS(generators)
	azureFileVolume_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume_STATUS{}), generators)

	return azureFileVolume_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume_STATUS(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec, ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec runs a test to see if a specific instance of ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec(subject ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec instances for property testing
// - lazily instantiated by ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator()
var containerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator gopter.Gen

// ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator returns a generator of ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec instances for property testing.
func ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator != nil {
		return containerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec(generators)
	containerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec{}), generators)

	return containerGroup_Properties_Containers_Properties_EnvironmentVariables_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_Containers_Properties_EnvironmentVariables_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec, ContainerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec runs a test to see if a specific instance of ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec(subject ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec instances for property testing - lazily
// instantiated by ContainerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator()
var containerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator gopter.Gen

// ContainerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator returns a generator of ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec instances for property testing.
func ContainerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator != nil {
		return containerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec(generators)
	containerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_Diagnostics_LogAnalytics_Spec{}), generators)

	return containerGroup_Properties_Diagnostics_LogAnalytics_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_Diagnostics_LogAnalytics_Spec(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.AlphaString())
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec, ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec runs a test to see if a specific instance of ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec(subject ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec instances for property
// testing - lazily instantiated by ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator()
var containerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator gopter.Gen

// ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator returns a generator of ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec instances for property testing.
func ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator() gopter.Gen {
	if containerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator != nil {
		return containerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec(generators)
	containerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec{}), generators)

	return containerGroup_Properties_InitContainers_Properties_EnvironmentVariables_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroup_Properties_InitContainers_Properties_EnvironmentVariables_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort runs a test to see if a specific instance of ContainerPort round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort(subject ContainerPort) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort instances for property testing - lazily instantiated by ContainerPortGenerator()
var containerPortGenerator gopter.Gen

// ContainerPortGenerator returns a generator of ContainerPort instances for property testing.
func ContainerPortGenerator() gopter.Gen {
	if containerPortGenerator != nil {
		return containerPortGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort(generators)
	containerPortGenerator = gen.Struct(reflect.TypeOf(ContainerPort{}), generators)

	return containerPortGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort_STATUS, ContainerPort_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort_STATUS runs a test to see if a specific instance of ContainerPort_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort_STATUS(subject ContainerPort_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort_STATUS instances for property testing - lazily instantiated by
// ContainerPort_STATUSGenerator()
var containerPort_STATUSGenerator gopter.Gen

// ContainerPort_STATUSGenerator returns a generator of ContainerPort_STATUS instances for property testing.
func ContainerPort_STATUSGenerator() gopter.Gen {
	if containerPort_STATUSGenerator != nil {
		return containerPort_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort_STATUS(generators)
	containerPort_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerPort_STATUS{}), generators)

	return containerPort_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort_STATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe runs a test to see if a specific instance of ContainerProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe(subject ContainerProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe instances for property testing - lazily instantiated by ContainerProbeGenerator()
var containerProbeGenerator gopter.Gen

// ContainerProbeGenerator returns a generator of ContainerProbe instances for property testing.
// We first initialize containerProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeGenerator() gopter.Gen {
	if containerProbeGenerator != nil {
		return containerProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	AddRelatedPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	return containerProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetGenerator())
}

func Test_ContainerProbe_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe_STATUS, ContainerProbe_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe_STATUS runs a test to see if a specific instance of ContainerProbe_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe_STATUS(subject ContainerProbe_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe_STATUS instances for property testing - lazily instantiated by
// ContainerProbe_STATUSGenerator()
var containerProbe_STATUSGenerator gopter.Gen

// ContainerProbe_STATUSGenerator returns a generator of ContainerProbe_STATUS instances for property testing.
// We first initialize containerProbe_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbe_STATUSGenerator() gopter.Gen {
	if containerProbe_STATUSGenerator != nil {
		return containerProbe_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe_STATUS(generators)
	containerProbe_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerProbe_STATUS(generators)
	containerProbe_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_STATUS{}), generators)

	return containerProbe_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe_STATUS(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe_STATUS(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExec_STATUSGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGet_STATUSGenerator())
}

func Test_ContainerProperties_InstanceView_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties_InstanceView_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProperties_InstanceView_STATUS, ContainerProperties_InstanceView_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProperties_InstanceView_STATUS runs a test to see if a specific instance of ContainerProperties_InstanceView_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProperties_InstanceView_STATUS(subject ContainerProperties_InstanceView_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties_InstanceView_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties_InstanceView_STATUS instances for property testing - lazily instantiated by
// ContainerProperties_InstanceView_STATUSGenerator()
var containerProperties_InstanceView_STATUSGenerator gopter.Gen

// ContainerProperties_InstanceView_STATUSGenerator returns a generator of ContainerProperties_InstanceView_STATUS instances for property testing.
// We first initialize containerProperties_InstanceView_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProperties_InstanceView_STATUSGenerator() gopter.Gen {
	if containerProperties_InstanceView_STATUSGenerator != nil {
		return containerProperties_InstanceView_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties_InstanceView_STATUS(generators)
	containerProperties_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_InstanceView_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProperties_InstanceView_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerProperties_InstanceView_STATUS(generators)
	containerProperties_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_InstanceView_STATUS{}), generators)

	return containerProperties_InstanceView_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerProperties_InstanceView_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProperties_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProperties_InstanceView_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProperties_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerState_STATUSGenerator())
	gens["Events"] = gen.SliceOf(Event_STATUSGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerState_STATUSGenerator())
}

func Test_EnvironmentVariable_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable_STATUS, EnvironmentVariable_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable_STATUS runs a test to see if a specific instance of EnvironmentVariable_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable_STATUS(subject EnvironmentVariable_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable_STATUS instances for property testing - lazily instantiated by
// EnvironmentVariable_STATUSGenerator()
var environmentVariable_STATUSGenerator gopter.Gen

// EnvironmentVariable_STATUSGenerator returns a generator of EnvironmentVariable_STATUS instances for property testing.
func EnvironmentVariable_STATUSGenerator() gopter.Gen {
	if environmentVariable_STATUSGenerator != nil {
		return environmentVariable_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable_STATUS(generators)
	environmentVariable_STATUSGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable_STATUS{}), generators)

	return environmentVariable_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Event_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Event_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEvent_STATUS, Event_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEvent_STATUS runs a test to see if a specific instance of Event_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEvent_STATUS(subject Event_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Event_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Event_STATUS instances for property testing - lazily instantiated by Event_STATUSGenerator()
var event_STATUSGenerator gopter.Gen

// Event_STATUSGenerator returns a generator of Event_STATUS instances for property testing.
func Event_STATUSGenerator() gopter.Gen {
	if event_STATUSGenerator != nil {
		return event_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEvent_STATUS(generators)
	event_STATUSGenerator = gen.Struct(reflect.TypeOf(Event_STATUS{}), generators)

	return event_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEvent_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEvent_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["FirstTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["LastTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume runs a test to see if a specific instance of GitRepoVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume(subject GitRepoVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume instances for property testing - lazily instantiated by GitRepoVolumeGenerator()
var gitRepoVolumeGenerator gopter.Gen

// GitRepoVolumeGenerator returns a generator of GitRepoVolume instances for property testing.
func GitRepoVolumeGenerator() gopter.Gen {
	if gitRepoVolumeGenerator != nil {
		return gitRepoVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume(generators)
	gitRepoVolumeGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume{}), generators)

	return gitRepoVolumeGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume_STATUS, GitRepoVolume_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume_STATUS runs a test to see if a specific instance of GitRepoVolume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume_STATUS(subject GitRepoVolume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume_STATUS instances for property testing - lazily instantiated by
// GitRepoVolume_STATUSGenerator()
var gitRepoVolume_STATUSGenerator gopter.Gen

// GitRepoVolume_STATUSGenerator returns a generator of GitRepoVolume_STATUS instances for property testing.
func GitRepoVolume_STATUSGenerator() gopter.Gen {
	if gitRepoVolume_STATUSGenerator != nil {
		return gitRepoVolume_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume_STATUS(generators)
	gitRepoVolume_STATUSGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume_STATUS{}), generators)

	return gitRepoVolume_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume_STATUS(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinition_InstanceView_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition_InstanceView_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinition_InstanceView_STATUS, InitContainerPropertiesDefinition_InstanceView_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinition_InstanceView_STATUS runs a test to see if a specific instance of InitContainerPropertiesDefinition_InstanceView_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinition_InstanceView_STATUS(subject InitContainerPropertiesDefinition_InstanceView_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition_InstanceView_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition_InstanceView_STATUS instances for property testing - lazily
// instantiated by InitContainerPropertiesDefinition_InstanceView_STATUSGenerator()
var initContainerPropertiesDefinition_InstanceView_STATUSGenerator gopter.Gen

// InitContainerPropertiesDefinition_InstanceView_STATUSGenerator returns a generator of InitContainerPropertiesDefinition_InstanceView_STATUS instances for property testing.
// We first initialize initContainerPropertiesDefinition_InstanceView_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinition_InstanceView_STATUSGenerator() gopter.Gen {
	if initContainerPropertiesDefinition_InstanceView_STATUSGenerator != nil {
		return initContainerPropertiesDefinition_InstanceView_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS(generators)
	initContainerPropertiesDefinition_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_InstanceView_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS(generators)
	initContainerPropertiesDefinition_InstanceView_STATUSGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_InstanceView_STATUS{}), generators)

	return initContainerPropertiesDefinition_InstanceView_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinition_InstanceView_STATUS(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerState_STATUSGenerator())
	gens["Events"] = gen.SliceOf(Event_STATUSGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerState_STATUSGenerator())
}

func Test_LogAnalytics_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics_STATUS, LogAnalytics_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics_STATUS runs a test to see if a specific instance of LogAnalytics_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics_STATUS(subject LogAnalytics_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics_STATUS instances for property testing - lazily instantiated by
// LogAnalytics_STATUSGenerator()
var logAnalytics_STATUSGenerator gopter.Gen

// LogAnalytics_STATUSGenerator returns a generator of LogAnalytics_STATUS instances for property testing.
func LogAnalytics_STATUSGenerator() gopter.Gen {
	if logAnalytics_STATUSGenerator != nil {
		return logAnalytics_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics_STATUS(generators)
	logAnalytics_STATUSGenerator = gen.Struct(reflect.TypeOf(LogAnalytics_STATUS{}), generators)

	return logAnalytics_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics_STATUS(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.AlphaString())
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort runs a test to see if a specific instance of Port round trips to JSON and back losslessly
func RunJSONSerializationTestForPort(subject Port) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port instances for property testing - lazily instantiated by PortGenerator()
var portGenerator gopter.Gen

// PortGenerator returns a generator of Port instances for property testing.
func PortGenerator() gopter.Gen {
	if portGenerator != nil {
		return portGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort(generators)
	portGenerator = gen.Struct(reflect.TypeOf(Port{}), generators)

	return portGenerator
}

// AddIndependentPropertyGeneratorsForPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort_STATUS, Port_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort_STATUS runs a test to see if a specific instance of Port_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPort_STATUS(subject Port_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port_STATUS instances for property testing - lazily instantiated by Port_STATUSGenerator()
var port_STATUSGenerator gopter.Gen

// Port_STATUSGenerator returns a generator of Port_STATUS instances for property testing.
func Port_STATUSGenerator() gopter.Gen {
	if port_STATUSGenerator != nil {
		return port_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort_STATUS(generators)
	port_STATUSGenerator = gen.Struct(reflect.TypeOf(Port_STATUS{}), generators)

	return port_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPort_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort_STATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceRequirements_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements runs a test to see if a specific instance of ResourceRequirements round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements(subject ResourceRequirements) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements instances for property testing - lazily instantiated by
// ResourceRequirementsGenerator()
var resourceRequirementsGenerator gopter.Gen

// ResourceRequirementsGenerator returns a generator of ResourceRequirements instances for property testing.
func ResourceRequirementsGenerator() gopter.Gen {
	if resourceRequirementsGenerator != nil {
		return resourceRequirementsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements(generators)
	resourceRequirementsGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements{}), generators)

	return resourceRequirementsGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsGenerator())
}

func Test_ResourceRequirements_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements_STATUS, ResourceRequirements_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements_STATUS runs a test to see if a specific instance of ResourceRequirements_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements_STATUS(subject ResourceRequirements_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements_STATUS instances for property testing - lazily instantiated by
// ResourceRequirements_STATUSGenerator()
var resourceRequirements_STATUSGenerator gopter.Gen

// ResourceRequirements_STATUSGenerator returns a generator of ResourceRequirements_STATUS instances for property testing.
func ResourceRequirements_STATUSGenerator() gopter.Gen {
	if resourceRequirements_STATUSGenerator != nil {
		return resourceRequirements_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements_STATUS(generators)
	resourceRequirements_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements_STATUS{}), generators)

	return resourceRequirements_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements_STATUS(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimits_STATUSGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequests_STATUSGenerator())
}

func Test_UserAssignedIdentities_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentities_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentities_STATUS, UserAssignedIdentities_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentities_STATUS runs a test to see if a specific instance of UserAssignedIdentities_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentities_STATUS(subject UserAssignedIdentities_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentities_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentities_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentities_STATUSGenerator()
var userAssignedIdentities_STATUSGenerator gopter.Gen

// UserAssignedIdentities_STATUSGenerator returns a generator of UserAssignedIdentities_STATUS instances for property testing.
func UserAssignedIdentities_STATUSGenerator() gopter.Gen {
	if userAssignedIdentities_STATUSGenerator != nil {
		return userAssignedIdentities_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentities_STATUS(generators)
	userAssignedIdentities_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentities_STATUS{}), generators)

	return userAssignedIdentities_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentities_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentities_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_VolumeMount_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount_STATUS, VolumeMount_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount_STATUS runs a test to see if a specific instance of VolumeMount_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount_STATUS(subject VolumeMount_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_STATUS instances for property testing - lazily instantiated by VolumeMount_STATUSGenerator()
var volumeMount_STATUSGenerator gopter.Gen

// VolumeMount_STATUSGenerator returns a generator of VolumeMount_STATUS instances for property testing.
func VolumeMount_STATUSGenerator() gopter.Gen {
	if volumeMount_STATUSGenerator != nil {
		return volumeMount_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount_STATUS(generators)
	volumeMount_STATUSGenerator = gen.Struct(reflect.TypeOf(VolumeMount_STATUS{}), generators)

	return volumeMount_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount_STATUS(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec runs a test to see if a specific instance of ContainerExec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec(subject ContainerExec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec instances for property testing - lazily instantiated by ContainerExecGenerator()
var containerExecGenerator gopter.Gen

// ContainerExecGenerator returns a generator of ContainerExec instances for property testing.
func ContainerExecGenerator() gopter.Gen {
	if containerExecGenerator != nil {
		return containerExecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec(generators)
	containerExecGenerator = gen.Struct(reflect.TypeOf(ContainerExec{}), generators)

	return containerExecGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerExec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec_STATUS, ContainerExec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec_STATUS runs a test to see if a specific instance of ContainerExec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec_STATUS(subject ContainerExec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec_STATUS instances for property testing - lazily instantiated by
// ContainerExec_STATUSGenerator()
var containerExec_STATUSGenerator gopter.Gen

// ContainerExec_STATUSGenerator returns a generator of ContainerExec_STATUS instances for property testing.
func ContainerExec_STATUSGenerator() gopter.Gen {
	if containerExec_STATUSGenerator != nil {
		return containerExec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec_STATUS(generators)
	containerExec_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerExec_STATUS{}), generators)

	return containerExec_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec_STATUS(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet runs a test to see if a specific instance of ContainerHttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet instances for property testing - lazily instantiated by ContainerHttpGetGenerator()
var containerHttpGetGenerator gopter.Gen

// ContainerHttpGetGenerator returns a generator of ContainerHttpGet instances for property testing.
// We first initialize containerHttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetGenerator() gopter.Gen {
	if containerHttpGetGenerator != nil {
		return containerHttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	return containerHttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderGenerator())
}

func Test_ContainerHttpGet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet_STATUS, ContainerHttpGet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet_STATUS runs a test to see if a specific instance of ContainerHttpGet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet_STATUS(subject ContainerHttpGet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet_STATUS instances for property testing - lazily instantiated by
// ContainerHttpGet_STATUSGenerator()
var containerHttpGet_STATUSGenerator gopter.Gen

// ContainerHttpGet_STATUSGenerator returns a generator of ContainerHttpGet_STATUS instances for property testing.
// We first initialize containerHttpGet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGet_STATUSGenerator() gopter.Gen {
	if containerHttpGet_STATUSGenerator != nil {
		return containerHttpGet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet_STATUS(generators)
	containerHttpGet_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet_STATUS(generators)
	containerHttpGet_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_STATUS{}), generators)

	return containerHttpGet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet_STATUS(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerHttpGet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet_STATUS(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeader_STATUSGenerator())
}

func Test_ContainerState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerState_STATUS, ContainerState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerState_STATUS runs a test to see if a specific instance of ContainerState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerState_STATUS(subject ContainerState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerState_STATUS instances for property testing - lazily instantiated by
// ContainerState_STATUSGenerator()
var containerState_STATUSGenerator gopter.Gen

// ContainerState_STATUSGenerator returns a generator of ContainerState_STATUS instances for property testing.
func ContainerState_STATUSGenerator() gopter.Gen {
	if containerState_STATUSGenerator != nil {
		return containerState_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerState_STATUS(generators)
	containerState_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerState_STATUS{}), generators)

	return containerState_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerState_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerState_STATUS(gens map[string]gopter.Gen) {
	gens["DetailStatus"] = gen.PtrOf(gen.AlphaString())
	gens["ExitCode"] = gen.PtrOf(gen.Int())
	gens["FinishTime"] = gen.PtrOf(gen.AlphaString())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits runs a test to see if a specific instance of ResourceLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits(subject ResourceLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits instances for property testing - lazily instantiated by ResourceLimitsGenerator()
var resourceLimitsGenerator gopter.Gen

// ResourceLimitsGenerator returns a generator of ResourceLimits instances for property testing.
// We first initialize resourceLimitsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsGenerator() gopter.Gen {
	if resourceLimitsGenerator != nil {
		return resourceLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	AddRelatedPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	return resourceLimitsGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceLimits_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits_STATUS, ResourceLimits_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits_STATUS runs a test to see if a specific instance of ResourceLimits_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits_STATUS(subject ResourceLimits_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits_STATUS instances for property testing - lazily instantiated by
// ResourceLimits_STATUSGenerator()
var resourceLimits_STATUSGenerator gopter.Gen

// ResourceLimits_STATUSGenerator returns a generator of ResourceLimits_STATUS instances for property testing.
// We first initialize resourceLimits_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimits_STATUSGenerator() gopter.Gen {
	if resourceLimits_STATUSGenerator != nil {
		return resourceLimits_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits_STATUS(generators)
	resourceLimits_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits_STATUS(generators)
	AddRelatedPropertyGeneratorsForResourceLimits_STATUS(generators)
	resourceLimits_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_STATUS{}), generators)

	return resourceLimits_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits_STATUS(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits_STATUS(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResource_STATUSGenerator())
}

func Test_ResourceRequests_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests runs a test to see if a specific instance of ResourceRequests round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests(subject ResourceRequests) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests instances for property testing - lazily instantiated by ResourceRequestsGenerator()
var resourceRequestsGenerator gopter.Gen

// ResourceRequestsGenerator returns a generator of ResourceRequests instances for property testing.
// We first initialize resourceRequestsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsGenerator() gopter.Gen {
	if resourceRequestsGenerator != nil {
		return resourceRequestsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	AddRelatedPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	return resourceRequestsGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequests_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests_STATUS, ResourceRequests_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests_STATUS runs a test to see if a specific instance of ResourceRequests_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests_STATUS(subject ResourceRequests_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests_STATUS instances for property testing - lazily instantiated by
// ResourceRequests_STATUSGenerator()
var resourceRequests_STATUSGenerator gopter.Gen

// ResourceRequests_STATUSGenerator returns a generator of ResourceRequests_STATUS instances for property testing.
// We first initialize resourceRequests_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequests_STATUSGenerator() gopter.Gen {
	if resourceRequests_STATUSGenerator != nil {
		return resourceRequests_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests_STATUS(generators)
	resourceRequests_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests_STATUS(generators)
	AddRelatedPropertyGeneratorsForResourceRequests_STATUS(generators)
	resourceRequests_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_STATUS{}), generators)

	return resourceRequests_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests_STATUS(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests_STATUS(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResource_STATUSGenerator())
}

func Test_GpuResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource runs a test to see if a specific instance of GpuResource round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource(subject GpuResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource instances for property testing - lazily instantiated by GpuResourceGenerator()
var gpuResourceGenerator gopter.Gen

// GpuResourceGenerator returns a generator of GpuResource instances for property testing.
func GpuResourceGenerator() gopter.Gen {
	if gpuResourceGenerator != nil {
		return gpuResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource(generators)
	gpuResourceGenerator = gen.Struct(reflect.TypeOf(GpuResource{}), generators)

	return gpuResourceGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
}

func Test_GpuResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource_STATUS, GpuResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource_STATUS runs a test to see if a specific instance of GpuResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource_STATUS(subject GpuResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource_STATUS instances for property testing - lazily instantiated by GpuResource_STATUSGenerator()
var gpuResource_STATUSGenerator gopter.Gen

// GpuResource_STATUSGenerator returns a generator of GpuResource_STATUS instances for property testing.
func GpuResource_STATUSGenerator() gopter.Gen {
	if gpuResource_STATUSGenerator != nil {
		return gpuResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource_STATUS(generators)
	gpuResource_STATUSGenerator = gen.Struct(reflect.TypeOf(GpuResource_STATUS{}), generators)

	return gpuResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader runs a test to see if a specific instance of HttpHeader round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader(subject HttpHeader) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader instances for property testing - lazily instantiated by HttpHeaderGenerator()
var httpHeaderGenerator gopter.Gen

// HttpHeaderGenerator returns a generator of HttpHeader instances for property testing.
func HttpHeaderGenerator() gopter.Gen {
	if httpHeaderGenerator != nil {
		return httpHeaderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader(generators)
	httpHeaderGenerator = gen.Struct(reflect.TypeOf(HttpHeader{}), generators)

	return httpHeaderGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader_STATUS, HttpHeader_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader_STATUS runs a test to see if a specific instance of HttpHeader_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader_STATUS(subject HttpHeader_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader_STATUS instances for property testing - lazily instantiated by HttpHeader_STATUSGenerator()
var httpHeader_STATUSGenerator gopter.Gen

// HttpHeader_STATUSGenerator returns a generator of HttpHeader_STATUS instances for property testing.
func HttpHeader_STATUSGenerator() gopter.Gen {
	if httpHeader_STATUSGenerator != nil {
		return httpHeader_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader_STATUS(generators)
	httpHeader_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpHeader_STATUS{}), generators)

	return httpHeader_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
