// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ContainerGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroup, ContainerGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroup runs a test to see if a specific instance of ContainerGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroup(subject ContainerGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup instances for property testing - lazily instantiated by ContainerGroupGenerator()
var containerGroupGenerator gopter.Gen

// ContainerGroupGenerator returns a generator of ContainerGroup instances for property testing.
func ContainerGroupGenerator() gopter.Gen {
	if containerGroupGenerator != nil {
		return containerGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroup(generators)
	containerGroupGenerator = gen.Struct(reflect.TypeOf(ContainerGroup{}), generators)

	return containerGroupGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = ContainerGroupsSpecGenerator()
	gens["Status"] = ContainerGroupStatusGenerator()
}

func Test_ContainerGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupStatus, ContainerGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupStatus runs a test to see if a specific instance of ContainerGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupStatus(subject ContainerGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Status instances for property testing - lazily instantiated by
// ContainerGroupStatusGenerator()
var containerGroupStatusGenerator gopter.Gen

// ContainerGroupStatusGenerator returns a generator of ContainerGroup_Status instances for property testing.
// We first initialize containerGroupStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupStatusGenerator() gopter.Gen {
	if containerGroupStatusGenerator != nil {
		return containerGroupStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatus(generators)
	containerGroupStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatus(generators)
	AddRelatedPropertyGeneratorsForContainerGroupStatus(generators)
	containerGroupStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status{}), generators)

	return containerGroupStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupStatus(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerStatusGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsStatusGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationStatusGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesStatusGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityStatusGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredentialStatusGenerator())
	gens["InitContainers"] = gen.SliceOf(InitContainerDefinitionStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerGroupStatusPropertiesInstanceViewGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressStatusGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdStatusGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeStatusGenerator())
}

func Test_ContainerGroups_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpec, ContainerGroupsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpec runs a test to see if a specific instance of ContainerGroups_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpec(subject ContainerGroups_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec instances for property testing - lazily instantiated by
// ContainerGroupsSpecGenerator()
var containerGroupsSpecGenerator gopter.Gen

// ContainerGroupsSpecGenerator returns a generator of ContainerGroups_Spec instances for property testing.
// We first initialize containerGroupsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecGenerator() gopter.Gen {
	if containerGroupsSpecGenerator != nil {
		return containerGroupsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpec(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpec(generators)
	containerGroupsSpecGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec{}), generators)

	return containerGroupsSpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["RestartPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpec(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGroupsSpecPropertiesContainersGenerator())
	gens["Diagnostics"] = gen.PtrOf(ContainerGroupDiagnosticsGenerator())
	gens["DnsConfig"] = gen.PtrOf(DnsConfigurationGenerator())
	gens["EncryptionProperties"] = gen.PtrOf(EncryptionPropertiesGenerator())
	gens["Identity"] = gen.PtrOf(ContainerGroupIdentityGenerator())
	gens["ImageRegistryCredentials"] = gen.SliceOf(ImageRegistryCredentialGenerator())
	gens["InitContainers"] = gen.SliceOf(ContainerGroupsSpecPropertiesInitContainersGenerator())
	gens["IpAddress"] = gen.PtrOf(IpAddressGenerator())
	gens["SubnetIds"] = gen.SliceOf(ContainerGroupSubnetIdGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_ContainerGroupDiagnostics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnostics, ContainerGroupDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnostics runs a test to see if a specific instance of ContainerGroupDiagnostics round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnostics(subject ContainerGroupDiagnostics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsGenerator()
var containerGroupDiagnosticsGenerator gopter.Gen

// ContainerGroupDiagnosticsGenerator returns a generator of ContainerGroupDiagnostics instances for property testing.
func ContainerGroupDiagnosticsGenerator() gopter.Gen {
	if containerGroupDiagnosticsGenerator != nil {
		return containerGroupDiagnosticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(generators)
	containerGroupDiagnosticsGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics{}), generators)

	return containerGroupDiagnosticsGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnostics is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnostics(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsGenerator())
}

func Test_ContainerGroupDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupDiagnosticsStatus, ContainerGroupDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupDiagnosticsStatus runs a test to see if a specific instance of ContainerGroupDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupDiagnosticsStatus(subject ContainerGroupDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupDiagnostics_Status instances for property testing - lazily instantiated by
// ContainerGroupDiagnosticsStatusGenerator()
var containerGroupDiagnosticsStatusGenerator gopter.Gen

// ContainerGroupDiagnosticsStatusGenerator returns a generator of ContainerGroupDiagnostics_Status instances for property testing.
func ContainerGroupDiagnosticsStatusGenerator() gopter.Gen {
	if containerGroupDiagnosticsStatusGenerator != nil {
		return containerGroupDiagnosticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus(generators)
	containerGroupDiagnosticsStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupDiagnostics_Status{}), generators)

	return containerGroupDiagnosticsStatusGenerator
}

// AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupDiagnosticsStatus(gens map[string]gopter.Gen) {
	gens["LogAnalytics"] = gen.PtrOf(LogAnalyticsStatusGenerator())
}

func Test_ContainerGroupIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentity, ContainerGroupIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentity runs a test to see if a specific instance of ContainerGroupIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentity(subject ContainerGroupIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity instances for property testing - lazily instantiated by
// ContainerGroupIdentityGenerator()
var containerGroupIdentityGenerator gopter.Gen

// ContainerGroupIdentityGenerator returns a generator of ContainerGroupIdentity instances for property testing.
func ContainerGroupIdentityGenerator() gopter.Gen {
	if containerGroupIdentityGenerator != nil {
		return containerGroupIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentity(generators)
	containerGroupIdentityGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity{}), generators)

	return containerGroupIdentityGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentityStatus, ContainerGroupIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentityStatus runs a test to see if a specific instance of ContainerGroupIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentityStatus(subject ContainerGroupIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_Status instances for property testing - lazily instantiated by
// ContainerGroupIdentityStatusGenerator()
var containerGroupIdentityStatusGenerator gopter.Gen

// ContainerGroupIdentityStatusGenerator returns a generator of ContainerGroupIdentity_Status instances for property testing.
// We first initialize containerGroupIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupIdentityStatusGenerator() gopter.Gen {
	if containerGroupIdentityStatusGenerator != nil {
		return containerGroupIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	containerGroupIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus(generators)
	containerGroupIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status{}), generators)

	return containerGroupIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_ContainerGroupSubnetId_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetId, ContainerGroupSubnetIdGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetId runs a test to see if a specific instance of ContainerGroupSubnetId round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetId(subject ContainerGroupSubnetId) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdGenerator()
var containerGroupSubnetIdGenerator gopter.Gen

// ContainerGroupSubnetIdGenerator returns a generator of ContainerGroupSubnetId instances for property testing.
func ContainerGroupSubnetIdGenerator() gopter.Gen {
	if containerGroupSubnetIdGenerator != nil {
		return containerGroupSubnetIdGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetId(generators)
	containerGroupSubnetIdGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId{}), generators)

	return containerGroupSubnetIdGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetId is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetId(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupSubnetId_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupSubnetId_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupSubnetIdStatus, ContainerGroupSubnetIdStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupSubnetIdStatus runs a test to see if a specific instance of ContainerGroupSubnetId_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupSubnetIdStatus(subject ContainerGroupSubnetId_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupSubnetId_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupSubnetId_Status instances for property testing - lazily instantiated by
// ContainerGroupSubnetIdStatusGenerator()
var containerGroupSubnetIdStatusGenerator gopter.Gen

// ContainerGroupSubnetIdStatusGenerator returns a generator of ContainerGroupSubnetId_Status instances for property testing.
func ContainerGroupSubnetIdStatusGenerator() gopter.Gen {
	if containerGroupSubnetIdStatusGenerator != nil {
		return containerGroupSubnetIdStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus(generators)
	containerGroupSubnetIdStatusGenerator = gen.Struct(reflect.TypeOf(ContainerGroupSubnetId_Status{}), generators)

	return containerGroupSubnetIdStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupSubnetIdStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroup_Status_Properties_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroup_Status_Properties_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView, ContainerGroupStatusPropertiesInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView runs a test to see if a specific instance of ContainerGroup_Status_Properties_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupStatusPropertiesInstanceView(subject ContainerGroup_Status_Properties_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroup_Status_Properties_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroup_Status_Properties_InstanceView instances for property testing - lazily instantiated by
// ContainerGroupStatusPropertiesInstanceViewGenerator()
var containerGroupStatusPropertiesInstanceViewGenerator gopter.Gen

// ContainerGroupStatusPropertiesInstanceViewGenerator returns a generator of ContainerGroup_Status_Properties_InstanceView instances for property testing.
// We first initialize containerGroupStatusPropertiesInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupStatusPropertiesInstanceViewGenerator() gopter.Gen {
	if containerGroupStatusPropertiesInstanceViewGenerator != nil {
		return containerGroupStatusPropertiesInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	containerGroupStatusPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status_Properties_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(generators)
	containerGroupStatusPropertiesInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerGroup_Status_Properties_InstanceView{}), generators)

	return containerGroupStatusPropertiesInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupStatusPropertiesInstanceView(gens map[string]gopter.Gen) {
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
}

func Test_ContainerGroups_Spec_Properties_Containers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_Containers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers, ContainerGroupsSpecPropertiesContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_Containers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesContainers(subject ContainerGroups_Spec_Properties_Containers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_Containers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_Containers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesContainersGenerator()
var containerGroupsSpecPropertiesContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesContainersGenerator returns a generator of ContainerGroups_Spec_Properties_Containers instances for property testing.
// We first initialize containerGroupsSpecPropertiesContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesContainersGenerator != nil {
		return containerGroupsSpecPropertiesContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(generators)
	containerGroupsSpecPropertiesContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_Containers{}), generators)

	return containerGroupsSpecPropertiesContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerGroups_Spec_Properties_InitContainers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroups_Spec_Properties_InitContainers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers, ContainerGroupsSpecPropertiesInitContainersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers runs a test to see if a specific instance of ContainerGroups_Spec_Properties_InitContainers round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupsSpecPropertiesInitContainers(subject ContainerGroups_Spec_Properties_InitContainers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroups_Spec_Properties_InitContainers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing - lazily instantiated by
// ContainerGroupsSpecPropertiesInitContainersGenerator()
var containerGroupsSpecPropertiesInitContainersGenerator gopter.Gen

// ContainerGroupsSpecPropertiesInitContainersGenerator returns a generator of ContainerGroups_Spec_Properties_InitContainers instances for property testing.
// We first initialize containerGroupsSpecPropertiesInitContainersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGroupsSpecPropertiesInitContainersGenerator() gopter.Gen {
	if containerGroupsSpecPropertiesInitContainersGenerator != nil {
		return containerGroupsSpecPropertiesInitContainersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(generators)
	containerGroupsSpecPropertiesInitContainersGenerator = gen.Struct(reflect.TypeOf(ContainerGroups_Spec_Properties_InitContainers{}), generators)

	return containerGroupsSpecPropertiesInitContainersGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerGroupsSpecPropertiesInitContainers(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_Container_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerStatus, ContainerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerStatus runs a test to see if a specific instance of Container_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerStatus(subject Container_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_Status instances for property testing - lazily instantiated by ContainerStatusGenerator()
var containerStatusGenerator gopter.Gen

// ContainerStatusGenerator returns a generator of Container_Status instances for property testing.
// We first initialize containerStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerStatusGenerator() gopter.Gen {
	if containerStatusGenerator != nil {
		return containerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStatus(generators)
	containerStatusGenerator = gen.Struct(reflect.TypeOf(Container_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStatus(generators)
	AddRelatedPropertyGeneratorsForContainerStatus(generators)
	containerStatusGenerator = gen.Struct(reflect.TypeOf(Container_Status{}), generators)

	return containerStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerStatus(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(ContainerPropertiesStatusInstanceViewGenerator())
	gens["LivenessProbe"] = gen.PtrOf(ContainerProbeStatusGenerator())
	gens["Ports"] = gen.SliceOf(ContainerPortStatusGenerator())
	gens["ReadinessProbe"] = gen.PtrOf(ContainerProbeStatusGenerator())
	gens["Resources"] = gen.PtrOf(ResourceRequirementsStatusGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountStatusGenerator())
}

func Test_DnsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfiguration, DnsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfiguration runs a test to see if a specific instance of DnsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfiguration(subject DnsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration instances for property testing - lazily instantiated by DnsConfigurationGenerator()
var dnsConfigurationGenerator gopter.Gen

// DnsConfigurationGenerator returns a generator of DnsConfiguration instances for property testing.
func DnsConfigurationGenerator() gopter.Gen {
	if dnsConfigurationGenerator != nil {
		return dnsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfiguration(generators)
	dnsConfigurationGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration{}), generators)

	return dnsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfiguration(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsConfigurationStatus, DnsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsConfigurationStatus runs a test to see if a specific instance of DnsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsConfigurationStatus(subject DnsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsConfiguration_Status instances for property testing - lazily instantiated by
// DnsConfigurationStatusGenerator()
var dnsConfigurationStatusGenerator gopter.Gen

// DnsConfigurationStatusGenerator returns a generator of DnsConfiguration_Status instances for property testing.
func DnsConfigurationStatusGenerator() gopter.Gen {
	if dnsConfigurationStatusGenerator != nil {
		return dnsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsConfigurationStatus(generators)
	dnsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(DnsConfiguration_Status{}), generators)

	return dnsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDnsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["NameServers"] = gen.SliceOf(gen.AlphaString())
	gens["Options"] = gen.PtrOf(gen.AlphaString())
	gens["SearchDomains"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties, EncryptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties runs a test to see if a specific instance of EncryptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties(subject EncryptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties instances for property testing - lazily instantiated by
// EncryptionPropertiesGenerator()
var encryptionPropertiesGenerator gopter.Gen

// EncryptionPropertiesGenerator returns a generator of EncryptionProperties instances for property testing.
func EncryptionPropertiesGenerator() gopter.Gen {
	if encryptionPropertiesGenerator != nil {
		return encryptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties(generators)
	encryptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties{}), generators)

	return encryptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesStatus, EncryptionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesStatus runs a test to see if a specific instance of EncryptionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesStatus(subject EncryptionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Status instances for property testing - lazily instantiated by
// EncryptionPropertiesStatusGenerator()
var encryptionPropertiesStatusGenerator gopter.Gen

// EncryptionPropertiesStatusGenerator returns a generator of EncryptionProperties_Status instances for property testing.
func EncryptionPropertiesStatusGenerator() gopter.Gen {
	if encryptionPropertiesStatusGenerator != nil {
		return encryptionPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(generators)
	encryptionPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	return encryptionPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredential, ImageRegistryCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredential runs a test to see if a specific instance of ImageRegistryCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredential(subject ImageRegistryCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential instances for property testing - lazily instantiated by
// ImageRegistryCredentialGenerator()
var imageRegistryCredentialGenerator gopter.Gen

// ImageRegistryCredentialGenerator returns a generator of ImageRegistryCredential instances for property testing.
func ImageRegistryCredentialGenerator() gopter.Gen {
	if imageRegistryCredentialGenerator != nil {
		return imageRegistryCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredential(generators)
	imageRegistryCredentialGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential{}), generators)

	return imageRegistryCredentialGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredential is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredential(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageRegistryCredential_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageRegistryCredential_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageRegistryCredentialStatus, ImageRegistryCredentialStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageRegistryCredentialStatus runs a test to see if a specific instance of ImageRegistryCredential_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageRegistryCredentialStatus(subject ImageRegistryCredential_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageRegistryCredential_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageRegistryCredential_Status instances for property testing - lazily instantiated by
// ImageRegistryCredentialStatusGenerator()
var imageRegistryCredentialStatusGenerator gopter.Gen

// ImageRegistryCredentialStatusGenerator returns a generator of ImageRegistryCredential_Status instances for property testing.
func ImageRegistryCredentialStatusGenerator() gopter.Gen {
	if imageRegistryCredentialStatusGenerator != nil {
		return imageRegistryCredentialStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus(generators)
	imageRegistryCredentialStatusGenerator = gen.Struct(reflect.TypeOf(ImageRegistryCredential_Status{}), generators)

	return imageRegistryCredentialStatusGenerator
}

// AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageRegistryCredentialStatus(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerDefinition_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerDefinition_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerDefinitionStatus, InitContainerDefinitionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerDefinitionStatus runs a test to see if a specific instance of InitContainerDefinition_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerDefinitionStatus(subject InitContainerDefinition_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerDefinition_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerDefinition_Status instances for property testing - lazily instantiated by
// InitContainerDefinitionStatusGenerator()
var initContainerDefinitionStatusGenerator gopter.Gen

// InitContainerDefinitionStatusGenerator returns a generator of InitContainerDefinition_Status instances for property testing.
// We first initialize initContainerDefinitionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerDefinitionStatusGenerator() gopter.Gen {
	if initContainerDefinitionStatusGenerator != nil {
		return initContainerDefinitionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	initContainerDefinitionStatusGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus(generators)
	initContainerDefinitionStatusGenerator = gen.Struct(reflect.TypeOf(InitContainerDefinition_Status{}), generators)

	return initContainerDefinitionStatusGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerDefinitionStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerDefinitionStatus(gens map[string]gopter.Gen) {
	gens["EnvironmentVariables"] = gen.SliceOf(EnvironmentVariableStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(InitContainerPropertiesDefinitionStatusInstanceViewGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountStatusGenerator())
}

func Test_IpAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddress, IpAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddress runs a test to see if a specific instance of IpAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddress(subject IpAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress instances for property testing - lazily instantiated by IpAddressGenerator()
var ipAddressGenerator gopter.Gen

// IpAddressGenerator returns a generator of IpAddress instances for property testing.
// We first initialize ipAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressGenerator() gopter.Gen {
	if ipAddressGenerator != nil {
		return ipAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddress(generators)
	AddRelatedPropertyGeneratorsForIpAddress(generators)
	ipAddressGenerator = gen.Struct(reflect.TypeOf(IpAddress{}), generators)

	return ipAddressGenerator
}

// AddIndependentPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIpAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddress(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortGenerator())
}

func Test_IpAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressStatus, IpAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressStatus runs a test to see if a specific instance of IpAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressStatus(subject IpAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddress_Status instances for property testing - lazily instantiated by IpAddressStatusGenerator()
var ipAddressStatusGenerator gopter.Gen

// IpAddressStatusGenerator returns a generator of IpAddress_Status instances for property testing.
// We first initialize ipAddressStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IpAddressStatusGenerator() gopter.Gen {
	if ipAddressStatusGenerator != nil {
		return ipAddressStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressStatus(generators)
	ipAddressStatusGenerator = gen.Struct(reflect.TypeOf(IpAddress_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressStatus(generators)
	AddRelatedPropertyGeneratorsForIpAddressStatus(generators)
	ipAddressStatusGenerator = gen.Struct(reflect.TypeOf(IpAddress_Status{}), generators)

	return ipAddressStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressStatus(gens map[string]gopter.Gen) {
	gens["DnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["DnsNameLabelReusePolicy"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIpAddressStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIpAddressStatus(gens map[string]gopter.Gen) {
	gens["Ports"] = gen.SliceOf(PortStatusGenerator())
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeGenerator())
}

func Test_Volume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeStatus, VolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeStatus runs a test to see if a specific instance of Volume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeStatus(subject Volume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_Status instances for property testing - lazily instantiated by VolumeStatusGenerator()
var volumeStatusGenerator gopter.Gen

// VolumeStatusGenerator returns a generator of Volume_Status instances for property testing.
// We first initialize volumeStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeStatusGenerator() gopter.Gen {
	if volumeStatusGenerator != nil {
		return volumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeStatus(generators)
	volumeStatusGenerator = gen.Struct(reflect.TypeOf(Volume_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeStatus(generators)
	AddRelatedPropertyGeneratorsForVolumeStatus(generators)
	volumeStatusGenerator = gen.Struct(reflect.TypeOf(Volume_Status{}), generators)

	return volumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVolumeStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolumeStatus(gens map[string]gopter.Gen) {
	gens["AzureFile"] = gen.PtrOf(AzureFileVolumeStatusGenerator())
	gens["GitRepo"] = gen.PtrOf(GitRepoVolumeStatusGenerator())
}

func Test_AzureFileVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolume, AzureFileVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolume runs a test to see if a specific instance of AzureFileVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolume(subject AzureFileVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume instances for property testing - lazily instantiated by AzureFileVolumeGenerator()
var azureFileVolumeGenerator gopter.Gen

// AzureFileVolumeGenerator returns a generator of AzureFileVolume instances for property testing.
func AzureFileVolumeGenerator() gopter.Gen {
	if azureFileVolumeGenerator != nil {
		return azureFileVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolume(generators)
	azureFileVolumeGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume{}), generators)

	return azureFileVolumeGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolume(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFileVolume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFileVolume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFileVolumeStatus, AzureFileVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFileVolumeStatus runs a test to see if a specific instance of AzureFileVolume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFileVolumeStatus(subject AzureFileVolume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFileVolume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFileVolume_Status instances for property testing - lazily instantiated by
// AzureFileVolumeStatusGenerator()
var azureFileVolumeStatusGenerator gopter.Gen

// AzureFileVolumeStatusGenerator returns a generator of AzureFileVolume_Status instances for property testing.
func AzureFileVolumeStatusGenerator() gopter.Gen {
	if azureFileVolumeStatusGenerator != nil {
		return azureFileVolumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFileVolumeStatus(generators)
	azureFileVolumeStatusGenerator = gen.Struct(reflect.TypeOf(AzureFileVolume_Status{}), generators)

	return azureFileVolumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForAzureFileVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFileVolumeStatus(gens map[string]gopter.Gen) {
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountKey"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerGroupIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerGroupIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities, ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of ContainerGroupIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerGroupIdentityStatusUserAssignedIdentities(subject ContainerGroupIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerGroupIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerGroupIdentity_Status_UserAssignedIdentities instances for property testing - lazily
// instantiated by ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator()
var containerGroupIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator returns a generator of ContainerGroupIdentity_Status_UserAssignedIdentities instances for property testing.
func ContainerGroupIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if containerGroupIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return containerGroupIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities(generators)
	containerGroupIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ContainerGroupIdentity_Status_UserAssignedIdentities{}), generators)

	return containerGroupIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerGroupIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPort, ContainerPortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPort runs a test to see if a specific instance of ContainerPort round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPort(subject ContainerPort) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort instances for property testing - lazily instantiated by ContainerPortGenerator()
var containerPortGenerator gopter.Gen

// ContainerPortGenerator returns a generator of ContainerPort instances for property testing.
func ContainerPortGenerator() gopter.Gen {
	if containerPortGenerator != nil {
		return containerPortGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPort(generators)
	containerPortGenerator = gen.Struct(reflect.TypeOf(ContainerPort{}), generators)

	return containerPortGenerator
}

// AddIndependentPropertyGeneratorsForContainerPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPort_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPort_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPortStatus, ContainerPortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPortStatus runs a test to see if a specific instance of ContainerPort_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPortStatus(subject ContainerPort_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPort_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPort_Status instances for property testing - lazily instantiated by
// ContainerPortStatusGenerator()
var containerPortStatusGenerator gopter.Gen

// ContainerPortStatusGenerator returns a generator of ContainerPort_Status instances for property testing.
func ContainerPortStatusGenerator() gopter.Gen {
	if containerPortStatusGenerator != nil {
		return containerPortStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPortStatus(generators)
	containerPortStatusGenerator = gen.Struct(reflect.TypeOf(ContainerPort_Status{}), generators)

	return containerPortStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerPortStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPortStatus(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbe, ContainerProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbe runs a test to see if a specific instance of ContainerProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbe(subject ContainerProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe instances for property testing - lazily instantiated by ContainerProbeGenerator()
var containerProbeGenerator gopter.Gen

// ContainerProbeGenerator returns a generator of ContainerProbe instances for property testing.
// We first initialize containerProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeGenerator() gopter.Gen {
	if containerProbeGenerator != nil {
		return containerProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbe(generators)
	AddRelatedPropertyGeneratorsForContainerProbe(generators)
	containerProbeGenerator = gen.Struct(reflect.TypeOf(ContainerProbe{}), generators)

	return containerProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbe(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetGenerator())
}

func Test_ContainerProbe_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProbe_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerProbeStatus, ContainerProbeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerProbeStatus runs a test to see if a specific instance of ContainerProbe_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerProbeStatus(subject ContainerProbe_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProbe_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProbe_Status instances for property testing - lazily instantiated by
// ContainerProbeStatusGenerator()
var containerProbeStatusGenerator gopter.Gen

// ContainerProbeStatusGenerator returns a generator of ContainerProbe_Status instances for property testing.
// We first initialize containerProbeStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerProbeStatusGenerator() gopter.Gen {
	if containerProbeStatusGenerator != nil {
		return containerProbeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeStatus(generators)
	containerProbeStatusGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerProbeStatus(generators)
	AddRelatedPropertyGeneratorsForContainerProbeStatus(generators)
	containerProbeStatusGenerator = gen.Struct(reflect.TypeOf(ContainerProbe_Status{}), generators)

	return containerProbeStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerProbeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerProbeStatus(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerProbeStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerProbeStatus(gens map[string]gopter.Gen) {
	gens["Exec"] = gen.PtrOf(ContainerExecStatusGenerator())
	gens["HttpGet"] = gen.PtrOf(ContainerHttpGetStatusGenerator())
}

func Test_ContainerProperties_Status_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerProperties_Status_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPropertiesStatusInstanceView, ContainerPropertiesStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPropertiesStatusInstanceView runs a test to see if a specific instance of ContainerProperties_Status_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPropertiesStatusInstanceView(subject ContainerProperties_Status_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerProperties_Status_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerProperties_Status_InstanceView instances for property testing - lazily instantiated by
// ContainerPropertiesStatusInstanceViewGenerator()
var containerPropertiesStatusInstanceViewGenerator gopter.Gen

// ContainerPropertiesStatusInstanceViewGenerator returns a generator of ContainerProperties_Status_InstanceView instances for property testing.
// We first initialize containerPropertiesStatusInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerPropertiesStatusInstanceViewGenerator() gopter.Gen {
	if containerPropertiesStatusInstanceViewGenerator != nil {
		return containerPropertiesStatusInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	containerPropertiesStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_Status_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView(generators)
	containerPropertiesStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(ContainerProperties_Status_InstanceView{}), generators)

	return containerPropertiesStatusInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPropertiesStatusInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerPropertiesStatusInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateStatusGenerator())
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateStatusGenerator())
}

func Test_EnvironmentVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariable, EnvironmentVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariable runs a test to see if a specific instance of EnvironmentVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariable(subject EnvironmentVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable instances for property testing - lazily instantiated by
// EnvironmentVariableGenerator()
var environmentVariableGenerator gopter.Gen

// EnvironmentVariableGenerator returns a generator of EnvironmentVariable instances for property testing.
func EnvironmentVariableGenerator() gopter.Gen {
	if environmentVariableGenerator != nil {
		return environmentVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariable(generators)
	environmentVariableGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable{}), generators)

	return environmentVariableGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariable(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnvironmentVariable_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVariable_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVariableStatus, EnvironmentVariableStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVariableStatus runs a test to see if a specific instance of EnvironmentVariable_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVariableStatus(subject EnvironmentVariable_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVariable_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVariable_Status instances for property testing - lazily instantiated by
// EnvironmentVariableStatusGenerator()
var environmentVariableStatusGenerator gopter.Gen

// EnvironmentVariableStatusGenerator returns a generator of EnvironmentVariable_Status instances for property testing.
func EnvironmentVariableStatusGenerator() gopter.Gen {
	if environmentVariableStatusGenerator != nil {
		return environmentVariableStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVariableStatus(generators)
	environmentVariableStatusGenerator = gen.Struct(reflect.TypeOf(EnvironmentVariable_Status{}), generators)

	return environmentVariableStatusGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVariableStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVariableStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecureValue"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Event_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Event_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventStatus, EventStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventStatus runs a test to see if a specific instance of Event_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventStatus(subject Event_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Event_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Event_Status instances for property testing - lazily instantiated by EventStatusGenerator()
var eventStatusGenerator gopter.Gen

// EventStatusGenerator returns a generator of Event_Status instances for property testing.
func EventStatusGenerator() gopter.Gen {
	if eventStatusGenerator != nil {
		return eventStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventStatus(generators)
	eventStatusGenerator = gen.Struct(reflect.TypeOf(Event_Status{}), generators)

	return eventStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventStatus(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["FirstTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["LastTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolume, GitRepoVolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolume runs a test to see if a specific instance of GitRepoVolume round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolume(subject GitRepoVolume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume instances for property testing - lazily instantiated by GitRepoVolumeGenerator()
var gitRepoVolumeGenerator gopter.Gen

// GitRepoVolumeGenerator returns a generator of GitRepoVolume instances for property testing.
func GitRepoVolumeGenerator() gopter.Gen {
	if gitRepoVolumeGenerator != nil {
		return gitRepoVolumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolume(generators)
	gitRepoVolumeGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume{}), generators)

	return gitRepoVolumeGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolume(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitRepoVolume_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepoVolume_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepoVolumeStatus, GitRepoVolumeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepoVolumeStatus runs a test to see if a specific instance of GitRepoVolume_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepoVolumeStatus(subject GitRepoVolume_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepoVolume_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepoVolume_Status instances for property testing - lazily instantiated by
// GitRepoVolumeStatusGenerator()
var gitRepoVolumeStatusGenerator gopter.Gen

// GitRepoVolumeStatusGenerator returns a generator of GitRepoVolume_Status instances for property testing.
func GitRepoVolumeStatusGenerator() gopter.Gen {
	if gitRepoVolumeStatusGenerator != nil {
		return gitRepoVolumeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepoVolumeStatus(generators)
	gitRepoVolumeStatusGenerator = gen.Struct(reflect.TypeOf(GitRepoVolume_Status{}), generators)

	return gitRepoVolumeStatusGenerator
}

// AddIndependentPropertyGeneratorsForGitRepoVolumeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepoVolumeStatus(gens map[string]gopter.Gen) {
	gens["Directory"] = gen.PtrOf(gen.AlphaString())
	gens["Repository"] = gen.PtrOf(gen.AlphaString())
	gens["Revision"] = gen.PtrOf(gen.AlphaString())
}

func Test_InitContainerPropertiesDefinition_Status_InstanceView_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InitContainerPropertiesDefinition_Status_InstanceView via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView, InitContainerPropertiesDefinitionStatusInstanceViewGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView runs a test to see if a specific instance of InitContainerPropertiesDefinition_Status_InstanceView round trips to JSON and back losslessly
func RunJSONSerializationTestForInitContainerPropertiesDefinitionStatusInstanceView(subject InitContainerPropertiesDefinition_Status_InstanceView) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InitContainerPropertiesDefinition_Status_InstanceView
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InitContainerPropertiesDefinition_Status_InstanceView instances for property testing - lazily
// instantiated by InitContainerPropertiesDefinitionStatusInstanceViewGenerator()
var initContainerPropertiesDefinitionStatusInstanceViewGenerator gopter.Gen

// InitContainerPropertiesDefinitionStatusInstanceViewGenerator returns a generator of InitContainerPropertiesDefinition_Status_InstanceView instances for property testing.
// We first initialize initContainerPropertiesDefinitionStatusInstanceViewGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InitContainerPropertiesDefinitionStatusInstanceViewGenerator() gopter.Gen {
	if initContainerPropertiesDefinitionStatusInstanceViewGenerator != nil {
		return initContainerPropertiesDefinitionStatusInstanceViewGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	initContainerPropertiesDefinitionStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_Status_InstanceView{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(generators)
	initContainerPropertiesDefinitionStatusInstanceViewGenerator = gen.Struct(reflect.TypeOf(InitContainerPropertiesDefinition_Status_InstanceView{}), generators)

	return initContainerPropertiesDefinitionStatusInstanceViewGenerator
}

// AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(gens map[string]gopter.Gen) {
	gens["RestartCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInitContainerPropertiesDefinitionStatusInstanceView(gens map[string]gopter.Gen) {
	gens["CurrentState"] = gen.PtrOf(ContainerStateStatusGenerator())
	gens["Events"] = gen.SliceOf(EventStatusGenerator())
	gens["PreviousState"] = gen.PtrOf(ContainerStateStatusGenerator())
}

func Test_LogAnalytics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalytics, LogAnalyticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalytics runs a test to see if a specific instance of LogAnalytics round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalytics(subject LogAnalytics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics instances for property testing - lazily instantiated by LogAnalyticsGenerator()
var logAnalyticsGenerator gopter.Gen

// LogAnalyticsGenerator returns a generator of LogAnalytics instances for property testing.
func LogAnalyticsGenerator() gopter.Gen {
	if logAnalyticsGenerator != nil {
		return logAnalyticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalytics(generators)
	logAnalyticsGenerator = gen.Struct(reflect.TypeOf(LogAnalytics{}), generators)

	return logAnalyticsGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalytics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalytics(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.AlphaString())
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalytics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalytics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsStatus, LogAnalyticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsStatus runs a test to see if a specific instance of LogAnalytics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsStatus(subject LogAnalytics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalytics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalytics_Status instances for property testing - lazily instantiated by LogAnalyticsStatusGenerator()
var logAnalyticsStatusGenerator gopter.Gen

// LogAnalyticsStatusGenerator returns a generator of LogAnalytics_Status instances for property testing.
func LogAnalyticsStatusGenerator() gopter.Gen {
	if logAnalyticsStatusGenerator != nil {
		return logAnalyticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsStatus(generators)
	logAnalyticsStatusGenerator = gen.Struct(reflect.TypeOf(LogAnalytics_Status{}), generators)

	return logAnalyticsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsStatus(gens map[string]gopter.Gen) {
	gens["LogType"] = gen.PtrOf(gen.AlphaString())
	gens["Metadata"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceKey"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPort, PortGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPort runs a test to see if a specific instance of Port round trips to JSON and back losslessly
func RunJSONSerializationTestForPort(subject Port) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port instances for property testing - lazily instantiated by PortGenerator()
var portGenerator gopter.Gen

// PortGenerator returns a generator of Port instances for property testing.
func PortGenerator() gopter.Gen {
	if portGenerator != nil {
		return portGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPort(generators)
	portGenerator = gen.Struct(reflect.TypeOf(Port{}), generators)

	return portGenerator
}

// AddIndependentPropertyGeneratorsForPort is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPort(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_Port_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Port_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPortStatus, PortStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPortStatus runs a test to see if a specific instance of Port_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPortStatus(subject Port_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Port_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Port_Status instances for property testing - lazily instantiated by PortStatusGenerator()
var portStatusGenerator gopter.Gen

// PortStatusGenerator returns a generator of Port_Status instances for property testing.
func PortStatusGenerator() gopter.Gen {
	if portStatusGenerator != nil {
		return portStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPortStatus(generators)
	portStatusGenerator = gen.Struct(reflect.TypeOf(Port_Status{}), generators)

	return portStatusGenerator
}

// AddIndependentPropertyGeneratorsForPortStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPortStatus(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceRequirements_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirements, ResourceRequirementsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirements runs a test to see if a specific instance of ResourceRequirements round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirements(subject ResourceRequirements) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements instances for property testing - lazily instantiated by
// ResourceRequirementsGenerator()
var resourceRequirementsGenerator gopter.Gen

// ResourceRequirementsGenerator returns a generator of ResourceRequirements instances for property testing.
func ResourceRequirementsGenerator() gopter.Gen {
	if resourceRequirementsGenerator != nil {
		return resourceRequirementsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirements(generators)
	resourceRequirementsGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements{}), generators)

	return resourceRequirementsGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirements is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirements(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsGenerator())
}

func Test_ResourceRequirements_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequirements_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequirementsStatus, ResourceRequirementsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequirementsStatus runs a test to see if a specific instance of ResourceRequirements_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequirementsStatus(subject ResourceRequirements_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequirements_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequirements_Status instances for property testing - lazily instantiated by
// ResourceRequirementsStatusGenerator()
var resourceRequirementsStatusGenerator gopter.Gen

// ResourceRequirementsStatusGenerator returns a generator of ResourceRequirements_Status instances for property testing.
func ResourceRequirementsStatusGenerator() gopter.Gen {
	if resourceRequirementsStatusGenerator != nil {
		return resourceRequirementsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceRequirementsStatus(generators)
	resourceRequirementsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequirements_Status{}), generators)

	return resourceRequirementsStatusGenerator
}

// AddRelatedPropertyGeneratorsForResourceRequirementsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequirementsStatus(gens map[string]gopter.Gen) {
	gens["Limits"] = gen.PtrOf(ResourceLimitsStatusGenerator())
	gens["Requests"] = gen.PtrOf(ResourceRequestsStatusGenerator())
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_VolumeMount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMountStatus, VolumeMountStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMountStatus runs a test to see if a specific instance of VolumeMount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMountStatus(subject VolumeMount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_Status instances for property testing - lazily instantiated by VolumeMountStatusGenerator()
var volumeMountStatusGenerator gopter.Gen

// VolumeMountStatusGenerator returns a generator of VolumeMount_Status instances for property testing.
func VolumeMountStatusGenerator() gopter.Gen {
	if volumeMountStatusGenerator != nil {
		return volumeMountStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMountStatus(generators)
	volumeMountStatusGenerator = gen.Struct(reflect.TypeOf(VolumeMount_Status{}), generators)

	return volumeMountStatusGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMountStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMountStatus(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReadOnly"] = gen.PtrOf(gen.Bool())
}

func Test_ContainerExec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExec, ContainerExecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExec runs a test to see if a specific instance of ContainerExec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExec(subject ContainerExec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec instances for property testing - lazily instantiated by ContainerExecGenerator()
var containerExecGenerator gopter.Gen

// ContainerExecGenerator returns a generator of ContainerExec instances for property testing.
func ContainerExecGenerator() gopter.Gen {
	if containerExecGenerator != nil {
		return containerExecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExec(generators)
	containerExecGenerator = gen.Struct(reflect.TypeOf(ContainerExec{}), generators)

	return containerExecGenerator
}

// AddIndependentPropertyGeneratorsForContainerExec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExec(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerExec_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerExec_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerExecStatus, ContainerExecStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerExecStatus runs a test to see if a specific instance of ContainerExec_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerExecStatus(subject ContainerExec_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerExec_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerExec_Status instances for property testing - lazily instantiated by
// ContainerExecStatusGenerator()
var containerExecStatusGenerator gopter.Gen

// ContainerExecStatusGenerator returns a generator of ContainerExec_Status instances for property testing.
func ContainerExecStatusGenerator() gopter.Gen {
	if containerExecStatusGenerator != nil {
		return containerExecStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerExecStatus(generators)
	containerExecStatusGenerator = gen.Struct(reflect.TypeOf(ContainerExec_Status{}), generators)

	return containerExecStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerExecStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerExecStatus(gens map[string]gopter.Gen) {
	gens["Command"] = gen.SliceOf(gen.AlphaString())
}

func Test_ContainerHttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGet, ContainerHttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGet runs a test to see if a specific instance of ContainerHttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGet(subject ContainerHttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet instances for property testing - lazily instantiated by ContainerHttpGetGenerator()
var containerHttpGetGenerator gopter.Gen

// ContainerHttpGetGenerator returns a generator of ContainerHttpGet instances for property testing.
// We first initialize containerHttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetGenerator() gopter.Gen {
	if containerHttpGetGenerator != nil {
		return containerHttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGet(generators)
	containerHttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet{}), generators)

	return containerHttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerHttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderGenerator())
}

func Test_ContainerHttpGet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerHttpGet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerHttpGetStatus, ContainerHttpGetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerHttpGetStatus runs a test to see if a specific instance of ContainerHttpGet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerHttpGetStatus(subject ContainerHttpGet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerHttpGet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerHttpGet_Status instances for property testing - lazily instantiated by
// ContainerHttpGetStatusGenerator()
var containerHttpGetStatusGenerator gopter.Gen

// ContainerHttpGetStatusGenerator returns a generator of ContainerHttpGet_Status instances for property testing.
// We first initialize containerHttpGetStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerHttpGetStatusGenerator() gopter.Gen {
	if containerHttpGetStatusGenerator != nil {
		return containerHttpGetStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetStatus(generators)
	containerHttpGetStatusGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerHttpGetStatus(generators)
	AddRelatedPropertyGeneratorsForContainerHttpGetStatus(generators)
	containerHttpGetStatusGenerator = gen.Struct(reflect.TypeOf(ContainerHttpGet_Status{}), generators)

	return containerHttpGetStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerHttpGetStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerHttpGetStatus(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerHttpGetStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerHttpGetStatus(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(HttpHeaderStatusGenerator())
}

func Test_ContainerState_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerState_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerStateStatus, ContainerStateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerStateStatus runs a test to see if a specific instance of ContainerState_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerStateStatus(subject ContainerState_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerState_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerState_Status instances for property testing - lazily instantiated by
// ContainerStateStatusGenerator()
var containerStateStatusGenerator gopter.Gen

// ContainerStateStatusGenerator returns a generator of ContainerState_Status instances for property testing.
func ContainerStateStatusGenerator() gopter.Gen {
	if containerStateStatusGenerator != nil {
		return containerStateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerStateStatus(generators)
	containerStateStatusGenerator = gen.Struct(reflect.TypeOf(ContainerState_Status{}), generators)

	return containerStateStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerStateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerStateStatus(gens map[string]gopter.Gen) {
	gens["DetailStatus"] = gen.PtrOf(gen.AlphaString())
	gens["ExitCode"] = gen.PtrOf(gen.Int())
	gens["FinishTime"] = gen.PtrOf(gen.AlphaString())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimits, ResourceLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimits runs a test to see if a specific instance of ResourceLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimits(subject ResourceLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits instances for property testing - lazily instantiated by ResourceLimitsGenerator()
var resourceLimitsGenerator gopter.Gen

// ResourceLimitsGenerator returns a generator of ResourceLimits instances for property testing.
// We first initialize resourceLimitsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsGenerator() gopter.Gen {
	if resourceLimitsGenerator != nil {
		return resourceLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimits(generators)
	AddRelatedPropertyGeneratorsForResourceLimits(generators)
	resourceLimitsGenerator = gen.Struct(reflect.TypeOf(ResourceLimits{}), generators)

	return resourceLimitsGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimits is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimits(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceLimits_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLimits_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLimitsStatus, ResourceLimitsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLimitsStatus runs a test to see if a specific instance of ResourceLimits_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLimitsStatus(subject ResourceLimits_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLimits_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLimits_Status instances for property testing - lazily instantiated by
// ResourceLimitsStatusGenerator()
var resourceLimitsStatusGenerator gopter.Gen

// ResourceLimitsStatusGenerator returns a generator of ResourceLimits_Status instances for property testing.
// We first initialize resourceLimitsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceLimitsStatusGenerator() gopter.Gen {
	if resourceLimitsStatusGenerator != nil {
		return resourceLimitsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsStatus(generators)
	resourceLimitsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLimitsStatus(generators)
	AddRelatedPropertyGeneratorsForResourceLimitsStatus(generators)
	resourceLimitsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLimits_Status{}), generators)

	return resourceLimitsStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceLimitsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLimitsStatus(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceLimitsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLimitsStatus(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceStatusGenerator())
}

func Test_ResourceRequests_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequests, ResourceRequestsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequests runs a test to see if a specific instance of ResourceRequests round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequests(subject ResourceRequests) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests instances for property testing - lazily instantiated by ResourceRequestsGenerator()
var resourceRequestsGenerator gopter.Gen

// ResourceRequestsGenerator returns a generator of ResourceRequests instances for property testing.
// We first initialize resourceRequestsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsGenerator() gopter.Gen {
	if resourceRequestsGenerator != nil {
		return resourceRequestsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequests(generators)
	AddRelatedPropertyGeneratorsForResourceRequests(generators)
	resourceRequestsGenerator = gen.Struct(reflect.TypeOf(ResourceRequests{}), generators)

	return resourceRequestsGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequests is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequests(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceGenerator())
}

func Test_ResourceRequests_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceRequests_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceRequestsStatus, ResourceRequestsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceRequestsStatus runs a test to see if a specific instance of ResourceRequests_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceRequestsStatus(subject ResourceRequests_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceRequests_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceRequests_Status instances for property testing - lazily instantiated by
// ResourceRequestsStatusGenerator()
var resourceRequestsStatusGenerator gopter.Gen

// ResourceRequestsStatusGenerator returns a generator of ResourceRequests_Status instances for property testing.
// We first initialize resourceRequestsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceRequestsStatusGenerator() gopter.Gen {
	if resourceRequestsStatusGenerator != nil {
		return resourceRequestsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsStatus(generators)
	resourceRequestsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceRequestsStatus(generators)
	AddRelatedPropertyGeneratorsForResourceRequestsStatus(generators)
	resourceRequestsStatusGenerator = gen.Struct(reflect.TypeOf(ResourceRequests_Status{}), generators)

	return resourceRequestsStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceRequestsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceRequestsStatus(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["MemoryInGB"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForResourceRequestsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceRequestsStatus(gens map[string]gopter.Gen) {
	gens["Gpu"] = gen.PtrOf(GpuResourceStatusGenerator())
}

func Test_GpuResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResource, GpuResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResource runs a test to see if a specific instance of GpuResource round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResource(subject GpuResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource instances for property testing - lazily instantiated by GpuResourceGenerator()
var gpuResourceGenerator gopter.Gen

// GpuResourceGenerator returns a generator of GpuResource instances for property testing.
func GpuResourceGenerator() gopter.Gen {
	if gpuResourceGenerator != nil {
		return gpuResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResource(generators)
	gpuResourceGenerator = gen.Struct(reflect.TypeOf(GpuResource{}), generators)

	return gpuResourceGenerator
}

// AddIndependentPropertyGeneratorsForGpuResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResource(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
}

func Test_GpuResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GpuResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGpuResourceStatus, GpuResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGpuResourceStatus runs a test to see if a specific instance of GpuResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForGpuResourceStatus(subject GpuResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GpuResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GpuResource_Status instances for property testing - lazily instantiated by GpuResourceStatusGenerator()
var gpuResourceStatusGenerator gopter.Gen

// GpuResourceStatusGenerator returns a generator of GpuResource_Status instances for property testing.
func GpuResourceStatusGenerator() gopter.Gen {
	if gpuResourceStatusGenerator != nil {
		return gpuResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGpuResourceStatus(generators)
	gpuResourceStatusGenerator = gen.Struct(reflect.TypeOf(GpuResource_Status{}), generators)

	return gpuResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForGpuResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGpuResourceStatus(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeader, HttpHeaderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeader runs a test to see if a specific instance of HttpHeader round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeader(subject HttpHeader) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader instances for property testing - lazily instantiated by HttpHeaderGenerator()
var httpHeaderGenerator gopter.Gen

// HttpHeaderGenerator returns a generator of HttpHeader instances for property testing.
func HttpHeaderGenerator() gopter.Gen {
	if httpHeaderGenerator != nil {
		return httpHeaderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeader(generators)
	httpHeaderGenerator = gen.Struct(reflect.TypeOf(HttpHeader{}), generators)

	return httpHeaderGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeader is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeader(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpHeader_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpHeader_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpHeaderStatus, HttpHeaderStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpHeaderStatus runs a test to see if a specific instance of HttpHeader_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpHeaderStatus(subject HttpHeader_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpHeader_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpHeader_Status instances for property testing - lazily instantiated by HttpHeaderStatusGenerator()
var httpHeaderStatusGenerator gopter.Gen

// HttpHeaderStatusGenerator returns a generator of HttpHeader_Status instances for property testing.
func HttpHeaderStatusGenerator() gopter.Gen {
	if httpHeaderStatusGenerator != nil {
		return httpHeaderStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpHeaderStatus(generators)
	httpHeaderStatusGenerator = gen.Struct(reflect.TypeOf(HttpHeader_Status{}), generators)

	return httpHeaderStatusGenerator
}

// AddIndependentPropertyGeneratorsForHttpHeaderStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpHeaderStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
