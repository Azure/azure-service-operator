// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"fmt"
	v20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1beta20201101storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancer_Spec   `json:"spec,omitempty"`
	Status            LoadBalancer_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &LoadBalancer{}

// GetConditions returns the conditions of the resource
func (balancer *LoadBalancer) GetConditions() conditions.Conditions {
	return balancer.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (balancer *LoadBalancer) SetConditions(conditions conditions.Conditions) {
	balancer.Status.Conditions = conditions
}

var _ conversion.Convertible = &LoadBalancer{}

// ConvertFrom populates our LoadBalancer from the provided hub LoadBalancer
func (balancer *LoadBalancer) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20201101s.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected network/v1beta20201101storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignProperties_From_LoadBalancer(source)
}

// ConvertTo populates the provided hub LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20201101s.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected network/v1beta20201101storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignProperties_To_LoadBalancer(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1beta20201101-loadbalancer,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1beta20201101,name=default.v1beta20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &LoadBalancer{}

// Default applies defaults to the LoadBalancer resource
func (balancer *LoadBalancer) Default() {
	balancer.defaultImpl()
	var temp interface{} = balancer
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (balancer *LoadBalancer) defaultAzureName() {
	if balancer.Spec.AzureName == "" {
		balancer.Spec.AzureName = balancer.Name
	}
}

// defaultImpl applies the code generated defaults to the LoadBalancer resource
func (balancer *LoadBalancer) defaultImpl() { balancer.defaultAzureName() }

var _ genruntime.KubernetesResource = &LoadBalancer{}

// AzureName returns the Azure name of the resource
func (balancer *LoadBalancer) AzureName() string {
	return balancer.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (balancer LoadBalancer) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (balancer *LoadBalancer) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (balancer *LoadBalancer) GetSpec() genruntime.ConvertibleSpec {
	return &balancer.Spec
}

// GetStatus returns the status of this resource
func (balancer *LoadBalancer) GetStatus() genruntime.ConvertibleStatus {
	return &balancer.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/loadBalancers"
func (balancer *LoadBalancer) GetType() string {
	return "Microsoft.Network/loadBalancers"
}

// NewEmptyStatus returns a new empty (blank) status
func (balancer *LoadBalancer) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &LoadBalancer_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (balancer *LoadBalancer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(balancer.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  balancer.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (balancer *LoadBalancer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*LoadBalancer_STATUS); ok {
		balancer.Status = *st
		return nil
	}

	// Convert status to required version
	var st LoadBalancer_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	balancer.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1beta20201101-loadbalancer,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1beta20201101,name=validate.v1beta20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &LoadBalancer{}

// ValidateCreate validates the creation of the resource
func (balancer *LoadBalancer) ValidateCreate() error {
	validations := balancer.createValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (balancer *LoadBalancer) ValidateDelete() error {
	validations := balancer.deleteValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (balancer *LoadBalancer) ValidateUpdate(old runtime.Object) error {
	validations := balancer.updateValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (balancer *LoadBalancer) createValidations() []func() error {
	return []func() error{balancer.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (balancer *LoadBalancer) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (balancer *LoadBalancer) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return balancer.validateResourceReferences()
		},
		balancer.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (balancer *LoadBalancer) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&balancer.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (balancer *LoadBalancer) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*LoadBalancer)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, balancer)
}

// AssignProperties_From_LoadBalancer populates our LoadBalancer from the provided source LoadBalancer
func (balancer *LoadBalancer) AssignProperties_From_LoadBalancer(source *v20201101s.LoadBalancer) error {

	// ObjectMeta
	balancer.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec LoadBalancer_Spec
	err := spec.AssignProperties_From_LoadBalancer_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_LoadBalancer_Spec() to populate field Spec")
	}
	balancer.Spec = spec

	// Status
	var status LoadBalancer_STATUS
	err = status.AssignProperties_From_LoadBalancer_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_LoadBalancer_STATUS() to populate field Status")
	}
	balancer.Status = status

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer populates the provided destination LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) AssignProperties_To_LoadBalancer(destination *v20201101s.LoadBalancer) error {

	// ObjectMeta
	destination.ObjectMeta = *balancer.ObjectMeta.DeepCopy()

	// Spec
	var spec v20201101s.LoadBalancer_Spec
	err := balancer.Spec.AssignProperties_To_LoadBalancer_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_LoadBalancer_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20201101s.LoadBalancer_STATUS
	err = balancer.Status.AssignProperties_To_LoadBalancer_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_LoadBalancer_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (balancer *LoadBalancer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: balancer.Spec.OriginalVersion(),
		Kind:    "LoadBalancer",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// +kubebuilder:validation:Enum={"2020-11-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-11-01")

type LoadBalancer_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []BackendAddressPool `json:"backendAddressPools,omitempty"`

	// ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// FrontendIPConfigurations: Object representing the frontend IPs to be used for the load balancer.
	FrontendIPConfigurations []FrontendIPConfiguration `json:"frontendIPConfigurations,omitempty"`

	// InboundNatPools: Defines an external port range for inbound NAT to a single backend port on NICs associated with a load
	// balancer. Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external
	// port from this range. Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound Nat
	// rules. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual
	// virtual machines cannot reference an inbound NAT pool. They have to reference individual inbound NAT rules.
	InboundNatPools []InboundNatPool `json:"inboundNatPools,omitempty"`

	// InboundNatRules: Collection of inbound NAT Rules used by a load balancer. Defining inbound NAT rules on your load
	// balancer is mutually exclusive with defining an inbound NAT pool. Inbound NAT pools are referenced from virtual machine
	// scale sets. NICs that are associated with individual virtual machines cannot reference an Inbound NAT pool. They have to
	// reference individual inbound NAT rules.
	InboundNatRules []InboundNatRule `json:"inboundNatRules,omitempty"`

	// LoadBalancingRules: Object collection representing the load balancing rules Gets the provisioning.
	LoadBalancingRules []LoadBalancingRule `json:"loadBalancingRules,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OutboundRules: The outbound rules.
	OutboundRules []OutboundRule `json:"outboundRules,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Probes: Collection of probe objects used in the load balancer.
	Probes []Probe `json:"probes,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// Sku: The load balancer SKU.
	Sku *LoadBalancerSku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancer_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancer *LoadBalancer_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancer == nil {
		return nil, nil
	}
	result := &LoadBalancer_Spec_ARM{}

	// Set property ‘AzureName’:
	result.AzureName = balancer.AzureName

	// Set property ‘ExtendedLocation’:
	if balancer.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*balancer.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*ExtendedLocation_ARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if balancer.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*balancer.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if balancer.Location != nil {
		location := *balancer.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if balancer.BackendAddressPools != nil ||
		balancer.FrontendIPConfigurations != nil ||
		balancer.InboundNatPools != nil ||
		balancer.InboundNatRules != nil ||
		balancer.LoadBalancingRules != nil ||
		balancer.OutboundRules != nil ||
		balancer.Probes != nil {
		result.Properties = &LoadBalancerPropertiesFormat_ARM{}
	}
	for _, item := range balancer.BackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddressPools = append(result.Properties.BackendAddressPools, *item_ARM.(*BackendAddressPool_ARM))
	}
	for _, item := range balancer.FrontendIPConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, *item_ARM.(*FrontendIPConfiguration_ARM))
	}
	for _, item := range balancer.InboundNatPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatPools = append(result.Properties.InboundNatPools, *item_ARM.(*InboundNatPool_ARM))
	}
	for _, item := range balancer.InboundNatRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatRules = append(result.Properties.InboundNatRules, *item_ARM.(*InboundNatRule_ARM))
	}
	for _, item := range balancer.LoadBalancingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancingRules = append(result.Properties.LoadBalancingRules, *item_ARM.(*LoadBalancingRule_ARM))
	}
	for _, item := range balancer.OutboundRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.OutboundRules = append(result.Properties.OutboundRules, *item_ARM.(*OutboundRule_ARM))
	}
	for _, item := range balancer.Probes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Probes = append(result.Properties.Probes, *item_ARM.(*Probe_ARM))
	}

	// Set property ‘Sku’:
	if balancer.Sku != nil {
		sku_ARM, err := (*balancer.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*LoadBalancerSku_ARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if balancer.Tags != nil {
		result.Tags = make(map[string]string, len(balancer.Tags))
		for key, value := range balancer.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *LoadBalancer_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancer_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *LoadBalancer_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancer_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancer_Spec_ARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	balancer.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.BackendAddressPools = append(balancer.BackendAddressPools, item1)
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		balancer.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.FrontendIPConfigurations = append(balancer.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatPools = append(balancer.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatRules = append(balancer.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.LoadBalancingRules = append(balancer.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		balancer.Location = &location
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.OutboundRules = append(balancer.OutboundRules, item1)
		}
	}

	// Set property ‘Owner’:
	balancer.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.Probes = append(balancer.Probes, item1)
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		balancer.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		balancer.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			balancer.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &LoadBalancer_Spec{}

// ConvertSpecFrom populates our LoadBalancer_Spec from the provided source
func (balancer *LoadBalancer_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20201101s.LoadBalancer_Spec)
	if ok {
		// Populate our instance from source
		return balancer.AssignProperties_From_LoadBalancer_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.LoadBalancer_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = balancer.AssignProperties_From_LoadBalancer_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20201101s.LoadBalancer_Spec)
	if ok {
		// Populate destination from our instance
		return balancer.AssignProperties_To_LoadBalancer_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.LoadBalancer_Spec{}
	err := balancer.AssignProperties_To_LoadBalancer_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_LoadBalancer_Spec populates our LoadBalancer_Spec from the provided source LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) AssignProperties_From_LoadBalancer_Spec(source *v20201101s.LoadBalancer_Spec) error {

	// AzureName
	balancer.AzureName = source.AzureName

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool
			err := backendAddressPool.AssignProperties_From_BackendAddressPool(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration
			err := frontendIPConfiguration.AssignProperties_From_FrontendIPConfiguration(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendIPConfiguration() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool
			err := inboundNatPool.AssignProperties_From_InboundNatPool(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatPool() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule
			err := inboundNatRule.AssignProperties_From_InboundNatRule(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule
			err := loadBalancingRule.AssignProperties_From_LoadBalancingRule(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingRule() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule
			err := outboundRule.AssignProperties_From_OutboundRule(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		balancer.Owner = &owner
	} else {
		balancer.Owner = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe
			err := probe.AssignProperties_From_Probe(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Probe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		balancer.Reference = &reference
	} else {
		balancer.Reference = nil
	}

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku
		err := sku.AssignProperties_From_LoadBalancerSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerSku() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer_Spec populates the provided destination LoadBalancer_Spec from our LoadBalancer_Spec
func (balancer *LoadBalancer_Spec) AssignProperties_To_LoadBalancer_Spec(destination *v20201101s.LoadBalancer_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = balancer.AzureName

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]v20201101s.BackendAddressPool, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v20201101s.BackendAddressPool
			err := backendAddressPoolItem.AssignProperties_To_BackendAddressPool(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation
		err := balancer.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20201101s.FrontendIPConfiguration, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20201101s.FrontendIPConfiguration
			err := frontendIPConfigurationItem.AssignProperties_To_FrontendIPConfiguration(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendIPConfiguration() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]v20201101s.InboundNatPool, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v20201101s.InboundNatPool
			err := inboundNatPoolItem.AssignProperties_To_InboundNatPool(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatPool() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]v20201101s.InboundNatRule, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v20201101s.InboundNatRule
			err := inboundNatRuleItem.AssignProperties_To_InboundNatRule(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20201101s.LoadBalancingRule, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20201101s.LoadBalancingRule
			err := loadBalancingRuleItem.AssignProperties_To_LoadBalancingRule(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingRule() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// OriginalVersion
	destination.OriginalVersion = balancer.OriginalVersion()

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]v20201101s.OutboundRule, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20201101s.OutboundRule
			err := outboundRuleItem.AssignProperties_To_OutboundRule(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Owner
	if balancer.Owner != nil {
		owner := balancer.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]v20201101s.Probe, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v20201101s.Probe
			err := probeItem.AssignProperties_To_Probe(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Probe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Reference
	if balancer.Reference != nil {
		reference := balancer.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Sku
	if balancer.Sku != nil {
		var sku v20201101s.LoadBalancerSku
		err := balancer.Sku.AssignProperties_To_LoadBalancerSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (balancer *LoadBalancer_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (balancer *LoadBalancer_Spec) SetAzureName(azureName string) { balancer.AzureName = azureName }

type LoadBalancer_STATUS struct {
	// BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []BackendAddressPool_STATUS `json:"backendAddressPools,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// FrontendIPConfigurations: Object representing the frontend IPs to be used for the load balancer.
	FrontendIPConfigurations []FrontendIPConfiguration_STATUS `json:"frontendIPConfigurations,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// InboundNatPools: Defines an external port range for inbound NAT to a single backend port on NICs associated with a load
	// balancer. Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external
	// port from this range. Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound Nat
	// rules. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual
	// virtual machines cannot reference an inbound NAT pool. They have to reference individual inbound NAT rules.
	InboundNatPools []InboundNatPool_STATUS `json:"inboundNatPools,omitempty"`

	// InboundNatRules: Collection of inbound NAT Rules used by a load balancer. Defining inbound NAT rules on your load
	// balancer is mutually exclusive with defining an inbound NAT pool. Inbound NAT pools are referenced from virtual machine
	// scale sets. NICs that are associated with individual virtual machines cannot reference an Inbound NAT pool. They have to
	// reference individual inbound NAT rules.
	InboundNatRules []InboundNatRule_STATUS `json:"inboundNatRules,omitempty"`

	// LoadBalancingRules: Object collection representing the load balancing rules Gets the provisioning.
	LoadBalancingRules []LoadBalancingRule_STATUS `json:"loadBalancingRules,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// OutboundRules: The outbound rules.
	OutboundRules []OutboundRule_STATUS `json:"outboundRules,omitempty"`

	// Probes: Collection of probe objects used in the load balancer.
	Probes []Probe_STATUS `json:"probes,omitempty"`

	// ProvisioningState: The provisioning state of the load balancer resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceGuid: The resource GUID property of the load balancer resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	// Sku: The load balancer SKU.
	Sku *LoadBalancerSku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &LoadBalancer_STATUS{}

// ConvertStatusFrom populates our LoadBalancer_STATUS from the provided source
func (balancer *LoadBalancer_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20201101s.LoadBalancer_STATUS)
	if ok {
		// Populate our instance from source
		return balancer.AssignProperties_From_LoadBalancer_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.LoadBalancer_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = balancer.AssignProperties_From_LoadBalancer_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20201101s.LoadBalancer_STATUS)
	if ok {
		// Populate destination from our instance
		return balancer.AssignProperties_To_LoadBalancer_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.LoadBalancer_STATUS{}
	err := balancer.AssignProperties_To_LoadBalancer_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &LoadBalancer_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *LoadBalancer_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancer_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *LoadBalancer_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancer_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancer_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.BackendAddressPools = append(balancer.BackendAddressPools, item1)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		balancer.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		balancer.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.FrontendIPConfigurations = append(balancer.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		balancer.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatPools = append(balancer.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatRules = append(balancer.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.LoadBalancingRules = append(balancer.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		balancer.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancer.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.OutboundRules = append(balancer.OutboundRules, item1)
		}
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.Probes = append(balancer.Probes, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			balancer.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			balancer.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		balancer.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		balancer.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			balancer.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		balancer.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancer_STATUS populates our LoadBalancer_STATUS from the provided source LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) AssignProperties_From_LoadBalancer_STATUS(source *v20201101s.LoadBalancer_STATUS) error {

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_STATUS, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_STATUS
			err := backendAddressPool.AssignProperties_From_BackendAddressPool_STATUS(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendAddressPool_STATUS() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// Conditions
	balancer.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	balancer.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_STATUS, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_STATUS
			err := frontendIPConfiguration.AssignProperties_From_FrontendIPConfiguration_STATUS(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendIPConfiguration_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// Id
	balancer.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool_STATUS, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool_STATUS
			err := inboundNatPool.AssignProperties_From_InboundNatPool_STATUS(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatPool_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_STATUS, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_STATUS
			err := inboundNatRule.AssignProperties_From_InboundNatRule_STATUS(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InboundNatRule_STATUS() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule_STATUS
			err := loadBalancingRule.AssignProperties_From_LoadBalancingRule_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingRule_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	balancer.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule_STATUS
			err := outboundRule.AssignProperties_From_OutboundRule_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe_STATUS, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe_STATUS
			err := probe.AssignProperties_From_Probe_STATUS(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Probe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		balancer.ProvisioningState = &provisioningState
	} else {
		balancer.ProvisioningState = nil
	}

	// ResourceGuid
	balancer.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_STATUS
		err := sku.AssignProperties_From_LoadBalancerSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerSku_STATUS() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	balancer.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_LoadBalancer_STATUS populates the provided destination LoadBalancer_STATUS from our LoadBalancer_STATUS
func (balancer *LoadBalancer_STATUS) AssignProperties_To_LoadBalancer_STATUS(destination *v20201101s.LoadBalancer_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]v20201101s.BackendAddressPool_STATUS, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v20201101s.BackendAddressPool_STATUS
			err := backendAddressPoolItem.AssignProperties_To_BackendAddressPool_STATUS(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendAddressPool_STATUS() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(balancer.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(balancer.Etag)

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := balancer.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20201101s.FrontendIPConfiguration_STATUS, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20201101s.FrontendIPConfiguration_STATUS
			err := frontendIPConfigurationItem.AssignProperties_To_FrontendIPConfiguration_STATUS(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendIPConfiguration_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(balancer.Id)

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]v20201101s.InboundNatPool_STATUS, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v20201101s.InboundNatPool_STATUS
			err := inboundNatPoolItem.AssignProperties_To_InboundNatPool_STATUS(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatPool_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]v20201101s.InboundNatRule_STATUS, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v20201101s.InboundNatRule_STATUS
			err := inboundNatRuleItem.AssignProperties_To_InboundNatRule_STATUS(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InboundNatRule_STATUS() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20201101s.LoadBalancingRule_STATUS, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20201101s.LoadBalancingRule_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_LoadBalancingRule_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingRule_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancer.Name)

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]v20201101s.OutboundRule_STATUS, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20201101s.OutboundRule_STATUS
			err := outboundRuleItem.AssignProperties_To_OutboundRule_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]v20201101s.Probe_STATUS, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v20201101s.Probe_STATUS
			err := probeItem.AssignProperties_To_Probe_STATUS(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Probe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// ProvisioningState
	if balancer.ProvisioningState != nil {
		provisioningState := string(*balancer.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(balancer.ResourceGuid)

	// Sku
	if balancer.Sku != nil {
		var sku v20201101s.LoadBalancerSku_STATUS
		err := balancer.Sku.AssignProperties_To_LoadBalancerSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(balancer.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackendAddressPool struct {
	// LoadBalancerBackendAddresses: An array of backend addresses.
	LoadBalancerBackendAddresses []LoadBalancerBackendAddress `json:"loadBalancerBackendAddresses,omitempty"`

	// Name: The name of the resource that is unique within the set of backend address pools used by the load balancer. This
	// name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAddressPool{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *BackendAddressPool) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &BackendAddressPool_ARM{}

	// Set property ‘Id’:
	if pool.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*pool.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pool.LoadBalancerBackendAddresses != nil {
		result.Properties = &BackendAddressPoolPropertiesFormat_ARM{}
	}
	for _, item := range pool.LoadBalancerBackendAddresses {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddresses = append(result.Properties.LoadBalancerBackendAddresses, *item_ARM.(*LoadBalancerBackendAddress_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendAddressPool) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendAddressPool) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_ARM, got %T", armInput)
	}

	// Set property ‘LoadBalancerBackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddresses {
			var item1 LoadBalancerBackendAddress
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.LoadBalancerBackendAddresses = append(pool.LoadBalancerBackendAddresses, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_BackendAddressPool populates our BackendAddressPool from the provided source BackendAddressPool
func (pool *BackendAddressPool) AssignProperties_From_BackendAddressPool(source *v20201101s.BackendAddressPool) error {

	// LoadBalancerBackendAddresses
	if source.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]LoadBalancerBackendAddress, len(source.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress LoadBalancerBackendAddress
			err := loadBalancerBackendAddress.AssignProperties_From_LoadBalancerBackendAddress(&loadBalancerBackendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerBackendAddress() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		pool.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		pool.LoadBalancerBackendAddresses = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		pool.Reference = &reference
	} else {
		pool.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool populates the provided destination BackendAddressPool from our BackendAddressPool
func (pool *BackendAddressPool) AssignProperties_To_BackendAddressPool(destination *v20201101s.BackendAddressPool) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LoadBalancerBackendAddresses
	if pool.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]v20201101s.LoadBalancerBackendAddress, len(pool.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range pool.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress v20201101s.LoadBalancerBackendAddress
			err := loadBalancerBackendAddressItem.AssignProperties_To_LoadBalancerBackendAddress(&loadBalancerBackendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerBackendAddress() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		destination.LoadBalancerBackendAddresses = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Reference
	if pool.Reference != nil {
		reference := pool.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackendAddressPool_STATUS struct {
	// BackendIPConfigurations: An array of references to IP addresses defined in network interfaces.
	BackendIPConfigurations []NetworkInterfaceIPConfiguration_STATUS `json:"backendIPConfigurations,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// LoadBalancerBackendAddresses: An array of backend addresses.
	LoadBalancerBackendAddresses []LoadBalancerBackendAddress_STATUS `json:"loadBalancerBackendAddresses,omitempty"`

	// LoadBalancingRules: An array of references to load balancing rules that use this backend address pool.
	LoadBalancingRules []SubResource_STATUS `json:"loadBalancingRules,omitempty"`

	// Name: The name of the resource that is unique within the set of backend address pools used by the load balancer. This
	// name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// OutboundRule: A reference to an outbound rule that uses this backend address pool.
	OutboundRule *SubResource_STATUS `json:"outboundRule,omitempty"`

	// OutboundRules: An array of references to outbound rules that use this backend address pool.
	OutboundRules []SubResource_STATUS `json:"outboundRules,omitempty"`

	// ProvisioningState: The provisioning state of the backend address pool resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendAddressPool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendAddressPool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘BackendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendIPConfigurations {
			var item1 NetworkInterfaceIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.BackendIPConfigurations = append(pool.BackendIPConfigurations, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		pool.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddresses {
			var item1 LoadBalancerBackendAddress_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.LoadBalancerBackendAddresses = append(pool.LoadBalancerBackendAddresses, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.LoadBalancingRules = append(pool.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘OutboundRule’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OutboundRule != nil {
			var outboundRule1 SubResource_STATUS
			err := outboundRule1.PopulateFromARM(owner, *typedInput.Properties.OutboundRule)
			if err != nil {
				return err
			}
			outboundRule := outboundRule1
			pool.OutboundRule = &outboundRule
		}
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.OutboundRules = append(pool.OutboundRules, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			pool.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		pool.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAddressPool_STATUS populates our BackendAddressPool_STATUS from the provided source BackendAddressPool_STATUS
func (pool *BackendAddressPool_STATUS) AssignProperties_From_BackendAddressPool_STATUS(source *v20201101s.BackendAddressPool_STATUS) error {

	// BackendIPConfigurations
	if source.BackendIPConfigurations != nil {
		backendIPConfigurationList := make([]NetworkInterfaceIPConfiguration_STATUS, len(source.BackendIPConfigurations))
		for backendIPConfigurationIndex, backendIPConfigurationItem := range source.BackendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			backendIPConfigurationItem := backendIPConfigurationItem
			var backendIPConfiguration NetworkInterfaceIPConfiguration_STATUS
			err := backendIPConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS(&backendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS() to populate field BackendIPConfigurations")
			}
			backendIPConfigurationList[backendIPConfigurationIndex] = backendIPConfiguration
		}
		pool.BackendIPConfigurations = backendIPConfigurationList
	} else {
		pool.BackendIPConfigurations = nil
	}

	// Etag
	pool.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddresses
	if source.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]LoadBalancerBackendAddress_STATUS, len(source.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress LoadBalancerBackendAddress_STATUS
			err := loadBalancerBackendAddress.AssignProperties_From_LoadBalancerBackendAddress_STATUS(&loadBalancerBackendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancerBackendAddress_STATUS() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		pool.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		pool.LoadBalancerBackendAddresses = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_STATUS
			err := loadBalancingRule.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		pool.LoadBalancingRules = loadBalancingRuleList
	} else {
		pool.LoadBalancingRules = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRule
	if source.OutboundRule != nil {
		var outboundRule SubResource_STATUS
		err := outboundRule.AssignProperties_From_SubResource_STATUS(source.OutboundRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRule")
		}
		pool.OutboundRule = &outboundRule
	} else {
		pool.OutboundRule = nil
	}

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule SubResource_STATUS
			err := outboundRule.AssignProperties_From_SubResource_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		pool.OutboundRules = outboundRuleList
	} else {
		pool.OutboundRules = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		pool.ProvisioningState = &provisioningState
	} else {
		pool.ProvisioningState = nil
	}

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackendAddressPool_STATUS populates the provided destination BackendAddressPool_STATUS from our BackendAddressPool_STATUS
func (pool *BackendAddressPool_STATUS) AssignProperties_To_BackendAddressPool_STATUS(destination *v20201101s.BackendAddressPool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendIPConfigurations
	if pool.BackendIPConfigurations != nil {
		backendIPConfigurationList := make([]v20201101s.NetworkInterfaceIPConfiguration_STATUS, len(pool.BackendIPConfigurations))
		for backendIPConfigurationIndex, backendIPConfigurationItem := range pool.BackendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			backendIPConfigurationItem := backendIPConfigurationItem
			var backendIPConfiguration v20201101s.NetworkInterfaceIPConfiguration_STATUS
			err := backendIPConfigurationItem.AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS(&backendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS() to populate field BackendIPConfigurations")
			}
			backendIPConfigurationList[backendIPConfigurationIndex] = backendIPConfiguration
		}
		destination.BackendIPConfigurations = backendIPConfigurationList
	} else {
		destination.BackendIPConfigurations = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(pool.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// LoadBalancerBackendAddresses
	if pool.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]v20201101s.LoadBalancerBackendAddress_STATUS, len(pool.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range pool.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress v20201101s.LoadBalancerBackendAddress_STATUS
			err := loadBalancerBackendAddressItem.AssignProperties_To_LoadBalancerBackendAddress_STATUS(&loadBalancerBackendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancerBackendAddress_STATUS() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		destination.LoadBalancerBackendAddresses = nil
	}

	// LoadBalancingRules
	if pool.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20201101s.SubResource_STATUS, len(pool.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range pool.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20201101s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// OutboundRule
	if pool.OutboundRule != nil {
		var outboundRule v20201101s.SubResource_STATUS
		err := pool.OutboundRule.AssignProperties_To_SubResource_STATUS(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRule")
		}
		destination.OutboundRule = &outboundRule
	} else {
		destination.OutboundRule = nil
	}

	// OutboundRules
	if pool.OutboundRules != nil {
		outboundRuleList := make([]v20201101s.SubResource_STATUS, len(pool.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range pool.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20201101s.SubResource_STATUS
			err := outboundRuleItem.AssignProperties_To_SubResource_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// ProvisioningState
	if pool.ProvisioningState != nil {
		provisioningState := string(*pool.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation struct {
	// +kubebuilder:validation:Required
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	result := &ExtendedLocation_ARM{}

	// Set property ‘Name’:
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if location.Type != nil {
		typeVar := *location.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *v20201101s.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *v20201101s.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_STATUS struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *v20201101s.ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_STATUS(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *v20201101s.ExtendedLocation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FrontendIPConfiguration struct {
	// Name: The name of the resource that is unique within the set of frontend IP configurations used by the load balancer.
	// This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion `json:"privateIPAddressVersion,omitempty"`

	// PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`

	// PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddressSpec `json:"publicIPAddress,omitempty"`

	// PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// Subnet: The reference to the subnet resource.
	Subnet *Subnet `json:"subnet,omitempty"`

	// Zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontendIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FrontendIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &FrontendIPConfiguration_ARM{}

	// Set property ‘Id’:
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configuration.PrivateIPAddress != nil ||
		configuration.PrivateIPAddressVersion != nil ||
		configuration.PrivateIPAllocationMethod != nil ||
		configuration.PublicIPAddress != nil ||
		configuration.PublicIPPrefix != nil ||
		configuration.Subnet != nil {
		result.Properties = &FrontendIPConfigurationPropertiesFormat_ARM{}
	}
	if configuration.PrivateIPAddress != nil {
		privateIPAddress := *configuration.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *configuration.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configuration.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *configuration.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if configuration.PublicIPAddress != nil {
		publicIPAddress_ARM, err := (*configuration.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := *publicIPAddress_ARM.(*PublicIPAddressSpec_ARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if configuration.PublicIPPrefix != nil {
		publicIPPrefix_ARM, err := (*configuration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := *publicIPPrefix_ARM.(*SubResource_ARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if configuration.Subnet != nil {
		subnet_ARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*Subnet_ARM)
		result.Properties.Subnet = &subnet
	}

	// Set property ‘Zones’:
	for _, item := range configuration.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FrontendIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FrontendIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			configuration.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			configuration.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddressSpec
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			configuration.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		configuration.Zones = append(configuration.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendIPConfiguration populates our FrontendIPConfiguration from the provided source FrontendIPConfiguration
func (configuration *FrontendIPConfiguration) AssignProperties_From_FrontendIPConfiguration(source *v20201101s.FrontendIPConfiguration) error {

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	configuration.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion(*source.PrivateIPAddressVersion)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod(*source.PrivateIPAllocationMethod)
		configuration.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		configuration.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec
		err := publicIPAddress.AssignProperties_From_PublicIPAddressSpec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSpec() to populate field PublicIPAddress")
		}
		configuration.PublicIPAddress = &publicIPAddress
	} else {
		configuration.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet
		err := subnet.AssignProperties_From_Subnet(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Zones
	configuration.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_FrontendIPConfiguration populates the provided destination FrontendIPConfiguration from our FrontendIPConfiguration
func (configuration *FrontendIPConfiguration) AssignProperties_To_FrontendIPConfiguration(destination *v20201101s.FrontendIPConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(configuration.PrivateIPAddress)

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if configuration.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*configuration.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if configuration.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddressSpec
		err := configuration.PublicIPAddress.AssignProperties_To_PublicIPAddressSpec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSpec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix v20201101s.SubResource
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v20201101s.Subnet
		err := configuration.Subnet.AssignProperties_To_Subnet(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(configuration.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FrontendIPConfiguration_STATUS struct {
	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// InboundNatPools: An array of references to inbound pools that use this frontend IP.
	InboundNatPools []SubResource_STATUS `json:"inboundNatPools,omitempty"`

	// InboundNatRules: An array of references to inbound rules that use this frontend IP.
	InboundNatRules []SubResource_STATUS `json:"inboundNatRules,omitempty"`

	// LoadBalancingRules: An array of references to load balancing rules that use this frontend IP.
	LoadBalancingRules []SubResource_STATUS `json:"loadBalancingRules,omitempty"`

	// Name: The name of the resource that is unique within the set of frontend IP configurations used by the load balancer.
	// This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// OutboundRules: An array of references to outbound rules that use this frontend IP.
	OutboundRules []SubResource_STATUS `json:"outboundRules,omitempty"`

	// PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_STATUS `json:"privateIPAddressVersion,omitempty"`

	// PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_STATUS `json:"privateIPAllocationMethod,omitempty"`

	// ProvisioningState: The provisioning state of the frontend IP configuration resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_STATUS `json:"publicIPAddress,omitempty"`

	// PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_STATUS `json:"publicIPPrefix,omitempty"`

	// Subnet: The reference to the subnet resource.
	Subnet *Subnet_STATUS `json:"subnet,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`

	// Zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FrontendIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FrontendIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		configuration.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.InboundNatPools = append(configuration.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.InboundNatRules = append(configuration.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancingRules = append(configuration.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.OutboundRules = append(configuration.OutboundRules, item1)
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			configuration.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			configuration.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			configuration.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_STATUS
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			configuration.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_STATUS
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		configuration.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		configuration.Zones = append(configuration.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendIPConfiguration_STATUS populates our FrontendIPConfiguration_STATUS from the provided source FrontendIPConfiguration_STATUS
func (configuration *FrontendIPConfiguration_STATUS) AssignProperties_From_FrontendIPConfiguration_STATUS(source *v20201101s.FrontendIPConfiguration_STATUS) error {

	// Etag
	configuration.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]SubResource_STATUS, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool SubResource_STATUS
			err := inboundNatPool.AssignProperties_From_SubResource_STATUS(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		configuration.InboundNatPools = inboundNatPoolList
	} else {
		configuration.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]SubResource_STATUS, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule SubResource_STATUS
			err := inboundNatRule.AssignProperties_From_SubResource_STATUS(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		configuration.InboundNatRules = inboundNatRuleList
	} else {
		configuration.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_STATUS
			err := loadBalancingRule.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		configuration.LoadBalancingRules = loadBalancingRuleList
	} else {
		configuration.LoadBalancingRules = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_STATUS, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule SubResource_STATUS
			err := outboundRule.AssignProperties_From_SubResource_STATUS(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		configuration.OutboundRules = outboundRuleList
	} else {
		configuration.OutboundRules = nil
	}

	// PrivateIPAddress
	configuration.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_STATUS(*source.PrivateIPAddressVersion)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_STATUS(*source.PrivateIPAllocationMethod)
		configuration.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		configuration.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		configuration.ProvisioningState = &provisioningState
	} else {
		configuration.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_STATUS
		err := publicIPAddress.AssignProperties_From_PublicIPAddress_STATUS(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddress_STATUS() to populate field PublicIPAddress")
		}
		configuration.PublicIPAddress = &publicIPAddress
	} else {
		configuration.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_STATUS
		err := subnet.AssignProperties_From_Subnet_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Subnet_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Type
	configuration.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	configuration.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_FrontendIPConfiguration_STATUS populates the provided destination FrontendIPConfiguration_STATUS from our FrontendIPConfiguration_STATUS
func (configuration *FrontendIPConfiguration_STATUS) AssignProperties_To_FrontendIPConfiguration_STATUS(destination *v20201101s.FrontendIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(configuration.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// InboundNatPools
	if configuration.InboundNatPools != nil {
		inboundNatPoolList := make([]v20201101s.SubResource_STATUS, len(configuration.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range configuration.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v20201101s.SubResource_STATUS
			err := inboundNatPoolItem.AssignProperties_To_SubResource_STATUS(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if configuration.InboundNatRules != nil {
		inboundNatRuleList := make([]v20201101s.SubResource_STATUS, len(configuration.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range configuration.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v20201101s.SubResource_STATUS
			err := inboundNatRuleItem.AssignProperties_To_SubResource_STATUS(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if configuration.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20201101s.SubResource_STATUS, len(configuration.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range configuration.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20201101s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// OutboundRules
	if configuration.OutboundRules != nil {
		outboundRuleList := make([]v20201101s.SubResource_STATUS, len(configuration.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range configuration.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v20201101s.SubResource_STATUS
			err := outboundRuleItem.AssignProperties_To_SubResource_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(configuration.PrivateIPAddress)

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if configuration.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*configuration.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if configuration.ProvisioningState != nil {
		provisioningState := string(*configuration.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if configuration.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddress_STATUS
		err := configuration.PublicIPAddress.AssignProperties_To_PublicIPAddress_STATUS(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddress_STATUS() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix v20201101s.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v20201101s.Subnet_STATUS
		err := configuration.Subnet.AssignProperties_To_Subnet_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Subnet_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(configuration.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(configuration.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatPool struct {
	// +kubebuilder:validation:Required
	// BackendPort: The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// +kubebuilder:validation:Required
	// FrontendPortRangeEnd: The last port number in the range of external ports that will be used to provide Inbound Nat to
	// NICs associated with a load balancer. Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	// +kubebuilder:validation:Required
	// FrontendPortRangeStart: The first port number in the range of external ports that will be used to provide Inbound Nat to
	// NICs associated with a load balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of inbound NAT pools used by the load balancer. This name
	// can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *TransportProtocol `json:"protocol,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatPool{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *InboundNatPool) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &InboundNatPool_ARM{}

	// Set property ‘Id’:
	if pool.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*pool.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pool.BackendPort != nil ||
		pool.EnableFloatingIP != nil ||
		pool.EnableTcpReset != nil ||
		pool.FrontendIPConfiguration != nil ||
		pool.FrontendPortRangeEnd != nil ||
		pool.FrontendPortRangeStart != nil ||
		pool.IdleTimeoutInMinutes != nil ||
		pool.Protocol != nil {
		result.Properties = &InboundNatPoolPropertiesFormat_ARM{}
	}
	if pool.BackendPort != nil {
		backendPort := *pool.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if pool.FrontendIPConfiguration != nil {
		frontendIPConfiguration_ARM, err := (*pool.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := *frontendIPConfiguration_ARM.(*SubResource_ARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if pool.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *pool.FrontendPortRangeEnd
		result.Properties.FrontendPortRangeEnd = &frontendPortRangeEnd
	}
	if pool.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *pool.FrontendPortRangeStart
		result.Properties.FrontendPortRangeStart = &frontendPortRangeStart
	}
	if pool.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *pool.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if pool.Protocol != nil {
		protocol := *pool.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *InboundNatPool) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *InboundNatPool) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_ARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			pool.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pool.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pool.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pool.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeEnd != nil {
			frontendPortRangeEnd := *typedInput.Properties.FrontendPortRangeEnd
			pool.FrontendPortRangeEnd = &frontendPortRangeEnd
		}
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeStart != nil {
			frontendPortRangeStart := *typedInput.Properties.FrontendPortRangeStart
			pool.FrontendPortRangeStart = &frontendPortRangeStart
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pool.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			pool.Protocol = &protocol
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_InboundNatPool populates our InboundNatPool from the provided source InboundNatPool
func (pool *InboundNatPool) AssignProperties_From_InboundNatPool(source *v20201101s.InboundNatPool) error {

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol(*source.Protocol)
		pool.Protocol = &protocol
	} else {
		pool.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		pool.Reference = &reference
	} else {
		pool.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatPool populates the provided destination InboundNatPool from our InboundNatPool
func (pool *InboundNatPool) AssignProperties_To_InboundNatPool(destination *v20201101s.InboundNatPool) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource
		err := pool.FrontendIPConfiguration.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	if pool.Protocol != nil {
		protocol := string(*pool.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if pool.Reference != nil {
		reference := pool.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatPool_STATUS struct {
	// BackendPort: The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_STATUS `json:"frontendIPConfiguration,omitempty"`

	// FrontendPortRangeEnd: The last port number in the range of external ports that will be used to provide Inbound Nat to
	// NICs associated with a load balancer. Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	// FrontendPortRangeStart: The first port number in the range of external ports that will be used to provide Inbound Nat to
	// NICs associated with a load balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of inbound NAT pools used by the load balancer. This name
	// can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *TransportProtocol_STATUS `json:"protocol,omitempty"`

	// ProvisioningState: The provisioning state of the inbound NAT pool resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatPool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *InboundNatPool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *InboundNatPool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			pool.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pool.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pool.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		pool.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_STATUS
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pool.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeEnd != nil {
			frontendPortRangeEnd := *typedInput.Properties.FrontendPortRangeEnd
			pool.FrontendPortRangeEnd = &frontendPortRangeEnd
		}
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeStart != nil {
			frontendPortRangeStart := *typedInput.Properties.FrontendPortRangeStart
			pool.FrontendPortRangeStart = &frontendPortRangeStart
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pool.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			pool.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			pool.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		pool.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_InboundNatPool_STATUS populates our InboundNatPool_STATUS from the provided source InboundNatPool_STATUS
func (pool *InboundNatPool_STATUS) AssignProperties_From_InboundNatPool_STATUS(source *v20201101s.InboundNatPool_STATUS) error {

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// Etag
	pool.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_STATUS
		err := frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_STATUS(*source.Protocol)
		pool.Protocol = &protocol
	} else {
		pool.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		pool.ProvisioningState = &provisioningState
	} else {
		pool.ProvisioningState = nil
	}

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_InboundNatPool_STATUS populates the provided destination InboundNatPool_STATUS from our InboundNatPool_STATUS
func (pool *InboundNatPool_STATUS) AssignProperties_To_InboundNatPool_STATUS(destination *v20201101s.InboundNatPool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(pool.Etag)

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource_STATUS
		err := pool.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	if pool.Protocol != nil {
		protocol := string(*pool.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if pool.ProvisioningState != nil {
		provisioningState := string(*pool.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule struct {
	// BackendPort: The port used for the internal endpoint. Acceptable values range from 1 to 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// FrontendPort: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer.
	// Acceptable values range from 1 to 65534.
	FrontendPort *int `json:"frontendPort,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of inbound NAT rules used by the load balancer. This name
	// can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Protocol: The reference to the transport protocol used by the load balancing rule.
	Protocol *TransportProtocol `json:"protocol,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *InboundNatRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &InboundNatRule_ARM{}

	// Set property ‘Id’:
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rule.BackendPort != nil ||
		rule.EnableFloatingIP != nil ||
		rule.EnableTcpReset != nil ||
		rule.FrontendIPConfiguration != nil ||
		rule.FrontendPort != nil ||
		rule.IdleTimeoutInMinutes != nil ||
		rule.Protocol != nil {
		result.Properties = &InboundNatRulePropertiesFormat_ARM{}
	}
	if rule.BackendPort != nil {
		backendPort := *rule.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if rule.FrontendIPConfiguration != nil {
		frontendIPConfiguration_ARM, err := (*rule.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := *frontendIPConfiguration_ARM.(*SubResource_ARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if rule.FrontendPort != nil {
		frontendPort := *rule.FrontendPort
		result.Properties.FrontendPort = &frontendPort
	}
	if rule.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rule.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rule.Protocol != nil {
		protocol := *rule.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *InboundNatRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *InboundNatRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_ARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rule.FrontendPort = &frontendPort
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_InboundNatRule populates our InboundNatRule from the provided source InboundNatRule
func (rule *InboundNatRule) AssignProperties_From_InboundNatRule(source *v20201101s.InboundNatRule) error {

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule populates the provided destination InboundNatRule from our InboundNatRule
func (rule *InboundNatRule) AssignProperties_To_InboundNatRule(destination *v20201101s.InboundNatRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule_STATUS struct {
	// BackendIPConfiguration: A reference to a private IP address defined on a network interface of a VM. Traffic sent to the
	// frontend port of each of the frontend IP configurations is forwarded to the backend IP.
	BackendIPConfiguration *NetworkInterfaceIPConfiguration_STATUS `json:"backendIPConfiguration,omitempty"`

	// BackendPort: The port used for the internal endpoint. Acceptable values range from 1 to 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_STATUS `json:"frontendIPConfiguration,omitempty"`

	// FrontendPort: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer.
	// Acceptable values range from 1 to 65534.
	FrontendPort *int `json:"frontendPort,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of inbound NAT rules used by the load balancer. This name
	// can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Protocol: The reference to the transport protocol used by the load balancing rule.
	Protocol *TransportProtocol_STATUS `json:"protocol,omitempty"`

	// ProvisioningState: The provisioning state of the inbound NAT rule resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *InboundNatRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *InboundNatRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘BackendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendIPConfiguration != nil {
			var backendIPConfiguration1 NetworkInterfaceIPConfiguration_STATUS
			err := backendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.BackendIPConfiguration)
			if err != nil {
				return err
			}
			backendIPConfiguration := backendIPConfiguration1
			rule.BackendIPConfiguration = &backendIPConfiguration
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_STATUS
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rule.FrontendPort = &frontendPort
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_InboundNatRule_STATUS populates our InboundNatRule_STATUS from the provided source InboundNatRule_STATUS
func (rule *InboundNatRule_STATUS) AssignProperties_From_InboundNatRule_STATUS(source *v20201101s.InboundNatRule_STATUS) error {

	// BackendIPConfiguration
	if source.BackendIPConfiguration != nil {
		var backendIPConfiguration NetworkInterfaceIPConfiguration_STATUS
		err := backendIPConfiguration.AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS(source.BackendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceIPConfiguration_STATUS() to populate field BackendIPConfiguration")
		}
		rule.BackendIPConfiguration = &backendIPConfiguration
	} else {
		rule.BackendIPConfiguration = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_STATUS
		err := frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_STATUS(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_InboundNatRule_STATUS populates the provided destination InboundNatRule_STATUS from our InboundNatRule_STATUS
func (rule *InboundNatRule_STATUS) AssignProperties_To_InboundNatRule_STATUS(destination *v20201101s.InboundNatRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendIPConfiguration
	if rule.BackendIPConfiguration != nil {
		var backendIPConfiguration v20201101s.NetworkInterfaceIPConfiguration_STATUS
		err := rule.BackendIPConfiguration.AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS(&backendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceIPConfiguration_STATUS() to populate field BackendIPConfiguration")
		}
		destination.BackendIPConfiguration = &backendIPConfiguration
	} else {
		destination.BackendIPConfiguration = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource_STATUS
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancerSku struct {
	// Name: Name of a load balancer SKU.
	Name *LoadBalancerSku_Name `json:"name,omitempty"`

	// Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancerSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancerSku *LoadBalancerSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancerSku == nil {
		return nil, nil
	}
	result := &LoadBalancerSku_ARM{}

	// Set property ‘Name’:
	if balancerSku.Name != nil {
		name := *balancerSku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if balancerSku.Tier != nil {
		tier := *balancerSku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancerSku populates our LoadBalancerSku from the provided source LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignProperties_From_LoadBalancerSku(source *v20201101s.LoadBalancerSku) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSku_Name(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSku_Tier(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerSku populates the provided destination LoadBalancerSku from our LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignProperties_To_LoadBalancerSku(destination *v20201101s.LoadBalancerSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancerSku_STATUS struct {
	// Name: Name of a load balancer SKU.
	Name *LoadBalancerSku_Name_STATUS `json:"name,omitempty"`

	// Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancerSku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancerSku_STATUS populates our LoadBalancerSku_STATUS from the provided source LoadBalancerSku_STATUS
func (balancerSku *LoadBalancerSku_STATUS) AssignProperties_From_LoadBalancerSku_STATUS(source *v20201101s.LoadBalancerSku_STATUS) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSku_Name_STATUS(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSku_Tier_STATUS(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerSku_STATUS populates the provided destination LoadBalancerSku_STATUS from our LoadBalancerSku_STATUS
func (balancerSku *LoadBalancerSku_STATUS) AssignProperties_To_LoadBalancerSku_STATUS(destination *v20201101s.LoadBalancerSku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancingRule struct {
	// BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend
	// IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	// BackendPort: The port used for internal connections on the endpoint. Acceptable values are between 0 and 65535. Note
	// that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	// DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the
	// frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// +kubebuilder:validation:Required
	// FrontendPort: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer.
	// Acceptable values are between 0 and 65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormat_LoadDistribution `json:"loadDistribution,omitempty"`

	// Name: The name of the resource that is unique within the set of load balancing rules used by the load balancer. This
	// name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource `json:"probe,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: The reference to the transport protocol used by the load balancing rule.
	Protocol *TransportProtocol `json:"protocol,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancingRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *LoadBalancingRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &LoadBalancingRule_ARM{}

	// Set property ‘Id’:
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rule.BackendAddressPool != nil ||
		rule.BackendPort != nil ||
		rule.DisableOutboundSnat != nil ||
		rule.EnableFloatingIP != nil ||
		rule.EnableTcpReset != nil ||
		rule.FrontendIPConfiguration != nil ||
		rule.FrontendPort != nil ||
		rule.IdleTimeoutInMinutes != nil ||
		rule.LoadDistribution != nil ||
		rule.Probe != nil ||
		rule.Protocol != nil {
		result.Properties = &LoadBalancingRulePropertiesFormat_ARM{}
	}
	if rule.BackendAddressPool != nil {
		backendAddressPool_ARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := *backendAddressPool_ARM.(*SubResource_ARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rule.BackendPort != nil {
		backendPort := *rule.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		result.Properties.DisableOutboundSnat = &disableOutboundSnat
	}
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if rule.FrontendIPConfiguration != nil {
		frontendIPConfiguration_ARM, err := (*rule.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := *frontendIPConfiguration_ARM.(*SubResource_ARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if rule.FrontendPort != nil {
		frontendPort := *rule.FrontendPort
		result.Properties.FrontendPort = &frontendPort
	}
	if rule.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rule.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rule.LoadDistribution != nil {
		loadDistribution := *rule.LoadDistribution
		result.Properties.LoadDistribution = &loadDistribution
	}
	if rule.Probe != nil {
		probe_ARM, err := (*rule.Probe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		probe := *probe_ARM.(*SubResource_ARM)
		result.Properties.Probe = &probe
	}
	if rule.Protocol != nil {
		protocol := *rule.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *LoadBalancingRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *LoadBalancingRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_ARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rule.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rule.FrontendPort = &frontendPort
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rule.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rule.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_LoadBalancingRule populates our LoadBalancingRule from the provided source LoadBalancingRule
func (rule *LoadBalancingRule) AssignProperties_From_LoadBalancingRule(source *v20201101s.LoadBalancingRule) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignProperties_From_SubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormat_LoadDistribution(*source.LoadDistribution)
		rule.LoadDistribution = &loadDistribution
	} else {
		rule.LoadDistribution = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource
		err := probe.AssignProperties_From_SubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Probe")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingRule populates the provided destination LoadBalancingRule from our LoadBalancingRule
func (rule *LoadBalancingRule) AssignProperties_To_LoadBalancingRule(destination *v20201101s.LoadBalancingRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v20201101s.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	if rule.LoadDistribution != nil {
		loadDistribution := string(*rule.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var probe v20201101s.SubResource
		err := rule.Probe.AssignProperties_To_SubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancingRule_STATUS struct {
	// BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend
	// IPs.
	BackendAddressPool *SubResource_STATUS `json:"backendAddressPool,omitempty"`

	// BackendPort: The port used for internal connections on the endpoint. Acceptable values are between 0 and 65535. Note
	// that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	// DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the
	// frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	// EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL
	// AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server.
	// This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_STATUS `json:"frontendIPConfiguration,omitempty"`

	// FrontendPort: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer.
	// Acceptable values are between 0 and 65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The
	// default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS `json:"loadDistribution,omitempty"`

	// Name: The name of the resource that is unique within the set of load balancing rules used by the load balancer. This
	// name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource_STATUS `json:"probe,omitempty"`

	// Protocol: The reference to the transport protocol used by the load balancing rule.
	Protocol *TransportProtocol_STATUS `json:"protocol,omitempty"`

	// ProvisioningState: The provisioning state of the load balancing rule resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancingRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *LoadBalancingRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *LoadBalancingRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_STATUS
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rule.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_STATUS
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rule.FrontendPort = &frontendPort
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rule.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource_STATUS
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rule.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancingRule_STATUS populates our LoadBalancingRule_STATUS from the provided source LoadBalancingRule_STATUS
func (rule *LoadBalancingRule_STATUS) AssignProperties_From_LoadBalancingRule_STATUS(source *v20201101s.LoadBalancingRule_STATUS) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_STATUS
		err := backendAddressPool.AssignProperties_From_SubResource_STATUS(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_STATUS
		err := frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS(*source.LoadDistribution)
		rule.LoadDistribution = &loadDistribution
	} else {
		rule.LoadDistribution = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource_STATUS
		err := probe.AssignProperties_From_SubResource_STATUS(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Probe")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_STATUS(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingRule_STATUS populates the provided destination LoadBalancingRule_STATUS from our LoadBalancingRule_STATUS
func (rule *LoadBalancingRule_STATUS) AssignProperties_To_LoadBalancingRule_STATUS(destination *v20201101s.LoadBalancingRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v20201101s.SubResource_STATUS
		err := rule.BackendAddressPool.AssignProperties_To_SubResource_STATUS(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v20201101s.SubResource_STATUS
		err := rule.FrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	if rule.LoadDistribution != nil {
		loadDistribution := string(*rule.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var probe v20201101s.SubResource_STATUS
		err := rule.Probe.AssignProperties_To_SubResource_STATUS(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OutboundRule struct {
	// AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// +kubebuilder:validation:Required
	// BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly load balanced across IPs in the backend
	// IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// +kubebuilder:validation:Required
	// FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource `json:"frontendIPConfigurations,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of outbound rules used by the load balancer. This name can
	// be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormat_Protocol `json:"protocol,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &OutboundRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *OutboundRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &OutboundRule_ARM{}

	// Set property ‘Id’:
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rule.AllocatedOutboundPorts != nil ||
		rule.BackendAddressPool != nil ||
		rule.EnableTcpReset != nil ||
		rule.FrontendIPConfigurations != nil ||
		rule.IdleTimeoutInMinutes != nil ||
		rule.Protocol != nil {
		result.Properties = &OutboundRulePropertiesFormat_ARM{}
	}
	if rule.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *rule.AllocatedOutboundPorts
		result.Properties.AllocatedOutboundPorts = &allocatedOutboundPorts
	}
	if rule.BackendAddressPool != nil {
		backendAddressPool_ARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := *backendAddressPool_ARM.(*SubResource_ARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	for _, item := range rule.FrontendIPConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, *item_ARM.(*SubResource_ARM))
	}
	if rule.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rule.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rule.Protocol != nil {
		protocol := *rule.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_ARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rule.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendIPConfigurations = append(rule.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignProperties_From_OutboundRule populates our OutboundRule from the provided source OutboundRule
func (rule *OutboundRule) AssignProperties_From_OutboundRule(source *v20201101s.OutboundRule) error {

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignProperties_From_SubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource
			err := frontendIPConfiguration.AssignProperties_From_SubResource(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormat_Protocol(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OutboundRule populates the provided destination OutboundRule from our OutboundRule
func (rule *OutboundRule) AssignProperties_To_OutboundRule(destination *v20201101s.OutboundRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v20201101s.SubResource
		err := rule.BackendAddressPool.AssignProperties_To_SubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20201101s.SubResource, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20201101s.SubResource
			err := frontendIPConfigurationItem.AssignProperties_To_SubResource(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OutboundRule_STATUS struct {
	// AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly load balanced across IPs in the backend
	// IPs.
	BackendAddressPool *SubResource_STATUS `json:"backendAddressPool,omitempty"`

	// EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This
	// element is only used when the protocol is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource_STATUS `json:"frontendIPConfigurations,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Name: The name of the resource that is unique within the set of outbound rules used by the load balancer. This name can
	// be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormat_Protocol_STATUS `json:"protocol,omitempty"`

	// ProvisioningState: The provisioning state of the outbound rule resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &OutboundRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rule.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_STATUS
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendIPConfigurations = append(rule.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_OutboundRule_STATUS populates our OutboundRule_STATUS from the provided source OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_From_OutboundRule_STATUS(source *v20201101s.OutboundRule_STATUS) error {

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_STATUS
		err := backendAddressPool.AssignProperties_From_SubResource_STATUS(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource_STATUS, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource_STATUS
			err := frontendIPConfiguration.AssignProperties_From_SubResource_STATUS(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormat_Protocol_STATUS(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_OutboundRule_STATUS populates the provided destination OutboundRule_STATUS from our OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_To_OutboundRule_STATUS(destination *v20201101s.OutboundRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v20201101s.SubResource_STATUS
		err := rule.BackendAddressPool.AssignProperties_To_SubResource_STATUS(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v20201101s.SubResource_STATUS, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v20201101s.SubResource_STATUS
			err := frontendIPConfigurationItem.AssignProperties_To_SubResource_STATUS(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Probe struct {
	// IntervalInSeconds: The interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the
	// interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking
	// the instance out of rotation. The default value is 15, the minimum value is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Name: The name of the resource that is unique within the set of probes used by the load balancer. This name can be used
	// to access the resource.
	Name *string `json:"name,omitempty"`

	// NumberOfProbes: The number of probes where if no response, will result in stopping further traffic from being delivered
	// to the endpoint. This values allows endpoints to be taken out of rotation faster or slower than the typical times used
	// in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	// +kubebuilder:validation:Required
	// Port: The port for communicating the probe. Possible values range from 1 to 65535, inclusive.
	Port *int `json:"port,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be
	// successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be
	// successful.
	Protocol *ProbePropertiesFormat_Protocol `json:"protocol,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// RequestPath: The URI used for requesting health status from the VM. Path is required if a protocol is set to http.
	// Otherwise, it is not allowed. There is no default value.
	RequestPath *string `json:"requestPath,omitempty"`
}

var _ genruntime.ARMTransformer = &Probe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *Probe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &Probe_ARM{}

	// Set property ‘Id’:
	if probe.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*probe.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if probe.Name != nil {
		name := *probe.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if probe.IntervalInSeconds != nil ||
		probe.NumberOfProbes != nil ||
		probe.Port != nil ||
		probe.Protocol != nil ||
		probe.RequestPath != nil {
		result.Properties = &ProbePropertiesFormat_ARM{}
	}
	if probe.IntervalInSeconds != nil {
		intervalInSeconds := *probe.IntervalInSeconds
		result.Properties.IntervalInSeconds = &intervalInSeconds
	}
	if probe.NumberOfProbes != nil {
		numberOfProbes := *probe.NumberOfProbes
		result.Properties.NumberOfProbes = &numberOfProbes
	}
	if probe.Port != nil {
		port := *probe.Port
		result.Properties.Port = &port
	}
	if probe.Protocol != nil {
		protocol := *probe.Protocol
		result.Properties.Protocol = &protocol
	}
	if probe.RequestPath != nil {
		requestPath := *probe.RequestPath
		result.Properties.RequestPath = &requestPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *Probe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *Probe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_ARM, got %T", armInput)
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probe.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probe.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			probe.Port = &port
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			probe.Protocol = &protocol
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probe.RequestPath = &requestPath
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Probe populates our Probe from the provided source Probe
func (probe *Probe) AssignProperties_From_Probe(source *v20201101s.Probe) error {

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormat_Protocol(*source.Protocol)
		probe.Protocol = &protocol
	} else {
		probe.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		probe.Reference = &reference
	} else {
		probe.Reference = nil
	}

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// No error
	return nil
}

// AssignProperties_To_Probe populates the provided destination Probe from our Probe
func (probe *Probe) AssignProperties_To_Probe(destination *v20201101s.Probe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if probe.Reference != nil {
		reference := probe.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Probe_STATUS struct {
	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IntervalInSeconds: The interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the
	// interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking
	// the instance out of rotation. The default value is 15, the minimum value is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// LoadBalancingRules: The load balancer rules that use this probe.
	LoadBalancingRules []SubResource_STATUS `json:"loadBalancingRules,omitempty"`

	// Name: The name of the resource that is unique within the set of probes used by the load balancer. This name can be used
	// to access the resource.
	Name *string `json:"name,omitempty"`

	// NumberOfProbes: The number of probes where if no response, will result in stopping further traffic from being delivered
	// to the endpoint. This values allows endpoints to be taken out of rotation faster or slower than the typical times used
	// in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	// Port: The port for communicating the probe. Possible values range from 1 to 65535, inclusive.
	Port *int `json:"port,omitempty"`

	// Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be
	// successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be
	// successful.
	Protocol *ProbePropertiesFormat_Protocol_STATUS `json:"protocol,omitempty"`

	// ProvisioningState: The provisioning state of the probe resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RequestPath: The URI used for requesting health status from the VM. Path is required if a protocol is set to http.
	// Otherwise, it is not allowed. There is no default value.
	RequestPath *string `json:"requestPath,omitempty"`

	// Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Probe_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *Probe_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *Probe_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		probe.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		probe.Id = &id
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probe.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			probe.LoadBalancingRules = append(probe.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probe.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			probe.Port = &port
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			probe.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			probe.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probe.RequestPath = &requestPath
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		probe.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Probe_STATUS populates our Probe_STATUS from the provided source Probe_STATUS
func (probe *Probe_STATUS) AssignProperties_From_Probe_STATUS(source *v20201101s.Probe_STATUS) error {

	// Etag
	probe.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	probe.Id = genruntime.ClonePointerToString(source.Id)

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_STATUS, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_STATUS
			err := loadBalancingRule.AssignProperties_From_SubResource_STATUS(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		probe.LoadBalancingRules = loadBalancingRuleList
	} else {
		probe.LoadBalancingRules = nil
	}

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormat_Protocol_STATUS(*source.Protocol)
		probe.Protocol = &protocol
	} else {
		probe.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		probe.ProvisioningState = &provisioningState
	} else {
		probe.ProvisioningState = nil
	}

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Probe_STATUS populates the provided destination Probe_STATUS from our Probe_STATUS
func (probe *Probe_STATUS) AssignProperties_To_Probe_STATUS(destination *v20201101s.Probe_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(probe.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(probe.Id)

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// LoadBalancingRules
	if probe.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v20201101s.SubResource_STATUS, len(probe.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range probe.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v20201101s.SubResource_STATUS
			err := loadBalancingRuleItem.AssignProperties_To_SubResource_STATUS(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if probe.ProvisioningState != nil {
		provisioningState := string(*probe.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
	ProvisioningState_STATUS_Updating  = ProvisioningState_STATUS("Updating")
)

type LoadBalancerBackendAddress struct {
	// IpAddress: IP Address belonging to the referenced virtual network.
	IpAddress *string `json:"ipAddress,omitempty"`

	// LoadBalancerFrontendIPConfiguration: Reference to the frontend ip address configuration defined in regional loadbalancer.
	LoadBalancerFrontendIPConfiguration *SubResource `json:"loadBalancerFrontendIPConfiguration,omitempty"`

	// Name: Name of the backend address.
	Name *string `json:"name,omitempty"`

	// Subnet: Reference to an existing subnet.
	Subnet *SubResource `json:"subnet,omitempty"`

	// VirtualNetwork: Reference to an existing virtual network.
	VirtualNetwork *SubResource `json:"virtualNetwork,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancerBackendAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *LoadBalancerBackendAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &LoadBalancerBackendAddress_ARM{}

	// Set property ‘Name’:
	if address.Name != nil {
		name := *address.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if address.IpAddress != nil ||
		address.LoadBalancerFrontendIPConfiguration != nil ||
		address.Subnet != nil ||
		address.VirtualNetwork != nil {
		result.Properties = &LoadBalancerBackendAddressPropertiesFormat_ARM{}
	}
	if address.IpAddress != nil {
		ipAddress := *address.IpAddress
		result.Properties.IpAddress = &ipAddress
	}
	if address.LoadBalancerFrontendIPConfiguration != nil {
		loadBalancerFrontendIPConfiguration_ARM, err := (*address.LoadBalancerFrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerFrontendIPConfiguration := *loadBalancerFrontendIPConfiguration_ARM.(*SubResource_ARM)
		result.Properties.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	}
	if address.Subnet != nil {
		subnet_ARM, err := (*address.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*SubResource_ARM)
		result.Properties.Subnet = &subnet
	}
	if address.VirtualNetwork != nil {
		virtualNetwork_ARM, err := (*address.VirtualNetwork).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualNetwork := *virtualNetwork_ARM.(*SubResource_ARM)
		result.Properties.VirtualNetwork = &virtualNetwork
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *LoadBalancerBackendAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerBackendAddress_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *LoadBalancerBackendAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerBackendAddress_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerBackendAddress_ARM, got %T", armInput)
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			address.IpAddress = &ipAddress
		}
	}

	// Set property ‘LoadBalancerFrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadBalancerFrontendIPConfiguration != nil {
			var loadBalancerFrontendIPConfiguration1 SubResource
			err := loadBalancerFrontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.LoadBalancerFrontendIPConfiguration)
			if err != nil {
				return err
			}
			loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfiguration1
			address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		address.Name = &name
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			address.Subnet = &subnet
		}
	}

	// Set property ‘VirtualNetwork’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetwork != nil {
			var virtualNetwork1 SubResource
			err := virtualNetwork1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetwork)
			if err != nil {
				return err
			}
			virtualNetwork := virtualNetwork1
			address.VirtualNetwork = &virtualNetwork
		}
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancerBackendAddress populates our LoadBalancerBackendAddress from the provided source LoadBalancerBackendAddress
func (address *LoadBalancerBackendAddress) AssignProperties_From_LoadBalancerBackendAddress(source *v20201101s.LoadBalancerBackendAddress) error {

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration SubResource
		err := loadBalancerFrontendIPConfiguration.AssignProperties_From_SubResource(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerFrontendIPConfiguration")
		}
		address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		address.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	address.Name = genruntime.ClonePointerToString(source.Name)

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet")
		}
		address.Subnet = &subnet
	} else {
		address.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var virtualNetwork SubResource
		err := virtualNetwork.AssignProperties_From_SubResource(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualNetwork")
		}
		address.VirtualNetwork = &virtualNetwork
	} else {
		address.VirtualNetwork = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerBackendAddress populates the provided destination LoadBalancerBackendAddress from our LoadBalancerBackendAddress
func (address *LoadBalancerBackendAddress) AssignProperties_To_LoadBalancerBackendAddress(destination *v20201101s.LoadBalancerBackendAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if address.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration v20201101s.SubResource
		err := address.LoadBalancerFrontendIPConfiguration.AssignProperties_To_SubResource(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerFrontendIPConfiguration")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(address.Name)

	// Subnet
	if address.Subnet != nil {
		var subnet v20201101s.SubResource
		err := address.Subnet.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if address.VirtualNetwork != nil {
		var virtualNetwork v20201101s.SubResource
		err := address.VirtualNetwork.AssignProperties_To_SubResource(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualNetwork")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancerBackendAddress_STATUS struct {
	// IpAddress: IP Address belonging to the referenced virtual network.
	IpAddress *string `json:"ipAddress,omitempty"`

	// LoadBalancerFrontendIPConfiguration: Reference to the frontend ip address configuration defined in regional loadbalancer.
	LoadBalancerFrontendIPConfiguration *SubResource_STATUS `json:"loadBalancerFrontendIPConfiguration,omitempty"`

	// Name: Name of the backend address.
	Name *string `json:"name,omitempty"`

	// NetworkInterfaceIPConfiguration: Reference to IP address defined in network interfaces.
	NetworkInterfaceIPConfiguration *SubResource_STATUS `json:"networkInterfaceIPConfiguration,omitempty"`

	// Subnet: Reference to an existing subnet.
	Subnet *SubResource_STATUS `json:"subnet,omitempty"`

	// VirtualNetwork: Reference to an existing virtual network.
	VirtualNetwork *SubResource_STATUS `json:"virtualNetwork,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancerBackendAddress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *LoadBalancerBackendAddress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerBackendAddress_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *LoadBalancerBackendAddress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerBackendAddress_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerBackendAddress_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			address.IpAddress = &ipAddress
		}
	}

	// Set property ‘LoadBalancerFrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadBalancerFrontendIPConfiguration != nil {
			var loadBalancerFrontendIPConfiguration1 SubResource_STATUS
			err := loadBalancerFrontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.LoadBalancerFrontendIPConfiguration)
			if err != nil {
				return err
			}
			loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfiguration1
			address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		address.Name = &name
	}

	// Set property ‘NetworkInterfaceIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkInterfaceIPConfiguration != nil {
			var networkInterfaceIPConfiguration1 SubResource_STATUS
			err := networkInterfaceIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.NetworkInterfaceIPConfiguration)
			if err != nil {
				return err
			}
			networkInterfaceIPConfiguration := networkInterfaceIPConfiguration1
			address.NetworkInterfaceIPConfiguration = &networkInterfaceIPConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource_STATUS
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			address.Subnet = &subnet
		}
	}

	// Set property ‘VirtualNetwork’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetwork != nil {
			var virtualNetwork1 SubResource_STATUS
			err := virtualNetwork1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetwork)
			if err != nil {
				return err
			}
			virtualNetwork := virtualNetwork1
			address.VirtualNetwork = &virtualNetwork
		}
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancerBackendAddress_STATUS populates our LoadBalancerBackendAddress_STATUS from the provided source LoadBalancerBackendAddress_STATUS
func (address *LoadBalancerBackendAddress_STATUS) AssignProperties_From_LoadBalancerBackendAddress_STATUS(source *v20201101s.LoadBalancerBackendAddress_STATUS) error {

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration SubResource_STATUS
		err := loadBalancerFrontendIPConfiguration.AssignProperties_From_SubResource_STATUS(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerFrontendIPConfiguration")
		}
		address.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		address.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	address.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkInterfaceIPConfiguration
	if source.NetworkInterfaceIPConfiguration != nil {
		var networkInterfaceIPConfiguration SubResource_STATUS
		err := networkInterfaceIPConfiguration.AssignProperties_From_SubResource_STATUS(source.NetworkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkInterfaceIPConfiguration")
		}
		address.NetworkInterfaceIPConfiguration = &networkInterfaceIPConfiguration
	} else {
		address.NetworkInterfaceIPConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource_STATUS
		err := subnet.AssignProperties_From_SubResource_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Subnet")
		}
		address.Subnet = &subnet
	} else {
		address.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var virtualNetwork SubResource_STATUS
		err := virtualNetwork.AssignProperties_From_SubResource_STATUS(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualNetwork")
		}
		address.VirtualNetwork = &virtualNetwork
	} else {
		address.VirtualNetwork = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LoadBalancerBackendAddress_STATUS populates the provided destination LoadBalancerBackendAddress_STATUS from our LoadBalancerBackendAddress_STATUS
func (address *LoadBalancerBackendAddress_STATUS) AssignProperties_To_LoadBalancerBackendAddress_STATUS(destination *v20201101s.LoadBalancerBackendAddress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if address.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration v20201101s.SubResource_STATUS
		err := address.LoadBalancerFrontendIPConfiguration.AssignProperties_To_SubResource_STATUS(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerFrontendIPConfiguration")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(address.Name)

	// NetworkInterfaceIPConfiguration
	if address.NetworkInterfaceIPConfiguration != nil {
		var networkInterfaceIPConfiguration v20201101s.SubResource_STATUS
		err := address.NetworkInterfaceIPConfiguration.AssignProperties_To_SubResource_STATUS(&networkInterfaceIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkInterfaceIPConfiguration")
		}
		destination.NetworkInterfaceIPConfiguration = &networkInterfaceIPConfiguration
	} else {
		destination.NetworkInterfaceIPConfiguration = nil
	}

	// Subnet
	if address.Subnet != nil {
		var subnet v20201101s.SubResource_STATUS
		err := address.Subnet.AssignProperties_To_SubResource_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if address.VirtualNetwork != nil {
		var virtualNetwork v20201101s.SubResource_STATUS
		err := address.VirtualNetwork.AssignProperties_To_SubResource_STATUS(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualNetwork")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Default","SourceIP","SourceIPProtocol"}
type LoadBalancingRulePropertiesFormat_LoadDistribution string

const (
	LoadBalancingRulePropertiesFormat_LoadDistribution_Default          = LoadBalancingRulePropertiesFormat_LoadDistribution("Default")
	LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP         = LoadBalancingRulePropertiesFormat_LoadDistribution("SourceIP")
	LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol = LoadBalancingRulePropertiesFormat_LoadDistribution("SourceIPProtocol")
)

type LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS string

const (
	LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_Default          = LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS("Default")
	LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_SourceIP         = LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS("SourceIP")
	LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_SourceIPProtocol = LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS("SourceIPProtocol")
)

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type OutboundRulePropertiesFormat_Protocol string

const (
	OutboundRulePropertiesFormat_Protocol_All = OutboundRulePropertiesFormat_Protocol("All")
	OutboundRulePropertiesFormat_Protocol_Tcp = OutboundRulePropertiesFormat_Protocol("Tcp")
	OutboundRulePropertiesFormat_Protocol_Udp = OutboundRulePropertiesFormat_Protocol("Udp")
)

type OutboundRulePropertiesFormat_Protocol_STATUS string

const (
	OutboundRulePropertiesFormat_Protocol_STATUS_All = OutboundRulePropertiesFormat_Protocol_STATUS("All")
	OutboundRulePropertiesFormat_Protocol_STATUS_Tcp = OutboundRulePropertiesFormat_Protocol_STATUS("Tcp")
	OutboundRulePropertiesFormat_Protocol_STATUS_Udp = OutboundRulePropertiesFormat_Protocol_STATUS("Udp")
)

// +kubebuilder:validation:Enum={"Http","Https","Tcp"}
type ProbePropertiesFormat_Protocol string

const (
	ProbePropertiesFormat_Protocol_Http  = ProbePropertiesFormat_Protocol("Http")
	ProbePropertiesFormat_Protocol_Https = ProbePropertiesFormat_Protocol("Https")
	ProbePropertiesFormat_Protocol_Tcp   = ProbePropertiesFormat_Protocol("Tcp")
)

type ProbePropertiesFormat_Protocol_STATUS string

const (
	ProbePropertiesFormat_Protocol_STATUS_Http  = ProbePropertiesFormat_Protocol_STATUS("Http")
	ProbePropertiesFormat_Protocol_STATUS_Https = ProbePropertiesFormat_Protocol_STATUS("Https")
	ProbePropertiesFormat_Protocol_STATUS_Tcp   = ProbePropertiesFormat_Protocol_STATUS("Tcp")
)

type PublicIPAddress_STATUS struct {
	// DdosSettings: The DDoS protection custom policy associated with the public IP address.
	DdosSettings *DdosSettings_STATUS `json:"ddosSettings,omitempty"`

	// DnsSettings: The FQDN of the DNS record associated with the public IP address.
	DnsSettings *PublicIPAddressDnsSettings_STATUS `json:"dnsSettings,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpAddress: The IP address associated with the public IP address resource.
	IpAddress *string `json:"ipAddress,omitempty"`

	// IpConfiguration: The IP configuration associated with the public IP address.
	IpConfiguration *IPConfiguration_STATUS `json:"ipConfiguration,omitempty"`

	// IpTags: The list of tags associated with the public IP address.
	IpTags []IpTag_STATUS `json:"ipTags,omitempty"`

	// LinkedPublicIPAddress: The linked public IP address of the public IP address resource.
	LinkedPublicIPAddress *PublicIPAddress_STATUS `json:"linkedPublicIPAddress,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MigrationPhase: Migration phase of Public IP Address.
	MigrationPhase *PublicIPAddressPropertiesFormat_MigrationPhase_STATUS `json:"migrationPhase,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// NatGateway: The NatGateway for the Public IP address.
	NatGateway *NatGateway_STATUS `json:"natGateway,omitempty"`

	// ProvisioningState: The provisioning state of the public IP address resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicIPAddressVersion: The public IP address version.
	PublicIPAddressVersion *IPVersion_STATUS `json:"publicIPAddressVersion,omitempty"`

	// PublicIPAllocationMethod: The public IP address allocation method.
	PublicIPAllocationMethod *IPAllocationMethod_STATUS `json:"publicIPAllocationMethod,omitempty"`

	// PublicIPPrefix: The Public IP Prefix this Public IP Address should be allocated from.
	PublicIPPrefix *SubResource_STATUS `json:"publicIPPrefix,omitempty"`

	// ResourceGuid: The resource GUID property of the public IP address resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	// ServicePublicIPAddress: The service public IP address of the public IP address resource.
	ServicePublicIPAddress *PublicIPAddress_STATUS `json:"servicePublicIPAddress,omitempty"`

	// Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// Zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *PublicIPAddress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *PublicIPAddress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘DdosSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DdosSettings != nil {
			var ddosSettings1 DdosSettings_STATUS
			err := ddosSettings1.PopulateFromARM(owner, *typedInput.Properties.DdosSettings)
			if err != nil {
				return err
			}
			ddosSettings := ddosSettings1
			address.DdosSettings = &ddosSettings
		}
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 PublicIPAddressDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			address.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		address.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		address.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		address.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			address.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			address.IpAddress = &ipAddress
		}
	}

	// Set property ‘IpConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpConfiguration != nil {
			var ipConfiguration1 IPConfiguration_STATUS
			err := ipConfiguration1.PopulateFromARM(owner, *typedInput.Properties.IpConfiguration)
			if err != nil {
				return err
			}
			ipConfiguration := ipConfiguration1
			address.IpConfiguration = &ipConfiguration
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 IpTag_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			address.IpTags = append(address.IpTags, item1)
		}
	}

	// Set property ‘LinkedPublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinkedPublicIPAddress != nil {
			var linkedPublicIPAddress1 PublicIPAddress_STATUS
			err := linkedPublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.LinkedPublicIPAddress)
			if err != nil {
				return err
			}
			linkedPublicIPAddress := linkedPublicIPAddress1
			address.LinkedPublicIPAddress = &linkedPublicIPAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		address.Location = &location
	}

	// Set property ‘MigrationPhase’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			address.MigrationPhase = &migrationPhase
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		address.Name = &name
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 NatGateway_STATUS
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			address.NatGateway = &natGateway
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			address.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			address.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAllocationMethod != nil {
			publicIPAllocationMethod := *typedInput.Properties.PublicIPAllocationMethod
			address.PublicIPAllocationMethod = &publicIPAllocationMethod
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			address.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			address.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘ServicePublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePublicIPAddress != nil {
			var servicePublicIPAddress1 PublicIPAddress_STATUS
			err := servicePublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.ServicePublicIPAddress)
			if err != nil {
				return err
			}
			servicePublicIPAddress := servicePublicIPAddress1
			address.ServicePublicIPAddress = &servicePublicIPAddress
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		address.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		address.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			address.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		address.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		address.Zones = append(address.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddress_STATUS populates our PublicIPAddress_STATUS from the provided source PublicIPAddress_STATUS
func (address *PublicIPAddress_STATUS) AssignProperties_From_PublicIPAddress_STATUS(source *v20201101s.PublicIPAddress_STATUS) error {

	// DdosSettings
	if source.DdosSettings != nil {
		var ddosSetting DdosSettings_STATUS
		err := ddosSetting.AssignProperties_From_DdosSettings_STATUS(source.DdosSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DdosSettings_STATUS() to populate field DdosSettings")
		}
		address.DdosSettings = &ddosSetting
	} else {
		address.DdosSettings = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting PublicIPAddressDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_PublicIPAddressDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressDnsSettings_STATUS() to populate field DnsSettings")
		}
		address.DnsSettings = &dnsSetting
	} else {
		address.DnsSettings = nil
	}

	// Etag
	address.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		address.ExtendedLocation = &extendedLocation
	} else {
		address.ExtendedLocation = nil
	}

	// Id
	address.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	address.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// IpConfiguration
	if source.IpConfiguration != nil {
		var ipConfiguration IPConfiguration_STATUS
		err := ipConfiguration.AssignProperties_From_IPConfiguration_STATUS(source.IpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IPConfiguration_STATUS() to populate field IpConfiguration")
		}
		address.IpConfiguration = &ipConfiguration
	} else {
		address.IpConfiguration = nil
	}

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]IpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag IpTag_STATUS
			err := ipTag.AssignProperties_From_IpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		address.IpTags = ipTagList
	} else {
		address.IpTags = nil
	}

	// LinkedPublicIPAddress
	if source.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress PublicIPAddress_STATUS
		err := linkedPublicIPAddress.AssignProperties_From_PublicIPAddress_STATUS(source.LinkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddress_STATUS() to populate field LinkedPublicIPAddress")
		}
		address.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		address.LinkedPublicIPAddress = nil
	}

	// Location
	address.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := PublicIPAddressPropertiesFormat_MigrationPhase_STATUS(*source.MigrationPhase)
		address.MigrationPhase = &migrationPhase
	} else {
		address.MigrationPhase = nil
	}

	// Name
	address.Name = genruntime.ClonePointerToString(source.Name)

	// NatGateway
	if source.NatGateway != nil {
		var natGateway NatGateway_STATUS
		err := natGateway.AssignProperties_From_NatGateway_STATUS(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NatGateway_STATUS() to populate field NatGateway")
		}
		address.NatGateway = &natGateway
	} else {
		address.NatGateway = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		address.ProvisioningState = &provisioningState
	} else {
		address.ProvisioningState = nil
	}

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := IPVersion_STATUS(*source.PublicIPAddressVersion)
		address.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		address.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := IPAllocationMethod_STATUS(*source.PublicIPAllocationMethod)
		address.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		address.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		address.PublicIPPrefix = &publicIPPrefix
	} else {
		address.PublicIPPrefix = nil
	}

	// ResourceGuid
	address.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// ServicePublicIPAddress
	if source.ServicePublicIPAddress != nil {
		var servicePublicIPAddress PublicIPAddress_STATUS
		err := servicePublicIPAddress.AssignProperties_From_PublicIPAddress_STATUS(source.ServicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddress_STATUS() to populate field ServicePublicIPAddress")
		}
		address.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		address.ServicePublicIPAddress = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_STATUS
		err := sku.AssignProperties_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		address.Sku = &sku
	} else {
		address.Sku = nil
	}

	// Tags
	address.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	address.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	address.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddress_STATUS populates the provided destination PublicIPAddress_STATUS from our PublicIPAddress_STATUS
func (address *PublicIPAddress_STATUS) AssignProperties_To_PublicIPAddress_STATUS(destination *v20201101s.PublicIPAddress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DdosSettings
	if address.DdosSettings != nil {
		var ddosSetting v20201101s.DdosSettings_STATUS
		err := address.DdosSettings.AssignProperties_To_DdosSettings_STATUS(&ddosSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DdosSettings_STATUS() to populate field DdosSettings")
		}
		destination.DdosSettings = &ddosSetting
	} else {
		destination.DdosSettings = nil
	}

	// DnsSettings
	if address.DnsSettings != nil {
		var dnsSetting v20201101s.PublicIPAddressDnsSettings_STATUS
		err := address.DnsSettings.AssignProperties_To_PublicIPAddressDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(address.Etag)

	// ExtendedLocation
	if address.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := address.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(address.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(address.IdleTimeoutInMinutes)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// IpConfiguration
	if address.IpConfiguration != nil {
		var ipConfiguration v20201101s.IPConfiguration_STATUS
		err := address.IpConfiguration.AssignProperties_To_IPConfiguration_STATUS(&ipConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IPConfiguration_STATUS() to populate field IpConfiguration")
		}
		destination.IpConfiguration = &ipConfiguration
	} else {
		destination.IpConfiguration = nil
	}

	// IpTags
	if address.IpTags != nil {
		ipTagList := make([]v20201101s.IpTag_STATUS, len(address.IpTags))
		for ipTagIndex, ipTagItem := range address.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20201101s.IpTag_STATUS
			err := ipTagItem.AssignProperties_To_IpTag_STATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// LinkedPublicIPAddress
	if address.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress v20201101s.PublicIPAddress_STATUS
		err := address.LinkedPublicIPAddress.AssignProperties_To_PublicIPAddress_STATUS(&linkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddress_STATUS() to populate field LinkedPublicIPAddress")
		}
		destination.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		destination.LinkedPublicIPAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(address.Location)

	// MigrationPhase
	if address.MigrationPhase != nil {
		migrationPhase := string(*address.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(address.Name)

	// NatGateway
	if address.NatGateway != nil {
		var natGateway v20201101s.NatGateway_STATUS
		err := address.NatGateway.AssignProperties_To_NatGateway_STATUS(&natGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NatGateway_STATUS() to populate field NatGateway")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// ProvisioningState
	if address.ProvisioningState != nil {
		provisioningState := string(*address.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddressVersion
	if address.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*address.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if address.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := string(*address.PublicIPAllocationMethod)
		destination.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		destination.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if address.PublicIPPrefix != nil {
		var publicIPPrefix v20201101s.SubResource_STATUS
		err := address.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(address.ResourceGuid)

	// ServicePublicIPAddress
	if address.ServicePublicIPAddress != nil {
		var servicePublicIPAddress v20201101s.PublicIPAddress_STATUS
		err := address.ServicePublicIPAddress.AssignProperties_To_PublicIPAddress_STATUS(&servicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddress_STATUS() to populate field ServicePublicIPAddress")
		}
		destination.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		destination.ServicePublicIPAddress = nil
	}

	// Sku
	if address.Sku != nil {
		var sku v20201101s.PublicIPAddressSku_STATUS
		err := address.Sku.AssignProperties_To_PublicIPAddressSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(address.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(address.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(address.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PublicIPAddressSpec struct {
	// DdosSettings: The DDoS protection custom policy associated with the public IP address.
	DdosSettings *DdosSettings `json:"ddosSettings,omitempty"`

	// DnsSettings: The FQDN of the DNS record associated with the public IP address.
	DnsSettings *PublicIPAddressDnsSettings `json:"dnsSettings,omitempty"`

	// ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpAddress: The IP address associated with the public IP address resource.
	IpAddress *string `json:"ipAddress,omitempty"`

	// IpTags: The list of tags associated with the public IP address.
	IpTags []IpTag `json:"ipTags,omitempty"`

	// LinkedPublicIPAddress: The linked public IP address of the public IP address resource.
	LinkedPublicIPAddress *PublicIPAddressSpec `json:"linkedPublicIPAddress,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MigrationPhase: Migration phase of Public IP Address.
	MigrationPhase *PublicIPAddressPropertiesFormat_MigrationPhase `json:"migrationPhase,omitempty"`

	// NatGateway: The NatGateway for the Public IP address.
	NatGateway *NatGatewaySpec `json:"natGateway,omitempty"`

	// PublicIPAddressVersion: The public IP address version.
	PublicIPAddressVersion *IPVersion `json:"publicIPAddressVersion,omitempty"`

	// PublicIPAllocationMethod: The public IP address allocation method.
	PublicIPAllocationMethod *IPAllocationMethod `json:"publicIPAllocationMethod,omitempty"`

	// PublicIPPrefix: The Public IP Prefix this Public IP Address should be allocated from.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// ServicePublicIPAddress: The service public IP address of the public IP address resource.
	ServicePublicIPAddress *PublicIPAddressSpec `json:"servicePublicIPAddress,omitempty"`

	// Sku: The public IP address SKU.
	Sku *PublicIPAddressSku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &PublicIPAddressSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *PublicIPAddressSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &PublicIPAddressSpec_ARM{}

	// Set property ‘ExtendedLocation’:
	if address.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*address.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*ExtendedLocation_ARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if address.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*address.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if address.Location != nil {
		location := *address.Location
		result.Location = &location
	}

	// Set property ‘Properties’:
	if address.DdosSettings != nil ||
		address.DnsSettings != nil ||
		address.IdleTimeoutInMinutes != nil ||
		address.IpAddress != nil ||
		address.IpTags != nil ||
		address.LinkedPublicIPAddress != nil ||
		address.MigrationPhase != nil ||
		address.NatGateway != nil ||
		address.PublicIPAddressVersion != nil ||
		address.PublicIPAllocationMethod != nil ||
		address.PublicIPPrefix != nil ||
		address.ServicePublicIPAddress != nil {
		result.Properties = &PublicIPAddressPropertiesFormat_ARM{}
	}
	if address.DdosSettings != nil {
		ddosSettings_ARM, err := (*address.DdosSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ddosSettings := *ddosSettings_ARM.(*DdosSettings_ARM)
		result.Properties.DdosSettings = &ddosSettings
	}
	if address.DnsSettings != nil {
		dnsSettings_ARM, err := (*address.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*PublicIPAddressDnsSettings_ARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if address.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *address.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if address.IpAddress != nil {
		ipAddress := *address.IpAddress
		result.Properties.IpAddress = &ipAddress
	}
	for _, item := range address.IpTags {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, *item_ARM.(*IpTag_ARM))
	}
	if address.LinkedPublicIPAddress != nil {
		linkedPublicIPAddress_ARM, err := (*address.LinkedPublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linkedPublicIPAddress := *linkedPublicIPAddress_ARM.(*PublicIPAddressSpec_ARM)
		result.Properties.LinkedPublicIPAddress = &linkedPublicIPAddress
	}
	if address.MigrationPhase != nil {
		migrationPhase := *address.MigrationPhase
		result.Properties.MigrationPhase = &migrationPhase
	}
	if address.NatGateway != nil {
		natGateway_ARM, err := (*address.NatGateway).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGateway := *natGateway_ARM.(*NatGatewaySpec_ARM)
		result.Properties.NatGateway = &natGateway
	}
	if address.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *address.PublicIPAddressVersion
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if address.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := *address.PublicIPAllocationMethod
		result.Properties.PublicIPAllocationMethod = &publicIPAllocationMethod
	}
	if address.PublicIPPrefix != nil {
		publicIPPrefix_ARM, err := (*address.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := *publicIPPrefix_ARM.(*SubResource_ARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if address.ServicePublicIPAddress != nil {
		servicePublicIPAddress_ARM, err := (*address.ServicePublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePublicIPAddress := *servicePublicIPAddress_ARM.(*PublicIPAddressSpec_ARM)
		result.Properties.ServicePublicIPAddress = &servicePublicIPAddress
	}

	// Set property ‘Sku’:
	if address.Sku != nil {
		sku_ARM, err := (*address.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*PublicIPAddressSku_ARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if address.Tags != nil {
		result.Tags = make(map[string]string, len(address.Tags))
		for key, value := range address.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range address.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *PublicIPAddressSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddressSpec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *PublicIPAddressSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddressSpec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddressSpec_ARM, got %T", armInput)
	}

	// Set property ‘DdosSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DdosSettings != nil {
			var ddosSettings1 DdosSettings
			err := ddosSettings1.PopulateFromARM(owner, *typedInput.Properties.DdosSettings)
			if err != nil {
				return err
			}
			ddosSettings := ddosSettings1
			address.DdosSettings = &ddosSettings
		}
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 PublicIPAddressDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			address.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		address.ExtendedLocation = &extendedLocation
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			address.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			address.IpAddress = &ipAddress
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 IpTag
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			address.IpTags = append(address.IpTags, item1)
		}
	}

	// Set property ‘LinkedPublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinkedPublicIPAddress != nil {
			var linkedPublicIPAddress1 PublicIPAddressSpec
			err := linkedPublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.LinkedPublicIPAddress)
			if err != nil {
				return err
			}
			linkedPublicIPAddress := linkedPublicIPAddress1
			address.LinkedPublicIPAddress = &linkedPublicIPAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		address.Location = &location
	}

	// Set property ‘MigrationPhase’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			address.MigrationPhase = &migrationPhase
		}
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 NatGatewaySpec
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			address.NatGateway = &natGateway
		}
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			address.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAllocationMethod != nil {
			publicIPAllocationMethod := *typedInput.Properties.PublicIPAllocationMethod
			address.PublicIPAllocationMethod = &publicIPAllocationMethod
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			address.PublicIPPrefix = &publicIPPrefix
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘ServicePublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePublicIPAddress != nil {
			var servicePublicIPAddress1 PublicIPAddressSpec
			err := servicePublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.ServicePublicIPAddress)
			if err != nil {
				return err
			}
			servicePublicIPAddress := servicePublicIPAddress1
			address.ServicePublicIPAddress = &servicePublicIPAddress
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		address.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		address.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			address.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		address.Zones = append(address.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddressSpec populates our PublicIPAddressSpec from the provided source PublicIPAddressSpec
func (address *PublicIPAddressSpec) AssignProperties_From_PublicIPAddressSpec(source *v20201101s.PublicIPAddressSpec) error {

	// DdosSettings
	if source.DdosSettings != nil {
		var ddosSetting DdosSettings
		err := ddosSetting.AssignProperties_From_DdosSettings(source.DdosSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DdosSettings() to populate field DdosSettings")
		}
		address.DdosSettings = &ddosSetting
	} else {
		address.DdosSettings = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting PublicIPAddressDnsSettings
		err := dnsSetting.AssignProperties_From_PublicIPAddressDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressDnsSettings() to populate field DnsSettings")
		}
		address.DnsSettings = &dnsSetting
	} else {
		address.DnsSettings = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		address.ExtendedLocation = &extendedLocation
	} else {
		address.ExtendedLocation = nil
	}

	// IdleTimeoutInMinutes
	address.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]IpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag IpTag
			err := ipTag.AssignProperties_From_IpTag(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		address.IpTags = ipTagList
	} else {
		address.IpTags = nil
	}

	// LinkedPublicIPAddress
	if source.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress PublicIPAddressSpec
		err := linkedPublicIPAddress.AssignProperties_From_PublicIPAddressSpec(source.LinkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSpec() to populate field LinkedPublicIPAddress")
		}
		address.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		address.LinkedPublicIPAddress = nil
	}

	// Location
	address.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := PublicIPAddressPropertiesFormat_MigrationPhase(*source.MigrationPhase)
		address.MigrationPhase = &migrationPhase
	} else {
		address.MigrationPhase = nil
	}

	// NatGateway
	if source.NatGateway != nil {
		var natGateway NatGatewaySpec
		err := natGateway.AssignProperties_From_NatGatewaySpec(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NatGatewaySpec() to populate field NatGateway")
		}
		address.NatGateway = &natGateway
	} else {
		address.NatGateway = nil
	}

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := IPVersion(*source.PublicIPAddressVersion)
		address.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		address.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := IPAllocationMethod(*source.PublicIPAllocationMethod)
		address.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		address.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix")
		}
		address.PublicIPPrefix = &publicIPPrefix
	} else {
		address.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		address.Reference = &reference
	} else {
		address.Reference = nil
	}

	// ServicePublicIPAddress
	if source.ServicePublicIPAddress != nil {
		var servicePublicIPAddress PublicIPAddressSpec
		err := servicePublicIPAddress.AssignProperties_From_PublicIPAddressSpec(source.ServicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSpec() to populate field ServicePublicIPAddress")
		}
		address.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		address.ServicePublicIPAddress = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.AssignProperties_From_PublicIPAddressSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku() to populate field Sku")
		}
		address.Sku = &sku
	} else {
		address.Sku = nil
	}

	// Tags
	address.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Zones
	address.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSpec populates the provided destination PublicIPAddressSpec from our PublicIPAddressSpec
func (address *PublicIPAddressSpec) AssignProperties_To_PublicIPAddressSpec(destination *v20201101s.PublicIPAddressSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DdosSettings
	if address.DdosSettings != nil {
		var ddosSetting v20201101s.DdosSettings
		err := address.DdosSettings.AssignProperties_To_DdosSettings(&ddosSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DdosSettings() to populate field DdosSettings")
		}
		destination.DdosSettings = &ddosSetting
	} else {
		destination.DdosSettings = nil
	}

	// DnsSettings
	if address.DnsSettings != nil {
		var dnsSetting v20201101s.PublicIPAddressDnsSettings
		err := address.DnsSettings.AssignProperties_To_PublicIPAddressDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// ExtendedLocation
	if address.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation
		err := address.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(address.IdleTimeoutInMinutes)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// IpTags
	if address.IpTags != nil {
		ipTagList := make([]v20201101s.IpTag, len(address.IpTags))
		for ipTagIndex, ipTagItem := range address.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20201101s.IpTag
			err := ipTagItem.AssignProperties_To_IpTag(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// LinkedPublicIPAddress
	if address.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress v20201101s.PublicIPAddressSpec
		err := address.LinkedPublicIPAddress.AssignProperties_To_PublicIPAddressSpec(&linkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSpec() to populate field LinkedPublicIPAddress")
		}
		destination.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		destination.LinkedPublicIPAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(address.Location)

	// MigrationPhase
	if address.MigrationPhase != nil {
		migrationPhase := string(*address.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// NatGateway
	if address.NatGateway != nil {
		var natGateway v20201101s.NatGatewaySpec
		err := address.NatGateway.AssignProperties_To_NatGatewaySpec(&natGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NatGatewaySpec() to populate field NatGateway")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// PublicIPAddressVersion
	if address.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*address.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if address.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := string(*address.PublicIPAllocationMethod)
		destination.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		destination.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if address.PublicIPPrefix != nil {
		var publicIPPrefix v20201101s.SubResource
		err := address.PublicIPPrefix.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if address.Reference != nil {
		reference := address.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ServicePublicIPAddress
	if address.ServicePublicIPAddress != nil {
		var servicePublicIPAddress v20201101s.PublicIPAddressSpec
		err := address.ServicePublicIPAddress.AssignProperties_To_PublicIPAddressSpec(&servicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSpec() to populate field ServicePublicIPAddress")
		}
		destination.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		destination.ServicePublicIPAddress = nil
	}

	// Sku
	if address.Sku != nil {
		var sku v20201101s.PublicIPAddressSku
		err := address.Sku.AssignProperties_To_PublicIPAddressSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(address.Tags)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(address.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet struct {
	// AddressPrefix: The address prefix for the subnet.
	AddressPrefix *string `json:"addressPrefix,omitempty"`

	// AddressPrefixes: List of address prefixes for the subnet.
	AddressPrefixes []string `json:"addressPrefixes,omitempty"`

	// ApplicationGatewayIpConfigurations: Application gateway IP configurations of virtual network resource.
	ApplicationGatewayIpConfigurations []ApplicationGatewayIPConfiguration `json:"applicationGatewayIpConfigurations,omitempty"`

	// Delegations: An array of references to the delegations on the subnet.
	Delegations []Delegation `json:"delegations,omitempty"`

	// IpAllocations: Array of IpAllocation which reference this subnet.
	IpAllocations []SubResource `json:"ipAllocations,omitempty"`

	// Name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// NatGateway: Nat gateway associated with this subnet.
	NatGateway *SubResource `json:"natGateway,omitempty"`

	// NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroupSpec `json:"networkSecurityGroup,omitempty"`

	// PrivateEndpointNetworkPolicies: Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *SubnetPropertiesFormat_PrivateEndpointNetworkPolicies `json:"privateEndpointNetworkPolicies,omitempty"`

	// PrivateLinkServiceNetworkPolicies: Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies `json:"privateLinkServiceNetworkPolicies,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// RouteTable: The reference to the RouteTable resource.
	RouteTable *RouteTableSpec `json:"routeTable,omitempty"`

	// ServiceEndpointPolicies: An array of service endpoint policies.
	ServiceEndpointPolicies []ServiceEndpointPolicySpec `json:"serviceEndpointPolicies,omitempty"`

	// ServiceEndpoints: An array of service endpoints.
	ServiceEndpoints []ServiceEndpointPropertiesFormat `json:"serviceEndpoints,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Subnet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subnet *Subnet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subnet == nil {
		return nil, nil
	}
	result := &Subnet_ARM{}

	// Set property ‘Id’:
	if subnet.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*subnet.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if subnet.Name != nil {
		name := *subnet.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if subnet.AddressPrefix != nil ||
		subnet.AddressPrefixes != nil ||
		subnet.ApplicationGatewayIpConfigurations != nil ||
		subnet.Delegations != nil ||
		subnet.IpAllocations != nil ||
		subnet.NatGateway != nil ||
		subnet.NetworkSecurityGroup != nil ||
		subnet.PrivateEndpointNetworkPolicies != nil ||
		subnet.PrivateLinkServiceNetworkPolicies != nil ||
		subnet.RouteTable != nil ||
		subnet.ServiceEndpointPolicies != nil ||
		subnet.ServiceEndpoints != nil {
		result.Properties = &SubnetPropertiesFormat_ARM{}
	}
	if subnet.AddressPrefix != nil {
		addressPrefix := *subnet.AddressPrefix
		result.Properties.AddressPrefix = &addressPrefix
	}
	for _, item := range subnet.AddressPrefixes {
		result.Properties.AddressPrefixes = append(result.Properties.AddressPrefixes, item)
	}
	for _, item := range subnet.ApplicationGatewayIpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayIpConfigurations = append(result.Properties.ApplicationGatewayIpConfigurations, *item_ARM.(*ApplicationGatewayIPConfiguration_ARM))
	}
	for _, item := range subnet.Delegations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Delegations = append(result.Properties.Delegations, *item_ARM.(*Delegation_ARM))
	}
	for _, item := range subnet.IpAllocations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpAllocations = append(result.Properties.IpAllocations, *item_ARM.(*SubResource_ARM))
	}
	if subnet.NatGateway != nil {
		natGateway_ARM, err := (*subnet.NatGateway).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGateway := *natGateway_ARM.(*SubResource_ARM)
		result.Properties.NatGateway = &natGateway
	}
	if subnet.NetworkSecurityGroup != nil {
		networkSecurityGroup_ARM, err := (*subnet.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := *networkSecurityGroup_ARM.(*NetworkSecurityGroupSpec_ARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if subnet.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicies := *subnet.PrivateEndpointNetworkPolicies
		result.Properties.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
	}
	if subnet.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicies := *subnet.PrivateLinkServiceNetworkPolicies
		result.Properties.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
	}
	if subnet.RouteTable != nil {
		routeTable_ARM, err := (*subnet.RouteTable).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routeTable := *routeTable_ARM.(*RouteTableSpec_ARM)
		result.Properties.RouteTable = &routeTable
	}
	for _, item := range subnet.ServiceEndpointPolicies {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ServiceEndpointPolicies = append(result.Properties.ServiceEndpointPolicies, *item_ARM.(*ServiceEndpointPolicySpec_ARM))
	}
	for _, item := range subnet.ServiceEndpoints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ServiceEndpoints = append(result.Properties.ServiceEndpoints, *item_ARM.(*ServiceEndpointPropertiesFormat_ARM))
	}

	// Set property ‘Type’:
	if subnet.Type != nil {
		typeVar := *subnet.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnet *Subnet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnet *Subnet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_ARM, got %T", armInput)
	}

	// Set property ‘AddressPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddressPrefix != nil {
			addressPrefix := *typedInput.Properties.AddressPrefix
			subnet.AddressPrefix = &addressPrefix
		}
	}

	// Set property ‘AddressPrefixes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AddressPrefixes {
			subnet.AddressPrefixes = append(subnet.AddressPrefixes, item)
		}
	}

	// Set property ‘ApplicationGatewayIpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayIpConfigurations {
			var item1 ApplicationGatewayIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ApplicationGatewayIpConfigurations = append(subnet.ApplicationGatewayIpConfigurations, item1)
		}
	}

	// Set property ‘Delegations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Delegations {
			var item1 Delegation
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.Delegations = append(subnet.Delegations, item1)
		}
	}

	// Set property ‘IpAllocations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpAllocations {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.IpAllocations = append(subnet.IpAllocations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnet.Name = &name
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 SubResource
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			subnet.NatGateway = &natGateway
		}
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroupSpec
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			subnet.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘PrivateEndpointNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointNetworkPolicies != nil {
			privateEndpointNetworkPolicies := *typedInput.Properties.PrivateEndpointNetworkPolicies
			subnet.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
		}
	}

	// Set property ‘PrivateLinkServiceNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkServiceNetworkPolicies != nil {
			privateLinkServiceNetworkPolicies := *typedInput.Properties.PrivateLinkServiceNetworkPolicies
			subnet.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘RouteTable’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RouteTable != nil {
			var routeTable1 RouteTableSpec
			err := routeTable1.PopulateFromARM(owner, *typedInput.Properties.RouteTable)
			if err != nil {
				return err
			}
			routeTable := routeTable1
			subnet.RouteTable = &routeTable
		}
	}

	// Set property ‘ServiceEndpointPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpointPolicies {
			var item1 ServiceEndpointPolicySpec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ServiceEndpointPolicies = append(subnet.ServiceEndpointPolicies, item1)
		}
	}

	// Set property ‘ServiceEndpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpoints {
			var item1 ServiceEndpointPropertiesFormat
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ServiceEndpoints = append(subnet.ServiceEndpoints, item1)
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		subnet.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Subnet populates our Subnet from the provided source Subnet
func (subnet *Subnet) AssignProperties_From_Subnet(source *v20201101s.Subnet) error {

	// AddressPrefix
	subnet.AddressPrefix = genruntime.ClonePointerToString(source.AddressPrefix)

	// AddressPrefixes
	subnet.AddressPrefixes = genruntime.CloneSliceOfString(source.AddressPrefixes)

	// ApplicationGatewayIpConfigurations
	if source.ApplicationGatewayIpConfigurations != nil {
		applicationGatewayIpConfigurationList := make([]ApplicationGatewayIPConfiguration, len(source.ApplicationGatewayIpConfigurations))
		for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range source.ApplicationGatewayIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
			var applicationGatewayIpConfiguration ApplicationGatewayIPConfiguration
			err := applicationGatewayIpConfiguration.AssignProperties_From_ApplicationGatewayIPConfiguration(&applicationGatewayIpConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayIPConfiguration() to populate field ApplicationGatewayIpConfigurations")
			}
			applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
		}
		subnet.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList
	} else {
		subnet.ApplicationGatewayIpConfigurations = nil
	}

	// Delegations
	if source.Delegations != nil {
		delegationList := make([]Delegation, len(source.Delegations))
		for delegationIndex, delegationItem := range source.Delegations {
			// Shadow the loop variable to avoid aliasing
			delegationItem := delegationItem
			var delegation Delegation
			err := delegation.AssignProperties_From_Delegation(&delegationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Delegation() to populate field Delegations")
			}
			delegationList[delegationIndex] = delegation
		}
		subnet.Delegations = delegationList
	} else {
		subnet.Delegations = nil
	}

	// IpAllocations
	if source.IpAllocations != nil {
		ipAllocationList := make([]SubResource, len(source.IpAllocations))
		for ipAllocationIndex, ipAllocationItem := range source.IpAllocations {
			// Shadow the loop variable to avoid aliasing
			ipAllocationItem := ipAllocationItem
			var ipAllocation SubResource
			err := ipAllocation.AssignProperties_From_SubResource(&ipAllocationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field IpAllocations")
			}
			ipAllocationList[ipAllocationIndex] = ipAllocation
		}
		subnet.IpAllocations = ipAllocationList
	} else {
		subnet.IpAllocations = nil
	}

	// Name
	subnet.Name = genruntime.ClonePointerToString(source.Name)

	// NatGateway
	if source.NatGateway != nil {
		var natGateway SubResource
		err := natGateway.AssignProperties_From_SubResource(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field NatGateway")
		}
		subnet.NatGateway = &natGateway
	} else {
		subnet.NatGateway = nil
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroupSpec
		err := networkSecurityGroup.AssignProperties_From_NetworkSecurityGroupSpec(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkSecurityGroupSpec() to populate field NetworkSecurityGroup")
		}
		subnet.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		subnet.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if source.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := SubnetPropertiesFormat_PrivateEndpointNetworkPolicies(*source.PrivateEndpointNetworkPolicies)
		subnet.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		subnet.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if source.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies(*source.PrivateLinkServiceNetworkPolicies)
		subnet.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		subnet.PrivateLinkServiceNetworkPolicies = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subnet.Reference = &reference
	} else {
		subnet.Reference = nil
	}

	// RouteTable
	if source.RouteTable != nil {
		var routeTable RouteTableSpec
		err := routeTable.AssignProperties_From_RouteTableSpec(source.RouteTable)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteTableSpec() to populate field RouteTable")
		}
		subnet.RouteTable = &routeTable
	} else {
		subnet.RouteTable = nil
	}

	// ServiceEndpointPolicies
	if source.ServiceEndpointPolicies != nil {
		serviceEndpointPolicyList := make([]ServiceEndpointPolicySpec, len(source.ServiceEndpointPolicies))
		for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range source.ServiceEndpointPolicies {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointPolicyItem := serviceEndpointPolicyItem
			var serviceEndpointPolicy ServiceEndpointPolicySpec
			err := serviceEndpointPolicy.AssignProperties_From_ServiceEndpointPolicySpec(&serviceEndpointPolicyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServiceEndpointPolicySpec() to populate field ServiceEndpointPolicies")
			}
			serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
		}
		subnet.ServiceEndpointPolicies = serviceEndpointPolicyList
	} else {
		subnet.ServiceEndpointPolicies = nil
	}

	// ServiceEndpoints
	if source.ServiceEndpoints != nil {
		serviceEndpointList := make([]ServiceEndpointPropertiesFormat, len(source.ServiceEndpoints))
		for serviceEndpointIndex, serviceEndpointItem := range source.ServiceEndpoints {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointItem := serviceEndpointItem
			var serviceEndpoint ServiceEndpointPropertiesFormat
			err := serviceEndpoint.AssignProperties_From_ServiceEndpointPropertiesFormat(&serviceEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServiceEndpointPropertiesFormat() to populate field ServiceEndpoints")
			}
			serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
		}
		subnet.ServiceEndpoints = serviceEndpointList
	} else {
		subnet.ServiceEndpoints = nil
	}

	// Type
	subnet.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Subnet populates the provided destination Subnet from our Subnet
func (subnet *Subnet) AssignProperties_To_Subnet(destination *v20201101s.Subnet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddressPrefix
	destination.AddressPrefix = genruntime.ClonePointerToString(subnet.AddressPrefix)

	// AddressPrefixes
	destination.AddressPrefixes = genruntime.CloneSliceOfString(subnet.AddressPrefixes)

	// ApplicationGatewayIpConfigurations
	if subnet.ApplicationGatewayIpConfigurations != nil {
		applicationGatewayIpConfigurationList := make([]v20201101s.ApplicationGatewayIPConfiguration, len(subnet.ApplicationGatewayIpConfigurations))
		for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range subnet.ApplicationGatewayIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
			var applicationGatewayIpConfiguration v20201101s.ApplicationGatewayIPConfiguration
			err := applicationGatewayIpConfigurationItem.AssignProperties_To_ApplicationGatewayIPConfiguration(&applicationGatewayIpConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayIPConfiguration() to populate field ApplicationGatewayIpConfigurations")
			}
			applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
		}
		destination.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList
	} else {
		destination.ApplicationGatewayIpConfigurations = nil
	}

	// Delegations
	if subnet.Delegations != nil {
		delegationList := make([]v20201101s.Delegation, len(subnet.Delegations))
		for delegationIndex, delegationItem := range subnet.Delegations {
			// Shadow the loop variable to avoid aliasing
			delegationItem := delegationItem
			var delegation v20201101s.Delegation
			err := delegationItem.AssignProperties_To_Delegation(&delegation)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Delegation() to populate field Delegations")
			}
			delegationList[delegationIndex] = delegation
		}
		destination.Delegations = delegationList
	} else {
		destination.Delegations = nil
	}

	// IpAllocations
	if subnet.IpAllocations != nil {
		ipAllocationList := make([]v20201101s.SubResource, len(subnet.IpAllocations))
		for ipAllocationIndex, ipAllocationItem := range subnet.IpAllocations {
			// Shadow the loop variable to avoid aliasing
			ipAllocationItem := ipAllocationItem
			var ipAllocation v20201101s.SubResource
			err := ipAllocationItem.AssignProperties_To_SubResource(&ipAllocation)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field IpAllocations")
			}
			ipAllocationList[ipAllocationIndex] = ipAllocation
		}
		destination.IpAllocations = ipAllocationList
	} else {
		destination.IpAllocations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(subnet.Name)

	// NatGateway
	if subnet.NatGateway != nil {
		var natGateway v20201101s.SubResource
		err := subnet.NatGateway.AssignProperties_To_SubResource(&natGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field NatGateway")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// NetworkSecurityGroup
	if subnet.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroupSpec
		err := subnet.NetworkSecurityGroup.AssignProperties_To_NetworkSecurityGroupSpec(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkSecurityGroupSpec() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if subnet.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := string(*subnet.PrivateEndpointNetworkPolicies)
		destination.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		destination.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if subnet.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := string(*subnet.PrivateLinkServiceNetworkPolicies)
		destination.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		destination.PrivateLinkServiceNetworkPolicies = nil
	}

	// Reference
	if subnet.Reference != nil {
		reference := subnet.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RouteTable
	if subnet.RouteTable != nil {
		var routeTable v20201101s.RouteTableSpec
		err := subnet.RouteTable.AssignProperties_To_RouteTableSpec(&routeTable)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteTableSpec() to populate field RouteTable")
		}
		destination.RouteTable = &routeTable
	} else {
		destination.RouteTable = nil
	}

	// ServiceEndpointPolicies
	if subnet.ServiceEndpointPolicies != nil {
		serviceEndpointPolicyList := make([]v20201101s.ServiceEndpointPolicySpec, len(subnet.ServiceEndpointPolicies))
		for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range subnet.ServiceEndpointPolicies {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointPolicyItem := serviceEndpointPolicyItem
			var serviceEndpointPolicy v20201101s.ServiceEndpointPolicySpec
			err := serviceEndpointPolicyItem.AssignProperties_To_ServiceEndpointPolicySpec(&serviceEndpointPolicy)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServiceEndpointPolicySpec() to populate field ServiceEndpointPolicies")
			}
			serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
		}
		destination.ServiceEndpointPolicies = serviceEndpointPolicyList
	} else {
		destination.ServiceEndpointPolicies = nil
	}

	// ServiceEndpoints
	if subnet.ServiceEndpoints != nil {
		serviceEndpointList := make([]v20201101s.ServiceEndpointPropertiesFormat, len(subnet.ServiceEndpoints))
		for serviceEndpointIndex, serviceEndpointItem := range subnet.ServiceEndpoints {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointItem := serviceEndpointItem
			var serviceEndpoint v20201101s.ServiceEndpointPropertiesFormat
			err := serviceEndpointItem.AssignProperties_To_ServiceEndpointPropertiesFormat(&serviceEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServiceEndpointPropertiesFormat() to populate field ServiceEndpoints")
			}
			serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
		}
		destination.ServiceEndpoints = serviceEndpointList
	} else {
		destination.ServiceEndpoints = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(subnet.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet_STATUS struct {
	// AddressPrefix: The address prefix for the subnet.
	AddressPrefix *string `json:"addressPrefix,omitempty"`

	// AddressPrefixes: List of address prefixes for the subnet.
	AddressPrefixes []string `json:"addressPrefixes,omitempty"`

	// ApplicationGatewayIpConfigurations: Application gateway IP configurations of virtual network resource.
	ApplicationGatewayIpConfigurations []ApplicationGatewayIPConfiguration_STATUS `json:"applicationGatewayIpConfigurations,omitempty"`

	// Delegations: An array of references to the delegations on the subnet.
	Delegations []Delegation_STATUS `json:"delegations,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IpAllocations: Array of IpAllocation which reference this subnet.
	IpAllocations []SubResource_STATUS `json:"ipAllocations,omitempty"`

	// IpConfigurationProfiles: Array of IP configuration profiles which reference this subnet.
	IpConfigurationProfiles []IPConfigurationProfile_STATUS `json:"ipConfigurationProfiles,omitempty"`

	// IpConfigurations: An array of references to the network interface IP configurations using subnet.
	IpConfigurations []IPConfiguration_STATUS `json:"ipConfigurations,omitempty"`

	// Name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// NatGateway: Nat gateway associated with this subnet.
	NatGateway *SubResource_STATUS `json:"natGateway,omitempty"`

	// NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroup_STATUS `json:"networkSecurityGroup,omitempty"`

	// PrivateEndpointNetworkPolicies: Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_STATUS `json:"privateEndpointNetworkPolicies,omitempty"`

	// PrivateEndpoints: An array of references to private endpoints.
	PrivateEndpoints []PrivateEndpoint_STATUS `json:"privateEndpoints,omitempty"`

	// PrivateLinkServiceNetworkPolicies: Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_STATUS `json:"privateLinkServiceNetworkPolicies,omitempty"`

	// ProvisioningState: The provisioning state of the subnet resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Purpose: A read-only string identifying the intention of use for this subnet based on delegations and other user-defined
	// properties.
	Purpose *string `json:"purpose,omitempty"`

	// ResourceNavigationLinks: An array of references to the external resources using subnet.
	ResourceNavigationLinks []ResourceNavigationLink_STATUS `json:"resourceNavigationLinks,omitempty"`

	// RouteTable: The reference to the RouteTable resource.
	RouteTable *RouteTable_STATUS `json:"routeTable,omitempty"`

	// ServiceAssociationLinks: An array of references to services injecting into this subnet.
	ServiceAssociationLinks []ServiceAssociationLink_STATUS `json:"serviceAssociationLinks,omitempty"`

	// ServiceEndpointPolicies: An array of service endpoint policies.
	ServiceEndpointPolicies []ServiceEndpointPolicy_STATUS `json:"serviceEndpointPolicies,omitempty"`

	// ServiceEndpoints: An array of service endpoints.
	ServiceEndpoints []ServiceEndpointPropertiesFormat_STATUS `json:"serviceEndpoints,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnet *Subnet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnet *Subnet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AddressPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddressPrefix != nil {
			addressPrefix := *typedInput.Properties.AddressPrefix
			subnet.AddressPrefix = &addressPrefix
		}
	}

	// Set property ‘AddressPrefixes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AddressPrefixes {
			subnet.AddressPrefixes = append(subnet.AddressPrefixes, item)
		}
	}

	// Set property ‘ApplicationGatewayIpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayIpConfigurations {
			var item1 ApplicationGatewayIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ApplicationGatewayIpConfigurations = append(subnet.ApplicationGatewayIpConfigurations, item1)
		}
	}

	// Set property ‘Delegations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Delegations {
			var item1 Delegation_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.Delegations = append(subnet.Delegations, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		subnet.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnet.Id = &id
	}

	// Set property ‘IpAllocations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpAllocations {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.IpAllocations = append(subnet.IpAllocations, item1)
		}
	}

	// Set property ‘IpConfigurationProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurationProfiles {
			var item1 IPConfigurationProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.IpConfigurationProfiles = append(subnet.IpConfigurationProfiles, item1)
		}
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 IPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.IpConfigurations = append(subnet.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		subnet.Name = &name
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 SubResource_STATUS
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			subnet.NatGateway = &natGateway
		}
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroup_STATUS
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			subnet.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘PrivateEndpointNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointNetworkPolicies != nil {
			privateEndpointNetworkPolicies := *typedInput.Properties.PrivateEndpointNetworkPolicies
			subnet.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicies
		}
	}

	// Set property ‘PrivateEndpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpoints {
			var item1 PrivateEndpoint_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.PrivateEndpoints = append(subnet.PrivateEndpoints, item1)
		}
	}

	// Set property ‘PrivateLinkServiceNetworkPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkServiceNetworkPolicies != nil {
			privateLinkServiceNetworkPolicies := *typedInput.Properties.PrivateLinkServiceNetworkPolicies
			subnet.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicies
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			subnet.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Purpose’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Purpose != nil {
			purpose := *typedInput.Properties.Purpose
			subnet.Purpose = &purpose
		}
	}

	// Set property ‘ResourceNavigationLinks’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ResourceNavigationLinks {
			var item1 ResourceNavigationLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ResourceNavigationLinks = append(subnet.ResourceNavigationLinks, item1)
		}
	}

	// Set property ‘RouteTable’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RouteTable != nil {
			var routeTable1 RouteTable_STATUS
			err := routeTable1.PopulateFromARM(owner, *typedInput.Properties.RouteTable)
			if err != nil {
				return err
			}
			routeTable := routeTable1
			subnet.RouteTable = &routeTable
		}
	}

	// Set property ‘ServiceAssociationLinks’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceAssociationLinks {
			var item1 ServiceAssociationLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ServiceAssociationLinks = append(subnet.ServiceAssociationLinks, item1)
		}
	}

	// Set property ‘ServiceEndpointPolicies’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpointPolicies {
			var item1 ServiceEndpointPolicy_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ServiceEndpointPolicies = append(subnet.ServiceEndpointPolicies, item1)
		}
	}

	// Set property ‘ServiceEndpoints’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ServiceEndpoints {
			var item1 ServiceEndpointPropertiesFormat_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			subnet.ServiceEndpoints = append(subnet.ServiceEndpoints, item1)
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		subnet.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Subnet_STATUS populates our Subnet_STATUS from the provided source Subnet_STATUS
func (subnet *Subnet_STATUS) AssignProperties_From_Subnet_STATUS(source *v20201101s.Subnet_STATUS) error {

	// AddressPrefix
	subnet.AddressPrefix = genruntime.ClonePointerToString(source.AddressPrefix)

	// AddressPrefixes
	subnet.AddressPrefixes = genruntime.CloneSliceOfString(source.AddressPrefixes)

	// ApplicationGatewayIpConfigurations
	if source.ApplicationGatewayIpConfigurations != nil {
		applicationGatewayIpConfigurationList := make([]ApplicationGatewayIPConfiguration_STATUS, len(source.ApplicationGatewayIpConfigurations))
		for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range source.ApplicationGatewayIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
			var applicationGatewayIpConfiguration ApplicationGatewayIPConfiguration_STATUS
			err := applicationGatewayIpConfiguration.AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS(&applicationGatewayIpConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGatewayIPConfiguration_STATUS() to populate field ApplicationGatewayIpConfigurations")
			}
			applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
		}
		subnet.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList
	} else {
		subnet.ApplicationGatewayIpConfigurations = nil
	}

	// Delegations
	if source.Delegations != nil {
		delegationList := make([]Delegation_STATUS, len(source.Delegations))
		for delegationIndex, delegationItem := range source.Delegations {
			// Shadow the loop variable to avoid aliasing
			delegationItem := delegationItem
			var delegation Delegation_STATUS
			err := delegation.AssignProperties_From_Delegation_STATUS(&delegationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Delegation_STATUS() to populate field Delegations")
			}
			delegationList[delegationIndex] = delegation
		}
		subnet.Delegations = delegationList
	} else {
		subnet.Delegations = nil
	}

	// Etag
	subnet.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	subnet.Id = genruntime.ClonePointerToString(source.Id)

	// IpAllocations
	if source.IpAllocations != nil {
		ipAllocationList := make([]SubResource_STATUS, len(source.IpAllocations))
		for ipAllocationIndex, ipAllocationItem := range source.IpAllocations {
			// Shadow the loop variable to avoid aliasing
			ipAllocationItem := ipAllocationItem
			var ipAllocation SubResource_STATUS
			err := ipAllocation.AssignProperties_From_SubResource_STATUS(&ipAllocationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field IpAllocations")
			}
			ipAllocationList[ipAllocationIndex] = ipAllocation
		}
		subnet.IpAllocations = ipAllocationList
	} else {
		subnet.IpAllocations = nil
	}

	// IpConfigurationProfiles
	if source.IpConfigurationProfiles != nil {
		ipConfigurationProfileList := make([]IPConfigurationProfile_STATUS, len(source.IpConfigurationProfiles))
		for ipConfigurationProfileIndex, ipConfigurationProfileItem := range source.IpConfigurationProfiles {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationProfileItem := ipConfigurationProfileItem
			var ipConfigurationProfile IPConfigurationProfile_STATUS
			err := ipConfigurationProfile.AssignProperties_From_IPConfigurationProfile_STATUS(&ipConfigurationProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IPConfigurationProfile_STATUS() to populate field IpConfigurationProfiles")
			}
			ipConfigurationProfileList[ipConfigurationProfileIndex] = ipConfigurationProfile
		}
		subnet.IpConfigurationProfiles = ipConfigurationProfileList
	} else {
		subnet.IpConfigurationProfiles = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]IPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration IPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_IPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		subnet.IpConfigurations = ipConfigurationList
	} else {
		subnet.IpConfigurations = nil
	}

	// Name
	subnet.Name = genruntime.ClonePointerToString(source.Name)

	// NatGateway
	if source.NatGateway != nil {
		var natGateway SubResource_STATUS
		err := natGateway.AssignProperties_From_SubResource_STATUS(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NatGateway")
		}
		subnet.NatGateway = &natGateway
	} else {
		subnet.NatGateway = nil
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_STATUS
		err := networkSecurityGroup.AssignProperties_From_NetworkSecurityGroup_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkSecurityGroup_STATUS() to populate field NetworkSecurityGroup")
		}
		subnet.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		subnet.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if source.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_STATUS(*source.PrivateEndpointNetworkPolicies)
		subnet.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		subnet.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateEndpoints
	if source.PrivateEndpoints != nil {
		privateEndpointList := make([]PrivateEndpoint_STATUS, len(source.PrivateEndpoints))
		for privateEndpointIndex, privateEndpointItem := range source.PrivateEndpoints {
			// Shadow the loop variable to avoid aliasing
			privateEndpointItem := privateEndpointItem
			var privateEndpoint PrivateEndpoint_STATUS
			err := privateEndpoint.AssignProperties_From_PrivateEndpoint_STATUS(&privateEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpoint_STATUS() to populate field PrivateEndpoints")
			}
			privateEndpointList[privateEndpointIndex] = privateEndpoint
		}
		subnet.PrivateEndpoints = privateEndpointList
	} else {
		subnet.PrivateEndpoints = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if source.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_STATUS(*source.PrivateLinkServiceNetworkPolicies)
		subnet.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		subnet.PrivateLinkServiceNetworkPolicies = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		subnet.ProvisioningState = &provisioningState
	} else {
		subnet.ProvisioningState = nil
	}

	// Purpose
	subnet.Purpose = genruntime.ClonePointerToString(source.Purpose)

	// ResourceNavigationLinks
	if source.ResourceNavigationLinks != nil {
		resourceNavigationLinkList := make([]ResourceNavigationLink_STATUS, len(source.ResourceNavigationLinks))
		for resourceNavigationLinkIndex, resourceNavigationLinkItem := range source.ResourceNavigationLinks {
			// Shadow the loop variable to avoid aliasing
			resourceNavigationLinkItem := resourceNavigationLinkItem
			var resourceNavigationLink ResourceNavigationLink_STATUS
			err := resourceNavigationLink.AssignProperties_From_ResourceNavigationLink_STATUS(&resourceNavigationLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceNavigationLink_STATUS() to populate field ResourceNavigationLinks")
			}
			resourceNavigationLinkList[resourceNavigationLinkIndex] = resourceNavigationLink
		}
		subnet.ResourceNavigationLinks = resourceNavigationLinkList
	} else {
		subnet.ResourceNavigationLinks = nil
	}

	// RouteTable
	if source.RouteTable != nil {
		var routeTable RouteTable_STATUS
		err := routeTable.AssignProperties_From_RouteTable_STATUS(source.RouteTable)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteTable_STATUS() to populate field RouteTable")
		}
		subnet.RouteTable = &routeTable
	} else {
		subnet.RouteTable = nil
	}

	// ServiceAssociationLinks
	if source.ServiceAssociationLinks != nil {
		serviceAssociationLinkList := make([]ServiceAssociationLink_STATUS, len(source.ServiceAssociationLinks))
		for serviceAssociationLinkIndex, serviceAssociationLinkItem := range source.ServiceAssociationLinks {
			// Shadow the loop variable to avoid aliasing
			serviceAssociationLinkItem := serviceAssociationLinkItem
			var serviceAssociationLink ServiceAssociationLink_STATUS
			err := serviceAssociationLink.AssignProperties_From_ServiceAssociationLink_STATUS(&serviceAssociationLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServiceAssociationLink_STATUS() to populate field ServiceAssociationLinks")
			}
			serviceAssociationLinkList[serviceAssociationLinkIndex] = serviceAssociationLink
		}
		subnet.ServiceAssociationLinks = serviceAssociationLinkList
	} else {
		subnet.ServiceAssociationLinks = nil
	}

	// ServiceEndpointPolicies
	if source.ServiceEndpointPolicies != nil {
		serviceEndpointPolicyList := make([]ServiceEndpointPolicy_STATUS, len(source.ServiceEndpointPolicies))
		for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range source.ServiceEndpointPolicies {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointPolicyItem := serviceEndpointPolicyItem
			var serviceEndpointPolicy ServiceEndpointPolicy_STATUS
			err := serviceEndpointPolicy.AssignProperties_From_ServiceEndpointPolicy_STATUS(&serviceEndpointPolicyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServiceEndpointPolicy_STATUS() to populate field ServiceEndpointPolicies")
			}
			serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
		}
		subnet.ServiceEndpointPolicies = serviceEndpointPolicyList
	} else {
		subnet.ServiceEndpointPolicies = nil
	}

	// ServiceEndpoints
	if source.ServiceEndpoints != nil {
		serviceEndpointList := make([]ServiceEndpointPropertiesFormat_STATUS, len(source.ServiceEndpoints))
		for serviceEndpointIndex, serviceEndpointItem := range source.ServiceEndpoints {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointItem := serviceEndpointItem
			var serviceEndpoint ServiceEndpointPropertiesFormat_STATUS
			err := serviceEndpoint.AssignProperties_From_ServiceEndpointPropertiesFormat_STATUS(&serviceEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServiceEndpointPropertiesFormat_STATUS() to populate field ServiceEndpoints")
			}
			serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
		}
		subnet.ServiceEndpoints = serviceEndpointList
	} else {
		subnet.ServiceEndpoints = nil
	}

	// Type
	subnet.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Subnet_STATUS populates the provided destination Subnet_STATUS from our Subnet_STATUS
func (subnet *Subnet_STATUS) AssignProperties_To_Subnet_STATUS(destination *v20201101s.Subnet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddressPrefix
	destination.AddressPrefix = genruntime.ClonePointerToString(subnet.AddressPrefix)

	// AddressPrefixes
	destination.AddressPrefixes = genruntime.CloneSliceOfString(subnet.AddressPrefixes)

	// ApplicationGatewayIpConfigurations
	if subnet.ApplicationGatewayIpConfigurations != nil {
		applicationGatewayIpConfigurationList := make([]v20201101s.ApplicationGatewayIPConfiguration_STATUS, len(subnet.ApplicationGatewayIpConfigurations))
		for applicationGatewayIpConfigurationIndex, applicationGatewayIpConfigurationItem := range subnet.ApplicationGatewayIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayIpConfigurationItem := applicationGatewayIpConfigurationItem
			var applicationGatewayIpConfiguration v20201101s.ApplicationGatewayIPConfiguration_STATUS
			err := applicationGatewayIpConfigurationItem.AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS(&applicationGatewayIpConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGatewayIPConfiguration_STATUS() to populate field ApplicationGatewayIpConfigurations")
			}
			applicationGatewayIpConfigurationList[applicationGatewayIpConfigurationIndex] = applicationGatewayIpConfiguration
		}
		destination.ApplicationGatewayIpConfigurations = applicationGatewayIpConfigurationList
	} else {
		destination.ApplicationGatewayIpConfigurations = nil
	}

	// Delegations
	if subnet.Delegations != nil {
		delegationList := make([]v20201101s.Delegation_STATUS, len(subnet.Delegations))
		for delegationIndex, delegationItem := range subnet.Delegations {
			// Shadow the loop variable to avoid aliasing
			delegationItem := delegationItem
			var delegation v20201101s.Delegation_STATUS
			err := delegationItem.AssignProperties_To_Delegation_STATUS(&delegation)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Delegation_STATUS() to populate field Delegations")
			}
			delegationList[delegationIndex] = delegation
		}
		destination.Delegations = delegationList
	} else {
		destination.Delegations = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(subnet.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(subnet.Id)

	// IpAllocations
	if subnet.IpAllocations != nil {
		ipAllocationList := make([]v20201101s.SubResource_STATUS, len(subnet.IpAllocations))
		for ipAllocationIndex, ipAllocationItem := range subnet.IpAllocations {
			// Shadow the loop variable to avoid aliasing
			ipAllocationItem := ipAllocationItem
			var ipAllocation v20201101s.SubResource_STATUS
			err := ipAllocationItem.AssignProperties_To_SubResource_STATUS(&ipAllocation)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field IpAllocations")
			}
			ipAllocationList[ipAllocationIndex] = ipAllocation
		}
		destination.IpAllocations = ipAllocationList
	} else {
		destination.IpAllocations = nil
	}

	// IpConfigurationProfiles
	if subnet.IpConfigurationProfiles != nil {
		ipConfigurationProfileList := make([]v20201101s.IPConfigurationProfile_STATUS, len(subnet.IpConfigurationProfiles))
		for ipConfigurationProfileIndex, ipConfigurationProfileItem := range subnet.IpConfigurationProfiles {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationProfileItem := ipConfigurationProfileItem
			var ipConfigurationProfile v20201101s.IPConfigurationProfile_STATUS
			err := ipConfigurationProfileItem.AssignProperties_To_IPConfigurationProfile_STATUS(&ipConfigurationProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IPConfigurationProfile_STATUS() to populate field IpConfigurationProfiles")
			}
			ipConfigurationProfileList[ipConfigurationProfileIndex] = ipConfigurationProfile
		}
		destination.IpConfigurationProfiles = ipConfigurationProfileList
	} else {
		destination.IpConfigurationProfiles = nil
	}

	// IpConfigurations
	if subnet.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.IPConfiguration_STATUS, len(subnet.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range subnet.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.IPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_IPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(subnet.Name)

	// NatGateway
	if subnet.NatGateway != nil {
		var natGateway v20201101s.SubResource_STATUS
		err := subnet.NatGateway.AssignProperties_To_SubResource_STATUS(&natGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NatGateway")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// NetworkSecurityGroup
	if subnet.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroup_STATUS
		err := subnet.NetworkSecurityGroup.AssignProperties_To_NetworkSecurityGroup_STATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkSecurityGroup_STATUS() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// PrivateEndpointNetworkPolicies
	if subnet.PrivateEndpointNetworkPolicies != nil {
		privateEndpointNetworkPolicy := string(*subnet.PrivateEndpointNetworkPolicies)
		destination.PrivateEndpointNetworkPolicies = &privateEndpointNetworkPolicy
	} else {
		destination.PrivateEndpointNetworkPolicies = nil
	}

	// PrivateEndpoints
	if subnet.PrivateEndpoints != nil {
		privateEndpointList := make([]v20201101s.PrivateEndpoint_STATUS, len(subnet.PrivateEndpoints))
		for privateEndpointIndex, privateEndpointItem := range subnet.PrivateEndpoints {
			// Shadow the loop variable to avoid aliasing
			privateEndpointItem := privateEndpointItem
			var privateEndpoint v20201101s.PrivateEndpoint_STATUS
			err := privateEndpointItem.AssignProperties_To_PrivateEndpoint_STATUS(&privateEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpoint_STATUS() to populate field PrivateEndpoints")
			}
			privateEndpointList[privateEndpointIndex] = privateEndpoint
		}
		destination.PrivateEndpoints = privateEndpointList
	} else {
		destination.PrivateEndpoints = nil
	}

	// PrivateLinkServiceNetworkPolicies
	if subnet.PrivateLinkServiceNetworkPolicies != nil {
		privateLinkServiceNetworkPolicy := string(*subnet.PrivateLinkServiceNetworkPolicies)
		destination.PrivateLinkServiceNetworkPolicies = &privateLinkServiceNetworkPolicy
	} else {
		destination.PrivateLinkServiceNetworkPolicies = nil
	}

	// ProvisioningState
	if subnet.ProvisioningState != nil {
		provisioningState := string(*subnet.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Purpose
	destination.Purpose = genruntime.ClonePointerToString(subnet.Purpose)

	// ResourceNavigationLinks
	if subnet.ResourceNavigationLinks != nil {
		resourceNavigationLinkList := make([]v20201101s.ResourceNavigationLink_STATUS, len(subnet.ResourceNavigationLinks))
		for resourceNavigationLinkIndex, resourceNavigationLinkItem := range subnet.ResourceNavigationLinks {
			// Shadow the loop variable to avoid aliasing
			resourceNavigationLinkItem := resourceNavigationLinkItem
			var resourceNavigationLink v20201101s.ResourceNavigationLink_STATUS
			err := resourceNavigationLinkItem.AssignProperties_To_ResourceNavigationLink_STATUS(&resourceNavigationLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceNavigationLink_STATUS() to populate field ResourceNavigationLinks")
			}
			resourceNavigationLinkList[resourceNavigationLinkIndex] = resourceNavigationLink
		}
		destination.ResourceNavigationLinks = resourceNavigationLinkList
	} else {
		destination.ResourceNavigationLinks = nil
	}

	// RouteTable
	if subnet.RouteTable != nil {
		var routeTable v20201101s.RouteTable_STATUS
		err := subnet.RouteTable.AssignProperties_To_RouteTable_STATUS(&routeTable)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteTable_STATUS() to populate field RouteTable")
		}
		destination.RouteTable = &routeTable
	} else {
		destination.RouteTable = nil
	}

	// ServiceAssociationLinks
	if subnet.ServiceAssociationLinks != nil {
		serviceAssociationLinkList := make([]v20201101s.ServiceAssociationLink_STATUS, len(subnet.ServiceAssociationLinks))
		for serviceAssociationLinkIndex, serviceAssociationLinkItem := range subnet.ServiceAssociationLinks {
			// Shadow the loop variable to avoid aliasing
			serviceAssociationLinkItem := serviceAssociationLinkItem
			var serviceAssociationLink v20201101s.ServiceAssociationLink_STATUS
			err := serviceAssociationLinkItem.AssignProperties_To_ServiceAssociationLink_STATUS(&serviceAssociationLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServiceAssociationLink_STATUS() to populate field ServiceAssociationLinks")
			}
			serviceAssociationLinkList[serviceAssociationLinkIndex] = serviceAssociationLink
		}
		destination.ServiceAssociationLinks = serviceAssociationLinkList
	} else {
		destination.ServiceAssociationLinks = nil
	}

	// ServiceEndpointPolicies
	if subnet.ServiceEndpointPolicies != nil {
		serviceEndpointPolicyList := make([]v20201101s.ServiceEndpointPolicy_STATUS, len(subnet.ServiceEndpointPolicies))
		for serviceEndpointPolicyIndex, serviceEndpointPolicyItem := range subnet.ServiceEndpointPolicies {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointPolicyItem := serviceEndpointPolicyItem
			var serviceEndpointPolicy v20201101s.ServiceEndpointPolicy_STATUS
			err := serviceEndpointPolicyItem.AssignProperties_To_ServiceEndpointPolicy_STATUS(&serviceEndpointPolicy)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServiceEndpointPolicy_STATUS() to populate field ServiceEndpointPolicies")
			}
			serviceEndpointPolicyList[serviceEndpointPolicyIndex] = serviceEndpointPolicy
		}
		destination.ServiceEndpointPolicies = serviceEndpointPolicyList
	} else {
		destination.ServiceEndpointPolicies = nil
	}

	// ServiceEndpoints
	if subnet.ServiceEndpoints != nil {
		serviceEndpointList := make([]v20201101s.ServiceEndpointPropertiesFormat_STATUS, len(subnet.ServiceEndpoints))
		for serviceEndpointIndex, serviceEndpointItem := range subnet.ServiceEndpoints {
			// Shadow the loop variable to avoid aliasing
			serviceEndpointItem := serviceEndpointItem
			var serviceEndpoint v20201101s.ServiceEndpointPropertiesFormat_STATUS
			err := serviceEndpointItem.AssignProperties_To_ServiceEndpointPropertiesFormat_STATUS(&serviceEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServiceEndpointPropertiesFormat_STATUS() to populate field ServiceEndpoints")
			}
			serviceEndpointList[serviceEndpointIndex] = serviceEndpoint
		}
		destination.ServiceEndpoints = serviceEndpointList
	} else {
		destination.ServiceEndpoints = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(subnet.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type TransportProtocol string

const (
	TransportProtocol_All = TransportProtocol("All")
	TransportProtocol_Tcp = TransportProtocol("Tcp")
	TransportProtocol_Udp = TransportProtocol("Udp")
)

type TransportProtocol_STATUS string

const (
	TransportProtocol_STATUS_All = TransportProtocol_STATUS("All")
	TransportProtocol_STATUS_Tcp = TransportProtocol_STATUS("Tcp")
	TransportProtocol_STATUS_Udp = TransportProtocol_STATUS("Udp")
)

type NatGateway_STATUS struct {
	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the nat gateway.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: The provisioning state of the NAT gateway resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicIpAddresses: An array of public ip addresses associated with the nat gateway resource.
	PublicIpAddresses []SubResource_STATUS `json:"publicIpAddresses,omitempty"`

	// PublicIpPrefixes: An array of public ip prefixes associated with the nat gateway resource.
	PublicIpPrefixes []SubResource_STATUS `json:"publicIpPrefixes,omitempty"`

	// ResourceGuid: The resource GUID property of the NAT gateway resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	// Sku: The nat gateway SKU.
	Sku *NatGatewaySku_STATUS `json:"sku,omitempty"`

	// Subnets: An array of references to the subnets using this nat gateway resource.
	Subnets []SubResource_STATUS `json:"subnets,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// Zones: A list of availability zones denoting the zone in which Nat Gateway should be deployed.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &NatGateway_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *NatGateway_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NatGateway_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *NatGateway_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NatGateway_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NatGateway_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		gateway.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		gateway.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			gateway.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		gateway.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		gateway.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			gateway.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIpAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PublicIpAddresses {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.PublicIpAddresses = append(gateway.PublicIpAddresses, item1)
		}
	}

	// Set property ‘PublicIpPrefixes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PublicIpPrefixes {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.PublicIpPrefixes = append(gateway.PublicIpPrefixes, item1)
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			gateway.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 NatGatewaySku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		gateway.Sku = &sku
	}

	// Set property ‘Subnets’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			gateway.Subnets = append(gateway.Subnets, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		gateway.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			gateway.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		gateway.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		gateway.Zones = append(gateway.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_NatGateway_STATUS populates our NatGateway_STATUS from the provided source NatGateway_STATUS
func (gateway *NatGateway_STATUS) AssignProperties_From_NatGateway_STATUS(source *v20201101s.NatGateway_STATUS) error {

	// Etag
	gateway.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	gateway.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	gateway.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Location
	gateway.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	gateway.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_STATUS(*source.ProvisioningState)
		gateway.ProvisioningState = &provisioningState
	} else {
		gateway.ProvisioningState = nil
	}

	// PublicIpAddresses
	if source.PublicIpAddresses != nil {
		publicIpAddressList := make([]SubResource_STATUS, len(source.PublicIpAddresses))
		for publicIpAddressIndex, publicIpAddressItem := range source.PublicIpAddresses {
			// Shadow the loop variable to avoid aliasing
			publicIpAddressItem := publicIpAddressItem
			var publicIpAddress SubResource_STATUS
			err := publicIpAddress.AssignProperties_From_SubResource_STATUS(&publicIpAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIpAddresses")
			}
			publicIpAddressList[publicIpAddressIndex] = publicIpAddress
		}
		gateway.PublicIpAddresses = publicIpAddressList
	} else {
		gateway.PublicIpAddresses = nil
	}

	// PublicIpPrefixes
	if source.PublicIpPrefixes != nil {
		publicIpPrefixList := make([]SubResource_STATUS, len(source.PublicIpPrefixes))
		for publicIpPrefixIndex, publicIpPrefixItem := range source.PublicIpPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIpPrefixItem := publicIpPrefixItem
			var publicIpPrefix SubResource_STATUS
			err := publicIpPrefix.AssignProperties_From_SubResource_STATUS(&publicIpPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIpPrefixes")
			}
			publicIpPrefixList[publicIpPrefixIndex] = publicIpPrefix
		}
		gateway.PublicIpPrefixes = publicIpPrefixList
	} else {
		gateway.PublicIpPrefixes = nil
	}

	// ResourceGuid
	gateway.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Sku
	if source.Sku != nil {
		var sku NatGatewaySku_STATUS
		err := sku.AssignProperties_From_NatGatewaySku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NatGatewaySku_STATUS() to populate field Sku")
		}
		gateway.Sku = &sku
	} else {
		gateway.Sku = nil
	}

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]SubResource_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet SubResource_STATUS
			err := subnet.AssignProperties_From_SubResource_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		gateway.Subnets = subnetList
	} else {
		gateway.Subnets = nil
	}

	// Tags
	gateway.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	gateway.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	gateway.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_NatGateway_STATUS populates the provided destination NatGateway_STATUS from our NatGateway_STATUS
func (gateway *NatGateway_STATUS) AssignProperties_To_NatGateway_STATUS(destination *v20201101s.NatGateway_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(gateway.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(gateway.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(gateway.IdleTimeoutInMinutes)

	// Location
	destination.Location = genruntime.ClonePointerToString(gateway.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(gateway.Name)

	// ProvisioningState
	if gateway.ProvisioningState != nil {
		provisioningState := string(*gateway.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIpAddresses
	if gateway.PublicIpAddresses != nil {
		publicIpAddressList := make([]v20201101s.SubResource_STATUS, len(gateway.PublicIpAddresses))
		for publicIpAddressIndex, publicIpAddressItem := range gateway.PublicIpAddresses {
			// Shadow the loop variable to avoid aliasing
			publicIpAddressItem := publicIpAddressItem
			var publicIpAddress v20201101s.SubResource_STATUS
			err := publicIpAddressItem.AssignProperties_To_SubResource_STATUS(&publicIpAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIpAddresses")
			}
			publicIpAddressList[publicIpAddressIndex] = publicIpAddress
		}
		destination.PublicIpAddresses = publicIpAddressList
	} else {
		destination.PublicIpAddresses = nil
	}

	// PublicIpPrefixes
	if gateway.PublicIpPrefixes != nil {
		publicIpPrefixList := make([]v20201101s.SubResource_STATUS, len(gateway.PublicIpPrefixes))
		for publicIpPrefixIndex, publicIpPrefixItem := range gateway.PublicIpPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIpPrefixItem := publicIpPrefixItem
			var publicIpPrefix v20201101s.SubResource_STATUS
			err := publicIpPrefixItem.AssignProperties_To_SubResource_STATUS(&publicIpPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIpPrefixes")
			}
			publicIpPrefixList[publicIpPrefixIndex] = publicIpPrefix
		}
		destination.PublicIpPrefixes = publicIpPrefixList
	} else {
		destination.PublicIpPrefixes = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(gateway.ResourceGuid)

	// Sku
	if gateway.Sku != nil {
		var sku v20201101s.NatGatewaySku_STATUS
		err := gateway.Sku.AssignProperties_To_NatGatewaySku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NatGatewaySku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Subnets
	if gateway.Subnets != nil {
		subnetList := make([]v20201101s.SubResource_STATUS, len(gateway.Subnets))
		for subnetIndex, subnetItem := range gateway.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet v20201101s.SubResource_STATUS
			err := subnetItem.AssignProperties_To_SubResource_STATUS(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(gateway.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(gateway.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(gateway.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
