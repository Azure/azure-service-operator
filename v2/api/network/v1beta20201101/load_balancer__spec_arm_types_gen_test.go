// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_SpecARM, LoadBalancer_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_SpecARM runs a test to see if a specific instance of LoadBalancer_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_SpecARM(subject LoadBalancer_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_SpecARM instances for property testing - lazily instantiated by
// LoadBalancer_SpecARMGenerator()
var loadBalancer_SpecARMGenerator gopter.Gen

// LoadBalancer_SpecARMGenerator returns a generator of LoadBalancer_SpecARM instances for property testing.
// We first initialize loadBalancer_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_SpecARMGenerator() gopter.Gen {
	if loadBalancer_SpecARMGenerator != nil {
		return loadBalancer_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	loadBalancer_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	loadBalancer_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_SpecARM{}), generators)

	return loadBalancer_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormatARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone))
}

func Test_LoadBalancerPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormatARM, LoadBalancerPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormatARM runs a test to see if a specific instance of LoadBalancerPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormatARM(subject LoadBalancerPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancerPropertiesFormatARMGenerator()
var loadBalancerPropertiesFormatARMGenerator gopter.Gen

// LoadBalancerPropertiesFormatARMGenerator returns a generator of LoadBalancerPropertiesFormatARM instances for property testing.
// We first initialize loadBalancerPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerPropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormatARMGenerator != nil {
		return loadBalancerPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatARM(generators)
	loadBalancerPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM(generators)
	loadBalancerPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormatARM{}), generators)

	return loadBalancerPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleARMGenerator())
	gens["Probes"] = gen.SliceOf(ProbeARMGenerator())
}

func Test_LoadBalancerSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuARM, LoadBalancerSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuARM runs a test to see if a specific instance of LoadBalancerSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuARM(subject LoadBalancerSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSkuARM instances for property testing - lazily instantiated by LoadBalancerSkuARMGenerator()
var loadBalancerSkuARMGenerator gopter.Gen

// LoadBalancerSkuARMGenerator returns a generator of LoadBalancerSkuARM instances for property testing.
func LoadBalancerSkuARMGenerator() gopter.Gen {
	if loadBalancerSkuARMGenerator != nil {
		return loadBalancerSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(generators)
	loadBalancerSkuARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSkuARM{}), generators)

	return loadBalancerSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM, BackendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM(subject BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by BackendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator()
var backendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// BackendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func BackendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if backendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return backendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM(generators)
	backendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return backendAddressPool_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolARM, InboundNatPoolARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolARM runs a test to see if a specific instance of InboundNatPoolARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolARM(subject InboundNatPoolARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolARM instances for property testing - lazily instantiated by InboundNatPoolARMGenerator()
var inboundNatPoolARMGenerator gopter.Gen

// InboundNatPoolARMGenerator returns a generator of InboundNatPoolARM instances for property testing.
// We first initialize inboundNatPoolARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolARMGenerator() gopter.Gen {
	if inboundNatPoolARMGenerator != nil {
		return inboundNatPoolARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolARM(generators)
	inboundNatPoolARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolARM(generators)
	inboundNatPoolARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolARM{}), generators)

	return inboundNatPoolARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPoolARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatARMGenerator())
}

func Test_InboundNatRule_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM, InboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of InboundNatRule_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM(subject InboundNatRule_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated
// by InboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator()
var inboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// InboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of InboundNatRule_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func InboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if inboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return inboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM(generators)
	inboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return inboundNatRule_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleARM, LoadBalancingRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleARM runs a test to see if a specific instance of LoadBalancingRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleARM(subject LoadBalancingRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRuleARM instances for property testing - lazily instantiated by
// LoadBalancingRuleARMGenerator()
var loadBalancingRuleARMGenerator gopter.Gen

// LoadBalancingRuleARMGenerator returns a generator of LoadBalancingRuleARM instances for property testing.
// We first initialize loadBalancingRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleARMGenerator() gopter.Gen {
	if loadBalancingRuleARMGenerator != nil {
		return loadBalancingRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(generators)
	loadBalancingRuleARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleARM(generators)
	loadBalancingRuleARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRuleARM{}), generators)

	return loadBalancingRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatARMGenerator())
}

func Test_OutboundRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleARM, OutboundRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleARM runs a test to see if a specific instance of OutboundRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleARM(subject OutboundRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRuleARM instances for property testing - lazily instantiated by OutboundRuleARMGenerator()
var outboundRuleARMGenerator gopter.Gen

// OutboundRuleARMGenerator returns a generator of OutboundRuleARM instances for property testing.
// We first initialize outboundRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleARMGenerator() gopter.Gen {
	if outboundRuleARMGenerator != nil {
		return outboundRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleARM(generators)
	outboundRuleARMGenerator = gen.Struct(reflect.TypeOf(OutboundRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleARM(generators)
	outboundRuleARMGenerator = gen.Struct(reflect.TypeOf(OutboundRuleARM{}), generators)

	return outboundRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatARMGenerator())
}

func Test_ProbeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeARM, ProbeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeARM runs a test to see if a specific instance of ProbeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeARM(subject ProbeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbeARM instances for property testing - lazily instantiated by ProbeARMGenerator()
var probeARMGenerator gopter.Gen

// ProbeARMGenerator returns a generator of ProbeARM instances for property testing.
// We first initialize probeARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbeARMGenerator() gopter.Gen {
	if probeARMGenerator != nil {
		return probeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeARM(generators)
	probeARMGenerator = gen.Struct(reflect.TypeOf(ProbeARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeARM(generators)
	AddRelatedPropertyGeneratorsForProbeARM(generators)
	probeARMGenerator = gen.Struct(reflect.TypeOf(ProbeARM{}), generators)

	return probeARMGenerator
}

// AddIndependentPropertyGeneratorsForProbeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbeARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM instances for property
// testing - lazily instantiated by FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResourceARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResourceARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResourceARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM, InboundNatPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM(subject InboundNatPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormatARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormatARMGenerator()
var inboundNatPoolPropertiesFormatARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatARMGenerator returns a generator of InboundNatPoolPropertiesFormatARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatARMGenerator != nil {
		return inboundNatPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	return inboundNatPoolPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM, LoadBalancingRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM(subject LoadBalancingRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormatARMGenerator()
var loadBalancingRulePropertiesFormatARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatARMGenerator returns a generator of LoadBalancingRulePropertiesFormatARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatARMGenerator != nil {
		return loadBalancingRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	return loadBalancingRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_OutboundRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatARM, OutboundRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatARM runs a test to see if a specific instance of OutboundRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatARM(subject OutboundRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormatARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormatARMGenerator()
var outboundRulePropertiesFormatARMGenerator gopter.Gen

// OutboundRulePropertiesFormatARMGenerator returns a generator of OutboundRulePropertiesFormatARM instances for property testing.
// We first initialize outboundRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatARMGenerator != nil {
		return outboundRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	return outboundRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_ProbePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatARM, ProbePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatARM runs a test to see if a specific instance of ProbePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatARM(subject ProbePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormatARM instances for property testing - lazily instantiated by
// ProbePropertiesFormatARMGenerator()
var probePropertiesFormatARMGenerator gopter.Gen

// ProbePropertiesFormatARMGenerator returns a generator of ProbePropertiesFormatARM instances for property testing.
// We first initialize probePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbePropertiesFormatARMGenerator() gopter.Gen {
	if probePropertiesFormatARMGenerator != nil {
		return probePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(generators)
	probePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForProbePropertiesFormatARM(generators)
	probePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormatARM{}), generators)

	return probePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Succeeded,
		ProvisioningState_Updating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM, PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(subject PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_Subnet_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_LoadBalancer_SubResourceEmbeddedARM, Subnet_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_LoadBalancer_SubResourceEmbeddedARM(subject Subnet_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
// Subnet_LoadBalancer_SubResourceEmbeddedARMGenerator()
var subnet_LoadBalancer_SubResourceEmbeddedARMGenerator gopter.Gen

// Subnet_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of Subnet_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func Subnet_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_LoadBalancer_SubResourceEmbeddedARMGenerator != nil {
		return subnet_LoadBalancer_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_LoadBalancer_SubResourceEmbeddedARM(generators)
	subnet_LoadBalancer_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return subnet_LoadBalancer_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
