// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualNetworksSubnet_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworksSubnet_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworksSubnet_SpecARM, VirtualNetworksSubnet_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworksSubnet_SpecARM runs a test to see if a specific instance of VirtualNetworksSubnet_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworksSubnet_SpecARM(subject VirtualNetworksSubnet_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworksSubnet_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworksSubnet_SpecARM instances for property testing - lazily instantiated by
// VirtualNetworksSubnet_SpecARMGenerator()
var virtualNetworksSubnet_SpecARMGenerator gopter.Gen

// VirtualNetworksSubnet_SpecARMGenerator returns a generator of VirtualNetworksSubnet_SpecARM instances for property testing.
// We first initialize virtualNetworksSubnet_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworksSubnet_SpecARMGenerator() gopter.Gen {
	if virtualNetworksSubnet_SpecARMGenerator != nil {
		return virtualNetworksSubnet_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworksSubnet_SpecARM(generators)
	virtualNetworksSubnet_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworksSubnet_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworksSubnet_SpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworksSubnet_SpecARM(generators)
	virtualNetworksSubnet_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworksSubnet_SpecARM{}), generators)

	return virtualNetworksSubnet_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworksSubnet_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworksSubnet_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworksSubnet_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworksSubnet_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SubnetPropertiesFormatARMGenerator())
}

func Test_SubnetPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubnetPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetPropertiesFormatARM, SubnetPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetPropertiesFormatARM runs a test to see if a specific instance of SubnetPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetPropertiesFormatARM(subject SubnetPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubnetPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubnetPropertiesFormatARM instances for property testing - lazily instantiated by
// SubnetPropertiesFormatARMGenerator()
var subnetPropertiesFormatARMGenerator gopter.Gen

// SubnetPropertiesFormatARMGenerator returns a generator of SubnetPropertiesFormatARM instances for property testing.
// We first initialize subnetPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SubnetPropertiesFormatARMGenerator() gopter.Gen {
	if subnetPropertiesFormatARMGenerator != nil {
		return subnetPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetPropertiesFormatARM(generators)
	subnetPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(SubnetPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForSubnetPropertiesFormatARM(generators)
	subnetPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(SubnetPropertiesFormatARM{}), generators)

	return subnetPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnetPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AddressPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["AddressPrefixes"] = gen.SliceOf(gen.AlphaString())
	gens["PrivateEndpointNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateEndpointNetworkPoliciesDisabled, SubnetPropertiesFormat_PrivateEndpointNetworkPoliciesEnabled))
	gens["PrivateLinkServiceNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateLinkServiceNetworkPoliciesDisabled, SubnetPropertiesFormat_PrivateLinkServiceNetworkPoliciesEnabled))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
	gens["Purpose"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSubnetPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSubnetPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayIpConfigurations"] = gen.SliceOf(ApplicationGatewayIPConfigurationARMGenerator())
	gens["Delegations"] = gen.SliceOf(DelegationARMGenerator())
	gens["IpAllocations"] = gen.SliceOf(SubResourceARMGenerator())
	gens["IpConfigurationProfiles"] = gen.SliceOf(IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
	gens["NatGateway"] = gen.PtrOf(SubResourceARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
	gens["ResourceNavigationLinks"] = gen.SliceOf(ResourceNavigationLinkARMGenerator())
	gens["RouteTable"] = gen.PtrOf(RouteTableSpecARMGenerator())
	gens["ServiceAssociationLinks"] = gen.SliceOf(ServiceAssociationLinkARMGenerator())
	gens["ServiceEndpointPolicies"] = gen.SliceOf(ServiceEndpointPolicySpecARMGenerator())
	gens["ServiceEndpoints"] = gen.SliceOf(ServiceEndpointPropertiesFormatARMGenerator())
}

func Test_ApplicationGatewayIPConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayIPConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayIPConfigurationARM, ApplicationGatewayIPConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayIPConfigurationARM runs a test to see if a specific instance of ApplicationGatewayIPConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayIPConfigurationARM(subject ApplicationGatewayIPConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayIPConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayIPConfigurationARM instances for property testing - lazily instantiated by
// ApplicationGatewayIPConfigurationARMGenerator()
var applicationGatewayIPConfigurationARMGenerator gopter.Gen

// ApplicationGatewayIPConfigurationARMGenerator returns a generator of ApplicationGatewayIPConfigurationARM instances for property testing.
// We first initialize applicationGatewayIPConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayIPConfigurationARMGenerator() gopter.Gen {
	if applicationGatewayIPConfigurationARMGenerator != nil {
		return applicationGatewayIPConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationARM(generators)
	applicationGatewayIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayIPConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationARM(generators)
	applicationGatewayIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayIPConfigurationARM{}), generators)

	return applicationGatewayIPConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ApplicationGatewayIPConfigurationPropertiesFormatARMGenerator())
}

func Test_DelegationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DelegationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDelegationARM, DelegationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDelegationARM runs a test to see if a specific instance of DelegationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDelegationARM(subject DelegationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DelegationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DelegationARM instances for property testing - lazily instantiated by DelegationARMGenerator()
var delegationARMGenerator gopter.Gen

// DelegationARMGenerator returns a generator of DelegationARM instances for property testing.
// We first initialize delegationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DelegationARMGenerator() gopter.Gen {
	if delegationARMGenerator != nil {
		return delegationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDelegationARM(generators)
	delegationARMGenerator = gen.Struct(reflect.TypeOf(DelegationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDelegationARM(generators)
	AddRelatedPropertyGeneratorsForDelegationARM(generators)
	delegationARMGenerator = gen.Struct(reflect.TypeOf(DelegationARM{}), generators)

	return delegationARMGenerator
}

// AddIndependentPropertyGeneratorsForDelegationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDelegationARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDelegationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDelegationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceDelegationPropertiesFormatARMGenerator())
}

func Test_IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM, IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing -
// lazily instantiated by IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationProfile_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
}

func Test_IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM, IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return ipConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfiguration_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
}

func Test_NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM, NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing -
// lazily instantiated by NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var networkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
func NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if networkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return networkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	networkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return networkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM, PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return privateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
}

func Test_ResourceNavigationLinkARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceNavigationLinkARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceNavigationLinkARM, ResourceNavigationLinkARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceNavigationLinkARM runs a test to see if a specific instance of ResourceNavigationLinkARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceNavigationLinkARM(subject ResourceNavigationLinkARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceNavigationLinkARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceNavigationLinkARM instances for property testing - lazily instantiated by
// ResourceNavigationLinkARMGenerator()
var resourceNavigationLinkARMGenerator gopter.Gen

// ResourceNavigationLinkARMGenerator returns a generator of ResourceNavigationLinkARM instances for property testing.
// We first initialize resourceNavigationLinkARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceNavigationLinkARMGenerator() gopter.Gen {
	if resourceNavigationLinkARMGenerator != nil {
		return resourceNavigationLinkARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceNavigationLinkARM(generators)
	resourceNavigationLinkARMGenerator = gen.Struct(reflect.TypeOf(ResourceNavigationLinkARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceNavigationLinkARM(generators)
	AddRelatedPropertyGeneratorsForResourceNavigationLinkARM(generators)
	resourceNavigationLinkARMGenerator = gen.Struct(reflect.TypeOf(ResourceNavigationLinkARM{}), generators)

	return resourceNavigationLinkARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceNavigationLinkARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceNavigationLinkARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForResourceNavigationLinkARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceNavigationLinkARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ResourceNavigationLinkFormatARMGenerator())
}

func Test_RouteTableSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteTableSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteTableSpecARM, RouteTableSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteTableSpecARM runs a test to see if a specific instance of RouteTableSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteTableSpecARM(subject RouteTableSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteTableSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteTableSpecARM instances for property testing - lazily instantiated by RouteTableSpecARMGenerator()
var routeTableSpecARMGenerator gopter.Gen

// RouteTableSpecARMGenerator returns a generator of RouteTableSpecARM instances for property testing.
func RouteTableSpecARMGenerator() gopter.Gen {
	if routeTableSpecARMGenerator != nil {
		return routeTableSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteTableSpecARM(generators)
	routeTableSpecARMGenerator = gen.Struct(reflect.TypeOf(RouteTableSpecARM{}), generators)

	return routeTableSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForRouteTableSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteTableSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceAssociationLinkARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceAssociationLinkARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceAssociationLinkARM, ServiceAssociationLinkARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceAssociationLinkARM runs a test to see if a specific instance of ServiceAssociationLinkARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceAssociationLinkARM(subject ServiceAssociationLinkARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceAssociationLinkARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceAssociationLinkARM instances for property testing - lazily instantiated by
// ServiceAssociationLinkARMGenerator()
var serviceAssociationLinkARMGenerator gopter.Gen

// ServiceAssociationLinkARMGenerator returns a generator of ServiceAssociationLinkARM instances for property testing.
// We first initialize serviceAssociationLinkARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceAssociationLinkARMGenerator() gopter.Gen {
	if serviceAssociationLinkARMGenerator != nil {
		return serviceAssociationLinkARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceAssociationLinkARM(generators)
	serviceAssociationLinkARMGenerator = gen.Struct(reflect.TypeOf(ServiceAssociationLinkARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceAssociationLinkARM(generators)
	AddRelatedPropertyGeneratorsForServiceAssociationLinkARM(generators)
	serviceAssociationLinkARMGenerator = gen.Struct(reflect.TypeOf(ServiceAssociationLinkARM{}), generators)

	return serviceAssociationLinkARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceAssociationLinkARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceAssociationLinkARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForServiceAssociationLinkARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceAssociationLinkARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceAssociationLinkPropertiesFormatARMGenerator())
}

func Test_ServiceEndpointPolicySpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceEndpointPolicySpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceEndpointPolicySpecARM, ServiceEndpointPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceEndpointPolicySpecARM runs a test to see if a specific instance of ServiceEndpointPolicySpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceEndpointPolicySpecARM(subject ServiceEndpointPolicySpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceEndpointPolicySpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceEndpointPolicySpecARM instances for property testing - lazily instantiated by
// ServiceEndpointPolicySpecARMGenerator()
var serviceEndpointPolicySpecARMGenerator gopter.Gen

// ServiceEndpointPolicySpecARMGenerator returns a generator of ServiceEndpointPolicySpecARM instances for property testing.
func ServiceEndpointPolicySpecARMGenerator() gopter.Gen {
	if serviceEndpointPolicySpecARMGenerator != nil {
		return serviceEndpointPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceEndpointPolicySpecARM(generators)
	serviceEndpointPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(ServiceEndpointPolicySpecARM{}), generators)

	return serviceEndpointPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceEndpointPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceEndpointPolicySpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceEndpointPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceEndpointPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceEndpointPropertiesFormatARM, ServiceEndpointPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceEndpointPropertiesFormatARM runs a test to see if a specific instance of ServiceEndpointPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceEndpointPropertiesFormatARM(subject ServiceEndpointPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceEndpointPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceEndpointPropertiesFormatARM instances for property testing - lazily instantiated by
// ServiceEndpointPropertiesFormatARMGenerator()
var serviceEndpointPropertiesFormatARMGenerator gopter.Gen

// ServiceEndpointPropertiesFormatARMGenerator returns a generator of ServiceEndpointPropertiesFormatARM instances for property testing.
func ServiceEndpointPropertiesFormatARMGenerator() gopter.Gen {
	if serviceEndpointPropertiesFormatARMGenerator != nil {
		return serviceEndpointPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceEndpointPropertiesFormatARM(generators)
	serviceEndpointPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ServiceEndpointPropertiesFormatARM{}), generators)

	return serviceEndpointPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceEndpointPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceEndpointPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["Locations"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
	gens["Service"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayIPConfigurationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayIPConfigurationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayIPConfigurationPropertiesFormatARM, ApplicationGatewayIPConfigurationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayIPConfigurationPropertiesFormatARM runs a test to see if a specific instance of ApplicationGatewayIPConfigurationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayIPConfigurationPropertiesFormatARM(subject ApplicationGatewayIPConfigurationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayIPConfigurationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayIPConfigurationPropertiesFormatARM instances for property testing - lazily
// instantiated by ApplicationGatewayIPConfigurationPropertiesFormatARMGenerator()
var applicationGatewayIPConfigurationPropertiesFormatARMGenerator gopter.Gen

// ApplicationGatewayIPConfigurationPropertiesFormatARMGenerator returns a generator of ApplicationGatewayIPConfigurationPropertiesFormatARM instances for property testing.
// We first initialize applicationGatewayIPConfigurationPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayIPConfigurationPropertiesFormatARMGenerator() gopter.Gen {
	if applicationGatewayIPConfigurationPropertiesFormatARMGenerator != nil {
		return applicationGatewayIPConfigurationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM(generators)
	applicationGatewayIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayIPConfigurationPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM(generators)
	applicationGatewayIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayIPConfigurationPropertiesFormatARM{}), generators)

	return applicationGatewayIPConfigurationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

// AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM, IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for
// property testing - lazily instantiated by
// IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

// AddRelatedPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationProfilePropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
}

func Test_IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM, IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property
// testing - lazily instantiated by IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethodDynamic, IPAllocationMethodStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

// AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator())
}

func Test_ResourceNavigationLinkFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceNavigationLinkFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceNavigationLinkFormatARM, ResourceNavigationLinkFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceNavigationLinkFormatARM runs a test to see if a specific instance of ResourceNavigationLinkFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceNavigationLinkFormatARM(subject ResourceNavigationLinkFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceNavigationLinkFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceNavigationLinkFormatARM instances for property testing - lazily instantiated by
// ResourceNavigationLinkFormatARMGenerator()
var resourceNavigationLinkFormatARMGenerator gopter.Gen

// ResourceNavigationLinkFormatARMGenerator returns a generator of ResourceNavigationLinkFormatARM instances for property testing.
func ResourceNavigationLinkFormatARMGenerator() gopter.Gen {
	if resourceNavigationLinkFormatARMGenerator != nil {
		return resourceNavigationLinkFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceNavigationLinkFormatARM(generators)
	resourceNavigationLinkFormatARMGenerator = gen.Struct(reflect.TypeOf(ResourceNavigationLinkFormatARM{}), generators)

	return resourceNavigationLinkFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceNavigationLinkFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceNavigationLinkFormatARM(gens map[string]gopter.Gen) {
	gens["Link"] = gen.PtrOf(gen.AlphaString())
	gens["LinkedResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

func Test_ServiceAssociationLinkPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceAssociationLinkPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceAssociationLinkPropertiesFormatARM, ServiceAssociationLinkPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceAssociationLinkPropertiesFormatARM runs a test to see if a specific instance of ServiceAssociationLinkPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceAssociationLinkPropertiesFormatARM(subject ServiceAssociationLinkPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceAssociationLinkPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceAssociationLinkPropertiesFormatARM instances for property testing - lazily instantiated by
// ServiceAssociationLinkPropertiesFormatARMGenerator()
var serviceAssociationLinkPropertiesFormatARMGenerator gopter.Gen

// ServiceAssociationLinkPropertiesFormatARMGenerator returns a generator of ServiceAssociationLinkPropertiesFormatARM instances for property testing.
func ServiceAssociationLinkPropertiesFormatARMGenerator() gopter.Gen {
	if serviceAssociationLinkPropertiesFormatARMGenerator != nil {
		return serviceAssociationLinkPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceAssociationLinkPropertiesFormatARM(generators)
	serviceAssociationLinkPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ServiceAssociationLinkPropertiesFormatARM{}), generators)

	return serviceAssociationLinkPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceAssociationLinkPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceAssociationLinkPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AllowDelete"] = gen.PtrOf(gen.Bool())
	gens["Link"] = gen.PtrOf(gen.AlphaString())
	gens["LinkedResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["Locations"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

func Test_ServiceDelegationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceDelegationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceDelegationPropertiesFormatARM, ServiceDelegationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceDelegationPropertiesFormatARM runs a test to see if a specific instance of ServiceDelegationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceDelegationPropertiesFormatARM(subject ServiceDelegationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceDelegationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceDelegationPropertiesFormatARM instances for property testing - lazily instantiated by
// ServiceDelegationPropertiesFormatARMGenerator()
var serviceDelegationPropertiesFormatARMGenerator gopter.Gen

// ServiceDelegationPropertiesFormatARMGenerator returns a generator of ServiceDelegationPropertiesFormatARM instances for property testing.
func ServiceDelegationPropertiesFormatARMGenerator() gopter.Gen {
	if serviceDelegationPropertiesFormatARMGenerator != nil {
		return serviceDelegationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceDelegationPropertiesFormatARM(generators)
	serviceDelegationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ServiceDelegationPropertiesFormatARM{}), generators)

	return serviceDelegationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceDelegationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceDelegationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
	gens["ServiceName"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM, PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM, Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM(subject Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing - lazily instantiated
// by Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator()
var subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator gopter.Gen

// Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator returns a generator of Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM instances for property testing.
func Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator != nil {
		return subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM(generators)
	subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_VirtualNetworksSubnet_SubResourceEmbeddedARM{}), generators)

	return subnet_VirtualNetworksSubnet_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_VirtualNetworksSubnet_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
