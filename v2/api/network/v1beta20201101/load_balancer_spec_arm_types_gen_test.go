// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Spec_ARM, LoadBalancer_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Spec_ARM(subject LoadBalancer_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Spec_ARMGenerator()
var loadBalancer_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Spec_ARMGenerator returns a generator of LoadBalancer_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Spec_ARMGenerator != nil {
		return loadBalancer_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	loadBalancer_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	loadBalancer_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec_ARM{}), generators)

	return loadBalancer_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormat_ARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_ARMGenerator())
}

func Test_ExtendedLocation_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_ARM, ExtendedLocation_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_ARM runs a test to see if a specific instance of ExtendedLocation_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_ARM(subject ExtendedLocation_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_ARM instances for property testing - lazily instantiated by
// ExtendedLocation_ARMGenerator()
var extendedLocation_ARMGenerator gopter.Gen

// ExtendedLocation_ARMGenerator returns a generator of ExtendedLocation_ARM instances for property testing.
func ExtendedLocation_ARMGenerator() gopter.Gen {
	if extendedLocation_ARMGenerator != nil {
		return extendedLocation_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_ARM(generators)
	extendedLocation_ARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_ARM{}), generators)

	return extendedLocation_ARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone))
}

func Test_LoadBalancerPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormat_ARM, LoadBalancerPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormat_ARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormat_ARM(subject LoadBalancerPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_ARM instances for property testing - lazily instantiated by
// LoadBalancerPropertiesFormat_ARMGenerator()
var loadBalancerPropertiesFormat_ARMGenerator gopter.Gen

// LoadBalancerPropertiesFormat_ARMGenerator returns a generator of LoadBalancerPropertiesFormat_ARM instances for property testing.
func LoadBalancerPropertiesFormat_ARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormat_ARMGenerator != nil {
		return loadBalancerPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_ARM(generators)
	loadBalancerPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_ARM{}), generators)

	return loadBalancerPropertiesFormat_ARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_ARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_ARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_ARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_ARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_ARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_ARMGenerator())
	gens["Probes"] = gen.SliceOf(Probe_ARMGenerator())
}

func Test_LoadBalancerSku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_ARM, LoadBalancerSku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_ARM runs a test to see if a specific instance of LoadBalancerSku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_ARM(subject LoadBalancerSku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_ARM instances for property testing - lazily instantiated by
// LoadBalancerSku_ARMGenerator()
var loadBalancerSku_ARMGenerator gopter.Gen

// LoadBalancerSku_ARMGenerator returns a generator of LoadBalancerSku_ARM instances for property testing.
func LoadBalancerSku_ARMGenerator() gopter.Gen {
	if loadBalancerSku_ARMGenerator != nil {
		return loadBalancerSku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM(generators)
	loadBalancerSku_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_ARM{}), generators)

	return loadBalancerSku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_BackendAddressPool_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_ARM, BackendAddressPool_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_ARM runs a test to see if a specific instance of BackendAddressPool_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_ARM(subject BackendAddressPool_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_ARM instances for property testing - lazily instantiated by
// BackendAddressPool_ARMGenerator()
var backendAddressPool_ARMGenerator gopter.Gen

// BackendAddressPool_ARMGenerator returns a generator of BackendAddressPool_ARM instances for property testing.
// We first initialize backendAddressPool_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPool_ARMGenerator() gopter.Gen {
	if backendAddressPool_ARMGenerator != nil {
		return backendAddressPool_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_ARM(generators)
	backendAddressPool_ARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_ARM(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPool_ARM(generators)
	backendAddressPool_ARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_ARM{}), generators)

	return backendAddressPool_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendAddressPool_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPool_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackendAddressPoolPropertiesFormat_ARMGenerator())
}

func Test_FrontendIPConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_ARM, FrontendIPConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_ARM runs a test to see if a specific instance of FrontendIPConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_ARM(subject FrontendIPConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_ARM instances for property testing - lazily instantiated by
// FrontendIPConfiguration_ARMGenerator()
var frontendIPConfiguration_ARMGenerator gopter.Gen

// FrontendIPConfiguration_ARMGenerator returns a generator of FrontendIPConfiguration_ARM instances for property testing.
// We first initialize frontendIPConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_ARMGenerator() gopter.Gen {
	if frontendIPConfiguration_ARMGenerator != nil {
		return frontendIPConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_ARM(generators)
	frontendIPConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_ARM(generators)
	frontendIPConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_ARM{}), generators)

	return frontendIPConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_ARMGenerator())
}

func Test_InboundNatPool_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_ARM, InboundNatPool_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_ARM runs a test to see if a specific instance of InboundNatPool_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_ARM(subject InboundNatPool_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_ARM instances for property testing - lazily instantiated by InboundNatPool_ARMGenerator()
var inboundNatPool_ARMGenerator gopter.Gen

// InboundNatPool_ARMGenerator returns a generator of InboundNatPool_ARM instances for property testing.
// We first initialize inboundNatPool_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_ARMGenerator() gopter.Gen {
	if inboundNatPool_ARMGenerator != nil {
		return inboundNatPool_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_ARM(generators)
	inboundNatPool_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_ARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_ARM(generators)
	inboundNatPool_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_ARM{}), generators)

	return inboundNatPool_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormat_ARMGenerator())
}

func Test_InboundNatRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_ARM, InboundNatRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_ARM runs a test to see if a specific instance of InboundNatRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_ARM(subject InboundNatRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_ARM instances for property testing - lazily instantiated by InboundNatRule_ARMGenerator()
var inboundNatRule_ARMGenerator gopter.Gen

// InboundNatRule_ARMGenerator returns a generator of InboundNatRule_ARM instances for property testing.
// We first initialize inboundNatRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRule_ARMGenerator() gopter.Gen {
	if inboundNatRule_ARMGenerator != nil {
		return inboundNatRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_ARM(generators)
	inboundNatRule_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_ARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRule_ARM(generators)
	inboundNatRule_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_ARM{}), generators)

	return inboundNatRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRule_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatRulePropertiesFormat_ARMGenerator())
}

func Test_LoadBalancingRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_ARM, LoadBalancingRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_ARM runs a test to see if a specific instance of LoadBalancingRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_ARM(subject LoadBalancingRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_ARM instances for property testing - lazily instantiated by
// LoadBalancingRule_ARMGenerator()
var loadBalancingRule_ARMGenerator gopter.Gen

// LoadBalancingRule_ARMGenerator returns a generator of LoadBalancingRule_ARM instances for property testing.
// We first initialize loadBalancingRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_ARMGenerator() gopter.Gen {
	if loadBalancingRule_ARMGenerator != nil {
		return loadBalancingRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_ARM(generators)
	loadBalancingRule_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_ARM(generators)
	loadBalancingRule_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_ARM{}), generators)

	return loadBalancingRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormat_ARMGenerator())
}

func Test_OutboundRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_ARM, OutboundRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_ARM runs a test to see if a specific instance of OutboundRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_ARM(subject OutboundRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_ARM instances for property testing - lazily instantiated by OutboundRule_ARMGenerator()
var outboundRule_ARMGenerator gopter.Gen

// OutboundRule_ARMGenerator returns a generator of OutboundRule_ARM instances for property testing.
// We first initialize outboundRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_ARMGenerator() gopter.Gen {
	if outboundRule_ARMGenerator != nil {
		return outboundRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_ARM(generators)
	outboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_ARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_ARM(generators)
	outboundRule_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_ARM{}), generators)

	return outboundRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormat_ARMGenerator())
}

func Test_Probe_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_ARM, Probe_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_ARM runs a test to see if a specific instance of Probe_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_ARM(subject Probe_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_ARM instances for property testing - lazily instantiated by Probe_ARMGenerator()
var probe_ARMGenerator gopter.Gen

// Probe_ARMGenerator returns a generator of Probe_ARM instances for property testing.
// We first initialize probe_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_ARMGenerator() gopter.Gen {
	if probe_ARMGenerator != nil {
		return probe_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_ARM(generators)
	probe_ARMGenerator = gen.Struct(reflect.TypeOf(Probe_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_ARM(generators)
	AddRelatedPropertyGeneratorsForProbe_ARM(generators)
	probe_ARMGenerator = gen.Struct(reflect.TypeOf(Probe_ARM{}), generators)

	return probe_ARMGenerator
}

// AddIndependentPropertyGeneratorsForProbe_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormat_ARMGenerator())
}

func Test_BackendAddressPoolPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPoolPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_ARM, BackendAddressPoolPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_ARM runs a test to see if a specific instance of BackendAddressPoolPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_ARM(subject BackendAddressPoolPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPoolPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPoolPropertiesFormat_ARM instances for property testing - lazily instantiated by
// BackendAddressPoolPropertiesFormat_ARMGenerator()
var backendAddressPoolPropertiesFormat_ARMGenerator gopter.Gen

// BackendAddressPoolPropertiesFormat_ARMGenerator returns a generator of BackendAddressPoolPropertiesFormat_ARM instances for property testing.
func BackendAddressPoolPropertiesFormat_ARMGenerator() gopter.Gen {
	if backendAddressPoolPropertiesFormat_ARMGenerator != nil {
		return backendAddressPoolPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_ARM(generators)
	backendAddressPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolPropertiesFormat_ARM{}), generators)

	return backendAddressPoolPropertiesFormat_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancerBackendAddress_ARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM, FrontendIPConfigurationPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM(subject FrontendIPConfigurationPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_ARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormat_ARMGenerator()
var frontendIPConfigurationPropertiesFormat_ARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_ARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_ARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_ARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_ARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	frontendIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	frontendIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_ARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_ARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_ARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM, InboundNatPoolPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM(subject InboundNatPoolPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_ARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormat_ARMGenerator()
var inboundNatPoolPropertiesFormat_ARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormat_ARMGenerator returns a generator of InboundNatPoolPropertiesFormat_ARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormat_ARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormat_ARMGenerator != nil {
		return inboundNatPoolPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	inboundNatPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	inboundNatPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_ARM{}), generators)

	return inboundNatPoolPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_InboundNatRulePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRulePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRulePropertiesFormat_ARM, InboundNatRulePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRulePropertiesFormat_ARM runs a test to see if a specific instance of InboundNatRulePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRulePropertiesFormat_ARM(subject InboundNatRulePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRulePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRulePropertiesFormat_ARM instances for property testing - lazily instantiated by
// InboundNatRulePropertiesFormat_ARMGenerator()
var inboundNatRulePropertiesFormat_ARMGenerator gopter.Gen

// InboundNatRulePropertiesFormat_ARMGenerator returns a generator of InboundNatRulePropertiesFormat_ARM instances for property testing.
// We first initialize inboundNatRulePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRulePropertiesFormat_ARMGenerator() gopter.Gen {
	if inboundNatRulePropertiesFormat_ARMGenerator != nil {
		return inboundNatRulePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM(generators)
	inboundNatRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM(generators)
	inboundNatRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormat_ARM{}), generators)

	return inboundNatRulePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM, LoadBalancingRulePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM(subject LoadBalancingRulePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_ARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormat_ARMGenerator()
var loadBalancingRulePropertiesFormat_ARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormat_ARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_ARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormat_ARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormat_ARMGenerator != nil {
		return loadBalancingRulePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	loadBalancingRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	loadBalancingRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_ARM{}), generators)

	return loadBalancingRulePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_OutboundRulePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM, OutboundRulePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM(subject OutboundRulePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_ARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormat_ARMGenerator()
var outboundRulePropertiesFormat_ARMGenerator gopter.Gen

// OutboundRulePropertiesFormat_ARMGenerator returns a generator of OutboundRulePropertiesFormat_ARM instances for property testing.
// We first initialize outboundRulePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormat_ARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormat_ARMGenerator != nil {
		return outboundRulePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	outboundRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	outboundRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_ARM{}), generators)

	return outboundRulePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_ARMGenerator())
}

func Test_ProbePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormat_ARM, ProbePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormat_ARM runs a test to see if a specific instance of ProbePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormat_ARM(subject ProbePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_ARM instances for property testing - lazily instantiated by
// ProbePropertiesFormat_ARMGenerator()
var probePropertiesFormat_ARMGenerator gopter.Gen

// ProbePropertiesFormat_ARMGenerator returns a generator of ProbePropertiesFormat_ARM instances for property testing.
func ProbePropertiesFormat_ARMGenerator() gopter.Gen {
	if probePropertiesFormat_ARMGenerator != nil {
		return probePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM(generators)
	probePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_ARM{}), generators)

	return probePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancerBackendAddress_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddress_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddress_ARM, LoadBalancerBackendAddress_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddress_ARM runs a test to see if a specific instance of LoadBalancerBackendAddress_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddress_ARM(subject LoadBalancerBackendAddress_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddress_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddress_ARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddress_ARMGenerator()
var loadBalancerBackendAddress_ARMGenerator gopter.Gen

// LoadBalancerBackendAddress_ARMGenerator returns a generator of LoadBalancerBackendAddress_ARM instances for property testing.
// We first initialize loadBalancerBackendAddress_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddress_ARMGenerator() gopter.Gen {
	if loadBalancerBackendAddress_ARMGenerator != nil {
		return loadBalancerBackendAddress_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_ARM(generators)
	loadBalancerBackendAddress_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_ARM(generators)
	loadBalancerBackendAddress_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_ARM{}), generators)

	return loadBalancerBackendAddress_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormat_ARMGenerator())
}

func Test_PublicIPAddressSpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec_ARM, PublicIPAddressSpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec_ARM runs a test to see if a specific instance of PublicIPAddressSpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec_ARM(subject PublicIPAddressSpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec_ARM instances for property testing - lazily instantiated by
// PublicIPAddressSpec_ARMGenerator()
var publicIPAddressSpec_ARMGenerator gopter.Gen

// PublicIPAddressSpec_ARMGenerator returns a generator of PublicIPAddressSpec_ARM instances for property testing.
// We first initialize publicIPAddressSpec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpec_ARMGenerator() gopter.Gen {
	if publicIPAddressSpec_ARMGenerator != nil {
		return publicIPAddressSpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_ARM(generators)
	publicIPAddressSpec_ARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_ARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec_ARM(generators)
	publicIPAddressSpec_ARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_ARM{}), generators)

	return publicIPAddressSpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_ARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_ARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM, LoadBalancerBackendAddressPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM(subject LoadBalancerBackendAddressPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormat_ARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressPropertiesFormat_ARMGenerator()
var loadBalancerBackendAddressPropertiesFormat_ARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormat_ARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormat_ARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormat_ARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormat_ARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	loadBalancerBackendAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	loadBalancerBackendAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_ARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_ARM, PublicIPAddressPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_ARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_ARM(subject PublicIPAddressPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_ARM instances for property testing - lazily instantiated by
// PublicIPAddressPropertiesFormat_ARMGenerator()
var publicIPAddressPropertiesFormat_ARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_ARMGenerator returns a generator of PublicIPAddressPropertiesFormat_ARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_ARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_ARMGenerator != nil {
		return publicIPAddressPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM(generators)
	publicIPAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM(generators)
	publicIPAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_ARM{}), generators)

	return publicIPAddressPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed,
		PublicIPAddressPropertiesFormat_MigrationPhase_None,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_ARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_ARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_ARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_ARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpec_ARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_ARMGenerator())
}
