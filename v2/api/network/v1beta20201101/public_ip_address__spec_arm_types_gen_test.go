// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddress_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_SpecARM, PublicIPAddress_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_SpecARM runs a test to see if a specific instance of PublicIPAddress_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_SpecARM(subject PublicIPAddress_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_SpecARM instances for property testing - lazily instantiated by
// PublicIPAddress_SpecARMGenerator()
var publicIPAddress_SpecARMGenerator gopter.Gen

// PublicIPAddress_SpecARMGenerator returns a generator of PublicIPAddress_SpecARM instances for property testing.
// We first initialize publicIPAddress_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_SpecARMGenerator() gopter.Gen {
	if publicIPAddress_SpecARMGenerator != nil {
		return publicIPAddress_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_SpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_SpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	return publicIPAddress_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_PublicIPAddressPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM, PublicIPAddressPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM(subject PublicIPAddressPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormatARM instances for property testing - lazily instantiated by
// PublicIPAddressPropertiesFormatARMGenerator()
var publicIPAddressPropertiesFormatARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatARMGenerator returns a generator of PublicIPAddressPropertiesFormatARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatARMGenerator != nil {
		return publicIPAddressPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	publicIPAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	publicIPAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormatARM{}), generators)

	return publicIPAddressPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhaseAbort,
		PublicIPAddressPropertiesFormat_MigrationPhaseCommit,
		PublicIPAddressPropertiesFormat_MigrationPhaseCommitted,
		PublicIPAddressPropertiesFormat_MigrationPhaseNone,
		PublicIPAddressPropertiesFormat_MigrationPhasePrepare))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersionIPv4, IPVersionIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethodDynamic, IPAllocationMethodStatic))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsARMGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator())
}

func Test_PublicIPAddressSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuARM, PublicIPAddressSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuARM runs a test to see if a specific instance of PublicIPAddressSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuARM(subject PublicIPAddressSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSkuARM instances for property testing - lazily instantiated by
// PublicIPAddressSkuARMGenerator()
var publicIPAddressSkuARMGenerator gopter.Gen

// PublicIPAddressSkuARMGenerator returns a generator of PublicIPAddressSkuARM instances for property testing.
func PublicIPAddressSkuARMGenerator() gopter.Gen {
	if publicIPAddressSkuARMGenerator != nil {
		return publicIPAddressSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(generators)
	publicIPAddressSkuARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSkuARM{}), generators)

	return publicIPAddressSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_NameBasic, PublicIPAddressSku_NameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_TierGlobal, PublicIPAddressSku_TierRegional))
}

func Test_DdosSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDdosSettingsARM, DdosSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettingsARM runs a test to see if a specific instance of DdosSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettingsARM(subject DdosSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettingsARM instances for property testing - lazily instantiated by DdosSettingsARMGenerator()
var ddosSettingsARMGenerator gopter.Gen

// DdosSettingsARMGenerator returns a generator of DdosSettingsARM instances for property testing.
// We first initialize ddosSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettingsARMGenerator() gopter.Gen {
	if ddosSettingsARMGenerator != nil {
		return ddosSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsARM(generators)
	ddosSettingsARMGenerator = gen.Struct(reflect.TypeOf(DdosSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettingsARM(generators)
	ddosSettingsARMGenerator = gen.Struct(reflect.TypeOf(DdosSettingsARM{}), generators)

	return ddosSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettingsARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettings_ProtectionCoverageBasic, DdosSettings_ProtectionCoverageStandard))
}

// AddRelatedPropertyGeneratorsForDdosSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettingsARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM, IPConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(subject IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by IPConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfiguration_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfiguration_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator())
}

func Test_IpTagARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTagARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpTagARM, IpTagARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTagARM runs a test to see if a specific instance of IpTagARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTagARM(subject IpTagARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTagARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpTagARM instances for property testing - lazily instantiated by IpTagARMGenerator()
var ipTagARMGenerator gopter.Gen

// IpTagARMGenerator returns a generator of IpTagARM instances for property testing.
func IpTagARMGenerator() gopter.Gen {
	if ipTagARMGenerator != nil {
		return ipTagARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTagARM(generators)
	ipTagARMGenerator = gen.Struct(reflect.TypeOf(IpTagARM{}), generators)

	return ipTagARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTagARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTagARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM, NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(subject NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return natGatewaySpec_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewaySpec_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(NatGatewaySkuARMGenerator())
}

func Test_PublicIPAddressDnsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettingsARM, PublicIPAddressDnsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettingsARM runs a test to see if a specific instance of PublicIPAddressDnsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettingsARM(subject PublicIPAddressDnsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettingsARM instances for property testing - lazily instantiated by
// PublicIPAddressDnsSettingsARMGenerator()
var publicIPAddressDnsSettingsARMGenerator gopter.Gen

// PublicIPAddressDnsSettingsARMGenerator returns a generator of PublicIPAddressDnsSettingsARM instances for property testing.
func PublicIPAddressDnsSettingsARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettingsARMGenerator != nil {
		return publicIPAddressDnsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM(generators)
	publicIPAddressDnsSettingsARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettingsARM{}), generators)

	return publicIPAddressDnsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM, PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(subject PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM, IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(subject IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM instances for property testing -
// lazily instantiated by IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethodDynamic, IPAllocationMethodStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDeleting,
		ProvisioningStateFailed,
		ProvisioningStateSucceeded,
		ProvisioningStateUpdating))
}

// AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator())
}

func Test_NatGatewaySkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySkuARM, NatGatewaySkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySkuARM runs a test to see if a specific instance of NatGatewaySkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySkuARM(subject NatGatewaySkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySkuARM instances for property testing - lazily instantiated by NatGatewaySkuARMGenerator()
var natGatewaySkuARMGenerator gopter.Gen

// NatGatewaySkuARMGenerator returns a generator of NatGatewaySkuARM instances for property testing.
func NatGatewaySkuARMGenerator() gopter.Gen {
	if natGatewaySkuARMGenerator != nil {
		return natGatewaySkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySkuARM(generators)
	natGatewaySkuARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySkuARM{}), generators)

	return natGatewaySkuARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySku_NameStandard))
}

func Test_Subnet_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_PublicIPAddress_SubResourceEmbeddedARM, Subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_PublicIPAddress_SubResourceEmbeddedARM(subject Subnet_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
// Subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// Subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of Subnet_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
func Subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_PublicIPAddress_SubResourceEmbeddedARM(generators)
	subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return subnet_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
