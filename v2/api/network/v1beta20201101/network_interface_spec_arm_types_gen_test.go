// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_Spec_ARM, NetworkInterface_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_Spec_ARM runs a test to see if a specific instance of NetworkInterface_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_Spec_ARM(subject NetworkInterface_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_Spec_ARM instances for property testing - lazily instantiated by
// NetworkInterface_Spec_ARMGenerator()
var networkInterface_Spec_ARMGenerator gopter.Gen

// NetworkInterface_Spec_ARMGenerator returns a generator of NetworkInterface_Spec_ARM instances for property testing.
// We first initialize networkInterface_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_Spec_ARMGenerator() gopter.Gen {
	if networkInterface_Spec_ARMGenerator != nil {
		return networkInterface_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)
	networkInterface_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_Spec_ARM(generators)
	networkInterface_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec_ARM{}), generators)

	return networkInterface_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_Spec_ARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Properties"] = gen.PtrOf(NetworkInterfacePropertiesFormat_ARMGenerator())
}

func Test_NetworkInterfacePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfacePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfacePropertiesFormat_ARM, NetworkInterfacePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfacePropertiesFormat_ARM runs a test to see if a specific instance of NetworkInterfacePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfacePropertiesFormat_ARM(subject NetworkInterfacePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfacePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfacePropertiesFormat_ARM instances for property testing - lazily instantiated by
// NetworkInterfacePropertiesFormat_ARMGenerator()
var networkInterfacePropertiesFormat_ARMGenerator gopter.Gen

// NetworkInterfacePropertiesFormat_ARMGenerator returns a generator of NetworkInterfacePropertiesFormat_ARM instances for property testing.
// We first initialize networkInterfacePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfacePropertiesFormat_ARMGenerator() gopter.Gen {
	if networkInterfacePropertiesFormat_ARMGenerator != nil {
		return networkInterfacePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)
	networkInterfacePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(generators)
	networkInterfacePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormat_ARM{}), generators)

	return networkInterfacePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		NetworkInterfacePropertiesFormat_MigrationPhase_Abort,
		NetworkInterfacePropertiesFormat_MigrationPhase_Commit,
		NetworkInterfacePropertiesFormat_MigrationPhase_Committed,
		NetworkInterfacePropertiesFormat_MigrationPhase_None,
		NetworkInterfacePropertiesFormat_MigrationPhase_Prepare))
	gens["NicType"] = gen.PtrOf(gen.OneConstOf(NetworkInterfacePropertiesFormat_NicType_Elastic, NetworkInterfacePropertiesFormat_NicType_Standard))
}

// AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettings_ARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_ARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpec_ARMGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceSpec_ARMGenerator())
}

func Test_NetworkInterfaceDnsSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettings_ARM, NetworkInterfaceDnsSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettings_ARM runs a test to see if a specific instance of NetworkInterfaceDnsSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettings_ARM(subject NetworkInterfaceDnsSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_ARM instances for property testing - lazily instantiated by
// NetworkInterfaceDnsSettings_ARMGenerator()
var networkInterfaceDnsSettings_ARMGenerator gopter.Gen

// NetworkInterfaceDnsSettings_ARMGenerator returns a generator of NetworkInterfaceDnsSettings_ARM instances for property testing.
func NetworkInterfaceDnsSettings_ARMGenerator() gopter.Gen {
	if networkInterfaceDnsSettings_ARMGenerator != nil {
		return networkInterfaceDnsSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_ARM(generators)
	networkInterfaceDnsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_ARM{}), generators)

	return networkInterfaceDnsSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_ARM(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfiguration_ARM, NetworkInterfaceIPConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfiguration_ARM runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfiguration_ARM(subject NetworkInterfaceIPConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_ARM instances for property testing - lazily instantiated by
// NetworkInterfaceIPConfiguration_ARMGenerator()
var networkInterfaceIPConfiguration_ARMGenerator gopter.Gen

// NetworkInterfaceIPConfiguration_ARMGenerator returns a generator of NetworkInterfaceIPConfiguration_ARM instances for property testing.
// We first initialize networkInterfaceIPConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfiguration_ARMGenerator() gopter.Gen {
	if networkInterfaceIPConfiguration_ARMGenerator != nil {
		return networkInterfaceIPConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM(generators)
	networkInterfaceIPConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM(generators)
	networkInterfaceIPConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_ARM{}), generators)

	return networkInterfaceIPConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator())
}

func Test_NetworkSecurityGroupSpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupSpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpec_ARM, NetworkSecurityGroupSpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpec_ARM runs a test to see if a specific instance of NetworkSecurityGroupSpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpec_ARM(subject NetworkSecurityGroupSpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupSpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupSpec_ARM instances for property testing - lazily instantiated by
// NetworkSecurityGroupSpec_ARMGenerator()
var networkSecurityGroupSpec_ARMGenerator gopter.Gen

// NetworkSecurityGroupSpec_ARMGenerator returns a generator of NetworkSecurityGroupSpec_ARM instances for property testing.
// We first initialize networkSecurityGroupSpec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkSecurityGroupSpec_ARMGenerator() gopter.Gen {
	if networkSecurityGroupSpec_ARMGenerator != nil {
		return networkSecurityGroupSpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_ARM(generators)
	networkSecurityGroupSpec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpec_ARM(generators)
	networkSecurityGroupSpec_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpec_ARM{}), generators)

	return networkSecurityGroupSpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkSecurityGroupPropertiesFormat_ARMGenerator())
}

func Test_PrivateLinkServiceSpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceSpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceSpec_ARM, PrivateLinkServiceSpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceSpec_ARM runs a test to see if a specific instance of PrivateLinkServiceSpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceSpec_ARM(subject PrivateLinkServiceSpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceSpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceSpec_ARM instances for property testing - lazily instantiated by
// PrivateLinkServiceSpec_ARMGenerator()
var privateLinkServiceSpec_ARMGenerator gopter.Gen

// PrivateLinkServiceSpec_ARMGenerator returns a generator of PrivateLinkServiceSpec_ARM instances for property testing.
// We first initialize privateLinkServiceSpec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceSpec_ARMGenerator() gopter.Gen {
	if privateLinkServiceSpec_ARMGenerator != nil {
		return privateLinkServiceSpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec_ARM(generators)
	privateLinkServiceSpec_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec_ARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec_ARM(generators)
	privateLinkServiceSpec_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpec_ARM{}), generators)

	return privateLinkServiceSpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Properties"] = gen.PtrOf(PrivateLinkServiceProperties_ARMGenerator())
}

func Test_NetworkInterfaceIPConfigurationPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormat_ARM, NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormat_ARM runs a test to see if a specific instance of NetworkInterfaceIPConfigurationPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(subject NetworkInterfaceIPConfigurationPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationPropertiesFormat_ARM instances for property testing - lazily instantiated
// by NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator()
var networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator gopter.Gen

// NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator returns a generator of NetworkInterfaceIPConfigurationPropertiesFormat_ARM instances for property testing.
// We first initialize networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfigurationPropertiesFormat_ARMGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator != nil {
		return networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)
	networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(generators)
	networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormat_ARM{}), generators)

	return networkInterfaceIPConfigurationPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPool_ARMGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroupSpec_ARMGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPool_ARMGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRule_ARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_ARMGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTapSpec_ARMGenerator())
}

func Test_NetworkSecurityGroupPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormat_ARM, NetworkSecurityGroupPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormat_ARM runs a test to see if a specific instance of NetworkSecurityGroupPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormat_ARM(subject NetworkSecurityGroupPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupPropertiesFormat_ARM instances for property testing - lazily instantiated by
// NetworkSecurityGroupPropertiesFormat_ARMGenerator()
var networkSecurityGroupPropertiesFormat_ARMGenerator gopter.Gen

// NetworkSecurityGroupPropertiesFormat_ARMGenerator returns a generator of NetworkSecurityGroupPropertiesFormat_ARM instances for property testing.
func NetworkSecurityGroupPropertiesFormat_ARMGenerator() gopter.Gen {
	if networkSecurityGroupPropertiesFormat_ARMGenerator != nil {
		return networkSecurityGroupPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormat_ARM(generators)
	networkSecurityGroupPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupPropertiesFormat_ARM{}), generators)

	return networkSecurityGroupPropertiesFormat_ARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["SecurityRules"] = gen.SliceOf(SecurityRule_ARMGenerator())
}

func Test_PrivateLinkServiceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceProperties_ARM, PrivateLinkServiceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceProperties_ARM runs a test to see if a specific instance of PrivateLinkServiceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceProperties_ARM(subject PrivateLinkServiceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceProperties_ARM instances for property testing - lazily instantiated by
// PrivateLinkServiceProperties_ARMGenerator()
var privateLinkServiceProperties_ARMGenerator gopter.Gen

// PrivateLinkServiceProperties_ARMGenerator returns a generator of PrivateLinkServiceProperties_ARM instances for property testing.
// We first initialize privateLinkServiceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceProperties_ARMGenerator() gopter.Gen {
	if privateLinkServiceProperties_ARMGenerator != nil {
		return privateLinkServiceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties_ARM(generators)
	privateLinkServiceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties_ARM(generators)
	privateLinkServiceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceProperties_ARM{}), generators)

	return privateLinkServiceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties_ARM(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSet_ARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfiguration_ARMGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfiguration_ARMGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSet_ARMGenerator())
}

func Test_ApplicationGatewayBackendAddressPool_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPool_ARM, ApplicationGatewayBackendAddressPool_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPool_ARM runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPool_ARM(subject ApplicationGatewayBackendAddressPool_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_ARM instances for property testing - lazily instantiated by
// ApplicationGatewayBackendAddressPool_ARMGenerator()
var applicationGatewayBackendAddressPool_ARMGenerator gopter.Gen

// ApplicationGatewayBackendAddressPool_ARMGenerator returns a generator of ApplicationGatewayBackendAddressPool_ARM instances for property testing.
// We first initialize applicationGatewayBackendAddressPool_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPool_ARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPool_ARMGenerator != nil {
		return applicationGatewayBackendAddressPool_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM(generators)
	applicationGatewayBackendAddressPool_ARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM(generators)
	applicationGatewayBackendAddressPool_ARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_ARM{}), generators)

	return applicationGatewayBackendAddressPool_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ApplicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator())
}

func Test_PrivateLinkServiceIpConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_ARM, PrivateLinkServiceIpConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_ARM runs a test to see if a specific instance of PrivateLinkServiceIpConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_ARM(subject PrivateLinkServiceIpConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfiguration_ARM instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfiguration_ARMGenerator()
var privateLinkServiceIpConfiguration_ARMGenerator gopter.Gen

// PrivateLinkServiceIpConfiguration_ARMGenerator returns a generator of PrivateLinkServiceIpConfiguration_ARM instances for property testing.
// We first initialize privateLinkServiceIpConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfiguration_ARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfiguration_ARMGenerator != nil {
		return privateLinkServiceIpConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM(generators)
	privateLinkServiceIpConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM(generators)
	privateLinkServiceIpConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_ARM{}), generators)

	return privateLinkServiceIpConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateLinkServiceIpConfigurationProperties_ARMGenerator())
}

func Test_ResourceSet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSet_ARM, ResourceSet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSet_ARM runs a test to see if a specific instance of ResourceSet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSet_ARM(subject ResourceSet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSet_ARM instances for property testing - lazily instantiated by ResourceSet_ARMGenerator()
var resourceSet_ARMGenerator gopter.Gen

// ResourceSet_ARMGenerator returns a generator of ResourceSet_ARM instances for property testing.
func ResourceSet_ARMGenerator() gopter.Gen {
	if resourceSet_ARMGenerator != nil {
		return resourceSet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSet_ARM(generators)
	resourceSet_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceSet_ARM{}), generators)

	return resourceSet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSet_ARM(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_SecurityRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityRule_ARM, SecurityRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityRule_ARM runs a test to see if a specific instance of SecurityRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityRule_ARM(subject SecurityRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityRule_ARM instances for property testing - lazily instantiated by SecurityRule_ARMGenerator()
var securityRule_ARMGenerator gopter.Gen

// SecurityRule_ARMGenerator returns a generator of SecurityRule_ARM instances for property testing.
// We first initialize securityRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityRule_ARMGenerator() gopter.Gen {
	if securityRule_ARMGenerator != nil {
		return securityRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityRule_ARM(generators)
	securityRule_ARMGenerator = gen.Struct(reflect.TypeOf(SecurityRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityRule_ARM(generators)
	AddRelatedPropertyGeneratorsForSecurityRule_ARM(generators)
	securityRule_ARMGenerator = gen.Struct(reflect.TypeOf(SecurityRule_ARM{}), generators)

	return securityRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityRule_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityRule_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SecurityRulePropertiesFormat_ARMGenerator())
}

func Test_VirtualNetworkTapSpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTapSpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapSpec_ARM, VirtualNetworkTapSpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapSpec_ARM runs a test to see if a specific instance of VirtualNetworkTapSpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapSpec_ARM(subject VirtualNetworkTapSpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTapSpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTapSpec_ARM instances for property testing - lazily instantiated by
// VirtualNetworkTapSpec_ARMGenerator()
var virtualNetworkTapSpec_ARMGenerator gopter.Gen

// VirtualNetworkTapSpec_ARMGenerator returns a generator of VirtualNetworkTapSpec_ARM instances for property testing.
// We first initialize virtualNetworkTapSpec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTapSpec_ARMGenerator() gopter.Gen {
	if virtualNetworkTapSpec_ARMGenerator != nil {
		return virtualNetworkTapSpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpec_ARM(generators)
	virtualNetworkTapSpec_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapSpec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpec_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTapSpec_ARM(generators)
	virtualNetworkTapSpec_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapSpec_ARM{}), generators)

	return virtualNetworkTapSpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapSpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapSpec_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTapSpec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTapSpec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualNetworkTapPropertiesFormat_ARMGenerator())
}

func Test_ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM, ApplicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM runs a test to see if a specific instance of ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM(subject ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM instances for property testing - lazily
// instantiated by ApplicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator()
var applicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator gopter.Gen

// ApplicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator returns a generator of ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM instances for property testing.
func ApplicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator != nil {
		return applicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM(generators)
	applicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPoolPropertiesFormat_ARM{}), generators)

	return applicationGatewayBackendAddressPoolPropertiesFormat_ARMGenerator
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddress_ARMGenerator())
}

func Test_PrivateLinkServiceIpConfigurationProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties_ARM, PrivateLinkServiceIpConfigurationProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties_ARM runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties_ARM(subject PrivateLinkServiceIpConfigurationProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationProperties_ARM instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfigurationProperties_ARMGenerator()
var privateLinkServiceIpConfigurationProperties_ARMGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationProperties_ARMGenerator returns a generator of PrivateLinkServiceIpConfigurationProperties_ARM instances for property testing.
// We first initialize privateLinkServiceIpConfigurationProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationProperties_ARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationProperties_ARMGenerator != nil {
		return privateLinkServiceIpConfigurationProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM(generators)
	privateLinkServiceIpConfigurationProperties_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM(generators)
	privateLinkServiceIpConfigurationProperties_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationProperties_ARM{}), generators)

	return privateLinkServiceIpConfigurationProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties_ARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(Subnet_ARMGenerator())
}

func Test_VirtualNetworkTapPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTapPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapPropertiesFormat_ARM, VirtualNetworkTapPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapPropertiesFormat_ARM runs a test to see if a specific instance of VirtualNetworkTapPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapPropertiesFormat_ARM(subject VirtualNetworkTapPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTapPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTapPropertiesFormat_ARM instances for property testing - lazily instantiated by
// VirtualNetworkTapPropertiesFormat_ARMGenerator()
var virtualNetworkTapPropertiesFormat_ARMGenerator gopter.Gen

// VirtualNetworkTapPropertiesFormat_ARMGenerator returns a generator of VirtualNetworkTapPropertiesFormat_ARM instances for property testing.
// We first initialize virtualNetworkTapPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTapPropertiesFormat_ARMGenerator() gopter.Gen {
	if virtualNetworkTapPropertiesFormat_ARMGenerator != nil {
		return virtualNetworkTapPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM(generators)
	virtualNetworkTapPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM(generators)
	virtualNetworkTapPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapPropertiesFormat_ARM{}), generators)

	return virtualNetworkTapPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["DestinationPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["DestinationLoadBalancerFrontEndIPConfiguration"] = gen.PtrOf(FrontendIPConfiguration_ARMGenerator())
	gens["DestinationNetworkInterfaceIPConfiguration"] = gen.PtrOf(NetworkInterfaceIPConfiguration_ARMGenerator())
}

func Test_ApplicationGatewayBackendAddress_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddress_ARM, ApplicationGatewayBackendAddress_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddress_ARM runs a test to see if a specific instance of ApplicationGatewayBackendAddress_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddress_ARM(subject ApplicationGatewayBackendAddress_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_ARM instances for property testing - lazily instantiated by
// ApplicationGatewayBackendAddress_ARMGenerator()
var applicationGatewayBackendAddress_ARMGenerator gopter.Gen

// ApplicationGatewayBackendAddress_ARMGenerator returns a generator of ApplicationGatewayBackendAddress_ARM instances for property testing.
func ApplicationGatewayBackendAddress_ARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddress_ARMGenerator != nil {
		return applicationGatewayBackendAddress_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_ARM(generators)
	applicationGatewayBackendAddress_ARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_ARM{}), generators)

	return applicationGatewayBackendAddress_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_ARM(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}
