// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_SpecARM, NetworkInterface_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_SpecARM runs a test to see if a specific instance of NetworkInterface_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_SpecARM(subject NetworkInterface_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_SpecARM instances for property testing - lazily instantiated by
// NetworkInterface_SpecARMGenerator()
var networkInterface_SpecARMGenerator gopter.Gen

// NetworkInterface_SpecARMGenerator returns a generator of NetworkInterface_SpecARM instances for property testing.
// We first initialize networkInterface_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_SpecARMGenerator() gopter.Gen {
	if networkInterface_SpecARMGenerator != nil {
		return networkInterface_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	networkInterface_SpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	networkInterface_SpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_SpecARM{}), generators)

	return networkInterface_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(NetworkInterfacePropertiesFormatARMGenerator())
}

func Test_NetworkInterfacePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfacePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM, NetworkInterfacePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM runs a test to see if a specific instance of NetworkInterfacePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM(subject NetworkInterfacePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfacePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfacePropertiesFormatARM instances for property testing - lazily instantiated by
// NetworkInterfacePropertiesFormatARMGenerator()
var networkInterfacePropertiesFormatARMGenerator gopter.Gen

// NetworkInterfacePropertiesFormatARMGenerator returns a generator of NetworkInterfacePropertiesFormatARM instances for property testing.
// We first initialize networkInterfacePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfacePropertiesFormatARMGenerator() gopter.Gen {
	if networkInterfacePropertiesFormatARMGenerator != nil {
		return networkInterfacePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	networkInterfacePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	networkInterfacePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormatARM{}), generators)

	return networkInterfacePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		NetworkInterfacePropertiesFormat_MigrationPhase_Abort,
		NetworkInterfacePropertiesFormat_MigrationPhase_Commit,
		NetworkInterfacePropertiesFormat_MigrationPhase_Committed,
		NetworkInterfacePropertiesFormat_MigrationPhase_None,
		NetworkInterfacePropertiesFormat_MigrationPhase_Prepare))
	gens["NicType"] = gen.PtrOf(gen.OneConstOf(NetworkInterfacePropertiesFormat_NicType_Elastic, NetworkInterfacePropertiesFormat_NicType_Standard))
}

// AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettingsARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfigurationARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpecARMGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceSpecARMGenerator())
}

func Test_NetworkInterfaceDnsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM, NetworkInterfaceDnsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM runs a test to see if a specific instance of NetworkInterfaceDnsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM(subject NetworkInterfaceDnsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettingsARM instances for property testing - lazily instantiated by
// NetworkInterfaceDnsSettingsARMGenerator()
var networkInterfaceDnsSettingsARMGenerator gopter.Gen

// NetworkInterfaceDnsSettingsARMGenerator returns a generator of NetworkInterfaceDnsSettingsARM instances for property testing.
func NetworkInterfaceDnsSettingsARMGenerator() gopter.Gen {
	if networkInterfaceDnsSettingsARMGenerator != nil {
		return networkInterfaceDnsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM(generators)
	networkInterfaceDnsSettingsARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettingsARM{}), generators)

	return networkInterfaceDnsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationARM, NetworkInterfaceIPConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationARM runs a test to see if a specific instance of NetworkInterfaceIPConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationARM(subject NetworkInterfaceIPConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationARM instances for property testing - lazily instantiated by
// NetworkInterfaceIPConfigurationARMGenerator()
var networkInterfaceIPConfigurationARMGenerator gopter.Gen

// NetworkInterfaceIPConfigurationARMGenerator returns a generator of NetworkInterfaceIPConfigurationARM instances for property testing.
// We first initialize networkInterfaceIPConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfigurationARMGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationARMGenerator != nil {
		return networkInterfaceIPConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationARM(generators)
	networkInterfaceIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationARM(generators)
	networkInterfaceIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationARM{}), generators)

	return networkInterfaceIPConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceIPConfigurationPropertiesFormatARMGenerator())
}

func Test_NetworkSecurityGroupSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpecARM, NetworkSecurityGroupSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpecARM runs a test to see if a specific instance of NetworkSecurityGroupSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpecARM(subject NetworkSecurityGroupSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupSpecARM instances for property testing - lazily instantiated by
// NetworkSecurityGroupSpecARMGenerator()
var networkSecurityGroupSpecARMGenerator gopter.Gen

// NetworkSecurityGroupSpecARMGenerator returns a generator of NetworkSecurityGroupSpecARM instances for property testing.
// We first initialize networkSecurityGroupSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkSecurityGroupSpecARMGenerator() gopter.Gen {
	if networkSecurityGroupSpecARMGenerator != nil {
		return networkSecurityGroupSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	networkSecurityGroupSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	networkSecurityGroupSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpecARM{}), generators)

	return networkSecurityGroupSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkSecurityGroupPropertiesFormatARMGenerator())
}

func Test_PrivateLinkServiceSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceSpecARM, PrivateLinkServiceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceSpecARM runs a test to see if a specific instance of PrivateLinkServiceSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceSpecARM(subject PrivateLinkServiceSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceSpecARM instances for property testing - lazily instantiated by
// PrivateLinkServiceSpecARMGenerator()
var privateLinkServiceSpecARMGenerator gopter.Gen

// PrivateLinkServiceSpecARMGenerator returns a generator of PrivateLinkServiceSpecARM instances for property testing.
// We first initialize privateLinkServiceSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceSpecARMGenerator() gopter.Gen {
	if privateLinkServiceSpecARMGenerator != nil {
		return privateLinkServiceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	privateLinkServiceSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	privateLinkServiceSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpecARM{}), generators)

	return privateLinkServiceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(PrivateLinkServicePropertiesARMGenerator())
}

func Test_NetworkInterfaceIPConfigurationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormatARM, NetworkInterfaceIPConfigurationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormatARM runs a test to see if a specific instance of NetworkInterfaceIPConfigurationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationPropertiesFormatARM(subject NetworkInterfaceIPConfigurationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationPropertiesFormatARM instances for property testing - lazily instantiated
// by NetworkInterfaceIPConfigurationPropertiesFormatARMGenerator()
var networkInterfaceIPConfigurationPropertiesFormatARMGenerator gopter.Gen

// NetworkInterfaceIPConfigurationPropertiesFormatARMGenerator returns a generator of NetworkInterfaceIPConfigurationPropertiesFormatARM instances for property testing.
// We first initialize networkInterfaceIPConfigurationPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfigurationPropertiesFormatARMGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationPropertiesFormatARMGenerator != nil {
		return networkInterfaceIPConfigurationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM(generators)
	networkInterfaceIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM(generators)
	networkInterfaceIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPropertiesFormatARM{}), generators)

	return networkInterfaceIPConfigurationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPoolARMGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroupSpecARMGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPoolARMGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRuleARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetARMGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTapSpecARMGenerator())
}

func Test_NetworkSecurityGroupPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormatARM, NetworkSecurityGroupPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormatARM runs a test to see if a specific instance of NetworkSecurityGroupPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupPropertiesFormatARM(subject NetworkSecurityGroupPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupPropertiesFormatARM instances for property testing - lazily instantiated by
// NetworkSecurityGroupPropertiesFormatARMGenerator()
var networkSecurityGroupPropertiesFormatARMGenerator gopter.Gen

// NetworkSecurityGroupPropertiesFormatARMGenerator returns a generator of NetworkSecurityGroupPropertiesFormatARM instances for property testing.
func NetworkSecurityGroupPropertiesFormatARMGenerator() gopter.Gen {
	if networkSecurityGroupPropertiesFormatARMGenerator != nil {
		return networkSecurityGroupPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormatARM(generators)
	networkSecurityGroupPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupPropertiesFormatARM{}), generators)

	return networkSecurityGroupPropertiesFormatARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["SecurityRules"] = gen.SliceOf(SecurityRuleARMGenerator())
}

func Test_PrivateLinkServicePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServicePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServicePropertiesARM, PrivateLinkServicePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServicePropertiesARM runs a test to see if a specific instance of PrivateLinkServicePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServicePropertiesARM(subject PrivateLinkServicePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServicePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServicePropertiesARM instances for property testing - lazily instantiated by
// PrivateLinkServicePropertiesARMGenerator()
var privateLinkServicePropertiesARMGenerator gopter.Gen

// PrivateLinkServicePropertiesARMGenerator returns a generator of PrivateLinkServicePropertiesARM instances for property testing.
// We first initialize privateLinkServicePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServicePropertiesARMGenerator() gopter.Gen {
	if privateLinkServicePropertiesARMGenerator != nil {
		return privateLinkServicePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	privateLinkServicePropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServicePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	privateLinkServicePropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServicePropertiesARM{}), generators)

	return privateLinkServicePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSetARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfigurationARMGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfigurationARMGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSetARMGenerator())
}

func Test_ApplicationGatewayBackendAddressPoolARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPoolARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPoolARM, ApplicationGatewayBackendAddressPoolARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPoolARM runs a test to see if a specific instance of ApplicationGatewayBackendAddressPoolARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPoolARM(subject ApplicationGatewayBackendAddressPoolARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPoolARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPoolARM instances for property testing - lazily instantiated by
// ApplicationGatewayBackendAddressPoolARMGenerator()
var applicationGatewayBackendAddressPoolARMGenerator gopter.Gen

// ApplicationGatewayBackendAddressPoolARMGenerator returns a generator of ApplicationGatewayBackendAddressPoolARM instances for property testing.
// We first initialize applicationGatewayBackendAddressPoolARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPoolARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPoolARMGenerator != nil {
		return applicationGatewayBackendAddressPoolARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM(generators)
	applicationGatewayBackendAddressPoolARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPoolARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM(generators)
	applicationGatewayBackendAddressPoolARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPoolARM{}), generators)

	return applicationGatewayBackendAddressPoolARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ApplicationGatewayBackendAddressPoolPropertiesFormatARMGenerator())
}

func Test_PrivateLinkServiceIpConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM, PrivateLinkServiceIpConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM(subject PrivateLinkServiceIpConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationARM instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfigurationARMGenerator()
var privateLinkServiceIpConfigurationARMGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationARMGenerator returns a generator of PrivateLinkServiceIpConfigurationARM instances for property testing.
// We first initialize privateLinkServiceIpConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationARMGenerator != nil {
		return privateLinkServiceIpConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	privateLinkServiceIpConfigurationARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	privateLinkServiceIpConfigurationARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationARM{}), generators)

	return privateLinkServiceIpConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateLinkServiceIpConfigurationPropertiesARMGenerator())
}

func Test_ResourceSetARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSetARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSetARM, ResourceSetARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSetARM runs a test to see if a specific instance of ResourceSetARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSetARM(subject ResourceSetARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSetARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSetARM instances for property testing - lazily instantiated by ResourceSetARMGenerator()
var resourceSetARMGenerator gopter.Gen

// ResourceSetARMGenerator returns a generator of ResourceSetARM instances for property testing.
func ResourceSetARMGenerator() gopter.Gen {
	if resourceSetARMGenerator != nil {
		return resourceSetARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSetARM(generators)
	resourceSetARMGenerator = gen.Struct(reflect.TypeOf(ResourceSetARM{}), generators)

	return resourceSetARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSetARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSetARM(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_SecurityRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityRuleARM, SecurityRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityRuleARM runs a test to see if a specific instance of SecurityRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityRuleARM(subject SecurityRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityRuleARM instances for property testing - lazily instantiated by SecurityRuleARMGenerator()
var securityRuleARMGenerator gopter.Gen

// SecurityRuleARMGenerator returns a generator of SecurityRuleARM instances for property testing.
// We first initialize securityRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityRuleARMGenerator() gopter.Gen {
	if securityRuleARMGenerator != nil {
		return securityRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityRuleARM(generators)
	securityRuleARMGenerator = gen.Struct(reflect.TypeOf(SecurityRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityRuleARM(generators)
	AddRelatedPropertyGeneratorsForSecurityRuleARM(generators)
	securityRuleARMGenerator = gen.Struct(reflect.TypeOf(SecurityRuleARM{}), generators)

	return securityRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityRuleARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SecurityRulePropertiesFormatARMGenerator())
}

func Test_VirtualNetworkTapSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTapSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapSpecARM, VirtualNetworkTapSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapSpecARM runs a test to see if a specific instance of VirtualNetworkTapSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapSpecARM(subject VirtualNetworkTapSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTapSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTapSpecARM instances for property testing - lazily instantiated by
// VirtualNetworkTapSpecARMGenerator()
var virtualNetworkTapSpecARMGenerator gopter.Gen

// VirtualNetworkTapSpecARMGenerator returns a generator of VirtualNetworkTapSpecARM instances for property testing.
// We first initialize virtualNetworkTapSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTapSpecARMGenerator() gopter.Gen {
	if virtualNetworkTapSpecARMGenerator != nil {
		return virtualNetworkTapSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecARM(generators)
	virtualNetworkTapSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecARM(generators)
	virtualNetworkTapSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapSpecARM{}), generators)

	return virtualNetworkTapSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualNetworkTapPropertiesFormatARMGenerator())
}

func Test_ApplicationGatewayBackendAddressPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormatARM, ApplicationGatewayBackendAddressPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormatARM runs a test to see if a specific instance of ApplicationGatewayBackendAddressPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPoolPropertiesFormatARM(subject ApplicationGatewayBackendAddressPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPoolPropertiesFormatARM instances for property testing - lazily
// instantiated by ApplicationGatewayBackendAddressPoolPropertiesFormatARMGenerator()
var applicationGatewayBackendAddressPoolPropertiesFormatARMGenerator gopter.Gen

// ApplicationGatewayBackendAddressPoolPropertiesFormatARMGenerator returns a generator of ApplicationGatewayBackendAddressPoolPropertiesFormatARM instances for property testing.
func ApplicationGatewayBackendAddressPoolPropertiesFormatARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPoolPropertiesFormatARMGenerator != nil {
		return applicationGatewayBackendAddressPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormatARM(generators)
	applicationGatewayBackendAddressPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPoolPropertiesFormatARM{}), generators)

	return applicationGatewayBackendAddressPoolPropertiesFormatARMGenerator
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddressARMGenerator())
}

func Test_PrivateLinkServiceIpConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM, PrivateLinkServiceIpConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM(subject PrivateLinkServiceIpConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationPropertiesARM instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfigurationPropertiesARMGenerator()
var privateLinkServiceIpConfigurationPropertiesARMGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationPropertiesARMGenerator returns a generator of PrivateLinkServiceIpConfigurationPropertiesARM instances for property testing.
// We first initialize privateLinkServiceIpConfigurationPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationPropertiesARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationPropertiesARMGenerator != nil {
		return privateLinkServiceIpConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(generators)
	privateLinkServiceIpConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(generators)
	privateLinkServiceIpConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationPropertiesARM{}), generators)

	return privateLinkServiceIpConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(SubnetARMGenerator())
}

func Test_VirtualNetworkTapPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTapPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapPropertiesFormatARM, VirtualNetworkTapPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapPropertiesFormatARM runs a test to see if a specific instance of VirtualNetworkTapPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapPropertiesFormatARM(subject VirtualNetworkTapPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTapPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTapPropertiesFormatARM instances for property testing - lazily instantiated by
// VirtualNetworkTapPropertiesFormatARMGenerator()
var virtualNetworkTapPropertiesFormatARMGenerator gopter.Gen

// VirtualNetworkTapPropertiesFormatARMGenerator returns a generator of VirtualNetworkTapPropertiesFormatARM instances for property testing.
// We first initialize virtualNetworkTapPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTapPropertiesFormatARMGenerator() gopter.Gen {
	if virtualNetworkTapPropertiesFormatARMGenerator != nil {
		return virtualNetworkTapPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM(generators)
	virtualNetworkTapPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM(generators)
	virtualNetworkTapPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTapPropertiesFormatARM{}), generators)

	return virtualNetworkTapPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DestinationPort"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTapPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DestinationLoadBalancerFrontEndIPConfiguration"] = gen.PtrOf(FrontendIPConfigurationARMGenerator())
	gens["DestinationNetworkInterfaceIPConfiguration"] = gen.PtrOf(NetworkInterfaceIPConfigurationARMGenerator())
}

func Test_ApplicationGatewayBackendAddressARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressARM, ApplicationGatewayBackendAddressARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressARM runs a test to see if a specific instance of ApplicationGatewayBackendAddressARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressARM(subject ApplicationGatewayBackendAddressARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressARM instances for property testing - lazily instantiated by
// ApplicationGatewayBackendAddressARMGenerator()
var applicationGatewayBackendAddressARMGenerator gopter.Gen

// ApplicationGatewayBackendAddressARMGenerator returns a generator of ApplicationGatewayBackendAddressARM instances for property testing.
func ApplicationGatewayBackendAddressARMGenerator() gopter.Gen {
	if applicationGatewayBackendAddressARMGenerator != nil {
		return applicationGatewayBackendAddressARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressARM(generators)
	applicationGatewayBackendAddressARMGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressARM{}), generators)

	return applicationGatewayBackendAddressARMGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressARM(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}
