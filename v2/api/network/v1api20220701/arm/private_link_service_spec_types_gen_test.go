// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded, FrontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded(subject FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded instances for property testing - lazily
// instantiated by FrontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator()
var frontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded instances for property testing.
func FrontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator != nil {
		return frontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded(generators)
	frontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded{}), generators)

	return frontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_PrivateLinkService_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceIpConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfiguration, PrivateLinkServiceIpConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfiguration runs a test to see if a specific instance of PrivateLinkServiceIpConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfiguration(subject PrivateLinkServiceIpConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfiguration instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfigurationGenerator()
var privateLinkServiceIpConfigurationGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationGenerator returns a generator of PrivateLinkServiceIpConfiguration instances for property testing.
// We first initialize privateLinkServiceIpConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationGenerator != nil {
		return privateLinkServiceIpConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration(generators)
	privateLinkServiceIpConfigurationGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration(generators)
	privateLinkServiceIpConfigurationGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration{}), generators)

	return privateLinkServiceIpConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateLinkServiceIpConfigurationPropertiesGenerator())
}

func Test_PrivateLinkServiceIpConfigurationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties, PrivateLinkServiceIpConfigurationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationProperties(subject PrivateLinkServiceIpConfigurationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationProperties instances for property testing - lazily instantiated by
// PrivateLinkServiceIpConfigurationPropertiesGenerator()
var privateLinkServiceIpConfigurationPropertiesGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationPropertiesGenerator returns a generator of PrivateLinkServiceIpConfigurationProperties instances for property testing.
// We first initialize privateLinkServiceIpConfigurationPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationPropertiesGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationPropertiesGenerator != nil {
		return privateLinkServiceIpConfigurationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties(generators)
	privateLinkServiceIpConfigurationPropertiesGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties(generators)
	privateLinkServiceIpConfigurationPropertiesGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationProperties{}), generators)

	return privateLinkServiceIpConfigurationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationProperties(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(Subnet_PrivateLinkService_SubResourceEmbeddedGenerator())
}

func Test_PrivateLinkServiceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceProperties, PrivateLinkServicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceProperties runs a test to see if a specific instance of PrivateLinkServiceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceProperties(subject PrivateLinkServiceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceProperties instances for property testing - lazily instantiated by
// PrivateLinkServicePropertiesGenerator()
var privateLinkServicePropertiesGenerator gopter.Gen

// PrivateLinkServicePropertiesGenerator returns a generator of PrivateLinkServiceProperties instances for property testing.
// We first initialize privateLinkServicePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServicePropertiesGenerator() gopter.Gen {
	if privateLinkServicePropertiesGenerator != nil {
		return privateLinkServicePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties(generators)
	privateLinkServicePropertiesGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties(generators)
	privateLinkServicePropertiesGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceProperties{}), generators)

	return privateLinkServicePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceProperties(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceProperties(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSetGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfigurationGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfiguration_PrivateLinkService_SubResourceEmbeddedGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSetGenerator())
}

func Test_PrivateLinkService_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkService_Spec, PrivateLinkService_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkService_Spec runs a test to see if a specific instance of PrivateLinkService_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkService_Spec(subject PrivateLinkService_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Spec instances for property testing - lazily instantiated by
// PrivateLinkService_SpecGenerator()
var privateLinkService_SpecGenerator gopter.Gen

// PrivateLinkService_SpecGenerator returns a generator of PrivateLinkService_Spec instances for property testing.
// We first initialize privateLinkService_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkService_SpecGenerator() gopter.Gen {
	if privateLinkService_SpecGenerator != nil {
		return privateLinkService_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(generators)
	privateLinkService_SpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkService_Spec(generators)
	privateLinkService_SpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	return privateLinkService_SpecGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkService_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkService_Spec(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["Properties"] = gen.PtrOf(PrivateLinkServicePropertiesGenerator())
}

func Test_ResourceSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSet, ResourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSet runs a test to see if a specific instance of ResourceSet round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSet(subject ResourceSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSet instances for property testing - lazily instantiated by ResourceSetGenerator()
var resourceSetGenerator gopter.Gen

// ResourceSetGenerator returns a generator of ResourceSet instances for property testing.
func ResourceSetGenerator() gopter.Gen {
	if resourceSetGenerator != nil {
		return resourceSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSet(generators)
	resourceSetGenerator = gen.Struct(reflect.TypeOf(ResourceSet{}), generators)

	return resourceSetGenerator
}

// AddIndependentPropertyGeneratorsForResourceSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSet(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_Subnet_PrivateLinkService_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_PrivateLinkService_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_PrivateLinkService_SubResourceEmbedded, Subnet_PrivateLinkService_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_PrivateLinkService_SubResourceEmbedded runs a test to see if a specific instance of Subnet_PrivateLinkService_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_PrivateLinkService_SubResourceEmbedded(subject Subnet_PrivateLinkService_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_PrivateLinkService_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_PrivateLinkService_SubResourceEmbedded instances for property testing - lazily instantiated by
// Subnet_PrivateLinkService_SubResourceEmbeddedGenerator()
var subnet_PrivateLinkService_SubResourceEmbeddedGenerator gopter.Gen

// Subnet_PrivateLinkService_SubResourceEmbeddedGenerator returns a generator of Subnet_PrivateLinkService_SubResourceEmbedded instances for property testing.
func Subnet_PrivateLinkService_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_PrivateLinkService_SubResourceEmbeddedGenerator != nil {
		return subnet_PrivateLinkService_SubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_PrivateLinkService_SubResourceEmbedded(generators)
	subnet_PrivateLinkService_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_PrivateLinkService_SubResourceEmbedded{}), generators)

	return subnet_PrivateLinkService_SubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_PrivateLinkService_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_PrivateLinkService_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
