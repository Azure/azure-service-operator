// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancers_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_SpecARM, LoadBalancers_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_SpecARM runs a test to see if a specific instance of LoadBalancers_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_SpecARM(subject LoadBalancers_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SpecARM instances for property testing - lazily instantiated by
// LoadBalancers_SpecARMGenerator()
var loadBalancers_SpecARMGenerator gopter.Gen

// LoadBalancers_SpecARMGenerator returns a generator of LoadBalancers_SpecARM instances for property testing.
// We first initialize loadBalancers_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_SpecARMGenerator() gopter.Gen {
	if loadBalancers_SpecARMGenerator != nil {
		return loadBalancers_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SpecARM(generators)
	loadBalancers_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_SpecARM(generators)
	loadBalancers_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SpecARM{}), generators)

	return loadBalancers_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancers_Spec_PropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocation_Type_EdgeZone))
}

func Test_LoadBalancers_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_PropertiesARM, LoadBalancers_Spec_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_PropertiesARM runs a test to see if a specific instance of LoadBalancers_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_PropertiesARM(subject LoadBalancers_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_PropertiesARM instances for property testing - lazily instantiated by
// LoadBalancers_Spec_PropertiesARMGenerator()
var loadBalancers_Spec_PropertiesARMGenerator gopter.Gen

// LoadBalancers_Spec_PropertiesARMGenerator returns a generator of LoadBalancers_Spec_PropertiesARM instances for property testing.
func LoadBalancers_Spec_PropertiesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_PropertiesARMGenerator != nil {
		return loadBalancers_Spec_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_PropertiesARM(generators)
	loadBalancers_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_PropertiesARM{}), generators)

	return loadBalancers_Spec_PropertiesARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(LoadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(LoadBalancers_Spec_Properties_InboundNatPoolsARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(LoadBalancers_Spec_Properties_OutboundRulesARMGenerator())
	gens["Probes"] = gen.SliceOf(LoadBalancers_Spec_Properties_ProbesARMGenerator())
}

func Test_LoadBalancerSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuARM, LoadBalancerSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuARM runs a test to see if a specific instance of LoadBalancerSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuARM(subject LoadBalancerSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSkuARM instances for property testing - lazily instantiated by LoadBalancerSkuARMGenerator()
var loadBalancerSkuARMGenerator gopter.Gen

// LoadBalancerSkuARMGenerator returns a generator of LoadBalancerSkuARM instances for property testing.
func LoadBalancerSkuARMGenerator() gopter.Gen {
	if loadBalancerSkuARMGenerator != nil {
		return loadBalancerSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(generators)
	loadBalancerSkuARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSkuARM{}), generators)

	return loadBalancerSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPoolsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPoolsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPoolsARM, LoadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPoolsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPoolsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(subject LoadBalancers_Spec_Properties_BackendAddressPoolsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPoolsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPoolsARM instances for property testing - lazily
// instantiated by LoadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator()
var loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPoolsARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator != nil {
		return loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}), generators)

	return loadBalancers_Spec_Properties_BackendAddressPoolsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPoolsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM, LoadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(subject LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM instances for property testing - lazily
// instantiated by LoadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator()
var loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator returns a generator of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator != nil {
		return loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(generators)
	loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(generators)
	loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}), generators)

	return loadBalancers_Spec_Properties_FrontendIPConfigurationsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_FrontendIPConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_InboundNatPoolsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_InboundNatPoolsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_InboundNatPoolsARM, LoadBalancers_Spec_Properties_InboundNatPoolsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_InboundNatPoolsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_InboundNatPoolsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_InboundNatPoolsARM(subject LoadBalancers_Spec_Properties_InboundNatPoolsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_InboundNatPoolsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_InboundNatPoolsARM instances for property testing - lazily instantiated by
// LoadBalancers_Spec_Properties_InboundNatPoolsARMGenerator()
var loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_InboundNatPoolsARMGenerator returns a generator of LoadBalancers_Spec_Properties_InboundNatPoolsARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_InboundNatPoolsARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator != nil {
		return loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM(generators)
	loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_InboundNatPoolsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM(generators)
	loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_InboundNatPoolsARM{}), generators)

	return loadBalancers_Spec_Properties_InboundNatPoolsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_InboundNatPoolsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_LoadBalancingRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_LoadBalancingRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_LoadBalancingRulesARM, LoadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_LoadBalancingRulesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_LoadBalancingRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(subject LoadBalancers_Spec_Properties_LoadBalancingRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_LoadBalancingRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_LoadBalancingRulesARM instances for property testing - lazily instantiated
// by LoadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator()
var loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator returns a generator of LoadBalancers_Spec_Properties_LoadBalancingRulesARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator != nil {
		return loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(generators)
	loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(generators)
	loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}), generators)

	return loadBalancers_Spec_Properties_LoadBalancingRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_LoadBalancingRulesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_OutboundRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_OutboundRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_OutboundRulesARM, LoadBalancers_Spec_Properties_OutboundRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_OutboundRulesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_OutboundRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_OutboundRulesARM(subject LoadBalancers_Spec_Properties_OutboundRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_OutboundRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_OutboundRulesARM instances for property testing - lazily instantiated by
// LoadBalancers_Spec_Properties_OutboundRulesARMGenerator()
var loadBalancers_Spec_Properties_OutboundRulesARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_OutboundRulesARMGenerator returns a generator of LoadBalancers_Spec_Properties_OutboundRulesARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_OutboundRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_OutboundRulesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_OutboundRulesARMGenerator != nil {
		return loadBalancers_Spec_Properties_OutboundRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM(generators)
	loadBalancers_Spec_Properties_OutboundRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_OutboundRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM(generators)
	loadBalancers_Spec_Properties_OutboundRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_OutboundRulesARM{}), generators)

	return loadBalancers_Spec_Properties_OutboundRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_OutboundRulesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_ProbesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_ProbesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_ProbesARM, LoadBalancers_Spec_Properties_ProbesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_ProbesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_ProbesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_ProbesARM(subject LoadBalancers_Spec_Properties_ProbesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_ProbesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_ProbesARM instances for property testing - lazily instantiated by
// LoadBalancers_Spec_Properties_ProbesARMGenerator()
var loadBalancers_Spec_Properties_ProbesARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_ProbesARMGenerator returns a generator of LoadBalancers_Spec_Properties_ProbesARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_ProbesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_ProbesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_ProbesARMGenerator != nil {
		return loadBalancers_Spec_Properties_ProbesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM(generators)
	loadBalancers_Spec_Properties_ProbesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_ProbesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM(generators)
	loadBalancers_Spec_Properties_ProbesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_ProbesARM{}), generators)

	return loadBalancers_Spec_Properties_ProbesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_ProbesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM, FrontendIPConfigurationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM(subject FrontendIPConfigurationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormatARMGenerator()
var frontendIPConfigurationPropertiesFormatARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormatARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormatARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormatARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	return frontendIPConfigurationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormat_PrivateIPAddressVersion_IPv4, FrontendIPConfigurationPropertiesFormat_PrivateIPAddressVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormat_PrivateIPAllocationMethod_Dynamic, FrontendIPConfigurationPropertiesFormat_PrivateIPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_InboundNatPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM, InboundNatPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM(subject InboundNatPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormatARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormatARMGenerator()
var inboundNatPoolPropertiesFormatARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatARMGenerator returns a generator of InboundNatPoolPropertiesFormatARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatARMGenerator != nil {
		return inboundNatPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	return inboundNatPoolPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(InboundNatPoolPropertiesFormat_Protocol_All, InboundNatPoolPropertiesFormat_Protocol_Tcp, InboundNatPoolPropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM, LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(subject LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM instances for property testing - lazily
// instantiated by LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator()
var loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator != nil {
		return loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}), generators)

	return loadBalancers_Spec_Properties_BackendAddressPools_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM, LoadBalancingRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM(subject LoadBalancingRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormatARMGenerator()
var loadBalancingRulePropertiesFormatARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatARMGenerator returns a generator of LoadBalancingRulePropertiesFormatARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatARMGenerator != nil {
		return loadBalancingRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	return loadBalancingRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_Protocol_All, LoadBalancingRulePropertiesFormat_Protocol_Tcp, LoadBalancingRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_OutboundRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatARM, OutboundRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatARM runs a test to see if a specific instance of OutboundRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatARM(subject OutboundRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormatARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormatARMGenerator()
var outboundRulePropertiesFormatARMGenerator gopter.Gen

// OutboundRulePropertiesFormatARMGenerator returns a generator of OutboundRulePropertiesFormatARM instances for property testing.
// We first initialize outboundRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatARMGenerator != nil {
		return outboundRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	return outboundRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_ProbePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatARM, ProbePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatARM runs a test to see if a specific instance of ProbePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatARM(subject ProbePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormatARM instances for property testing - lazily instantiated by
// ProbePropertiesFormatARMGenerator()
var probePropertiesFormatARMGenerator gopter.Gen

// ProbePropertiesFormatARMGenerator returns a generator of ProbePropertiesFormatARM instances for property testing.
func ProbePropertiesFormatARMGenerator() gopter.Gen {
	if probePropertiesFormatARMGenerator != nil {
		return probePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(generators)
	probePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormatARM{}), generators)

	return probePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM, LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(subject LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM instances
// for property testing - lazily instantiated by
// LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator()
var loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator gopter.Gen

// LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM instances for property testing.
// We first initialize loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator() gopter.Gen {
	if loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator != nil {
		return loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(generators)
	loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}), generators)

	return loadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormatARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM, LoadBalancerBackendAddressPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM(subject LoadBalancerBackendAddressPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressPropertiesFormatARMGenerator()
var loadBalancerBackendAddressPropertiesFormatARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormatARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormatARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResourceARMGenerator())
}
