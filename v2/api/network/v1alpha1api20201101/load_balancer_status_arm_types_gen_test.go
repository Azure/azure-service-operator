// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSTATUSARM, LoadBalancerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSTATUSARM runs a test to see if a specific instance of LoadBalancer_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSTATUSARM(subject LoadBalancer_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerSTATUSARMGenerator()
var loadBalancerSTATUSARMGenerator gopter.Gen

// LoadBalancerSTATUSARMGenerator returns a generator of LoadBalancer_STATUSARM instances for property testing.
// We first initialize loadBalancerSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerSTATUSARMGenerator() gopter.Gen {
	if loadBalancerSTATUSARMGenerator != nil {
		return loadBalancerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSTATUSARM(generators)
	loadBalancerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerSTATUSARM(generators)
	loadBalancerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUSARM{}), generators)

	return loadBalancerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormatSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuSTATUSARMGenerator())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSTATUSARM, ExtendedLocationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSTATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSTATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocationSTATUSARMGenerator()
var extendedLocationSTATUSARMGenerator gopter.Gen

// ExtendedLocationSTATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocationSTATUSARMGenerator() gopter.Gen {
	if extendedLocationSTATUSARMGenerator != nil {
		return extendedLocationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(generators)
	extendedLocationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_EdgeZone))
}

func Test_LoadBalancerPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormatSTATUSARM, LoadBalancerPropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormatSTATUSARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormatSTATUSARM(subject LoadBalancerPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerPropertiesFormatSTATUSARMGenerator()
var loadBalancerPropertiesFormatSTATUSARMGenerator gopter.Gen

// LoadBalancerPropertiesFormatSTATUSARMGenerator returns a generator of LoadBalancerPropertiesFormat_STATUSARM instances for property testing.
// We first initialize loadBalancerPropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerPropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormatSTATUSARMGenerator != nil {
		return loadBalancerPropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM(generators)
	loadBalancerPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM(generators)
	loadBalancerPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_STATUSARM{}), generators)

	return loadBalancerPropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolSTATUSARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleSTATUSARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleSTATUSARMGenerator())
	gens["Probes"] = gen.SliceOf(ProbeSTATUSARMGenerator())
}

func Test_LoadBalancerSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuSTATUSARM, LoadBalancerSkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuSTATUSARM runs a test to see if a specific instance of LoadBalancerSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuSTATUSARM(subject LoadBalancerSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerSkuSTATUSARMGenerator()
var loadBalancerSkuSTATUSARMGenerator gopter.Gen

// LoadBalancerSkuSTATUSARMGenerator returns a generator of LoadBalancerSku_STATUSARM instances for property testing.
func LoadBalancerSkuSTATUSARMGenerator() gopter.Gen {
	if loadBalancerSkuSTATUSARMGenerator != nil {
		return loadBalancerSkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuSTATUSARM(generators)
	loadBalancerSkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_STATUSARM{}), generators)

	return loadBalancerSkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSTATUSName_Basic, LoadBalancerSkuSTATUSName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSTATUSTier_Global, LoadBalancerSkuSTATUSTier_Regional))
}

func Test_BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM, BackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM(subject BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by BackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var backendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// BackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func BackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if backendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return backendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	backendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return backendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM, FrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(subject FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing -
// lazily instantiated by FrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPool_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolSTATUSARM, InboundNatPoolSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolSTATUSARM runs a test to see if a specific instance of InboundNatPool_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolSTATUSARM(subject InboundNatPool_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_STATUSARM instances for property testing - lazily instantiated by
// InboundNatPoolSTATUSARMGenerator()
var inboundNatPoolSTATUSARMGenerator gopter.Gen

// InboundNatPoolSTATUSARMGenerator returns a generator of InboundNatPool_STATUSARM instances for property testing.
// We first initialize inboundNatPoolSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolSTATUSARMGenerator() gopter.Gen {
	if inboundNatPoolSTATUSARMGenerator != nil {
		return inboundNatPoolSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSTATUSARM(generators)
	inboundNatPoolSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolSTATUSARM(generators)
	inboundNatPoolSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUSARM{}), generators)

	return inboundNatPoolSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPoolSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatSTATUSARMGenerator())
}

func Test_InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM, InboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM(subject InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by InboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var inboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// InboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func InboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if inboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return inboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	inboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return inboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRuleSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleSTATUSARM, LoadBalancingRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleSTATUSARM runs a test to see if a specific instance of LoadBalancingRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleSTATUSARM(subject LoadBalancingRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancingRuleSTATUSARMGenerator()
var loadBalancingRuleSTATUSARMGenerator gopter.Gen

// LoadBalancingRuleSTATUSARMGenerator returns a generator of LoadBalancingRule_STATUSARM instances for property testing.
// We first initialize loadBalancingRuleSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleSTATUSARMGenerator() gopter.Gen {
	if loadBalancingRuleSTATUSARMGenerator != nil {
		return loadBalancingRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSTATUSARM(generators)
	loadBalancingRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleSTATUSARM(generators)
	loadBalancingRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUSARM{}), generators)

	return loadBalancingRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatSTATUSARMGenerator())
}

func Test_OutboundRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleSTATUSARM, OutboundRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleSTATUSARM runs a test to see if a specific instance of OutboundRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleSTATUSARM(subject OutboundRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_STATUSARM instances for property testing - lazily instantiated by
// OutboundRuleSTATUSARMGenerator()
var outboundRuleSTATUSARMGenerator gopter.Gen

// OutboundRuleSTATUSARMGenerator returns a generator of OutboundRule_STATUSARM instances for property testing.
// We first initialize outboundRuleSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleSTATUSARMGenerator() gopter.Gen {
	if outboundRuleSTATUSARMGenerator != nil {
		return outboundRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSTATUSARM(generators)
	outboundRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleSTATUSARM(generators)
	outboundRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUSARM{}), generators)

	return outboundRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRuleSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatSTATUSARMGenerator())
}

func Test_Probe_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeSTATUSARM, ProbeSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeSTATUSARM runs a test to see if a specific instance of Probe_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeSTATUSARM(subject Probe_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_STATUSARM instances for property testing - lazily instantiated by ProbeSTATUSARMGenerator()
var probeSTATUSARMGenerator gopter.Gen

// ProbeSTATUSARMGenerator returns a generator of Probe_STATUSARM instances for property testing.
// We first initialize probeSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbeSTATUSARMGenerator() gopter.Gen {
	if probeSTATUSARMGenerator != nil {
		return probeSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeSTATUSARM(generators)
	probeSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Probe_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForProbeSTATUSARM(generators)
	probeSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Probe_STATUSARM{}), generators)

	return probeSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForProbeSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbeSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbeSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatSTATUSARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM, FrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(subject FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for
// property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_STATUS_IPv4, IPVersion_STATUS_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatSTATUSARM, InboundNatPoolPropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatSTATUSARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatSTATUSARM(subject InboundNatPoolPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormatSTATUSARMGenerator()
var inboundNatPoolPropertiesFormatSTATUSARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatSTATUSARMGenerator returns a generator of InboundNatPoolPropertiesFormat_STATUSARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatSTATUSARMGenerator != nil {
		return inboundNatPoolPropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM(generators)
	inboundNatPoolPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM(generators)
	inboundNatPoolPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_STATUSARM{}), generators)

	return inboundNatPoolPropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_STATUS_All, TransportProtocol_STATUS_Tcp, TransportProtocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSTATUSARM, LoadBalancingRulePropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSTATUSARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSTATUSARM(subject LoadBalancingRulePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormatSTATUSARMGenerator()
var loadBalancingRulePropertiesFormatSTATUSARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatSTATUSARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_STATUSARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatSTATUSARMGenerator != nil {
		return loadBalancingRulePropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM(generators)
	loadBalancingRulePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM(generators)
	loadBalancingRulePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_STATUSARM{}), generators)

	return loadBalancingRulePropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatSTATUSLoadDistribution_Default, LoadBalancingRulePropertiesFormatSTATUSLoadDistribution_SourceIP, LoadBalancingRulePropertiesFormatSTATUSLoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_STATUS_All, TransportProtocol_STATUS_Tcp, TransportProtocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_OutboundRulePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatSTATUSARM, OutboundRulePropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatSTATUSARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatSTATUSARM(subject OutboundRulePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormatSTATUSARMGenerator()
var outboundRulePropertiesFormatSTATUSARMGenerator gopter.Gen

// OutboundRulePropertiesFormatSTATUSARMGenerator returns a generator of OutboundRulePropertiesFormat_STATUSARM instances for property testing.
// We first initialize outboundRulePropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatSTATUSARMGenerator != nil {
		return outboundRulePropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM(generators)
	outboundRulePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM(generators)
	outboundRulePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_STATUSARM{}), generators)

	return outboundRulePropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormatSTATUSProtocol_All, OutboundRulePropertiesFormatSTATUSProtocol_Tcp, OutboundRulePropertiesFormatSTATUSProtocol_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
}

func Test_ProbePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatSTATUSARM, ProbePropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatSTATUSARM runs a test to see if a specific instance of ProbePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatSTATUSARM(subject ProbePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// ProbePropertiesFormatSTATUSARMGenerator()
var probePropertiesFormatSTATUSARMGenerator gopter.Gen

// ProbePropertiesFormatSTATUSARMGenerator returns a generator of ProbePropertiesFormat_STATUSARM instances for property testing.
// We first initialize probePropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbePropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if probePropertiesFormatSTATUSARMGenerator != nil {
		return probePropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatSTATUSARM(generators)
	probePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForProbePropertiesFormatSTATUSARM(generators)
	probePropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_STATUSARM{}), generators)

	return probePropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormatSTATUSProtocol_Http, ProbePropertiesFormatSTATUSProtocol_Https, ProbePropertiesFormatSTATUSProtocol_Tcp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbePropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbePropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceSTATUSARMGenerator())
}

func Test_PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM, PublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(subject PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSTATUSARMGenerator())
}

func Test_Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM, SubnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM(subject Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated
// by SubnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator()
var subnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// SubnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func SubnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return subnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM(generators)
	subnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return subnetSTATUSLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetSTATUSLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
