// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_STATUSARM, LoadBalancer_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_STATUSARM runs a test to see if a specific instance of LoadBalancer_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_STATUSARM(subject LoadBalancer_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancer_STATUSARMGenerator()
var loadBalancer_STATUSARMGenerator gopter.Gen

// LoadBalancer_STATUSARMGenerator returns a generator of LoadBalancer_STATUSARM instances for property testing.
// We first initialize loadBalancer_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_STATUSARMGenerator() gopter.Gen {
	if loadBalancer_STATUSARMGenerator != nil {
		return loadBalancer_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_STATUSARM(generators)
	loadBalancer_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_STATUSARM(generators)
	loadBalancer_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUSARM{}), generators)

	return loadBalancer_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormat_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_STATUSARMGenerator())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUSARM, ExtendedLocation_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSARMGenerator()
var extendedLocation_STATUSARMGenerator gopter.Gen

// ExtendedLocation_STATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocation_STATUSARMGenerator() gopter.Gen {
	if extendedLocation_STATUSARMGenerator != nil {
		return extendedLocation_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(generators)
	extendedLocation_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocation_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone_STATUS))
}

func Test_LoadBalancerPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormat_STATUSARM, LoadBalancerPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormat_STATUSARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormat_STATUSARM(subject LoadBalancerPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerPropertiesFormat_STATUSARMGenerator()
var loadBalancerPropertiesFormat_STATUSARMGenerator gopter.Gen

// LoadBalancerPropertiesFormat_STATUSARMGenerator returns a generator of LoadBalancerPropertiesFormat_STATUSARM instances for property testing.
// We first initialize loadBalancerPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormat_STATUSARMGenerator != nil {
		return loadBalancerPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM(generators)
	loadBalancerPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM(generators)
	loadBalancerPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_STATUSARM{}), generators)

	return loadBalancerPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_STATUSARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_STATUSARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_STATUSARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_STATUSARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_STATUSARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_STATUSARMGenerator())
	gens["Probes"] = gen.SliceOf(Probe_STATUSARMGenerator())
}

func Test_LoadBalancerSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_STATUSARM, LoadBalancerSku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_STATUSARM runs a test to see if a specific instance of LoadBalancerSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_STATUSARM(subject LoadBalancerSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerSku_STATUSARMGenerator()
var loadBalancerSku_STATUSARMGenerator gopter.Gen

// LoadBalancerSku_STATUSARMGenerator returns a generator of LoadBalancerSku_STATUSARM instances for property testing.
func LoadBalancerSku_STATUSARMGenerator() gopter.Gen {
	if loadBalancerSku_STATUSARMGenerator != nil {
		return loadBalancerSku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUSARM(generators)
	loadBalancerSku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_STATUSARM{}), generators)

	return loadBalancerSku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic_STATUS, LoadBalancerSku_Name_Standard_STATUS))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global_STATUS, LoadBalancerSku_Tier_Regional_STATUS))
}

func Test_BackendAddressPool_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_STATUSARM, BackendAddressPool_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_STATUSARM runs a test to see if a specific instance of BackendAddressPool_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_STATUSARM(subject BackendAddressPool_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_STATUSARM instances for property testing - lazily instantiated by
// BackendAddressPool_STATUSARMGenerator()
var backendAddressPool_STATUSARMGenerator gopter.Gen

// BackendAddressPool_STATUSARMGenerator returns a generator of BackendAddressPool_STATUSARM instances for property testing.
// We first initialize backendAddressPool_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPool_STATUSARMGenerator() gopter.Gen {
	if backendAddressPool_STATUSARMGenerator != nil {
		return backendAddressPool_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_STATUSARM(generators)
	backendAddressPool_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPool_STATUSARM(generators)
	backendAddressPool_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_STATUSARM{}), generators)

	return backendAddressPool_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendAddressPool_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPool_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackendAddressPoolPropertiesFormat_STATUSARMGenerator())
}

func Test_FrontendIPConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_STATUSARM, FrontendIPConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_STATUSARM runs a test to see if a specific instance of FrontendIPConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_STATUSARM(subject FrontendIPConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_STATUSARM instances for property testing - lazily instantiated by
// FrontendIPConfiguration_STATUSARMGenerator()
var frontendIPConfiguration_STATUSARMGenerator gopter.Gen

// FrontendIPConfiguration_STATUSARMGenerator returns a generator of FrontendIPConfiguration_STATUSARM instances for property testing.
// We first initialize frontendIPConfiguration_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_STATUSARMGenerator() gopter.Gen {
	if frontendIPConfiguration_STATUSARMGenerator != nil {
		return frontendIPConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUSARM(generators)
	frontendIPConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUSARM(generators)
	frontendIPConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUSARM{}), generators)

	return frontendIPConfiguration_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_STATUSARMGenerator())
}

func Test_InboundNatPool_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_STATUSARM, InboundNatPool_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_STATUSARM runs a test to see if a specific instance of InboundNatPool_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_STATUSARM(subject InboundNatPool_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_STATUSARM instances for property testing - lazily instantiated by
// InboundNatPool_STATUSARMGenerator()
var inboundNatPool_STATUSARMGenerator gopter.Gen

// InboundNatPool_STATUSARMGenerator returns a generator of InboundNatPool_STATUSARM instances for property testing.
// We first initialize inboundNatPool_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_STATUSARMGenerator() gopter.Gen {
	if inboundNatPool_STATUSARMGenerator != nil {
		return inboundNatPool_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_STATUSARM(generators)
	inboundNatPool_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_STATUSARM(generators)
	inboundNatPool_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUSARM{}), generators)

	return inboundNatPool_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormat_STATUSARMGenerator())
}

func Test_InboundNatRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_STATUSARM, InboundNatRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_STATUSARM runs a test to see if a specific instance of InboundNatRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_STATUSARM(subject InboundNatRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_STATUSARM instances for property testing - lazily instantiated by
// InboundNatRule_STATUSARMGenerator()
var inboundNatRule_STATUSARMGenerator gopter.Gen

// InboundNatRule_STATUSARMGenerator returns a generator of InboundNatRule_STATUSARM instances for property testing.
// We first initialize inboundNatRule_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRule_STATUSARMGenerator() gopter.Gen {
	if inboundNatRule_STATUSARMGenerator != nil {
		return inboundNatRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_STATUSARM(generators)
	inboundNatRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRule_STATUSARM(generators)
	inboundNatRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_STATUSARM{}), generators)

	return inboundNatRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatRule_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatRulePropertiesFormat_STATUSARMGenerator())
}

func Test_LoadBalancingRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_STATUSARM, LoadBalancingRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_STATUSARM runs a test to see if a specific instance of LoadBalancingRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_STATUSARM(subject LoadBalancingRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancingRule_STATUSARMGenerator()
var loadBalancingRule_STATUSARMGenerator gopter.Gen

// LoadBalancingRule_STATUSARMGenerator returns a generator of LoadBalancingRule_STATUSARM instances for property testing.
// We first initialize loadBalancingRule_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_STATUSARMGenerator() gopter.Gen {
	if loadBalancingRule_STATUSARMGenerator != nil {
		return loadBalancingRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUSARM(generators)
	loadBalancingRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUSARM(generators)
	loadBalancingRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUSARM{}), generators)

	return loadBalancingRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormat_STATUSARMGenerator())
}

func Test_OutboundRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_STATUSARM, OutboundRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_STATUSARM runs a test to see if a specific instance of OutboundRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_STATUSARM(subject OutboundRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_STATUSARM instances for property testing - lazily instantiated by
// OutboundRule_STATUSARMGenerator()
var outboundRule_STATUSARMGenerator gopter.Gen

// OutboundRule_STATUSARMGenerator returns a generator of OutboundRule_STATUSARM instances for property testing.
// We first initialize outboundRule_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_STATUSARMGenerator() gopter.Gen {
	if outboundRule_STATUSARMGenerator != nil {
		return outboundRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_STATUSARM(generators)
	outboundRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_STATUSARM(generators)
	outboundRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUSARM{}), generators)

	return outboundRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormat_STATUSARMGenerator())
}

func Test_Probe_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_STATUSARM, Probe_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_STATUSARM runs a test to see if a specific instance of Probe_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_STATUSARM(subject Probe_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_STATUSARM instances for property testing - lazily instantiated by Probe_STATUSARMGenerator()
var probe_STATUSARMGenerator gopter.Gen

// Probe_STATUSARMGenerator returns a generator of Probe_STATUSARM instances for property testing.
// We first initialize probe_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_STATUSARMGenerator() gopter.Gen {
	if probe_STATUSARMGenerator != nil {
		return probe_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_STATUSARM(generators)
	probe_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Probe_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForProbe_STATUSARM(generators)
	probe_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Probe_STATUSARM{}), generators)

	return probe_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForProbe_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormat_STATUSARMGenerator())
}

func Test_BackendAddressPoolPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPoolPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_STATUSARM, BackendAddressPoolPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_STATUSARM runs a test to see if a specific instance of BackendAddressPoolPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolPropertiesFormat_STATUSARM(subject BackendAddressPoolPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPoolPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPoolPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// BackendAddressPoolPropertiesFormat_STATUSARMGenerator()
var backendAddressPoolPropertiesFormat_STATUSARMGenerator gopter.Gen

// BackendAddressPoolPropertiesFormat_STATUSARMGenerator returns a generator of BackendAddressPoolPropertiesFormat_STATUSARM instances for property testing.
// We first initialize backendAddressPoolPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPoolPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if backendAddressPoolPropertiesFormat_STATUSARMGenerator != nil {
		return backendAddressPoolPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM(generators)
	backendAddressPoolPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM(generators)
	backendAddressPoolPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolPropertiesFormat_STATUSARM{}), generators)

	return backendAddressPoolPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendIPConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_STATUSARMGenerator())
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancerBackendAddress_STATUSARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["OutboundRule"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_STATUSARM, FrontendIPConfigurationPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_STATUSARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_STATUSARM(subject FrontendIPConfigurationPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_STATUSARM instances for property testing - lazily instantiated
// by FrontendIPConfigurationPropertiesFormat_STATUSARMGenerator()
var frontendIPConfigurationPropertiesFormat_STATUSARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_STATUSARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_STATUSARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_STATUSARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM(generators)
	frontendIPConfigurationPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM(generators)
	frontendIPConfigurationPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_STATUSARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4_STATUS, IPVersion_IPv6_STATUS))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic_STATUS, IPAllocationMethod_Static_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_STATUSARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormat_STATUSARM, InboundNatPoolPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormat_STATUSARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormat_STATUSARM(subject InboundNatPoolPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormat_STATUSARMGenerator()
var inboundNatPoolPropertiesFormat_STATUSARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormat_STATUSARMGenerator returns a generator of InboundNatPoolPropertiesFormat_STATUSARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormat_STATUSARMGenerator != nil {
		return inboundNatPoolPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM(generators)
	inboundNatPoolPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM(generators)
	inboundNatPoolPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_STATUSARM{}), generators)

	return inboundNatPoolPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All_STATUS, TransportProtocol_Tcp_STATUS, TransportProtocol_Udp_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_InboundNatRulePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRulePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRulePropertiesFormat_STATUSARM, InboundNatRulePropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRulePropertiesFormat_STATUSARM runs a test to see if a specific instance of InboundNatRulePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRulePropertiesFormat_STATUSARM(subject InboundNatRulePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRulePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRulePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// InboundNatRulePropertiesFormat_STATUSARMGenerator()
var inboundNatRulePropertiesFormat_STATUSARMGenerator gopter.Gen

// InboundNatRulePropertiesFormat_STATUSARMGenerator returns a generator of InboundNatRulePropertiesFormat_STATUSARM instances for property testing.
// We first initialize inboundNatRulePropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRulePropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if inboundNatRulePropertiesFormat_STATUSARMGenerator != nil {
		return inboundNatRulePropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM(generators)
	inboundNatRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM(generators)
	inboundNatRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormat_STATUSARM{}), generators)

	return inboundNatRulePropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All_STATUS, TransportProtocol_Tcp_STATUS, TransportProtocol_Udp_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendIPConfiguration"] = gen.PtrOf(NetworkInterfaceIPConfiguration_STATUSARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_STATUSARM, LoadBalancingRulePropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_STATUSARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_STATUSARM(subject LoadBalancingRulePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormat_STATUSARMGenerator()
var loadBalancingRulePropertiesFormat_STATUSARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormat_STATUSARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_STATUSARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormat_STATUSARMGenerator != nil {
		return loadBalancingRulePropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM(generators)
	loadBalancingRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM(generators)
	loadBalancingRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_STATUSARM{}), generators)

	return loadBalancingRulePropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default_STATUS, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP_STATUS, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol_STATUS))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All_STATUS, TransportProtocol_Tcp_STATUS, TransportProtocol_Udp_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_OutboundRulePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormat_STATUSARM, OutboundRulePropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormat_STATUSARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormat_STATUSARM(subject OutboundRulePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormat_STATUSARMGenerator()
var outboundRulePropertiesFormat_STATUSARMGenerator gopter.Gen

// OutboundRulePropertiesFormat_STATUSARMGenerator returns a generator of OutboundRulePropertiesFormat_STATUSARM instances for property testing.
// We first initialize outboundRulePropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormat_STATUSARMGenerator != nil {
		return outboundRulePropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM(generators)
	outboundRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM(generators)
	outboundRulePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_STATUSARM{}), generators)

	return outboundRulePropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All_STATUS, OutboundRulePropertiesFormat_Protocol_Tcp_STATUS, OutboundRulePropertiesFormat_Protocol_Udp_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_STATUSARMGenerator())
}

func Test_ProbePropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormat_STATUSARM, ProbePropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormat_STATUSARM runs a test to see if a specific instance of ProbePropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormat_STATUSARM(subject ProbePropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// ProbePropertiesFormat_STATUSARMGenerator()
var probePropertiesFormat_STATUSARMGenerator gopter.Gen

// ProbePropertiesFormat_STATUSARMGenerator returns a generator of ProbePropertiesFormat_STATUSARM instances for property testing.
// We first initialize probePropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbePropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if probePropertiesFormat_STATUSARMGenerator != nil {
		return probePropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_STATUSARM(generators)
	probePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForProbePropertiesFormat_STATUSARM(generators)
	probePropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_STATUSARM{}), generators)

	return probePropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http_STATUS, ProbePropertiesFormat_Protocol_Https_STATUS, ProbePropertiesFormat_Protocol_Tcp_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbePropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbePropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSARMGenerator())
}

func Test_LoadBalancerBackendAddress_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddress_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddress_STATUSARM, LoadBalancerBackendAddress_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddress_STATUSARM runs a test to see if a specific instance of LoadBalancerBackendAddress_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddress_STATUSARM(subject LoadBalancerBackendAddress_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddress_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddress_STATUSARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddress_STATUSARMGenerator()
var loadBalancerBackendAddress_STATUSARMGenerator gopter.Gen

// LoadBalancerBackendAddress_STATUSARMGenerator returns a generator of LoadBalancerBackendAddress_STATUSARM instances for property testing.
// We first initialize loadBalancerBackendAddress_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddress_STATUSARMGenerator() gopter.Gen {
	if loadBalancerBackendAddress_STATUSARMGenerator != nil {
		return loadBalancerBackendAddress_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM(generators)
	loadBalancerBackendAddress_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM(generators)
	loadBalancerBackendAddress_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_STATUSARM{}), generators)

	return loadBalancerBackendAddress_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator())
}

func Test_PublicIPAddress_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_STATUSARM, PublicIPAddress_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_STATUSARM runs a test to see if a specific instance of PublicIPAddress_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_STATUSARM(subject PublicIPAddress_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_STATUSARM instances for property testing - lazily instantiated by
// PublicIPAddress_STATUSARMGenerator()
var publicIPAddress_STATUSARMGenerator gopter.Gen

// PublicIPAddress_STATUSARMGenerator returns a generator of PublicIPAddress_STATUSARM instances for property testing.
// We first initialize publicIPAddress_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_STATUSARMGenerator() gopter.Gen {
	if publicIPAddress_STATUSARMGenerator != nil {
		return publicIPAddress_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUSARM(generators)
	publicIPAddress_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_STATUSARM(generators)
	publicIPAddress_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUSARM{}), generators)

	return publicIPAddress_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_STATUSARMGenerator())
}

func Test_Subnet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_STATUSARM, Subnet_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_STATUSARM runs a test to see if a specific instance of Subnet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_STATUSARM(subject Subnet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_STATUSARM instances for property testing - lazily instantiated by Subnet_STATUSARMGenerator()
var subnet_STATUSARMGenerator gopter.Gen

// Subnet_STATUSARMGenerator returns a generator of Subnet_STATUSARM instances for property testing.
// We first initialize subnet_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Subnet_STATUSARMGenerator() gopter.Gen {
	if subnet_STATUSARMGenerator != nil {
		return subnet_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_STATUSARM(generators)
	subnet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForSubnet_STATUSARM(generators)
	subnet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUSARM{}), generators)

	return subnet_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSubnet_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSubnet_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SubnetPropertiesFormat_STATUSARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_STATUSARM, LoadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_STATUSARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(subject LoadBalancerBackendAddressPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormat_STATUSARM instances for property testing - lazily
// instantiated by LoadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator()
var loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormat_STATUSARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(generators)
	loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(generators)
	loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_STATUSARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["NetworkInterfaceIPConfiguration"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM, PublicIPAddressPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM(subject PublicIPAddressPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// PublicIPAddressPropertiesFormat_STATUSARMGenerator()
var publicIPAddressPropertiesFormat_STATUSARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_STATUSARMGenerator returns a generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_STATUSARMGenerator != nil {
		return publicIPAddressPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	publicIPAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	publicIPAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	return publicIPAddressPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_None_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4_STATUS, IPVersion_IPv6_STATUS))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic_STATUS, IPAllocationMethod_Static_STATUS))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_STATUSARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_STATUSARMGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfiguration_STATUSARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_STATUSARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_STATUSARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSARMGenerator())
}

func Test_NatGateway_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGateway_STATUSARM, NatGateway_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGateway_STATUSARM runs a test to see if a specific instance of NatGateway_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGateway_STATUSARM(subject NatGateway_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_STATUSARM instances for property testing - lazily instantiated by
// NatGateway_STATUSARMGenerator()
var natGateway_STATUSARMGenerator gopter.Gen

// NatGateway_STATUSARMGenerator returns a generator of NatGateway_STATUSARM instances for property testing.
// We first initialize natGateway_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGateway_STATUSARMGenerator() gopter.Gen {
	if natGateway_STATUSARMGenerator != nil {
		return natGateway_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUSARM(generators)
	natGateway_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNatGateway_STATUSARM(generators)
	natGateway_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUSARM{}), generators)

	return natGateway_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGateway_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGateway_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGateway_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGateway_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NatGatewayPropertiesFormat_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(NatGatewaySku_STATUSARMGenerator())
}

func Test_NatGatewayPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewayPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewayPropertiesFormat_STATUSARM, NatGatewayPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewayPropertiesFormat_STATUSARM runs a test to see if a specific instance of NatGatewayPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewayPropertiesFormat_STATUSARM(subject NatGatewayPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewayPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewayPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// NatGatewayPropertiesFormat_STATUSARMGenerator()
var natGatewayPropertiesFormat_STATUSARMGenerator gopter.Gen

// NatGatewayPropertiesFormat_STATUSARMGenerator returns a generator of NatGatewayPropertiesFormat_STATUSARM instances for property testing.
// We first initialize natGatewayPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewayPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if natGatewayPropertiesFormat_STATUSARMGenerator != nil {
		return natGatewayPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM(generators)
	natGatewayPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM(generators)
	natGatewayPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_STATUSARM{}), generators)

	return natGatewayPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["PublicIpAddresses"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["PublicIpPrefixes"] = gen.SliceOf(SubResource_STATUSARMGenerator())
	gens["Subnets"] = gen.SliceOf(SubResource_STATUSARMGenerator())
}
