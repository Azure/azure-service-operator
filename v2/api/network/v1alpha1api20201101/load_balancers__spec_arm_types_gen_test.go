// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancers_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecARM, LoadBalancersSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecARM runs a test to see if a specific instance of LoadBalancers_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecARM(subject LoadBalancers_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SpecARM instances for property testing - lazily instantiated by
// LoadBalancersSpecARMGenerator()
var loadBalancersSpecARMGenerator gopter.Gen

// LoadBalancersSpecARMGenerator returns a generator of LoadBalancers_SpecARM instances for property testing.
// We first initialize loadBalancersSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecARMGenerator() gopter.Gen {
	if loadBalancersSpecARMGenerator != nil {
		return loadBalancersSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecARM(generators)
	loadBalancersSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecARM(generators)
	loadBalancersSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SpecARM{}), generators)

	return loadBalancersSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancersSpecPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationTypeEdgeZone))
}

func Test_LoadBalancerSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuARM, LoadBalancerSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuARM runs a test to see if a specific instance of LoadBalancerSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuARM(subject LoadBalancerSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSkuARM instances for property testing - lazily instantiated by LoadBalancerSkuARMGenerator()
var loadBalancerSkuARMGenerator gopter.Gen

// LoadBalancerSkuARMGenerator returns a generator of LoadBalancerSkuARM instances for property testing.
func LoadBalancerSkuARMGenerator() gopter.Gen {
	if loadBalancerSkuARMGenerator != nil {
		return loadBalancerSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(generators)
	loadBalancerSkuARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSkuARM{}), generators)

	return loadBalancerSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuNameBasic, LoadBalancerSkuNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuTierGlobal, LoadBalancerSkuTierRegional))
}

func Test_LoadBalancers_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesARM, LoadBalancersSpecPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesARM runs a test to see if a specific instance of LoadBalancers_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesARM(subject LoadBalancers_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_PropertiesARM instances for property testing - lazily instantiated by
// LoadBalancersSpecPropertiesARMGenerator()
var loadBalancersSpecPropertiesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesARMGenerator returns a generator of LoadBalancers_Spec_PropertiesARM instances for property testing.
func LoadBalancersSpecPropertiesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesARMGenerator != nil {
		return loadBalancersSpecPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesARM(generators)
	loadBalancersSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_PropertiesARM{}), generators)

	return loadBalancersSpecPropertiesARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(LoadBalancersSpecPropertiesBackendAddressPoolsARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(LoadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(LoadBalancersSpecPropertiesInboundNatPoolsARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancersSpecPropertiesLoadBalancingRulesARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(LoadBalancersSpecPropertiesOutboundRulesARMGenerator())
	gens["Probes"] = gen.SliceOf(LoadBalancersSpecPropertiesProbesARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPoolsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPoolsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsARM, LoadBalancersSpecPropertiesBackendAddressPoolsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPoolsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsARM(subject LoadBalancers_Spec_Properties_BackendAddressPoolsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPoolsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPoolsARM instances for property testing - lazily
// instantiated by LoadBalancersSpecPropertiesBackendAddressPoolsARMGenerator()
var loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesBackendAddressPoolsARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPoolsARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesBackendAddressPoolsARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator != nil {
		return loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}), generators)

	return loadBalancersSpecPropertiesBackendAddressPoolsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM, LoadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(subject LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM instances for property testing - lazily
// instantiated by LoadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator()
var loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator returns a generator of LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator != nil {
		return loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(generators)
	loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(generators)
	loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}), generators)

	return loadBalancersSpecPropertiesFrontendIPConfigurationsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesFrontendIPConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_InboundNatPoolsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_InboundNatPoolsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesInboundNatPoolsARM, LoadBalancersSpecPropertiesInboundNatPoolsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesInboundNatPoolsARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_InboundNatPoolsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesInboundNatPoolsARM(subject LoadBalancers_Spec_Properties_InboundNatPoolsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_InboundNatPoolsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_InboundNatPoolsARM instances for property testing - lazily instantiated by
// LoadBalancersSpecPropertiesInboundNatPoolsARMGenerator()
var loadBalancersSpecPropertiesInboundNatPoolsARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesInboundNatPoolsARMGenerator returns a generator of LoadBalancers_Spec_Properties_InboundNatPoolsARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesInboundNatPoolsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesInboundNatPoolsARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesInboundNatPoolsARMGenerator != nil {
		return loadBalancersSpecPropertiesInboundNatPoolsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM(generators)
	loadBalancersSpecPropertiesInboundNatPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_InboundNatPoolsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM(generators)
	loadBalancersSpecPropertiesInboundNatPoolsARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_InboundNatPoolsARM{}), generators)

	return loadBalancersSpecPropertiesInboundNatPoolsARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesInboundNatPoolsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_LoadBalancingRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_LoadBalancingRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesLoadBalancingRulesARM, LoadBalancersSpecPropertiesLoadBalancingRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesLoadBalancingRulesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_LoadBalancingRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesLoadBalancingRulesARM(subject LoadBalancers_Spec_Properties_LoadBalancingRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_LoadBalancingRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_LoadBalancingRulesARM instances for property testing - lazily instantiated
// by LoadBalancersSpecPropertiesLoadBalancingRulesARMGenerator()
var loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesLoadBalancingRulesARMGenerator returns a generator of LoadBalancers_Spec_Properties_LoadBalancingRulesARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesLoadBalancingRulesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator != nil {
		return loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM(generators)
	loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM(generators)
	loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}), generators)

	return loadBalancersSpecPropertiesLoadBalancingRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesLoadBalancingRulesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_OutboundRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_OutboundRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesOutboundRulesARM, LoadBalancersSpecPropertiesOutboundRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesOutboundRulesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_OutboundRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesOutboundRulesARM(subject LoadBalancers_Spec_Properties_OutboundRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_OutboundRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_OutboundRulesARM instances for property testing - lazily instantiated by
// LoadBalancersSpecPropertiesOutboundRulesARMGenerator()
var loadBalancersSpecPropertiesOutboundRulesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesOutboundRulesARMGenerator returns a generator of LoadBalancers_Spec_Properties_OutboundRulesARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesOutboundRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesOutboundRulesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesOutboundRulesARMGenerator != nil {
		return loadBalancersSpecPropertiesOutboundRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM(generators)
	loadBalancersSpecPropertiesOutboundRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_OutboundRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM(generators)
	loadBalancersSpecPropertiesOutboundRulesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_OutboundRulesARM{}), generators)

	return loadBalancersSpecPropertiesOutboundRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesOutboundRulesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_ProbesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_ProbesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesProbesARM, LoadBalancersSpecPropertiesProbesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesProbesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_ProbesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesProbesARM(subject LoadBalancers_Spec_Properties_ProbesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_ProbesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_ProbesARM instances for property testing - lazily instantiated by
// LoadBalancersSpecPropertiesProbesARMGenerator()
var loadBalancersSpecPropertiesProbesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesProbesARMGenerator returns a generator of LoadBalancers_Spec_Properties_ProbesARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesProbesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesProbesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesProbesARMGenerator != nil {
		return loadBalancersSpecPropertiesProbesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM(generators)
	loadBalancersSpecPropertiesProbesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_ProbesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM(generators)
	loadBalancersSpecPropertiesProbesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_ProbesARM{}), generators)

	return loadBalancersSpecPropertiesProbesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesProbesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM, FrontendIPConfigurationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM(subject FrontendIPConfigurationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormatARMGenerator()
var frontendIPConfigurationPropertiesFormatARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormatARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormatARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormatARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	return frontendIPConfigurationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv4, FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodDynamic, FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodStatic))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_InboundNatPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM, InboundNatPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM(subject InboundNatPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormatARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormatARMGenerator()
var inboundNatPoolPropertiesFormatARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatARMGenerator returns a generator of InboundNatPoolPropertiesFormatARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatARMGenerator != nil {
		return inboundNatPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	return inboundNatPoolPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(InboundNatPoolPropertiesFormatProtocolAll, InboundNatPoolPropertiesFormatProtocolTcp, InboundNatPoolPropertiesFormatProtocolUdp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM, LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(subject LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM instances for property testing - lazily
// instantiated by LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator()
var loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator != nil {
		return loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}), generators)

	return loadBalancersSpecPropertiesBackendAddressPoolsPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM, LoadBalancingRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM(subject LoadBalancingRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormatARMGenerator()
var loadBalancingRulePropertiesFormatARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatARMGenerator returns a generator of LoadBalancingRulePropertiesFormatARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatARMGenerator != nil {
		return loadBalancingRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	return loadBalancingRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatLoadDistributionDefault, LoadBalancingRulePropertiesFormatLoadDistributionSourceIP, LoadBalancingRulePropertiesFormatLoadDistributionSourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatProtocolAll, LoadBalancingRulePropertiesFormatProtocolTcp, LoadBalancingRulePropertiesFormatProtocolUdp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_OutboundRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatARM, OutboundRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatARM runs a test to see if a specific instance of OutboundRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatARM(subject OutboundRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormatARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormatARMGenerator()
var outboundRulePropertiesFormatARMGenerator gopter.Gen

// OutboundRulePropertiesFormatARMGenerator returns a generator of OutboundRulePropertiesFormatARM instances for property testing.
// We first initialize outboundRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatARMGenerator != nil {
		return outboundRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	return outboundRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormatProtocolAll, OutboundRulePropertiesFormatProtocolTcp, OutboundRulePropertiesFormatProtocolUdp))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_ProbePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatARM, ProbePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatARM runs a test to see if a specific instance of ProbePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatARM(subject ProbePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormatARM instances for property testing - lazily instantiated by
// ProbePropertiesFormatARMGenerator()
var probePropertiesFormatARMGenerator gopter.Gen

// ProbePropertiesFormatARMGenerator returns a generator of ProbePropertiesFormatARM instances for property testing.
func ProbePropertiesFormatARMGenerator() gopter.Gen {
	if probePropertiesFormatARMGenerator != nil {
		return probePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(generators)
	probePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormatARM{}), generators)

	return probePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormatProtocolHttp, ProbePropertiesFormatProtocolHttps, ProbePropertiesFormatProtocolTcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM, LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM runs a test to see if a specific instance of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(subject LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM instances
// for property testing - lazily instantiated by
// LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator()
var loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator gopter.Gen

// LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator returns a generator of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM instances for property testing.
// We first initialize loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator() gopter.Gen {
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator != nil {
		return loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(generators)
	loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}), generators)

	return loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddressesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormatARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM, LoadBalancerBackendAddressPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM(subject LoadBalancerBackendAddressPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressPropertiesFormatARMGenerator()
var loadBalancerBackendAddressPropertiesFormatARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormatARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormatARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResourceARMGenerator())
}
