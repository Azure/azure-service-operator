// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancers_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSPECARM, LoadBalancersSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSPECARM runs a test to see if a specific instance of LoadBalancers_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSPECARM(subject LoadBalancers_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SPECARM instances for property testing - lazily instantiated by
//LoadBalancersSPECARMGenerator()
var loadBalancersSPECARMGenerator gopter.Gen

// LoadBalancersSPECARMGenerator returns a generator of LoadBalancers_SPECARM instances for property testing.
// We first initialize loadBalancersSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSPECARMGenerator() gopter.Gen {
	if loadBalancersSPECARMGenerator != nil {
		return loadBalancersSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSPECARM(generators)
	loadBalancersSPECARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSPECARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSPECARM(generators)
	loadBalancersSPECARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPECARM{}), generators)

	return loadBalancersSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormatSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuSpecARMGenerator())
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpecARM, ExtendedLocationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocationSpecARMGenerator()
var extendedLocationSpecARMGenerator gopter.Gen

// ExtendedLocationSpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocationSpecARMGenerator() gopter.Gen {
	if extendedLocationSpecARMGenerator != nil {
		return extendedLocationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(generators)
	extendedLocationSpecARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_SpecEdgeZone)
}

func Test_LoadBalancerPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormatSpecARM, LoadBalancerPropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormatSpecARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormatSpecARM(subject LoadBalancerPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//LoadBalancerPropertiesFormatSpecARMGenerator()
var loadBalancerPropertiesFormatSpecARMGenerator gopter.Gen

// LoadBalancerPropertiesFormatSpecARMGenerator returns a generator of LoadBalancerPropertiesFormat_SpecARM instances for property testing.
func LoadBalancerPropertiesFormatSpecARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormatSpecARMGenerator != nil {
		return loadBalancerPropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSpecARM(generators)
	loadBalancerPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_SpecARM{}), generators)

	return loadBalancerPropertiesFormatSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolSpecARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleSpecARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleSpecARMGenerator())
	gens["Probes"] = gen.SliceOf(ProbeSpecARMGenerator())
}

func Test_LoadBalancerSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuSpecARM, LoadBalancerSkuSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuSpecARM runs a test to see if a specific instance of LoadBalancerSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuSpecARM(subject LoadBalancerSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_SpecARM instances for property testing - lazily instantiated by
//LoadBalancerSkuSpecARMGenerator()
var loadBalancerSkuSpecARMGenerator gopter.Gen

// LoadBalancerSkuSpecARMGenerator returns a generator of LoadBalancerSku_SpecARM instances for property testing.
func LoadBalancerSkuSpecARMGenerator() gopter.Gen {
	if loadBalancerSkuSpecARMGenerator != nil {
		return loadBalancerSkuSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuSpecARM(generators)
	loadBalancerSkuSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_SpecARM{}), generators)

	return loadBalancerSkuSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSpecNameBasic, LoadBalancerSkuSpecNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSpecTierGlobal, LoadBalancerSkuSpecTierRegional))
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM, BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator()
var backendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if backendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return backendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM(generators)
	backendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return backendAddressPoolSpecLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM, FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator()
var frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPool_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolSpecARM, InboundNatPoolSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolSpecARM runs a test to see if a specific instance of InboundNatPool_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolSpecARM(subject InboundNatPool_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_SpecARM instances for property testing - lazily instantiated by
//InboundNatPoolSpecARMGenerator()
var inboundNatPoolSpecARMGenerator gopter.Gen

// InboundNatPoolSpecARMGenerator returns a generator of InboundNatPool_SpecARM instances for property testing.
// We first initialize inboundNatPoolSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolSpecARMGenerator() gopter.Gen {
	if inboundNatPoolSpecARMGenerator != nil {
		return inboundNatPoolSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSpecARM(generators)
	inboundNatPoolSpecARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSpecARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolSpecARM(generators)
	inboundNatPoolSpecARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_SpecARM{}), generators)

	return inboundNatPoolSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPoolSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatSpecARMGenerator())
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM, InboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by InboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator()
var inboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// InboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func InboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if inboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return inboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM(generators)
	inboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return inboundNatRuleSpecLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRuleSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleSpecARM, LoadBalancingRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleSpecARM runs a test to see if a specific instance of LoadBalancingRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleSpecARM(subject LoadBalancingRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_SpecARM instances for property testing - lazily instantiated by
//LoadBalancingRuleSpecARMGenerator()
var loadBalancingRuleSpecARMGenerator gopter.Gen

// LoadBalancingRuleSpecARMGenerator returns a generator of LoadBalancingRule_SpecARM instances for property testing.
// We first initialize loadBalancingRuleSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleSpecARMGenerator() gopter.Gen {
	if loadBalancingRuleSpecARMGenerator != nil {
		return loadBalancingRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSpecARM(generators)
	loadBalancingRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleSpecARM(generators)
	loadBalancingRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_SpecARM{}), generators)

	return loadBalancingRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatSpecARMGenerator())
}

func Test_OutboundRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleSpecARM, OutboundRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleSpecARM runs a test to see if a specific instance of OutboundRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleSpecARM(subject OutboundRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_SpecARM instances for property testing - lazily instantiated by
//OutboundRuleSpecARMGenerator()
var outboundRuleSpecARMGenerator gopter.Gen

// OutboundRuleSpecARMGenerator returns a generator of OutboundRule_SpecARM instances for property testing.
// We first initialize outboundRuleSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleSpecARMGenerator() gopter.Gen {
	if outboundRuleSpecARMGenerator != nil {
		return outboundRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSpecARM(generators)
	outboundRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSpecARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleSpecARM(generators)
	outboundRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_SpecARM{}), generators)

	return outboundRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRuleSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatSpecARMGenerator())
}

func Test_Probe_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeSpecARM, ProbeSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeSpecARM runs a test to see if a specific instance of Probe_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeSpecARM(subject Probe_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_SpecARM instances for property testing - lazily instantiated by ProbeSpecARMGenerator()
var probeSpecARMGenerator gopter.Gen

// ProbeSpecARMGenerator returns a generator of Probe_SpecARM instances for property testing.
// We first initialize probeSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbeSpecARMGenerator() gopter.Gen {
	if probeSpecARMGenerator != nil {
		return probeSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeSpecARM(generators)
	probeSpecARMGenerator = gen.Struct(reflect.TypeOf(Probe_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeSpecARM(generators)
	AddRelatedPropertyGeneratorsForProbeSpecARM(generators)
	probeSpecARMGenerator = gen.Struct(reflect.TypeOf(Probe_SpecARM{}), generators)

	return probeSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForProbeSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbeSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbeSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatSpecARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM, FrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(subject FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property
//testing - lazily instantiated by FrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator()
var frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetSpecLoadBalancerSubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatSpecARM, InboundNatPoolPropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatSpecARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatSpecARM(subject InboundNatPoolPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//InboundNatPoolPropertiesFormatSpecARMGenerator()
var inboundNatPoolPropertiesFormatSpecARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatSpecARMGenerator returns a generator of InboundNatPoolPropertiesFormat_SpecARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatSpecARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatSpecARMGenerator != nil {
		return inboundNatPoolPropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM(generators)
	inboundNatPoolPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM(generators)
	inboundNatPoolPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_SpecARM{}), generators)

	return inboundNatPoolPropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.Int()
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.Int()
	gens["FrontendPortRangeStart"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp)
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSpecARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSpecARM, LoadBalancingRulePropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSpecARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatSpecARM(subject LoadBalancingRulePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//LoadBalancingRulePropertiesFormatSpecARMGenerator()
var loadBalancingRulePropertiesFormatSpecARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatSpecARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_SpecARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatSpecARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatSpecARMGenerator != nil {
		return loadBalancingRulePropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM(generators)
	loadBalancingRulePropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM(generators)
	loadBalancingRulePropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_SpecARM{}), generators)

	return loadBalancingRulePropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatSpecLoadDistributionDefault, LoadBalancingRulePropertiesFormatSpecLoadDistributionSourceIP, LoadBalancingRulePropertiesFormatSpecLoadDistributionSourceIPProtocol))
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp)
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceSpecARMGenerator())
}

func Test_OutboundRulePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatSpecARM, OutboundRulePropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatSpecARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatSpecARM(subject OutboundRulePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//OutboundRulePropertiesFormatSpecARMGenerator()
var outboundRulePropertiesFormatSpecARMGenerator gopter.Gen

// OutboundRulePropertiesFormatSpecARMGenerator returns a generator of OutboundRulePropertiesFormat_SpecARM instances for property testing.
// We first initialize outboundRulePropertiesFormatSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatSpecARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatSpecARMGenerator != nil {
		return outboundRulePropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM(generators)
	outboundRulePropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM(generators)
	outboundRulePropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_SpecARM{}), generators)

	return outboundRulePropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(OutboundRulePropertiesFormatSpecProtocolAll, OutboundRulePropertiesFormatSpecProtocolTcp, OutboundRulePropertiesFormatSpecProtocolUdp)
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = SubResourceSpecARMGenerator()
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceSpecARMGenerator())
}

func Test_ProbePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatSpecARM, ProbePropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatSpecARM runs a test to see if a specific instance of ProbePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatSpecARM(subject ProbePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//ProbePropertiesFormatSpecARMGenerator()
var probePropertiesFormatSpecARMGenerator gopter.Gen

// ProbePropertiesFormatSpecARMGenerator returns a generator of ProbePropertiesFormat_SpecARM instances for property testing.
func ProbePropertiesFormatSpecARMGenerator() gopter.Gen {
	if probePropertiesFormatSpecARMGenerator != nil {
		return probePropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatSpecARM(generators)
	probePropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_SpecARM{}), generators)

	return probePropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.Int()
	gens["Protocol"] = gen.OneConstOf(ProbePropertiesFormatSpecProtocolHttp, ProbePropertiesFormatSpecProtocolHttps, ProbePropertiesFormatSpecProtocolTcp)
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddress_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpecARM, PublicIPAddressSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpecARM runs a test to see if a specific instance of PublicIPAddress_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpecARM(subject PublicIPAddress_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressSpecARMGenerator()
var publicIPAddressSpecARMGenerator gopter.Gen

// PublicIPAddressSpecARMGenerator returns a generator of PublicIPAddress_SpecARM instances for property testing.
// We first initialize publicIPAddressSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpecARMGenerator() gopter.Gen {
	if publicIPAddressSpecARMGenerator != nil {
		return publicIPAddressSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	publicIPAddressSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	publicIPAddressSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	return publicIPAddressSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSpecARMGenerator())
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbeddedARM, SubnetSpecLoadBalancerSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbeddedARM(subject Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
//SubnetSpecLoadBalancerSubResourceEmbeddedARMGenerator()
var subnetSpecLoadBalancerSubResourceEmbeddedARMGenerator gopter.Gen

// SubnetSpecLoadBalancerSubResourceEmbeddedARMGenerator returns a generator of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func SubnetSpecLoadBalancerSubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnetSpecLoadBalancerSubResourceEmbeddedARMGenerator != nil {
		return subnetSpecLoadBalancerSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetSpecLoadBalancerSubResourceEmbeddedARM(generators)
	subnetSpecLoadBalancerSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return subnetSpecLoadBalancerSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnetSpecLoadBalancerSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetSpecLoadBalancerSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecARM, PublicIPAddressPropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecARM(subject PublicIPAddressPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressPropertiesFormatSpecARMGenerator()
var publicIPAddressPropertiesFormatSpecARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatSpecARMGenerator returns a generator of PublicIPAddressPropertiesFormat_SpecARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatSpecARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatSpecARMGenerator != nil {
		return publicIPAddressPropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM(generators)
	publicIPAddressPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM(generators)
	publicIPAddressPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SpecARM{}), generators)

	return publicIPAddressPropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormatSpecMigrationPhaseAbort,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommit,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommitted,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseNone,
		PublicIPAddressPropertiesFormatSpecMigrationPhasePrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsSpecARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsSpecARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagSpecARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
}
