// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancers_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_SPECARM, LoadBalancers_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_SPECARM runs a test to see if a specific instance of LoadBalancers_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_SPECARM(subject LoadBalancers_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SPECARM instances for property testing - lazily instantiated by
//LoadBalancers_SPECARMGenerator()
var loadBalancers_specarmGenerator gopter.Gen

// LoadBalancers_SPECARMGenerator returns a generator of LoadBalancers_SPECARM instances for property testing.
// We first initialize loadBalancers_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_SPECARMGenerator() gopter.Gen {
	if loadBalancers_specarmGenerator != nil {
		return loadBalancers_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SPECARM(generators)
	loadBalancers_specarmGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SPECARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_SPECARM(generators)
	loadBalancers_specarmGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPECARM{}), generators)

	return loadBalancers_specarmGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormat_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_SpecARMGenerator())
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_SpecARM, ExtendedLocation_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_SpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_SpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocation_SpecARMGenerator()
var extendedLocation_specARMGenerator gopter.Gen

// ExtendedLocation_SpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocation_SpecARMGenerator() gopter.Gen {
	if extendedLocation_specARMGenerator != nil {
		return extendedLocation_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(generators)
	extendedLocation_specARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocation_specARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_SpecEdgeZone)
}

func Test_LoadBalancerPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormat_SpecARM, LoadBalancerPropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormat_SpecARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormat_SpecARM(subject LoadBalancerPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//LoadBalancerPropertiesFormat_SpecARMGenerator()
var loadBalancerPropertiesFormat_specARMGenerator gopter.Gen

// LoadBalancerPropertiesFormat_SpecARMGenerator returns a generator of LoadBalancerPropertiesFormat_SpecARM instances for property testing.
func LoadBalancerPropertiesFormat_SpecARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormat_specARMGenerator != nil {
		return loadBalancerPropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_SpecARM(generators)
	loadBalancerPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_SpecARM{}), generators)

	return loadBalancerPropertiesFormat_specARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_SpecARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_SpecARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_SpecARMGenerator())
	gens["Probes"] = gen.SliceOf(Probe_SpecARMGenerator())
}

func Test_LoadBalancerSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_SpecARM, LoadBalancerSku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_SpecARM runs a test to see if a specific instance of LoadBalancerSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_SpecARM(subject LoadBalancerSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_SpecARM instances for property testing - lazily instantiated by
//LoadBalancerSku_SpecARMGenerator()
var loadBalancerSku_specARMGenerator gopter.Gen

// LoadBalancerSku_SpecARMGenerator returns a generator of LoadBalancerSku_SpecARM instances for property testing.
func LoadBalancerSku_SpecARMGenerator() gopter.Gen {
	if loadBalancerSku_specARMGenerator != nil {
		return loadBalancerSku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_SpecARM(generators)
	loadBalancerSku_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_SpecARM{}), generators)

	return loadBalancerSku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_SpecBasic, LoadBalancerSku_Name_SpecStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_SpecGlobal, LoadBalancerSku_Tier_SpecRegional))
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM, BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var backendAddressPool_spec_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if backendAddressPool_spec_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return backendAddressPool_spec_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	backendAddressPool_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return backendAddressPool_spec_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPool_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_SpecARM, InboundNatPool_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_SpecARM runs a test to see if a specific instance of InboundNatPool_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_SpecARM(subject InboundNatPool_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_SpecARM instances for property testing - lazily instantiated by
//InboundNatPool_SpecARMGenerator()
var inboundNatPool_specARMGenerator gopter.Gen

// InboundNatPool_SpecARMGenerator returns a generator of InboundNatPool_SpecARM instances for property testing.
// We first initialize inboundNatPool_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_SpecARMGenerator() gopter.Gen {
	if inboundNatPool_specARMGenerator != nil {
		return inboundNatPool_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_SpecARM(generators)
	inboundNatPool_specARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_SpecARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_SpecARM(generators)
	inboundNatPool_specARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_SpecARM{}), generators)

	return inboundNatPool_specARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormat_SpecARMGenerator())
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM, InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var inboundNatRule_spec_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if inboundNatRule_spec_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return inboundNatRule_spec_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	inboundNatRule_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return inboundNatRule_spec_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_SpecARM, LoadBalancingRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_SpecARM runs a test to see if a specific instance of LoadBalancingRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_SpecARM(subject LoadBalancingRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_SpecARM instances for property testing - lazily instantiated by
//LoadBalancingRule_SpecARMGenerator()
var loadBalancingRule_specARMGenerator gopter.Gen

// LoadBalancingRule_SpecARMGenerator returns a generator of LoadBalancingRule_SpecARM instances for property testing.
// We first initialize loadBalancingRule_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_SpecARMGenerator() gopter.Gen {
	if loadBalancingRule_specARMGenerator != nil {
		return loadBalancingRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_SpecARM(generators)
	loadBalancingRule_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_SpecARM(generators)
	loadBalancingRule_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_SpecARM{}), generators)

	return loadBalancingRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormat_SpecARMGenerator())
}

func Test_OutboundRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_SpecARM, OutboundRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_SpecARM runs a test to see if a specific instance of OutboundRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_SpecARM(subject OutboundRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_SpecARM instances for property testing - lazily instantiated by
//OutboundRule_SpecARMGenerator()
var outboundRule_specARMGenerator gopter.Gen

// OutboundRule_SpecARMGenerator returns a generator of OutboundRule_SpecARM instances for property testing.
// We first initialize outboundRule_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_SpecARMGenerator() gopter.Gen {
	if outboundRule_specARMGenerator != nil {
		return outboundRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_SpecARM(generators)
	outboundRule_specARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_SpecARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_SpecARM(generators)
	outboundRule_specARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_SpecARM{}), generators)

	return outboundRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormat_SpecARMGenerator())
}

func Test_Probe_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_SpecARM, Probe_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_SpecARM runs a test to see if a specific instance of Probe_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_SpecARM(subject Probe_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_SpecARM instances for property testing - lazily instantiated by Probe_SpecARMGenerator()
var probe_specARMGenerator gopter.Gen

// Probe_SpecARMGenerator returns a generator of Probe_SpecARM instances for property testing.
// We first initialize probe_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_SpecARMGenerator() gopter.Gen {
	if probe_specARMGenerator != nil {
		return probe_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_SpecARM(generators)
	probe_specARMGenerator = gen.Struct(reflect.TypeOf(Probe_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_SpecARM(generators)
	AddRelatedPropertyGeneratorsForProbe_SpecARM(generators)
	probe_specARMGenerator = gen.Struct(reflect.TypeOf(Probe_SpecARM{}), generators)

	return probe_specARMGenerator
}

// AddIndependentPropertyGeneratorsForProbe_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormat_SpecARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property
//testing - lazily instantiated by
//FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_spec_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormat_SpecARM, InboundNatPoolPropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormat_SpecARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormat_SpecARM(subject InboundNatPoolPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//InboundNatPoolPropertiesFormat_SpecARMGenerator()
var inboundNatPoolPropertiesFormat_specARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormat_SpecARMGenerator returns a generator of InboundNatPoolPropertiesFormat_SpecARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormat_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormat_SpecARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormat_specARMGenerator != nil {
		return inboundNatPoolPropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM(generators)
	inboundNatPoolPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM(generators)
	inboundNatPoolPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_SpecARM{}), generators)

	return inboundNatPoolPropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.Int()
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.Int()
	gens["FrontendPortRangeStart"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp)
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_SpecARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_SpecARM, LoadBalancingRulePropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_SpecARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_SpecARM(subject LoadBalancingRulePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//LoadBalancingRulePropertiesFormat_SpecARMGenerator()
var loadBalancingRulePropertiesFormat_specARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormat_SpecARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_SpecARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormat_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormat_SpecARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormat_specARMGenerator != nil {
		return loadBalancingRulePropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM(generators)
	loadBalancingRulePropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM(generators)
	loadBalancingRulePropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_SpecARM{}), generators)

	return loadBalancingRulePropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_SpecDefault, LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIPProtocol))
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp)
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_SpecARMGenerator())
}

func Test_OutboundRulePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormat_SpecARM, OutboundRulePropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormat_SpecARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormat_SpecARM(subject OutboundRulePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//OutboundRulePropertiesFormat_SpecARMGenerator()
var outboundRulePropertiesFormat_specARMGenerator gopter.Gen

// OutboundRulePropertiesFormat_SpecARMGenerator returns a generator of OutboundRulePropertiesFormat_SpecARM instances for property testing.
// We first initialize outboundRulePropertiesFormat_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormat_SpecARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormat_specARMGenerator != nil {
		return outboundRulePropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM(generators)
	outboundRulePropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM(generators)
	outboundRulePropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_SpecARM{}), generators)

	return outboundRulePropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_SpecAll, OutboundRulePropertiesFormat_Protocol_SpecTcp, OutboundRulePropertiesFormat_Protocol_SpecUdp)
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = SubResource_SpecARMGenerator()
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_SpecARMGenerator())
}

func Test_ProbePropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormat_SpecARM, ProbePropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormat_SpecARM runs a test to see if a specific instance of ProbePropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormat_SpecARM(subject ProbePropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//ProbePropertiesFormat_SpecARMGenerator()
var probePropertiesFormat_specARMGenerator gopter.Gen

// ProbePropertiesFormat_SpecARMGenerator returns a generator of ProbePropertiesFormat_SpecARM instances for property testing.
func ProbePropertiesFormat_SpecARMGenerator() gopter.Gen {
	if probePropertiesFormat_specARMGenerator != nil {
		return probePropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_SpecARM(generators)
	probePropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_SpecARM{}), generators)

	return probePropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.Int()
	gens["Protocol"] = gen.OneConstOf(ProbePropertiesFormat_Protocol_SpecHttp, ProbePropertiesFormat_Protocol_SpecHttps, ProbePropertiesFormat_Protocol_SpecTcp)
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddress_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_SpecARM, PublicIPAddress_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_SpecARM runs a test to see if a specific instance of PublicIPAddress_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_SpecARM(subject PublicIPAddress_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddress_SpecARMGenerator()
var publicIPAddress_specARMGenerator gopter.Gen

// PublicIPAddress_SpecARMGenerator returns a generator of PublicIPAddress_SpecARM instances for property testing.
// We first initialize publicIPAddress_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_SpecARMGenerator() gopter.Gen {
	if publicIPAddress_specARMGenerator != nil {
		return publicIPAddress_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	return publicIPAddress_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_SpecARMGenerator())
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM, Subnet_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM(subject Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
//Subnet_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator()
var subnet_spec_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// Subnet_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func Subnet_Spec_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_spec_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return subnet_spec_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM(generators)
	subnet_spec_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return subnet_spec_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_Spec_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SpecARM, PublicIPAddressPropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SpecARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SpecARM(subject PublicIPAddressPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressPropertiesFormat_SpecARMGenerator()
var publicIPAddressPropertiesFormat_specARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_SpecARMGenerator returns a generator of PublicIPAddressPropertiesFormat_SpecARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_SpecARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_specARMGenerator != nil {
		return publicIPAddressPropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM(generators)
	publicIPAddressPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM(generators)
	publicIPAddressPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SpecARM{}), generators)

	return publicIPAddressPropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecAbort,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommit,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommitted,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecNone,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecPrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_SpecARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_SpecARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_SpecARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_SpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecARMGenerator())
}
