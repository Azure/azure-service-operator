// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_SpecARM, NetworkInterface_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_SpecARM runs a test to see if a specific instance of NetworkInterface_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_SpecARM(subject NetworkInterface_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_SpecARM instances for property testing - lazily instantiated by
//NetworkInterface_SpecARMGenerator()
var networkInterface_specARMGenerator gopter.Gen

// NetworkInterface_SpecARMGenerator returns a generator of NetworkInterface_SpecARM instances for property testing.
// We first initialize networkInterface_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_SpecARMGenerator() gopter.Gen {
	if networkInterface_specARMGenerator != nil {
		return networkInterface_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	networkInterface_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM(generators)
	networkInterface_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_SpecARM{}), generators)

	return networkInterface_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(NetworkInterfacePropertiesFormatARMGenerator())
}

func Test_NetworkInterfacePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfacePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM, NetworkInterfacePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM runs a test to see if a specific instance of NetworkInterfacePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfacePropertiesFormatARM(subject NetworkInterfacePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfacePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfacePropertiesFormatARM instances for property testing - lazily instantiated by
//NetworkInterfacePropertiesFormatARMGenerator()
var networkInterfacePropertiesFormatARMGenerator gopter.Gen

// NetworkInterfacePropertiesFormatARMGenerator returns a generator of NetworkInterfacePropertiesFormatARM instances for property testing.
// We first initialize networkInterfacePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfacePropertiesFormatARMGenerator() gopter.Gen {
	if networkInterfacePropertiesFormatARMGenerator != nil {
		return networkInterfacePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	networkInterfacePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(generators)
	networkInterfacePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfacePropertiesFormatARM{}), generators)

	return networkInterfacePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		NetworkInterfacePropertiesFormatMigrationPhaseAbort,
		NetworkInterfacePropertiesFormatMigrationPhaseCommit,
		NetworkInterfacePropertiesFormatMigrationPhaseCommitted,
		NetworkInterfacePropertiesFormatMigrationPhaseNone,
		NetworkInterfacePropertiesFormatMigrationPhasePrepare))
	gens["NicType"] = gen.PtrOf(gen.OneConstOf(NetworkInterfacePropertiesFormatNicTypeElastic, NetworkInterfacePropertiesFormatNicTypeStandard))
}

// AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfacePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettingsARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpecARMGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceSpecARMGenerator())
}

func Test_NetworkInterfaceDnsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM, NetworkInterfaceDnsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM runs a test to see if a specific instance of NetworkInterfaceDnsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettingsARM(subject NetworkInterfaceDnsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettingsARM instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettingsARMGenerator()
var networkInterfaceDnsSettingsARMGenerator gopter.Gen

// NetworkInterfaceDnsSettingsARMGenerator returns a generator of NetworkInterfaceDnsSettingsARM instances for property testing.
func NetworkInterfaceDnsSettingsARMGenerator() gopter.Gen {
	if networkInterfaceDnsSettingsARMGenerator != nil {
		return networkInterfaceDnsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM(generators)
	networkInterfaceDnsSettingsARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettingsARM{}), generators)

	return networkInterfaceDnsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsARM(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkSecurityGroupSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpecARM, NetworkSecurityGroupSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpecARM runs a test to see if a specific instance of NetworkSecurityGroupSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpecARM(subject NetworkSecurityGroupSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupSpecARM instances for property testing - lazily instantiated by
//NetworkSecurityGroupSpecARMGenerator()
var networkSecurityGroupSpecARMGenerator gopter.Gen

// NetworkSecurityGroupSpecARMGenerator returns a generator of NetworkSecurityGroupSpecARM instances for property testing.
// We first initialize networkSecurityGroupSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkSecurityGroupSpecARMGenerator() gopter.Gen {
	if networkSecurityGroupSpecARMGenerator != nil {
		return networkSecurityGroupSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	networkSecurityGroupSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM(generators)
	networkSecurityGroupSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpecARM{}), generators)

	return networkSecurityGroupSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkSecurityGroupPropertiesFormatARMGenerator())
}

func Test_PrivateLinkServiceSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceSpecARM, PrivateLinkServiceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceSpecARM runs a test to see if a specific instance of PrivateLinkServiceSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceSpecARM(subject PrivateLinkServiceSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceSpecARM instances for property testing - lazily instantiated by
//PrivateLinkServiceSpecARMGenerator()
var privateLinkServiceSpecARMGenerator gopter.Gen

// PrivateLinkServiceSpecARMGenerator returns a generator of PrivateLinkServiceSpecARM instances for property testing.
// We first initialize privateLinkServiceSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceSpecARMGenerator() gopter.Gen {
	if privateLinkServiceSpecARMGenerator != nil {
		return privateLinkServiceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	privateLinkServiceSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM(generators)
	privateLinkServiceSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpecARM{}), generators)

	return privateLinkServiceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(PrivateLinkServicePropertiesARMGenerator())
}

func Test_PrivateLinkServicePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServicePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServicePropertiesARM, PrivateLinkServicePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServicePropertiesARM runs a test to see if a specific instance of PrivateLinkServicePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServicePropertiesARM(subject PrivateLinkServicePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServicePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServicePropertiesARM instances for property testing - lazily instantiated by
//PrivateLinkServicePropertiesARMGenerator()
var privateLinkServicePropertiesARMGenerator gopter.Gen

// PrivateLinkServicePropertiesARMGenerator returns a generator of PrivateLinkServicePropertiesARM instances for property testing.
// We first initialize privateLinkServicePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServicePropertiesARMGenerator() gopter.Gen {
	if privateLinkServicePropertiesARMGenerator != nil {
		return privateLinkServicePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	privateLinkServicePropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServicePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM(generators)
	privateLinkServicePropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServicePropertiesARM{}), generators)

	return privateLinkServicePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServicePropertiesARM(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServicePropertiesARM(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSetARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfigurationARMGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfigurationARMGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSetARMGenerator())
}

func Test_PrivateLinkServiceIpConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM, PrivateLinkServiceIpConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationARM(subject PrivateLinkServiceIpConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationARM instances for property testing - lazily instantiated by
//PrivateLinkServiceIpConfigurationARMGenerator()
var privateLinkServiceIpConfigurationARMGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationARMGenerator returns a generator of PrivateLinkServiceIpConfigurationARM instances for property testing.
// We first initialize privateLinkServiceIpConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationARMGenerator != nil {
		return privateLinkServiceIpConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	privateLinkServiceIpConfigurationARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(generators)
	privateLinkServiceIpConfigurationARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationARM{}), generators)

	return privateLinkServiceIpConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateLinkServiceIpConfigurationPropertiesARMGenerator())
}

func Test_ResourceSetARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSetARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSetARM, ResourceSetARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSetARM runs a test to see if a specific instance of ResourceSetARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSetARM(subject ResourceSetARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSetARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSetARM instances for property testing - lazily instantiated by ResourceSetARMGenerator()
var resourceSetARMGenerator gopter.Gen

// ResourceSetARMGenerator returns a generator of ResourceSetARM instances for property testing.
func ResourceSetARMGenerator() gopter.Gen {
	if resourceSetARMGenerator != nil {
		return resourceSetARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSetARM(generators)
	resourceSetARMGenerator = gen.Struct(reflect.TypeOf(ResourceSetARM{}), generators)

	return resourceSetARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSetARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSetARM(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_PrivateLinkServiceIpConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM, PrivateLinkServiceIpConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM runs a test to see if a specific instance of PrivateLinkServiceIpConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationPropertiesARM(subject PrivateLinkServiceIpConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfigurationPropertiesARM instances for property testing - lazily instantiated by
//PrivateLinkServiceIpConfigurationPropertiesARMGenerator()
var privateLinkServiceIpConfigurationPropertiesARMGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationPropertiesARMGenerator returns a generator of PrivateLinkServiceIpConfigurationPropertiesARM instances for property testing.
func PrivateLinkServiceIpConfigurationPropertiesARMGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationPropertiesARMGenerator != nil {
		return privateLinkServiceIpConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(generators)
	privateLinkServiceIpConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfigurationPropertiesARM{}), generators)

	return privateLinkServiceIpConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersionIPv4, IPVersionIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethodDynamic, IPAllocationMethodStatic))
	gens["Subnet"] = gen.PtrOf(gen.AlphaString())
}
