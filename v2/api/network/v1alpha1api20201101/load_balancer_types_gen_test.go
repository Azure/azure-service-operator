// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	alpha20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	v20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1beta20201101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to hub returns original",
		prop.ForAll(RunResourceConversionTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForLoadBalancer tests if a specific instance of LoadBalancer round trips to the hub storage version and back losslessly
func RunResourceConversionTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20201101s.LoadBalancer
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual LoadBalancer
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to LoadBalancer via AssignProperties_To_LoadBalancer & AssignProperties_From_LoadBalancer returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer tests if a specific instance of LoadBalancer can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancer
	err := copied.AssignProperties_To_LoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer
	err = actual.AssignProperties_From_LoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer runs a test to see if a specific instance of LoadBalancer round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer(subject LoadBalancer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer instances for property testing - lazily instantiated by LoadBalancerGenerator()
var loadBalancerGenerator gopter.Gen

// LoadBalancerGenerator returns a generator of LoadBalancer instances for property testing.
func LoadBalancerGenerator() gopter.Gen {
	if loadBalancerGenerator != nil {
		return loadBalancerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancer(generators)
	loadBalancerGenerator = gen.Struct(reflect.TypeOf(LoadBalancer{}), generators)

	return loadBalancerGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer(gens map[string]gopter.Gen) {
	gens["Spec"] = LoadBalancer_SpecGenerator()
	gens["Status"] = LoadBalancer_STATUSGenerator()
}

func Test_LoadBalancer_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer_Spec to LoadBalancer_Spec via AssignProperties_To_LoadBalancer_Spec & AssignProperties_From_LoadBalancer_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer_Spec, LoadBalancer_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer_Spec tests if a specific instance of LoadBalancer_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer_Spec(subject LoadBalancer_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancer_Spec
	err := copied.AssignProperties_To_LoadBalancer_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer_Spec
	err = actual.AssignProperties_From_LoadBalancer_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Spec, LoadBalancer_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Spec runs a test to see if a specific instance of LoadBalancer_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Spec(subject LoadBalancer_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Spec instances for property testing - lazily instantiated by LoadBalancer_SpecGenerator()
var loadBalancer_SpecGenerator gopter.Gen

// LoadBalancer_SpecGenerator returns a generator of LoadBalancer_Spec instances for property testing.
// We first initialize loadBalancer_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_SpecGenerator() gopter.Gen {
	if loadBalancer_SpecGenerator != nil {
		return loadBalancer_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec(generators)
	loadBalancer_SpecGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Spec(generators)
	loadBalancer_SpecGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec{}), generators)

	return loadBalancer_SpecGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Spec(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleGenerator())
	gens["Probes"] = gen.SliceOf(ProbeGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuGenerator())
}

func Test_LoadBalancer_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer_STATUS to LoadBalancer_STATUS via AssignProperties_To_LoadBalancer_STATUS & AssignProperties_From_LoadBalancer_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer_STATUS, LoadBalancer_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer_STATUS tests if a specific instance of LoadBalancer_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer_STATUS(subject LoadBalancer_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancer_STATUS
	err := copied.AssignProperties_To_LoadBalancer_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer_STATUS
	err = actual.AssignProperties_From_LoadBalancer_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_STATUS, LoadBalancer_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_STATUS runs a test to see if a specific instance of LoadBalancer_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_STATUS(subject LoadBalancer_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_STATUS instances for property testing - lazily instantiated by
// LoadBalancer_STATUSGenerator()
var loadBalancer_STATUSGenerator gopter.Gen

// LoadBalancer_STATUSGenerator returns a generator of LoadBalancer_STATUS instances for property testing.
// We first initialize loadBalancer_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_STATUSGenerator() gopter.Gen {
	if loadBalancer_STATUSGenerator != nil {
		return loadBalancer_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_STATUS(generators)
	loadBalancer_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_STATUS(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_STATUS(generators)
	loadBalancer_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_STATUS{}), generators)

	return loadBalancer_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_STATUS(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_STATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_STATUSGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_STATUSGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_STATUSGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_STATUSGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_STATUSGenerator())
	gens["Probes"] = gen.SliceOf(Probe_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_STATUSGenerator())
}

func Test_BackendAddressPool_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool to BackendAddressPool via AssignProperties_To_BackendAddressPool & AssignProperties_From_BackendAddressPool returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPool, BackendAddressPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPool tests if a specific instance of BackendAddressPool can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPool(subject BackendAddressPool) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.BackendAddressPool
	err := copied.AssignProperties_To_BackendAddressPool(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool
	err = actual.AssignProperties_From_BackendAddressPool(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool, BackendAddressPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool runs a test to see if a specific instance of BackendAddressPool round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool(subject BackendAddressPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool instances for property testing - lazily instantiated by BackendAddressPoolGenerator()
var backendAddressPoolGenerator gopter.Gen

// BackendAddressPoolGenerator returns a generator of BackendAddressPool instances for property testing.
// We first initialize backendAddressPoolGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPoolGenerator() gopter.Gen {
	if backendAddressPoolGenerator != nil {
		return backendAddressPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool(generators)
	backendAddressPoolGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPool(generators)
	backendAddressPoolGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool{}), generators)

	return backendAddressPoolGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendAddressPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPool(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancerBackendAddressGenerator())
}

func Test_BackendAddressPool_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_STATUS to BackendAddressPool_STATUS via AssignProperties_To_BackendAddressPool_STATUS & AssignProperties_From_BackendAddressPool_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPool_STATUS, BackendAddressPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPool_STATUS tests if a specific instance of BackendAddressPool_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPool_STATUS(subject BackendAddressPool_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.BackendAddressPool_STATUS
	err := copied.AssignProperties_To_BackendAddressPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_STATUS
	err = actual.AssignProperties_From_BackendAddressPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_STATUS, BackendAddressPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_STATUS runs a test to see if a specific instance of BackendAddressPool_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_STATUS(subject BackendAddressPool_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_STATUS instances for property testing - lazily instantiated by
// BackendAddressPool_STATUSGenerator()
var backendAddressPool_STATUSGenerator gopter.Gen

// BackendAddressPool_STATUSGenerator returns a generator of BackendAddressPool_STATUS instances for property testing.
// We first initialize backendAddressPool_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPool_STATUSGenerator() gopter.Gen {
	if backendAddressPool_STATUSGenerator != nil {
		return backendAddressPool_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_STATUS(generators)
	backendAddressPool_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_STATUS(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPool_STATUS(generators)
	backendAddressPool_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_STATUS{}), generators)

	return backendAddressPool_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendAddressPool_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPool_STATUS(gens map[string]gopter.Gen) {
	gens["BackendIPConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_STATUSGenerator())
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancerBackendAddress_STATUSGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["OutboundRule"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_STATUSGenerator())
}

func Test_ExtendedLocation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation to ExtendedLocation via AssignProperties_To_ExtendedLocation & AssignProperties_From_ExtendedLocation returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation tests if a specific instance of ExtendedLocation can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation(subject ExtendedLocation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.ExtendedLocation
	err := copied.AssignProperties_To_ExtendedLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation
	err = actual.AssignProperties_From_ExtendedLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation runs a test to see if a specific instance of ExtendedLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation(subject ExtendedLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation instances for property testing - lazily instantiated by ExtendedLocationGenerator()
var extendedLocationGenerator gopter.Gen

// ExtendedLocationGenerator returns a generator of ExtendedLocation instances for property testing.
func ExtendedLocationGenerator() gopter.Gen {
	if extendedLocationGenerator != nil {
		return extendedLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation(generators)
	extendedLocationGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation{}), generators)

	return extendedLocationGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone))
}

func Test_ExtendedLocation_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_STATUS to ExtendedLocation_STATUS via AssignProperties_To_ExtendedLocation_STATUS & AssignProperties_From_ExtendedLocation_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_STATUS, ExtendedLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_STATUS tests if a specific instance of ExtendedLocation_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_STATUS(subject ExtendedLocation_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.ExtendedLocation_STATUS
	err := copied.AssignProperties_To_ExtendedLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_STATUS
	err = actual.AssignProperties_From_ExtendedLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUS, ExtendedLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUS runs a test to see if a specific instance of ExtendedLocation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUS(subject ExtendedLocation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUS instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSGenerator()
var extendedLocation_STATUSGenerator gopter.Gen

// ExtendedLocation_STATUSGenerator returns a generator of ExtendedLocation_STATUS instances for property testing.
func ExtendedLocation_STATUSGenerator() gopter.Gen {
	if extendedLocation_STATUSGenerator != nil {
		return extendedLocation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUS(generators)
	extendedLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUS{}), generators)

	return extendedLocation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_EdgeZone))
}

func Test_FrontendIPConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration to FrontendIPConfiguration via AssignProperties_To_FrontendIPConfiguration & AssignProperties_From_FrontendIPConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfiguration, FrontendIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfiguration tests if a specific instance of FrontendIPConfiguration can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfiguration(subject FrontendIPConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.FrontendIPConfiguration
	err := copied.AssignProperties_To_FrontendIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration
	err = actual.AssignProperties_From_FrontendIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration, FrontendIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration runs a test to see if a specific instance of FrontendIPConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration(subject FrontendIPConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration instances for property testing - lazily instantiated by
// FrontendIPConfigurationGenerator()
var frontendIPConfigurationGenerator gopter.Gen

// FrontendIPConfigurationGenerator returns a generator of FrontendIPConfiguration instances for property testing.
// We first initialize frontendIPConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationGenerator() gopter.Gen {
	if frontendIPConfigurationGenerator != nil {
		return frontendIPConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration(generators)
	frontendIPConfigurationGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration(generators)
	frontendIPConfigurationGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration{}), generators)

	return frontendIPConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetGenerator())
}

func Test_FrontendIPConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_STATUS to FrontendIPConfiguration_STATUS via AssignProperties_To_FrontendIPConfiguration_STATUS & AssignProperties_From_FrontendIPConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfiguration_STATUS, FrontendIPConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfiguration_STATUS tests if a specific instance of FrontendIPConfiguration_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfiguration_STATUS(subject FrontendIPConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.FrontendIPConfiguration_STATUS
	err := copied.AssignProperties_To_FrontendIPConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_STATUS
	err = actual.AssignProperties_From_FrontendIPConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_STATUS, FrontendIPConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_STATUS runs a test to see if a specific instance of FrontendIPConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_STATUS(subject FrontendIPConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_STATUS instances for property testing - lazily instantiated by
// FrontendIPConfiguration_STATUSGenerator()
var frontendIPConfiguration_STATUSGenerator gopter.Gen

// FrontendIPConfiguration_STATUSGenerator returns a generator of FrontendIPConfiguration_STATUS instances for property testing.
// We first initialize frontendIPConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_STATUSGenerator() gopter.Gen {
	if frontendIPConfiguration_STATUSGenerator != nil {
		return frontendIPConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUS(generators)
	frontendIPConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUS(generators)
	frontendIPConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_STATUS{}), generators)

	return frontendIPConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_STATUS_IPv4, IPVersion_STATUS_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_STATUSGenerator())
}

func Test_InboundNatPool_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool to InboundNatPool via AssignProperties_To_InboundNatPool & AssignProperties_From_InboundNatPool returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPool, InboundNatPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPool tests if a specific instance of InboundNatPool can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPool(subject InboundNatPool) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.InboundNatPool
	err := copied.AssignProperties_To_InboundNatPool(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool
	err = actual.AssignProperties_From_InboundNatPool(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool, InboundNatPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool runs a test to see if a specific instance of InboundNatPool round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool(subject InboundNatPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool instances for property testing - lazily instantiated by InboundNatPoolGenerator()
var inboundNatPoolGenerator gopter.Gen

// InboundNatPoolGenerator returns a generator of InboundNatPool instances for property testing.
// We first initialize inboundNatPoolGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolGenerator() gopter.Gen {
	if inboundNatPoolGenerator != nil {
		return inboundNatPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool(generators)
	inboundNatPoolGenerator = gen.Struct(reflect.TypeOf(InboundNatPool{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool(generators)
	inboundNatPoolGenerator = gen.Struct(reflect.TypeOf(InboundNatPool{}), generators)

	return inboundNatPoolGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceGenerator())
}

func Test_InboundNatPool_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool_STATUS to InboundNatPool_STATUS via AssignProperties_To_InboundNatPool_STATUS & AssignProperties_From_InboundNatPool_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPool_STATUS, InboundNatPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPool_STATUS tests if a specific instance of InboundNatPool_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPool_STATUS(subject InboundNatPool_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.InboundNatPool_STATUS
	err := copied.AssignProperties_To_InboundNatPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool_STATUS
	err = actual.AssignProperties_From_InboundNatPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_STATUS, InboundNatPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_STATUS runs a test to see if a specific instance of InboundNatPool_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_STATUS(subject InboundNatPool_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_STATUS instances for property testing - lazily instantiated by
// InboundNatPool_STATUSGenerator()
var inboundNatPool_STATUSGenerator gopter.Gen

// InboundNatPool_STATUSGenerator returns a generator of InboundNatPool_STATUS instances for property testing.
// We first initialize inboundNatPool_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_STATUSGenerator() gopter.Gen {
	if inboundNatPool_STATUSGenerator != nil {
		return inboundNatPool_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_STATUS(generators)
	inboundNatPool_STATUSGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_STATUS(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_STATUS(generators)
	inboundNatPool_STATUSGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_STATUS{}), generators)

	return inboundNatPool_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_STATUS_All, TransportProtocol_STATUS_Tcp, TransportProtocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_STATUS(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_InboundNatRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule to InboundNatRule via AssignProperties_To_InboundNatRule & AssignProperties_From_InboundNatRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRule, InboundNatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRule tests if a specific instance of InboundNatRule can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRule(subject InboundNatRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.InboundNatRule
	err := copied.AssignProperties_To_InboundNatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule
	err = actual.AssignProperties_From_InboundNatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule, InboundNatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule runs a test to see if a specific instance of InboundNatRule round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule(subject InboundNatRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule instances for property testing - lazily instantiated by InboundNatRuleGenerator()
var inboundNatRuleGenerator gopter.Gen

// InboundNatRuleGenerator returns a generator of InboundNatRule instances for property testing.
// We first initialize inboundNatRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRuleGenerator() gopter.Gen {
	if inboundNatRuleGenerator != nil {
		return inboundNatRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule(generators)
	inboundNatRuleGenerator = gen.Struct(reflect.TypeOf(InboundNatRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule(generators)
	AddRelatedPropertyGeneratorsForInboundNatRule(generators)
	inboundNatRuleGenerator = gen.Struct(reflect.TypeOf(InboundNatRule{}), generators)

	return inboundNatRuleGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRule(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceGenerator())
}

func Test_InboundNatRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_STATUS to InboundNatRule_STATUS via AssignProperties_To_InboundNatRule_STATUS & AssignProperties_From_InboundNatRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRule_STATUS, InboundNatRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRule_STATUS tests if a specific instance of InboundNatRule_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRule_STATUS(subject InboundNatRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.InboundNatRule_STATUS
	err := copied.AssignProperties_To_InboundNatRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_STATUS
	err = actual.AssignProperties_From_InboundNatRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_STATUS, InboundNatRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_STATUS runs a test to see if a specific instance of InboundNatRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_STATUS(subject InboundNatRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_STATUS instances for property testing - lazily instantiated by
// InboundNatRule_STATUSGenerator()
var inboundNatRule_STATUSGenerator gopter.Gen

// InboundNatRule_STATUSGenerator returns a generator of InboundNatRule_STATUS instances for property testing.
// We first initialize inboundNatRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRule_STATUSGenerator() gopter.Gen {
	if inboundNatRule_STATUSGenerator != nil {
		return inboundNatRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_STATUS(generators)
	inboundNatRule_STATUSGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForInboundNatRule_STATUS(generators)
	inboundNatRule_STATUSGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_STATUS{}), generators)

	return inboundNatRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_STATUS_All, TransportProtocol_STATUS_Tcp, TransportProtocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRule_STATUS(gens map[string]gopter.Gen) {
	gens["BackendIPConfiguration"] = gen.PtrOf(NetworkInterfaceIPConfiguration_STATUSGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_LoadBalancerSku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku to LoadBalancerSku via AssignProperties_To_LoadBalancerSku & AssignProperties_From_LoadBalancerSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSku, LoadBalancerSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSku tests if a specific instance of LoadBalancerSku can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSku(subject LoadBalancerSku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancerSku
	err := copied.AssignProperties_To_LoadBalancerSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku
	err = actual.AssignProperties_From_LoadBalancerSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku, LoadBalancerSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku runs a test to see if a specific instance of LoadBalancerSku round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku(subject LoadBalancerSku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku instances for property testing - lazily instantiated by LoadBalancerSkuGenerator()
var loadBalancerSkuGenerator gopter.Gen

// LoadBalancerSkuGenerator returns a generator of LoadBalancerSku instances for property testing.
func LoadBalancerSkuGenerator() gopter.Gen {
	if loadBalancerSkuGenerator != nil {
		return loadBalancerSkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku(generators)
	loadBalancerSkuGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku{}), generators)

	return loadBalancerSkuGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_LoadBalancerSku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku_STATUS to LoadBalancerSku_STATUS via AssignProperties_To_LoadBalancerSku_STATUS & AssignProperties_From_LoadBalancerSku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSku_STATUS, LoadBalancerSku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSku_STATUS tests if a specific instance of LoadBalancerSku_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSku_STATUS(subject LoadBalancerSku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancerSku_STATUS
	err := copied.AssignProperties_To_LoadBalancerSku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku_STATUS
	err = actual.AssignProperties_From_LoadBalancerSku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_STATUS, LoadBalancerSku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_STATUS runs a test to see if a specific instance of LoadBalancerSku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_STATUS(subject LoadBalancerSku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_STATUS instances for property testing - lazily instantiated by
// LoadBalancerSku_STATUSGenerator()
var loadBalancerSku_STATUSGenerator gopter.Gen

// LoadBalancerSku_STATUSGenerator returns a generator of LoadBalancerSku_STATUS instances for property testing.
func LoadBalancerSku_STATUSGenerator() gopter.Gen {
	if loadBalancerSku_STATUSGenerator != nil {
		return loadBalancerSku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUS(generators)
	loadBalancerSku_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_STATUS{}), generators)

	return loadBalancerSku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_STATUS_Basic, LoadBalancerSku_Name_STATUS_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_STATUS_Global, LoadBalancerSku_Tier_STATUS_Regional))
}

func Test_LoadBalancingRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule to LoadBalancingRule via AssignProperties_To_LoadBalancingRule & AssignProperties_From_LoadBalancingRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRule, LoadBalancingRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRule tests if a specific instance of LoadBalancingRule can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRule(subject LoadBalancingRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancingRule
	err := copied.AssignProperties_To_LoadBalancingRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule
	err = actual.AssignProperties_From_LoadBalancingRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule, LoadBalancingRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule runs a test to see if a specific instance of LoadBalancingRule round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule(subject LoadBalancingRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule instances for property testing - lazily instantiated by LoadBalancingRuleGenerator()
var loadBalancingRuleGenerator gopter.Gen

// LoadBalancingRuleGenerator returns a generator of LoadBalancingRule instances for property testing.
// We first initialize loadBalancingRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleGenerator() gopter.Gen {
	if loadBalancingRuleGenerator != nil {
		return loadBalancingRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule(generators)
	loadBalancingRuleGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule(generators)
	loadBalancingRuleGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule{}), generators)

	return loadBalancingRuleGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceGenerator())
}

func Test_LoadBalancingRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule_STATUS to LoadBalancingRule_STATUS via AssignProperties_To_LoadBalancingRule_STATUS & AssignProperties_From_LoadBalancingRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRule_STATUS, LoadBalancingRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRule_STATUS tests if a specific instance of LoadBalancingRule_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRule_STATUS(subject LoadBalancingRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancingRule_STATUS
	err := copied.AssignProperties_To_LoadBalancingRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule_STATUS
	err = actual.AssignProperties_From_LoadBalancingRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_STATUS, LoadBalancingRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_STATUS runs a test to see if a specific instance of LoadBalancingRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_STATUS(subject LoadBalancingRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_STATUS instances for property testing - lazily instantiated by
// LoadBalancingRule_STATUSGenerator()
var loadBalancingRule_STATUSGenerator gopter.Gen

// LoadBalancingRule_STATUSGenerator returns a generator of LoadBalancingRule_STATUS instances for property testing.
// We first initialize loadBalancingRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_STATUSGenerator() gopter.Gen {
	if loadBalancingRule_STATUSGenerator != nil {
		return loadBalancingRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUS(generators)
	loadBalancingRule_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUS(generators)
	loadBalancingRule_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_STATUS{}), generators)

	return loadBalancingRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_STATUS_SourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_STATUS_All, TransportProtocol_STATUS_Tcp, TransportProtocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_STATUS(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_OutboundRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule to OutboundRule via AssignProperties_To_OutboundRule & AssignProperties_From_OutboundRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule, OutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule tests if a specific instance of OutboundRule can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule(subject OutboundRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.OutboundRule
	err := copied.AssignProperties_To_OutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule
	err = actual.AssignProperties_From_OutboundRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule, OutboundRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule runs a test to see if a specific instance of OutboundRule round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule(subject OutboundRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule instances for property testing - lazily instantiated by OutboundRuleGenerator()
var outboundRuleGenerator gopter.Gen

// OutboundRuleGenerator returns a generator of OutboundRule instances for property testing.
// We first initialize outboundRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleGenerator() gopter.Gen {
	if outboundRuleGenerator != nil {
		return outboundRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule(generators)
	outboundRuleGenerator = gen.Struct(reflect.TypeOf(OutboundRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule(generators)
	AddRelatedPropertyGeneratorsForOutboundRule(generators)
	outboundRuleGenerator = gen.Struct(reflect.TypeOf(OutboundRule{}), generators)

	return outboundRuleGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForOutboundRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceGenerator())
}

func Test_OutboundRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_STATUS to OutboundRule_STATUS via AssignProperties_To_OutboundRule_STATUS & AssignProperties_From_OutboundRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule_STATUS, OutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule_STATUS tests if a specific instance of OutboundRule_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule_STATUS(subject OutboundRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.OutboundRule_STATUS
	err := copied.AssignProperties_To_OutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_STATUS
	err = actual.AssignProperties_From_OutboundRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_STATUS, OutboundRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_STATUS runs a test to see if a specific instance of OutboundRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_STATUS(subject OutboundRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_STATUS instances for property testing - lazily instantiated by
// OutboundRule_STATUSGenerator()
var outboundRule_STATUSGenerator gopter.Gen

// OutboundRule_STATUSGenerator returns a generator of OutboundRule_STATUS instances for property testing.
// We first initialize outboundRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_STATUSGenerator() gopter.Gen {
	if outboundRule_STATUSGenerator != nil {
		return outboundRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_STATUS(generators)
	outboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_STATUS(generators)
	outboundRule_STATUSGenerator = gen.Struct(reflect.TypeOf(OutboundRule_STATUS{}), generators)

	return outboundRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_STATUS_All, OutboundRulePropertiesFormat_Protocol_STATUS_Tcp, OutboundRulePropertiesFormat_Protocol_STATUS_Udp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_STATUS(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_STATUSGenerator())
}

func Test_Probe_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe to Probe via AssignProperties_To_Probe & AssignProperties_From_Probe returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbe, ProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbe tests if a specific instance of Probe can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbe(subject Probe) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.Probe
	err := copied.AssignProperties_To_Probe(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe
	err = actual.AssignProperties_From_Probe(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe, ProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe runs a test to see if a specific instance of Probe round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe(subject Probe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe instances for property testing - lazily instantiated by ProbeGenerator()
var probeGenerator gopter.Gen

// ProbeGenerator returns a generator of Probe instances for property testing.
func ProbeGenerator() gopter.Gen {
	if probeGenerator != nil {
		return probeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe(generators)
	probeGenerator = gen.Struct(reflect.TypeOf(Probe{}), generators)

	return probeGenerator
}

// AddIndependentPropertyGeneratorsForProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_Probe_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe_STATUS to Probe_STATUS via AssignProperties_To_Probe_STATUS & AssignProperties_From_Probe_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbe_STATUS, Probe_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbe_STATUS tests if a specific instance of Probe_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbe_STATUS(subject Probe_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.Probe_STATUS
	err := copied.AssignProperties_To_Probe_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe_STATUS
	err = actual.AssignProperties_From_Probe_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_STATUS, Probe_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_STATUS runs a test to see if a specific instance of Probe_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_STATUS(subject Probe_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_STATUS instances for property testing - lazily instantiated by Probe_STATUSGenerator()
var probe_STATUSGenerator gopter.Gen

// Probe_STATUSGenerator returns a generator of Probe_STATUS instances for property testing.
// We first initialize probe_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_STATUSGenerator() gopter.Gen {
	if probe_STATUSGenerator != nil {
		return probe_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_STATUS(generators)
	probe_STATUSGenerator = gen.Struct(reflect.TypeOf(Probe_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_STATUS(generators)
	AddRelatedPropertyGeneratorsForProbe_STATUS(generators)
	probe_STATUSGenerator = gen.Struct(reflect.TypeOf(Probe_STATUS{}), generators)

	return probe_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForProbe_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_STATUS_Http, ProbePropertiesFormat_Protocol_STATUS_Https, ProbePropertiesFormat_Protocol_STATUS_Tcp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_STATUS(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_STATUSGenerator())
}

func Test_LoadBalancerBackendAddress_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerBackendAddress to LoadBalancerBackendAddress via AssignProperties_To_LoadBalancerBackendAddress & AssignProperties_From_LoadBalancerBackendAddress returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerBackendAddress, LoadBalancerBackendAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerBackendAddress tests if a specific instance of LoadBalancerBackendAddress can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerBackendAddress(subject LoadBalancerBackendAddress) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancerBackendAddress
	err := copied.AssignProperties_To_LoadBalancerBackendAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerBackendAddress
	err = actual.AssignProperties_From_LoadBalancerBackendAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerBackendAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddress, LoadBalancerBackendAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddress runs a test to see if a specific instance of LoadBalancerBackendAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddress(subject LoadBalancerBackendAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddress instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressGenerator()
var loadBalancerBackendAddressGenerator gopter.Gen

// LoadBalancerBackendAddressGenerator returns a generator of LoadBalancerBackendAddress instances for property testing.
// We first initialize loadBalancerBackendAddressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressGenerator() gopter.Gen {
	if loadBalancerBackendAddressGenerator != nil {
		return loadBalancerBackendAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress(generators)
	loadBalancerBackendAddressGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress(generators)
	loadBalancerBackendAddressGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress{}), generators)

	return loadBalancerBackendAddressGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResourceGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResourceGenerator())
}

func Test_LoadBalancerBackendAddress_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerBackendAddress_STATUS to LoadBalancerBackendAddress_STATUS via AssignProperties_To_LoadBalancerBackendAddress_STATUS & AssignProperties_From_LoadBalancerBackendAddress_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerBackendAddress_STATUS, LoadBalancerBackendAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerBackendAddress_STATUS tests if a specific instance of LoadBalancerBackendAddress_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerBackendAddress_STATUS(subject LoadBalancerBackendAddress_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.LoadBalancerBackendAddress_STATUS
	err := copied.AssignProperties_To_LoadBalancerBackendAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerBackendAddress_STATUS
	err = actual.AssignProperties_From_LoadBalancerBackendAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerBackendAddress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddress_STATUS, LoadBalancerBackendAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddress_STATUS runs a test to see if a specific instance of LoadBalancerBackendAddress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddress_STATUS(subject LoadBalancerBackendAddress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddress_STATUS instances for property testing - lazily instantiated by
// LoadBalancerBackendAddress_STATUSGenerator()
var loadBalancerBackendAddress_STATUSGenerator gopter.Gen

// LoadBalancerBackendAddress_STATUSGenerator returns a generator of LoadBalancerBackendAddress_STATUS instances for property testing.
// We first initialize loadBalancerBackendAddress_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddress_STATUSGenerator() gopter.Gen {
	if loadBalancerBackendAddress_STATUSGenerator != nil {
		return loadBalancerBackendAddress_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUS(generators)
	loadBalancerBackendAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUS(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUS(generators)
	loadBalancerBackendAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddress_STATUS{}), generators)

	return loadBalancerBackendAddress_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddress_STATUS(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddress_STATUS(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["NetworkInterfaceIPConfiguration"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Subnet"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_PublicIPAddress_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_STATUS to PublicIPAddress_STATUS via AssignProperties_To_PublicIPAddress_STATUS & AssignProperties_From_PublicIPAddress_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddress_STATUS, PublicIPAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddress_STATUS tests if a specific instance of PublicIPAddress_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddress_STATUS(subject PublicIPAddress_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.PublicIPAddress_STATUS
	err := copied.AssignProperties_To_PublicIPAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_STATUS
	err = actual.AssignProperties_From_PublicIPAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_STATUS, PublicIPAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_STATUS runs a test to see if a specific instance of PublicIPAddress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_STATUS(subject PublicIPAddress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_STATUS instances for property testing - lazily instantiated by
// PublicIPAddress_STATUSGenerator()
var publicIPAddress_STATUSGenerator gopter.Gen

// PublicIPAddress_STATUSGenerator returns a generator of PublicIPAddress_STATUS instances for property testing.
// We first initialize publicIPAddress_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_STATUSGenerator() gopter.Gen {
	if publicIPAddress_STATUSGenerator != nil {
		return publicIPAddress_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS(generators)
	publicIPAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS(generators)
	publicIPAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS{}), generators)

	return publicIPAddress_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_STATUS_Abort,
		PublicIPAddressPropertiesFormat_MigrationPhase_STATUS_Commit,
		PublicIPAddressPropertiesFormat_MigrationPhase_STATUS_Committed,
		PublicIPAddressPropertiesFormat_MigrationPhase_STATUS_None,
		PublicIPAddressPropertiesFormat_MigrationPhase_STATUS_Prepare))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_STATUS_IPv4, IPVersion_STATUS_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_STATUSGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_STATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfiguration_STATUSGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_STATUSGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_STATUSGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddress_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_STATUSGenerator())
}

func Test_PublicIPAddressSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddressSpec to PublicIPAddressSpec via AssignProperties_To_PublicIPAddressSpec & AssignProperties_From_PublicIPAddressSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddressSpec, PublicIPAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddressSpec tests if a specific instance of PublicIPAddressSpec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddressSpec(subject PublicIPAddressSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.PublicIPAddressSpec
	err := copied.AssignProperties_To_PublicIPAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddressSpec
	err = actual.AssignProperties_From_PublicIPAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddressSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec, PublicIPAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec runs a test to see if a specific instance of PublicIPAddressSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec(subject PublicIPAddressSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec instances for property testing - lazily instantiated by
// PublicIPAddressSpecGenerator()
var publicIPAddressSpecGenerator gopter.Gen

// PublicIPAddressSpecGenerator returns a generator of PublicIPAddressSpec instances for property testing.
// We first initialize publicIPAddressSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpecGenerator() gopter.Gen {
	if publicIPAddressSpecGenerator != nil {
		return publicIPAddressSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec(generators)
	publicIPAddressSpecGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec(generators)
	publicIPAddressSpecGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec{}), generators)

	return publicIPAddressSpecGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed,
		PublicIPAddressPropertiesFormat_MigrationPhase_None,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuGenerator())
}

func Test_Subnet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet to Subnet via AssignProperties_To_Subnet & AssignProperties_From_Subnet returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnet, SubnetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnet tests if a specific instance of Subnet can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnet(subject Subnet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.Subnet
	err := copied.AssignProperties_To_Subnet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet
	err = actual.AssignProperties_From_Subnet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet, SubnetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet runs a test to see if a specific instance of Subnet round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet(subject Subnet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet instances for property testing - lazily instantiated by SubnetGenerator()
var subnetGenerator gopter.Gen

// SubnetGenerator returns a generator of Subnet instances for property testing.
// We first initialize subnetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SubnetGenerator() gopter.Gen {
	if subnetGenerator != nil {
		return subnetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet(generators)
	subnetGenerator = gen.Struct(reflect.TypeOf(Subnet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet(generators)
	AddRelatedPropertyGeneratorsForSubnet(generators)
	subnetGenerator = gen.Struct(reflect.TypeOf(Subnet{}), generators)

	return subnetGenerator
}

// AddIndependentPropertyGeneratorsForSubnet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet(gens map[string]gopter.Gen) {
	gens["AddressPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["AddressPrefixes"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateEndpointNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_Disabled, SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_Enabled))
	gens["PrivateLinkServiceNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_Disabled, SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_Enabled))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSubnet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSubnet(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayIpConfigurations"] = gen.SliceOf(ApplicationGatewayIPConfigurationGenerator())
	gens["Delegations"] = gen.SliceOf(DelegationGenerator())
	gens["IpAllocations"] = gen.SliceOf(SubResourceGenerator())
	gens["NatGateway"] = gen.PtrOf(SubResourceGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpecGenerator())
	gens["RouteTable"] = gen.PtrOf(RouteTableSpecGenerator())
	gens["ServiceEndpointPolicies"] = gen.SliceOf(ServiceEndpointPolicySpecGenerator())
	gens["ServiceEndpoints"] = gen.SliceOf(ServiceEndpointPropertiesFormatGenerator())
}

func Test_Subnet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_STATUS to Subnet_STATUS via AssignProperties_To_Subnet_STATUS & AssignProperties_From_Subnet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnet_STATUS, Subnet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnet_STATUS tests if a specific instance of Subnet_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnet_STATUS(subject Subnet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.Subnet_STATUS
	err := copied.AssignProperties_To_Subnet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_STATUS
	err = actual.AssignProperties_From_Subnet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_STATUS, Subnet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_STATUS runs a test to see if a specific instance of Subnet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_STATUS(subject Subnet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_STATUS instances for property testing - lazily instantiated by Subnet_STATUSGenerator()
var subnet_STATUSGenerator gopter.Gen

// Subnet_STATUSGenerator returns a generator of Subnet_STATUS instances for property testing.
// We first initialize subnet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Subnet_STATUSGenerator() gopter.Gen {
	if subnet_STATUSGenerator != nil {
		return subnet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_STATUS(generators)
	subnet_STATUSGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_STATUS(generators)
	AddRelatedPropertyGeneratorsForSubnet_STATUS(generators)
	subnet_STATUSGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS{}), generators)

	return subnet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_STATUS(gens map[string]gopter.Gen) {
	gens["AddressPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["AddressPrefixes"] = gen.SliceOf(gen.AlphaString())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateEndpointNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_STATUS_Disabled, SubnetPropertiesFormat_PrivateEndpointNetworkPolicies_STATUS_Enabled))
	gens["PrivateLinkServiceNetworkPolicies"] = gen.PtrOf(gen.OneConstOf(SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_STATUS_Disabled, SubnetPropertiesFormat_PrivateLinkServiceNetworkPolicies_STATUS_Enabled))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Purpose"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSubnet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSubnet_STATUS(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayIpConfigurations"] = gen.SliceOf(ApplicationGatewayIPConfiguration_STATUSGenerator())
	gens["Delegations"] = gen.SliceOf(Delegation_STATUSGenerator())
	gens["IpAllocations"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["IpConfigurationProfiles"] = gen.SliceOf(IPConfigurationProfile_STATUSGenerator())
	gens["IpConfigurations"] = gen.SliceOf(IPConfiguration_STATUSGenerator())
	gens["NatGateway"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroup_STATUSGenerator())
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpoint_STATUSGenerator())
	gens["ResourceNavigationLinks"] = gen.SliceOf(ResourceNavigationLink_STATUSGenerator())
	gens["RouteTable"] = gen.PtrOf(RouteTable_STATUSGenerator())
	gens["ServiceAssociationLinks"] = gen.SliceOf(ServiceAssociationLink_STATUSGenerator())
	gens["ServiceEndpointPolicies"] = gen.SliceOf(ServiceEndpointPolicy_STATUSGenerator())
	gens["ServiceEndpoints"] = gen.SliceOf(ServiceEndpointPropertiesFormat_STATUSGenerator())
}

func Test_NatGateway_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NatGateway_STATUS to NatGateway_STATUS via AssignProperties_To_NatGateway_STATUS & AssignProperties_From_NatGateway_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNatGateway_STATUS, NatGateway_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNatGateway_STATUS tests if a specific instance of NatGateway_STATUS can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNatGateway_STATUS(subject NatGateway_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20201101s.NatGateway_STATUS
	err := copied.AssignProperties_To_NatGateway_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NatGateway_STATUS
	err = actual.AssignProperties_From_NatGateway_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NatGateway_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGateway_STATUS, NatGateway_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGateway_STATUS runs a test to see if a specific instance of NatGateway_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGateway_STATUS(subject NatGateway_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_STATUS instances for property testing - lazily instantiated by NatGateway_STATUSGenerator()
var natGateway_STATUSGenerator gopter.Gen

// NatGateway_STATUSGenerator returns a generator of NatGateway_STATUS instances for property testing.
// We first initialize natGateway_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGateway_STATUSGenerator() gopter.Gen {
	if natGateway_STATUSGenerator != nil {
		return natGateway_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUS(generators)
	natGateway_STATUSGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUS(generators)
	AddRelatedPropertyGeneratorsForNatGateway_STATUS(generators)
	natGateway_STATUSGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS{}), generators)

	return natGateway_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNatGateway_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGateway_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGateway_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGateway_STATUS(gens map[string]gopter.Gen) {
	gens["PublicIpAddresses"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["PublicIpPrefixes"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(NatGatewaySku_STATUSGenerator())
	gens["Subnets"] = gen.SliceOf(SubResource_STATUSGenerator())
}
