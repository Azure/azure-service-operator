// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to hub returns original",
		prop.ForAll(RunResourceConversionTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForLoadBalancer tests if a specific instance of LoadBalancer round trips to the hub storage version and back losslessly
func RunResourceConversionTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201101storage.LoadBalancer
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual LoadBalancer
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to LoadBalancer via AssignPropertiesToLoadBalancer & AssignPropertiesFromLoadBalancer returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer tests if a specific instance of LoadBalancer can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancer
	err := copied.AssignPropertiesToLoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer
	err = actual.AssignPropertiesFromLoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer runs a test to see if a specific instance of LoadBalancer round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer(subject LoadBalancer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer instances for property testing - lazily instantiated by LoadBalancerGenerator()
var loadBalancerGenerator gopter.Gen

// LoadBalancerGenerator returns a generator of LoadBalancer instances for property testing.
func LoadBalancerGenerator() gopter.Gen {
	if loadBalancerGenerator != nil {
		return loadBalancerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancer(generators)
	loadBalancerGenerator = gen.Struct(reflect.TypeOf(LoadBalancer{}), generators)

	return loadBalancerGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer(gens map[string]gopter.Gen) {
	gens["Spec"] = LoadBalancersSPECGenerator()
	gens["Status"] = LoadBalancerStatusGenerator()
}

func Test_LoadBalancer_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer_Status to LoadBalancer_Status via AssignPropertiesToLoadBalancerStatus & AssignPropertiesFromLoadBalancerStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerStatus, LoadBalancerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerStatus tests if a specific instance of LoadBalancer_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerStatus(subject LoadBalancer_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancer_Status
	err := copied.AssignPropertiesToLoadBalancerStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer_Status
	err = actual.AssignPropertiesFromLoadBalancerStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerStatus, LoadBalancerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerStatus runs a test to see if a specific instance of LoadBalancer_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerStatus(subject LoadBalancer_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Status instances for property testing - lazily instantiated by LoadBalancerStatusGenerator()
var loadBalancerStatusGenerator gopter.Gen

// LoadBalancerStatusGenerator returns a generator of LoadBalancer_Status instances for property testing.
// We first initialize loadBalancerStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerStatusGenerator() gopter.Gen {
	if loadBalancerStatusGenerator != nil {
		return loadBalancerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerStatus(generators)
	loadBalancerStatusGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerStatus(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerStatus(generators)
	loadBalancerStatusGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Status{}), generators)

	return loadBalancerStatusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerStatus(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolStatusGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleStatusGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleStatusGenerator())
	gens["Probes"] = gen.SliceOf(ProbeStatusGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuStatusGenerator())
}

func Test_LoadBalancers_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancers_SPEC to LoadBalancers_SPEC via AssignPropertiesToLoadBalancersSPEC & AssignPropertiesFromLoadBalancersSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancersSPEC, LoadBalancersSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancersSPEC tests if a specific instance of LoadBalancers_SPEC can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancersSPEC(subject LoadBalancers_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancers_SPEC
	err := copied.AssignPropertiesToLoadBalancersSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancers_SPEC
	err = actual.AssignPropertiesFromLoadBalancersSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancers_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancersSPEC, LoadBalancersSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancersSPEC runs a test to see if a specific instance of LoadBalancers_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancersSPEC(subject LoadBalancers_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SPEC instances for property testing - lazily instantiated by LoadBalancersSPECGenerator()
var loadBalancersSPECGenerator gopter.Gen

// LoadBalancersSPECGenerator returns a generator of LoadBalancers_SPEC instances for property testing.
// We first initialize loadBalancersSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancersSPECGenerator() gopter.Gen {
	if loadBalancersSPECGenerator != nil {
		return loadBalancersSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSPEC(generators)
	loadBalancersSPECGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancersSPEC(generators)
	AddRelatedPropertyGeneratorsForLoadBalancersSPEC(generators)
	loadBalancersSPECGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPEC{}), generators)

	return loadBalancersSPECGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancersSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancersSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancersSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancersSPEC(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolSpecGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleSpecGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleSpecGenerator())
	gens["Probes"] = gen.SliceOf(ProbeSpecGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuSpecGenerator())
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded to BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToBackendAddressPoolSpecLoadBalancerSubResourceEmbedded & AssignPropertiesFromBackendAddressPoolSpecLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded, BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded tests if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPoolSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPoolSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded, BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolSpecLoadBalancerSubResourceEmbedded(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator()
var backendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func BackendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator != nil {
		return backendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	backendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return backendAddressPoolSpecLoadBalancerSubResourceEmbeddedGenerator
}

func Test_BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded to BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded & AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded, BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded tests if a specific instance of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(subject BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded, BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(subject BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator()
var backendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func BackendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator != nil {
		return backendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(generators)
	backendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return backendAddressPoolStatusLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocationSpec & AssignPropertiesFromExtendedLocationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocationSpec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocationSpecGenerator()
var extendedLocationSpecGenerator gopter.Gen

// ExtendedLocationSpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocationSpecGenerator() gopter.Gen {
	if extendedLocationSpecGenerator != nil {
		return extendedLocationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpec(generators)
	extendedLocationSpecGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocationSpecGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_SpecEdgeZone)
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocationStatus & AssignPropertiesFromExtendedLocationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocationStatus tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatus runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocationStatusGenerator()
var extendedLocationStatusGenerator gopter.Gen

// ExtendedLocationStatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocationStatusGenerator() gopter.Gen {
	if extendedLocationStatusGenerator != nil {
		return extendedLocationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatus(generators)
	extendedLocationStatusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocationStatusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_StatusEdgeZone)
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded to FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded & AssignPropertiesFromFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded, FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded tests if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded, FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator()
var frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator != nil {
		return frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(generators)
	frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(generators)
	frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return frontendIPConfigurationSpecLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetSpecLoadBalancerSubResourceEmbeddedGenerator())
}

func Test_FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded to FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded & AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded, FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded tests if a specific instance of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(subject FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded, FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(subject FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator()
var frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator != nil {
		return frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(generators)
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(generators)
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return frontendIPConfigurationStatusLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_StatusIPv4, IPVersion_StatusIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_StatusDynamic, IPAllocationMethod_StatusStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetStatusLoadBalancerSubResourceEmbeddedGenerator())
}

func Test_InboundNatPool_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool_Spec to InboundNatPool_Spec via AssignPropertiesToInboundNatPoolSpec & AssignPropertiesFromInboundNatPoolSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPoolSpec, InboundNatPoolSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPoolSpec tests if a specific instance of InboundNatPool_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPoolSpec(subject InboundNatPool_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatPool_Spec
	err := copied.AssignPropertiesToInboundNatPoolSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool_Spec
	err = actual.AssignPropertiesFromInboundNatPoolSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolSpec, InboundNatPoolSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolSpec runs a test to see if a specific instance of InboundNatPool_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolSpec(subject InboundNatPool_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_Spec instances for property testing - lazily instantiated by InboundNatPoolSpecGenerator()
var inboundNatPoolSpecGenerator gopter.Gen

// InboundNatPoolSpecGenerator returns a generator of InboundNatPool_Spec instances for property testing.
// We first initialize inboundNatPoolSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolSpecGenerator() gopter.Gen {
	if inboundNatPoolSpecGenerator != nil {
		return inboundNatPoolSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSpec(generators)
	inboundNatPoolSpecGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolSpec(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolSpec(generators)
	inboundNatPoolSpecGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Spec{}), generators)

	return inboundNatPoolSpecGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolSpec(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolSpec(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_InboundNatPool_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool_Status to InboundNatPool_Status via AssignPropertiesToInboundNatPoolStatus & AssignPropertiesFromInboundNatPoolStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPoolStatus, InboundNatPoolStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPoolStatus tests if a specific instance of InboundNatPool_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPoolStatus(subject InboundNatPool_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatPool_Status
	err := copied.AssignPropertiesToInboundNatPoolStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool_Status
	err = actual.AssignPropertiesFromInboundNatPoolStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolStatus, InboundNatPoolStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolStatus runs a test to see if a specific instance of InboundNatPool_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolStatus(subject InboundNatPool_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_Status instances for property testing - lazily instantiated by
//InboundNatPoolStatusGenerator()
var inboundNatPoolStatusGenerator gopter.Gen

// InboundNatPoolStatusGenerator returns a generator of InboundNatPool_Status instances for property testing.
// We first initialize inboundNatPoolStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolStatusGenerator() gopter.Gen {
	if inboundNatPoolStatusGenerator != nil {
		return inboundNatPoolStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolStatus(generators)
	inboundNatPoolStatusGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolStatus(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolStatus(generators)
	inboundNatPoolStatusGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Status{}), generators)

	return inboundNatPoolStatusGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolStatus(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPoolStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolStatus(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded to InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToInboundNatRuleSpecLoadBalancerSubResourceEmbedded & AssignPropertiesFromInboundNatRuleSpecLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded, InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded tests if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRuleSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRuleSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded, InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleSpecLoadBalancerSubResourceEmbedded(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator()
var inboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator returns a generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func InboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator != nil {
		return inboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	inboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return inboundNatRuleSpecLoadBalancerSubResourceEmbeddedGenerator
}

func Test_InboundNatRule_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Status_LoadBalancer_SubResourceEmbedded to InboundNatRule_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded & AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded, InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded tests if a specific instance of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded(subject InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded, InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleStatusLoadBalancerSubResourceEmbedded(subject InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator()
var inboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator returns a generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func InboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator != nil {
		return inboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleStatusLoadBalancerSubResourceEmbedded(generators)
	inboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return inboundNatRuleStatusLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRuleStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRuleStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancerSku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku_Spec to LoadBalancerSku_Spec via AssignPropertiesToLoadBalancerSkuSpec & AssignPropertiesFromLoadBalancerSkuSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSkuSpec, LoadBalancerSkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSkuSpec tests if a specific instance of LoadBalancerSku_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSkuSpec(subject LoadBalancerSku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancerSku_Spec
	err := copied.AssignPropertiesToLoadBalancerSkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku_Spec
	err = actual.AssignPropertiesFromLoadBalancerSkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuSpec, LoadBalancerSkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuSpec runs a test to see if a specific instance of LoadBalancerSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuSpec(subject LoadBalancerSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_Spec instances for property testing - lazily instantiated by
//LoadBalancerSkuSpecGenerator()
var loadBalancerSkuSpecGenerator gopter.Gen

// LoadBalancerSkuSpecGenerator returns a generator of LoadBalancerSku_Spec instances for property testing.
func LoadBalancerSkuSpecGenerator() gopter.Gen {
	if loadBalancerSkuSpecGenerator != nil {
		return loadBalancerSkuSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuSpec(generators)
	loadBalancerSkuSpecGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_Spec{}), generators)

	return loadBalancerSkuSpecGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSpecNameBasic, LoadBalancerSkuSpecNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuSpecTierGlobal, LoadBalancerSkuSpecTierRegional))
}

func Test_LoadBalancerSku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku_Status to LoadBalancerSku_Status via AssignPropertiesToLoadBalancerSkuStatus & AssignPropertiesFromLoadBalancerSkuStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSkuStatus, LoadBalancerSkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSkuStatus tests if a specific instance of LoadBalancerSku_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSkuStatus(subject LoadBalancerSku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancerSku_Status
	err := copied.AssignPropertiesToLoadBalancerSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku_Status
	err = actual.AssignPropertiesFromLoadBalancerSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuStatus, LoadBalancerSkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuStatus runs a test to see if a specific instance of LoadBalancerSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuStatus(subject LoadBalancerSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_Status instances for property testing - lazily instantiated by
//LoadBalancerSkuStatusGenerator()
var loadBalancerSkuStatusGenerator gopter.Gen

// LoadBalancerSkuStatusGenerator returns a generator of LoadBalancerSku_Status instances for property testing.
func LoadBalancerSkuStatusGenerator() gopter.Gen {
	if loadBalancerSkuStatusGenerator != nil {
		return loadBalancerSkuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuStatus(generators)
	loadBalancerSkuStatusGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_Status{}), generators)

	return loadBalancerSkuStatusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuStatusNameBasic, LoadBalancerSkuStatusNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSkuStatusTierGlobal, LoadBalancerSkuStatusTierRegional))
}

func Test_LoadBalancingRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule_Spec to LoadBalancingRule_Spec via AssignPropertiesToLoadBalancingRuleSpec & AssignPropertiesFromLoadBalancingRuleSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRuleSpec, LoadBalancingRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRuleSpec tests if a specific instance of LoadBalancingRule_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRuleSpec(subject LoadBalancingRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancingRule_Spec
	err := copied.AssignPropertiesToLoadBalancingRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule_Spec
	err = actual.AssignPropertiesFromLoadBalancingRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleSpec, LoadBalancingRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleSpec runs a test to see if a specific instance of LoadBalancingRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleSpec(subject LoadBalancingRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_Spec instances for property testing - lazily instantiated by
//LoadBalancingRuleSpecGenerator()
var loadBalancingRuleSpecGenerator gopter.Gen

// LoadBalancingRuleSpecGenerator returns a generator of LoadBalancingRule_Spec instances for property testing.
// We first initialize loadBalancingRuleSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleSpecGenerator() gopter.Gen {
	if loadBalancingRuleSpecGenerator != nil {
		return loadBalancingRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSpec(generators)
	loadBalancingRuleSpecGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleSpec(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleSpec(generators)
	loadBalancingRuleSpecGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Spec{}), generators)

	return loadBalancingRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleSpec(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatSpecLoadDistributionDefault, LoadBalancingRulePropertiesFormatSpecLoadDistributionSourceIP, LoadBalancingRulePropertiesFormatSpecLoadDistributionSourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleSpec(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_LoadBalancingRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule_Status to LoadBalancingRule_Status via AssignPropertiesToLoadBalancingRuleStatus & AssignPropertiesFromLoadBalancingRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRuleStatus, LoadBalancingRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRuleStatus tests if a specific instance of LoadBalancingRule_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRuleStatus(subject LoadBalancingRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancingRule_Status
	err := copied.AssignPropertiesToLoadBalancingRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule_Status
	err = actual.AssignPropertiesFromLoadBalancingRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleStatus, LoadBalancingRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleStatus runs a test to see if a specific instance of LoadBalancingRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleStatus(subject LoadBalancingRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_Status instances for property testing - lazily instantiated by
//LoadBalancingRuleStatusGenerator()
var loadBalancingRuleStatusGenerator gopter.Gen

// LoadBalancingRuleStatusGenerator returns a generator of LoadBalancingRule_Status instances for property testing.
// We first initialize loadBalancingRuleStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleStatusGenerator() gopter.Gen {
	if loadBalancingRuleStatusGenerator != nil {
		return loadBalancingRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleStatus(generators)
	loadBalancingRuleStatusGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleStatus(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleStatus(generators)
	loadBalancingRuleStatusGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Status{}), generators)

	return loadBalancingRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleStatus(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormatStatusLoadDistributionDefault, LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIP, LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleStatus(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_OutboundRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_Spec to OutboundRule_Spec via AssignPropertiesToOutboundRuleSpec & AssignPropertiesFromOutboundRuleSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRuleSpec, OutboundRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRuleSpec tests if a specific instance of OutboundRule_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRuleSpec(subject OutboundRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.OutboundRule_Spec
	err := copied.AssignPropertiesToOutboundRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_Spec
	err = actual.AssignPropertiesFromOutboundRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleSpec, OutboundRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleSpec runs a test to see if a specific instance of OutboundRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleSpec(subject OutboundRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_Spec instances for property testing - lazily instantiated by OutboundRuleSpecGenerator()
var outboundRuleSpecGenerator gopter.Gen

// OutboundRuleSpecGenerator returns a generator of OutboundRule_Spec instances for property testing.
// We first initialize outboundRuleSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleSpecGenerator() gopter.Gen {
	if outboundRuleSpecGenerator != nil {
		return outboundRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSpec(generators)
	outboundRuleSpecGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleSpec(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleSpec(generators)
	outboundRuleSpecGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Spec{}), generators)

	return outboundRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleSpec(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormatSpecProtocolAll, OutboundRulePropertiesFormatSpecProtocolTcp, OutboundRulePropertiesFormatSpecProtocolUdp))
}

// AddRelatedPropertyGeneratorsForOutboundRuleSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleSpec(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceSpecGenerator())
}

func Test_OutboundRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_Status to OutboundRule_Status via AssignPropertiesToOutboundRuleStatus & AssignPropertiesFromOutboundRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRuleStatus, OutboundRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRuleStatus tests if a specific instance of OutboundRule_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRuleStatus(subject OutboundRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.OutboundRule_Status
	err := copied.AssignPropertiesToOutboundRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_Status
	err = actual.AssignPropertiesFromOutboundRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleStatus, OutboundRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleStatus runs a test to see if a specific instance of OutboundRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleStatus(subject OutboundRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_Status instances for property testing - lazily instantiated by OutboundRuleStatusGenerator()
var outboundRuleStatusGenerator gopter.Gen

// OutboundRuleStatusGenerator returns a generator of OutboundRule_Status instances for property testing.
// We first initialize outboundRuleStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleStatusGenerator() gopter.Gen {
	if outboundRuleStatusGenerator != nil {
		return outboundRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleStatus(generators)
	outboundRuleStatusGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleStatus(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleStatus(generators)
	outboundRuleStatusGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Status{}), generators)

	return outboundRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleStatus(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormatStatusProtocolAll, OutboundRulePropertiesFormatStatusProtocolTcp, OutboundRulePropertiesFormatStatusProtocolUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRuleStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleStatus(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceStatusGenerator())
}

func Test_Probe_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe_Spec to Probe_Spec via AssignPropertiesToProbeSpec & AssignPropertiesFromProbeSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbeSpec, ProbeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbeSpec tests if a specific instance of Probe_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbeSpec(subject Probe_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Probe_Spec
	err := copied.AssignPropertiesToProbeSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe_Spec
	err = actual.AssignPropertiesFromProbeSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeSpec, ProbeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeSpec runs a test to see if a specific instance of Probe_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeSpec(subject Probe_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_Spec instances for property testing - lazily instantiated by ProbeSpecGenerator()
var probeSpecGenerator gopter.Gen

// ProbeSpecGenerator returns a generator of Probe_Spec instances for property testing.
func ProbeSpecGenerator() gopter.Gen {
	if probeSpecGenerator != nil {
		return probeSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeSpec(generators)
	probeSpecGenerator = gen.Struct(reflect.TypeOf(Probe_Spec{}), generators)

	return probeSpecGenerator
}

// AddIndependentPropertyGeneratorsForProbeSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeSpec(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormatSpecProtocolHttp, ProbePropertiesFormatSpecProtocolHttps, ProbePropertiesFormatSpecProtocolTcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_Probe_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe_Status to Probe_Status via AssignPropertiesToProbeStatus & AssignPropertiesFromProbeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbeStatus, ProbeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbeStatus tests if a specific instance of Probe_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbeStatus(subject Probe_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Probe_Status
	err := copied.AssignPropertiesToProbeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe_Status
	err = actual.AssignPropertiesFromProbeStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeStatus, ProbeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeStatus runs a test to see if a specific instance of Probe_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeStatus(subject Probe_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_Status instances for property testing - lazily instantiated by ProbeStatusGenerator()
var probeStatusGenerator gopter.Gen

// ProbeStatusGenerator returns a generator of Probe_Status instances for property testing.
// We first initialize probeStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbeStatusGenerator() gopter.Gen {
	if probeStatusGenerator != nil {
		return probeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeStatus(generators)
	probeStatusGenerator = gen.Struct(reflect.TypeOf(Probe_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeStatus(generators)
	AddRelatedPropertyGeneratorsForProbeStatus(generators)
	probeStatusGenerator = gen.Struct(reflect.TypeOf(Probe_Status{}), generators)

	return probeStatusGenerator
}

// AddIndependentPropertyGeneratorsForProbeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormatStatusProtocolHttp, ProbePropertiesFormatStatusProtocolHttps, ProbePropertiesFormatStatusProtocolTcp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbeStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbeStatus(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResourceStatusGenerator())
}

func Test_PublicIPAddress_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_Spec to PublicIPAddress_Spec via AssignPropertiesToPublicIPAddressSpec & AssignPropertiesFromPublicIPAddressSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddressSpec, PublicIPAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddressSpec tests if a specific instance of PublicIPAddress_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddressSpec(subject PublicIPAddress_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PublicIPAddress_Spec
	err := copied.AssignPropertiesToPublicIPAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_Spec
	err = actual.AssignPropertiesFromPublicIPAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec, PublicIPAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec runs a test to see if a specific instance of PublicIPAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec(subject PublicIPAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Spec instances for property testing - lazily instantiated by
//PublicIPAddressSpecGenerator()
var publicIPAddressSpecGenerator gopter.Gen

// PublicIPAddressSpecGenerator returns a generator of PublicIPAddress_Spec instances for property testing.
// We first initialize publicIPAddressSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpecGenerator() gopter.Gen {
	if publicIPAddressSpecGenerator != nil {
		return publicIPAddressSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec(generators)
	publicIPAddressSpecGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec(generators)
	publicIPAddressSpecGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec{}), generators)

	return publicIPAddressSpecGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormatSpecMigrationPhaseAbort,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommit,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommitted,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseNone,
		PublicIPAddressPropertiesFormatSpecMigrationPhasePrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsSpecGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagSpecGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSpecGenerator())
}

func Test_PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded to PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded & AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded, PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded tests if a specific instance of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(subject PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded, PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(subject PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator()
var publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator returns a generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator != nil {
		return publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(generators)
	publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(generators)
	publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return publicIPAddressStatusLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuStatusGenerator())
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Spec_LoadBalancer_SubResourceEmbedded to Subnet_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToSubnetSpecLoadBalancerSubResourceEmbedded & AssignPropertiesFromSubnetSpecLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnetSpecLoadBalancerSubResourceEmbedded, SubnetSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnetSpecLoadBalancerSubResourceEmbedded tests if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnetSpecLoadBalancerSubResourceEmbedded(subject Subnet_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnetSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnetSpecLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbedded, SubnetSpecLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSpecLoadBalancerSubResourceEmbedded(subject Subnet_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily instantiated by
//SubnetSpecLoadBalancerSubResourceEmbeddedGenerator()
var subnetSpecLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// SubnetSpecLoadBalancerSubResourceEmbeddedGenerator returns a generator of Subnet_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func SubnetSpecLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if subnetSpecLoadBalancerSubResourceEmbeddedGenerator != nil {
		return subnetSpecLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	subnetSpecLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return subnetSpecLoadBalancerSubResourceEmbeddedGenerator
}

func Test_Subnet_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Status_LoadBalancer_SubResourceEmbedded to Subnet_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded & AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnetStatusLoadBalancerSubResourceEmbedded, SubnetStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnetStatusLoadBalancerSubResourceEmbedded tests if a specific instance of Subnet_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnetStatusLoadBalancerSubResourceEmbedded(subject Subnet_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetStatusLoadBalancerSubResourceEmbedded, SubnetStatusLoadBalancerSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetStatusLoadBalancerSubResourceEmbedded runs a test to see if a specific instance of Subnet_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetStatusLoadBalancerSubResourceEmbedded(subject Subnet_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily instantiated by
//SubnetStatusLoadBalancerSubResourceEmbeddedGenerator()
var subnetStatusLoadBalancerSubResourceEmbeddedGenerator gopter.Gen

// SubnetStatusLoadBalancerSubResourceEmbeddedGenerator returns a generator of Subnet_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func SubnetStatusLoadBalancerSubResourceEmbeddedGenerator() gopter.Gen {
	if subnetStatusLoadBalancerSubResourceEmbeddedGenerator != nil {
		return subnetStatusLoadBalancerSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetStatusLoadBalancerSubResourceEmbedded(generators)
	subnetStatusLoadBalancerSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return subnetStatusLoadBalancerSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnetStatusLoadBalancerSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetStatusLoadBalancerSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
