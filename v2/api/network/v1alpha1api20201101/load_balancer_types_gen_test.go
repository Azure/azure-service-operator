// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to hub returns original",
		prop.ForAll(RunResourceConversionTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForLoadBalancer tests if a specific instance of LoadBalancer round trips to the hub storage version and back losslessly
func RunResourceConversionTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201101storage.LoadBalancer
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual LoadBalancer
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer to LoadBalancer via AssignPropertiesToLoadBalancer & AssignPropertiesFromLoadBalancer returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer tests if a specific instance of LoadBalancer can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer(subject LoadBalancer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancer
	err := copied.AssignPropertiesToLoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer
	err = actual.AssignPropertiesFromLoadBalancer(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer, LoadBalancerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer runs a test to see if a specific instance of LoadBalancer round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer(subject LoadBalancer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer instances for property testing - lazily instantiated by LoadBalancerGenerator()
var loadBalancerGenerator gopter.Gen

// LoadBalancerGenerator returns a generator of LoadBalancer instances for property testing.
func LoadBalancerGenerator() gopter.Gen {
	if loadBalancerGenerator != nil {
		return loadBalancerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancer(generators)
	loadBalancerGenerator = gen.Struct(reflect.TypeOf(LoadBalancer{}), generators)

	return loadBalancerGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer(gens map[string]gopter.Gen) {
	gens["Spec"] = LoadBalancers_SPECGenerator()
	gens["Status"] = LoadBalancer_StatusGenerator()
}

func Test_LoadBalancer_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancer_Status to LoadBalancer_Status via AssignPropertiesToLoadBalancer_Status & AssignPropertiesFromLoadBalancer_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancer_Status, LoadBalancer_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancer_Status tests if a specific instance of LoadBalancer_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancer_Status(subject LoadBalancer_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancer_Status
	err := copied.AssignPropertiesToLoadBalancer_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancer_Status
	err = actual.AssignPropertiesFromLoadBalancer_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancer_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Status, LoadBalancer_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Status runs a test to see if a specific instance of LoadBalancer_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Status(subject LoadBalancer_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Status instances for property testing - lazily instantiated by
//LoadBalancer_StatusGenerator()
var loadBalancer_statusGenerator gopter.Gen

// LoadBalancer_StatusGenerator returns a generator of LoadBalancer_Status instances for property testing.
// We first initialize loadBalancer_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_StatusGenerator() gopter.Gen {
	if loadBalancer_statusGenerator != nil {
		return loadBalancer_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Status(generators)
	loadBalancer_statusGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Status(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Status(generators)
	loadBalancer_statusGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Status{}), generators)

	return loadBalancer_statusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Status(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Status(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_StatusGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_StatusGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_StatusGenerator())
	gens["Probes"] = gen.SliceOf(Probe_StatusGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_StatusGenerator())
}

func Test_LoadBalancers_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancers_SPEC to LoadBalancers_SPEC via AssignPropertiesToLoadBalancers_SPEC & AssignPropertiesFromLoadBalancers_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancers_SPEC, LoadBalancers_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancers_SPEC tests if a specific instance of LoadBalancers_SPEC can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancers_SPEC(subject LoadBalancers_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancers_SPEC
	err := copied.AssignPropertiesToLoadBalancers_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancers_SPEC
	err = actual.AssignPropertiesFromLoadBalancers_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancers_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancers_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancers_SPEC, LoadBalancers_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancers_SPEC runs a test to see if a specific instance of LoadBalancers_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancers_SPEC(subject LoadBalancers_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancers_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancers_SPEC instances for property testing - lazily instantiated by LoadBalancers_SPECGenerator()
var loadBalancers_specGenerator gopter.Gen

// LoadBalancers_SPECGenerator returns a generator of LoadBalancers_SPEC instances for property testing.
// We first initialize loadBalancers_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancers_SPECGenerator() gopter.Gen {
	if loadBalancers_specGenerator != nil {
		return loadBalancers_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SPEC(generators)
	loadBalancers_specGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancers_SPEC(generators)
	AddRelatedPropertyGeneratorsForLoadBalancers_SPEC(generators)
	loadBalancers_specGenerator = gen.Struct(reflect.TypeOf(LoadBalancers_SPEC{}), generators)

	return loadBalancers_specGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancers_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancers_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancers_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancers_SPEC(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_SpecGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_SpecGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_SpecGenerator())
	gens["Probes"] = gen.SliceOf(Probe_SpecGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_SpecGenerator())
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded to BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded, BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded tests if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded, BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(subject BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator()
var backendAddressPool_spec_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPool_spec_loadBalancer_subResourceEmbeddedGenerator != nil {
		return backendAddressPool_spec_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	backendAddressPool_spec_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return backendAddressPool_spec_loadBalancer_subResourceEmbeddedGenerator
}

func Test_BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded to BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded tests if a specific instance of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(subject BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(subject BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator()
var backendAddressPool_status_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPool_status_loadBalancer_subResourceEmbeddedGenerator != nil {
		return backendAddressPool_status_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(generators)
	backendAddressPool_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return backendAddressPool_status_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocation_Spec & AssignPropertiesFromExtendedLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Spec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_SpecEdgeZone)
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocation_Status & AssignPropertiesFromExtendedLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Status tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_StatusEdgeZone)
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded to FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded, FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded tests if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded, FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(subject FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator()
var frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator != nil {
		return frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(generators)
	frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(generators)
	frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return frontendIPConfiguration_spec_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator())
}

func Test_FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded to FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded tests if a specific instance of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(subject FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(subject FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator()
var frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator != nil {
		return frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(generators)
	frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(generators)
	frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_StatusIPv4, IPVersion_StatusIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_StatusDynamic, IPAllocationMethod_StatusStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator())
}

func Test_InboundNatPool_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool_Spec to InboundNatPool_Spec via AssignPropertiesToInboundNatPool_Spec & AssignPropertiesFromInboundNatPool_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPool_Spec, InboundNatPool_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPool_Spec tests if a specific instance of InboundNatPool_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPool_Spec(subject InboundNatPool_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatPool_Spec
	err := copied.AssignPropertiesToInboundNatPool_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool_Spec
	err = actual.AssignPropertiesFromInboundNatPool_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_Spec, InboundNatPool_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_Spec runs a test to see if a specific instance of InboundNatPool_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_Spec(subject InboundNatPool_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_Spec instances for property testing - lazily instantiated by
//InboundNatPool_SpecGenerator()
var inboundNatPool_specGenerator gopter.Gen

// InboundNatPool_SpecGenerator returns a generator of InboundNatPool_Spec instances for property testing.
// We first initialize inboundNatPool_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_SpecGenerator() gopter.Gen {
	if inboundNatPool_specGenerator != nil {
		return inboundNatPool_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_Spec(generators)
	inboundNatPool_specGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_Spec(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_Spec(generators)
	inboundNatPool_specGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Spec{}), generators)

	return inboundNatPool_specGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_Spec(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp))
}

// AddRelatedPropertyGeneratorsForInboundNatPool_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_Spec(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_InboundNatPool_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatPool_Status to InboundNatPool_Status via AssignPropertiesToInboundNatPool_Status & AssignPropertiesFromInboundNatPool_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatPool_Status, InboundNatPool_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatPool_Status tests if a specific instance of InboundNatPool_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatPool_Status(subject InboundNatPool_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatPool_Status
	err := copied.AssignPropertiesToInboundNatPool_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatPool_Status
	err = actual.AssignPropertiesFromInboundNatPool_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatPool_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_Status, InboundNatPool_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_Status runs a test to see if a specific instance of InboundNatPool_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_Status(subject InboundNatPool_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_Status instances for property testing - lazily instantiated by
//InboundNatPool_StatusGenerator()
var inboundNatPool_statusGenerator gopter.Gen

// InboundNatPool_StatusGenerator returns a generator of InboundNatPool_Status instances for property testing.
// We first initialize inboundNatPool_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_StatusGenerator() gopter.Gen {
	if inboundNatPool_statusGenerator != nil {
		return inboundNatPool_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_Status(generators)
	inboundNatPool_statusGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_Status(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_Status(generators)
	inboundNatPool_statusGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_Status{}), generators)

	return inboundNatPool_statusGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_Status(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_Status(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded to InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded, InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded tests if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded, InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(subject InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator()
var inboundNatRule_spec_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRule_spec_loadBalancer_subResourceEmbeddedGenerator != nil {
		return inboundNatRule_spec_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	inboundNatRule_spec_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return inboundNatRule_spec_loadBalancer_subResourceEmbeddedGenerator
}

func Test_InboundNatRule_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Status_LoadBalancer_SubResourceEmbedded to InboundNatRule_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded, InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded tests if a specific instance of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(subject InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded, InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(subject InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator()
var inboundNatRule_status_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRule_status_loadBalancer_subResourceEmbeddedGenerator != nil {
		return inboundNatRule_status_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(generators)
	inboundNatRule_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return inboundNatRule_status_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancerSku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku_Spec to LoadBalancerSku_Spec via AssignPropertiesToLoadBalancerSku_Spec & AssignPropertiesFromLoadBalancerSku_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSku_Spec, LoadBalancerSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSku_Spec tests if a specific instance of LoadBalancerSku_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSku_Spec(subject LoadBalancerSku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancerSku_Spec
	err := copied.AssignPropertiesToLoadBalancerSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku_Spec
	err = actual.AssignPropertiesFromLoadBalancerSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_Spec, LoadBalancerSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_Spec runs a test to see if a specific instance of LoadBalancerSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_Spec(subject LoadBalancerSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_Spec instances for property testing - lazily instantiated by
//LoadBalancerSku_SpecGenerator()
var loadBalancerSku_specGenerator gopter.Gen

// LoadBalancerSku_SpecGenerator returns a generator of LoadBalancerSku_Spec instances for property testing.
func LoadBalancerSku_SpecGenerator() gopter.Gen {
	if loadBalancerSku_specGenerator != nil {
		return loadBalancerSku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_Spec(generators)
	loadBalancerSku_specGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_Spec{}), generators)

	return loadBalancerSku_specGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_SpecBasic, LoadBalancerSku_Name_SpecStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_SpecGlobal, LoadBalancerSku_Tier_SpecRegional))
}

func Test_LoadBalancerSku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerSku_Status to LoadBalancerSku_Status via AssignPropertiesToLoadBalancerSku_Status & AssignPropertiesFromLoadBalancerSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerSku_Status, LoadBalancerSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerSku_Status tests if a specific instance of LoadBalancerSku_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerSku_Status(subject LoadBalancerSku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancerSku_Status
	err := copied.AssignPropertiesToLoadBalancerSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerSku_Status
	err = actual.AssignPropertiesFromLoadBalancerSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_Status, LoadBalancerSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_Status runs a test to see if a specific instance of LoadBalancerSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_Status(subject LoadBalancerSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_Status instances for property testing - lazily instantiated by
//LoadBalancerSku_StatusGenerator()
var loadBalancerSku_statusGenerator gopter.Gen

// LoadBalancerSku_StatusGenerator returns a generator of LoadBalancerSku_Status instances for property testing.
func LoadBalancerSku_StatusGenerator() gopter.Gen {
	if loadBalancerSku_statusGenerator != nil {
		return loadBalancerSku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_Status(generators)
	loadBalancerSku_statusGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_Status{}), generators)

	return loadBalancerSku_statusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_StatusBasic, LoadBalancerSku_Name_StatusStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_StatusGlobal, LoadBalancerSku_Tier_StatusRegional))
}

func Test_LoadBalancingRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule_Spec to LoadBalancingRule_Spec via AssignPropertiesToLoadBalancingRule_Spec & AssignPropertiesFromLoadBalancingRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRule_Spec, LoadBalancingRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRule_Spec tests if a specific instance of LoadBalancingRule_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRule_Spec(subject LoadBalancingRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancingRule_Spec
	err := copied.AssignPropertiesToLoadBalancingRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule_Spec
	err = actual.AssignPropertiesFromLoadBalancingRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_Spec, LoadBalancingRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_Spec runs a test to see if a specific instance of LoadBalancingRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_Spec(subject LoadBalancingRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_Spec instances for property testing - lazily instantiated by
//LoadBalancingRule_SpecGenerator()
var loadBalancingRule_specGenerator gopter.Gen

// LoadBalancingRule_SpecGenerator returns a generator of LoadBalancingRule_Spec instances for property testing.
// We first initialize loadBalancingRule_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_SpecGenerator() gopter.Gen {
	if loadBalancingRule_specGenerator != nil {
		return loadBalancingRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_Spec(generators)
	loadBalancingRule_specGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_Spec(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_Spec(generators)
	loadBalancingRule_specGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Spec{}), generators)

	return loadBalancingRule_specGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_Spec(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_SpecDefault, LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_SpecAll, TransportProtocol_SpecTcp, TransportProtocol_SpecUdp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_Spec(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_LoadBalancingRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingRule_Status to LoadBalancingRule_Status via AssignPropertiesToLoadBalancingRule_Status & AssignPropertiesFromLoadBalancingRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingRule_Status, LoadBalancingRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingRule_Status tests if a specific instance of LoadBalancingRule_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingRule_Status(subject LoadBalancingRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.LoadBalancingRule_Status
	err := copied.AssignPropertiesToLoadBalancingRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingRule_Status
	err = actual.AssignPropertiesFromLoadBalancingRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_Status, LoadBalancingRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_Status runs a test to see if a specific instance of LoadBalancingRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_Status(subject LoadBalancingRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_Status instances for property testing - lazily instantiated by
//LoadBalancingRule_StatusGenerator()
var loadBalancingRule_statusGenerator gopter.Gen

// LoadBalancingRule_StatusGenerator returns a generator of LoadBalancingRule_Status instances for property testing.
// We first initialize loadBalancingRule_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_StatusGenerator() gopter.Gen {
	if loadBalancingRule_statusGenerator != nil {
		return loadBalancingRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_Status(generators)
	loadBalancingRule_statusGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_Status(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_Status(generators)
	loadBalancingRule_statusGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_Status{}), generators)

	return loadBalancingRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_Status(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_StatusDefault, LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIPProtocol))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_Status(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_OutboundRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_Spec to OutboundRule_Spec via AssignPropertiesToOutboundRule_Spec & AssignPropertiesFromOutboundRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule_Spec, OutboundRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule_Spec tests if a specific instance of OutboundRule_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule_Spec(subject OutboundRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.OutboundRule_Spec
	err := copied.AssignPropertiesToOutboundRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_Spec
	err = actual.AssignPropertiesFromOutboundRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_Spec, OutboundRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_Spec runs a test to see if a specific instance of OutboundRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_Spec(subject OutboundRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_Spec instances for property testing - lazily instantiated by OutboundRule_SpecGenerator()
var outboundRule_specGenerator gopter.Gen

// OutboundRule_SpecGenerator returns a generator of OutboundRule_Spec instances for property testing.
// We first initialize outboundRule_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_SpecGenerator() gopter.Gen {
	if outboundRule_specGenerator != nil {
		return outboundRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_Spec(generators)
	outboundRule_specGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_Spec(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_Spec(generators)
	outboundRule_specGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Spec{}), generators)

	return outboundRule_specGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_Spec(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_SpecAll, OutboundRulePropertiesFormat_Protocol_SpecTcp, OutboundRulePropertiesFormat_Protocol_SpecUdp))
}

// AddRelatedPropertyGeneratorsForOutboundRule_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_Spec(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_SpecGenerator())
}

func Test_OutboundRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OutboundRule_Status to OutboundRule_Status via AssignPropertiesToOutboundRule_Status & AssignPropertiesFromOutboundRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForOutboundRule_Status, OutboundRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOutboundRule_Status tests if a specific instance of OutboundRule_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForOutboundRule_Status(subject OutboundRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.OutboundRule_Status
	err := copied.AssignPropertiesToOutboundRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OutboundRule_Status
	err = actual.AssignPropertiesFromOutboundRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OutboundRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_Status, OutboundRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_Status runs a test to see if a specific instance of OutboundRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_Status(subject OutboundRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_Status instances for property testing - lazily instantiated by
//OutboundRule_StatusGenerator()
var outboundRule_statusGenerator gopter.Gen

// OutboundRule_StatusGenerator returns a generator of OutboundRule_Status instances for property testing.
// We first initialize outboundRule_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_StatusGenerator() gopter.Gen {
	if outboundRule_statusGenerator != nil {
		return outboundRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_Status(generators)
	outboundRule_statusGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_Status(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_Status(generators)
	outboundRule_statusGenerator = gen.Struct(reflect.TypeOf(OutboundRule_Status{}), generators)

	return outboundRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_Status(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_StatusAll, OutboundRulePropertiesFormat_Protocol_StatusTcp, OutboundRulePropertiesFormat_Protocol_StatusUdp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_Status(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_StatusGenerator())
}

func Test_Probe_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe_Spec to Probe_Spec via AssignPropertiesToProbe_Spec & AssignPropertiesFromProbe_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbe_Spec, Probe_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbe_Spec tests if a specific instance of Probe_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbe_Spec(subject Probe_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Probe_Spec
	err := copied.AssignPropertiesToProbe_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe_Spec
	err = actual.AssignPropertiesFromProbe_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_Spec, Probe_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_Spec runs a test to see if a specific instance of Probe_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_Spec(subject Probe_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_Spec instances for property testing - lazily instantiated by Probe_SpecGenerator()
var probe_specGenerator gopter.Gen

// Probe_SpecGenerator returns a generator of Probe_Spec instances for property testing.
func Probe_SpecGenerator() gopter.Gen {
	if probe_specGenerator != nil {
		return probe_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_Spec(generators)
	probe_specGenerator = gen.Struct(reflect.TypeOf(Probe_Spec{}), generators)

	return probe_specGenerator
}

// AddIndependentPropertyGeneratorsForProbe_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_Spec(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_SpecHttp, ProbePropertiesFormat_Protocol_SpecHttps, ProbePropertiesFormat_Protocol_SpecTcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_Probe_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Probe_Status to Probe_Status via AssignPropertiesToProbe_Status & AssignPropertiesFromProbe_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForProbe_Status, Probe_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProbe_Status tests if a specific instance of Probe_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForProbe_Status(subject Probe_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Probe_Status
	err := copied.AssignPropertiesToProbe_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Probe_Status
	err = actual.AssignPropertiesFromProbe_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Probe_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_Status, Probe_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_Status runs a test to see if a specific instance of Probe_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_Status(subject Probe_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_Status instances for property testing - lazily instantiated by Probe_StatusGenerator()
var probe_statusGenerator gopter.Gen

// Probe_StatusGenerator returns a generator of Probe_Status instances for property testing.
// We first initialize probe_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_StatusGenerator() gopter.Gen {
	if probe_statusGenerator != nil {
		return probe_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_Status(generators)
	probe_statusGenerator = gen.Struct(reflect.TypeOf(Probe_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_Status(generators)
	AddRelatedPropertyGeneratorsForProbe_Status(generators)
	probe_statusGenerator = gen.Struct(reflect.TypeOf(Probe_Status{}), generators)

	return probe_statusGenerator
}

// AddIndependentPropertyGeneratorsForProbe_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_Status(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_StatusHttp, ProbePropertiesFormat_Protocol_StatusHttps, ProbePropertiesFormat_Protocol_StatusTcp))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_Status(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_StatusGenerator())
}

func Test_PublicIPAddress_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_Spec to PublicIPAddress_Spec via AssignPropertiesToPublicIPAddress_Spec & AssignPropertiesFromPublicIPAddress_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddress_Spec, PublicIPAddress_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddress_Spec tests if a specific instance of PublicIPAddress_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddress_Spec(subject PublicIPAddress_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PublicIPAddress_Spec
	err := copied.AssignPropertiesToPublicIPAddress_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_Spec
	err = actual.AssignPropertiesFromPublicIPAddress_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Spec, PublicIPAddress_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Spec runs a test to see if a specific instance of PublicIPAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Spec(subject PublicIPAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Spec instances for property testing - lazily instantiated by
//PublicIPAddress_SpecGenerator()
var publicIPAddress_specGenerator gopter.Gen

// PublicIPAddress_SpecGenerator returns a generator of PublicIPAddress_Spec instances for property testing.
// We first initialize publicIPAddress_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_SpecGenerator() gopter.Gen {
	if publicIPAddress_specGenerator != nil {
		return publicIPAddress_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Spec(generators)
	publicIPAddress_specGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Spec(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Spec(generators)
	publicIPAddress_specGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec{}), generators)

	return publicIPAddress_specGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Spec(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecAbort,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommit,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommitted,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecNone,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecPrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Spec(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_SpecGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_SpecGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_SpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_SpecGenerator())
}

func Test_PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded to PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded, PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded tests if a specific instance of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(subject PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded, PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(subject PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily
//instantiated by PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator()
var publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
// We first initialize publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator != nil {
		return publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(generators)
	publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(generators)
	publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return publicIPAddress_status_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_StatusGenerator())
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Spec_LoadBalancer_SubResourceEmbedded to Subnet_Spec_LoadBalancer_SubResourceEmbedded via AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded, Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded tests if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded(subject Subnet_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Spec_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded, Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of Subnet_Spec_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Spec_LoadBalancer_SubResourceEmbedded(subject Subnet_Spec_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_LoadBalancer_SubResourceEmbedded instances for property testing - lazily instantiated by
//Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator()
var subnet_spec_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of Subnet_Spec_LoadBalancer_SubResourceEmbedded instances for property testing.
func Subnet_Spec_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_spec_loadBalancer_subResourceEmbeddedGenerator != nil {
		return subnet_spec_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	subnet_spec_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_LoadBalancer_SubResourceEmbedded{}), generators)

	return subnet_spec_loadBalancer_subResourceEmbeddedGenerator
}

func Test_Subnet_Status_LoadBalancer_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Status_LoadBalancer_SubResourceEmbedded to Subnet_Status_LoadBalancer_SubResourceEmbedded via AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded & AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnet_Status_LoadBalancer_SubResourceEmbedded, Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnet_Status_LoadBalancer_SubResourceEmbedded tests if a specific instance of Subnet_Status_LoadBalancer_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnet_Status_LoadBalancer_SubResourceEmbedded(subject Subnet_Status_LoadBalancer_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Status_LoadBalancer_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Status_LoadBalancer_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_LoadBalancer_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbedded, Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbedded runs a test to see if a specific instance of Subnet_Status_LoadBalancer_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbedded(subject Subnet_Status_LoadBalancer_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_LoadBalancer_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_LoadBalancer_SubResourceEmbedded instances for property testing - lazily instantiated by
//Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator()
var subnet_status_loadBalancer_subResourceEmbeddedGenerator gopter.Gen

// Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator returns a generator of Subnet_Status_LoadBalancer_SubResourceEmbedded instances for property testing.
func Subnet_Status_LoadBalancer_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_status_loadBalancer_subResourceEmbeddedGenerator != nil {
		return subnet_status_loadBalancer_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbedded(generators)
	subnet_status_loadBalancer_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_LoadBalancer_SubResourceEmbedded{}), generators)

	return subnet_status_loadBalancer_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
