// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddress_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_SpecARM, PublicIPAddress_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_SpecARM runs a test to see if a specific instance of PublicIPAddress_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_SpecARM(subject PublicIPAddress_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_SpecARM instances for property testing - lazily instantiated by
// PublicIPAddress_SpecARMGenerator()
var publicIPAddress_SpecARMGenerator gopter.Gen

// PublicIPAddress_SpecARMGenerator returns a generator of PublicIPAddress_SpecARM instances for property testing.
// We first initialize publicIPAddress_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_SpecARMGenerator() gopter.Gen {
	if publicIPAddress_SpecARMGenerator != nil {
		return publicIPAddress_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_SpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(generators)
	publicIPAddress_SpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_SpecARM{}), generators)

	return publicIPAddress_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM, PublicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(subject PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator()
var publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressPropertiesFormat_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed,
		PublicIPAddressPropertiesFormat_MigrationPhase_None,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_SubResourceEmbeddedARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpec_SubResourceEmbeddedARMGenerator())
}

func Test_PublicIPAddressSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuARM, PublicIPAddressSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuARM runs a test to see if a specific instance of PublicIPAddressSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuARM(subject PublicIPAddressSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSkuARM instances for property testing - lazily instantiated by
// PublicIPAddressSkuARMGenerator()
var publicIPAddressSkuARMGenerator gopter.Gen

// PublicIPAddressSkuARMGenerator returns a generator of PublicIPAddressSkuARM instances for property testing.
func PublicIPAddressSkuARMGenerator() gopter.Gen {
	if publicIPAddressSkuARMGenerator != nil {
		return publicIPAddressSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(generators)
	publicIPAddressSkuARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSkuARM{}), generators)

	return publicIPAddressSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Name_Basic, PublicIPAddressSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Tier_Global, PublicIPAddressSku_Tier_Regional))
}

func Test_DdosSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDdosSettingsARM, DdosSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettingsARM runs a test to see if a specific instance of DdosSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettingsARM(subject DdosSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettingsARM instances for property testing - lazily instantiated by DdosSettingsARMGenerator()
var ddosSettingsARMGenerator gopter.Gen

// DdosSettingsARMGenerator returns a generator of DdosSettingsARM instances for property testing.
// We first initialize ddosSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettingsARMGenerator() gopter.Gen {
	if ddosSettingsARMGenerator != nil {
		return ddosSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsARM(generators)
	ddosSettingsARMGenerator = gen.Struct(reflect.TypeOf(DdosSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettingsARM(generators)
	ddosSettingsARMGenerator = gen.Struct(reflect.TypeOf(DdosSettingsARM{}), generators)

	return ddosSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettingsARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettings_ProtectionCoverage_Basic, DdosSettings_ProtectionCoverage_Standard))
}

// AddRelatedPropertyGeneratorsForDdosSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettingsARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_IpTagARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTagARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpTagARM, IpTagARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTagARM runs a test to see if a specific instance of IpTagARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTagARM(subject IpTagARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTagARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpTagARM instances for property testing - lazily instantiated by IpTagARMGenerator()
var ipTagARMGenerator gopter.Gen

// IpTagARMGenerator returns a generator of IpTagARM instances for property testing.
func IpTagARMGenerator() gopter.Gen {
	if ipTagARMGenerator != nil {
		return ipTagARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTagARM(generators)
	ipTagARMGenerator = gen.Struct(reflect.TypeOf(IpTagARM{}), generators)

	return ipTagARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTagARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTagARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGatewaySpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySpecARM, NatGatewaySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySpecARM runs a test to see if a specific instance of NatGatewaySpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySpecARM(subject NatGatewaySpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySpecARM instances for property testing - lazily instantiated by NatGatewaySpecARMGenerator()
var natGatewaySpecARMGenerator gopter.Gen

// NatGatewaySpecARMGenerator returns a generator of NatGatewaySpecARM instances for property testing.
// We first initialize natGatewaySpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewaySpecARMGenerator() gopter.Gen {
	if natGatewaySpecARMGenerator != nil {
		return natGatewaySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpecARM(generators)
	natGatewaySpecARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpecARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewaySpecARM(generators)
	natGatewaySpecARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySpecARM{}), generators)

	return natGatewaySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGatewaySpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewaySpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NatGatewayPropertiesFormatARMGenerator())
	gens["Sku"] = gen.PtrOf(NatGatewaySkuARMGenerator())
}

func Test_PublicIPAddressDnsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettingsARM, PublicIPAddressDnsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettingsARM runs a test to see if a specific instance of PublicIPAddressDnsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettingsARM(subject PublicIPAddressDnsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettingsARM instances for property testing - lazily instantiated by
// PublicIPAddressDnsSettingsARMGenerator()
var publicIPAddressDnsSettingsARMGenerator gopter.Gen

// PublicIPAddressDnsSettingsARMGenerator returns a generator of PublicIPAddressDnsSettingsARM instances for property testing.
func PublicIPAddressDnsSettingsARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettingsARMGenerator != nil {
		return publicIPAddressDnsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM(generators)
	publicIPAddressDnsSettingsARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettingsARM{}), generators)

	return publicIPAddressDnsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressSpec_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpec_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpec_SubResourceEmbeddedARM, PublicIPAddressSpec_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpec_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressSpec_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpec_SubResourceEmbeddedARM(subject PublicIPAddressSpec_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpec_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpec_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
// PublicIPAddressSpec_SubResourceEmbeddedARMGenerator()
var publicIPAddressSpec_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSpec_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressSpec_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSpec_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpec_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSpec_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSpec_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM(generators)
	publicIPAddressSpec_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpec_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSpec_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_SubResourceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResourceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceARM, SubResourceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceARM runs a test to see if a specific instance of SubResourceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceARM(subject SubResourceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResourceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResourceARM instances for property testing - lazily instantiated by SubResourceARMGenerator()
var subResourceARMGenerator gopter.Gen

// SubResourceARMGenerator returns a generator of SubResourceARM instances for property testing.
func SubResourceARMGenerator() gopter.Gen {
	if subResourceARMGenerator != nil {
		return subResourceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResourceARM(generators)
	subResourceARMGenerator = gen.Struct(reflect.TypeOf(SubResourceARM{}), generators)

	return subResourceARMGenerator
}

// AddIndependentPropertyGeneratorsForSubResourceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResourceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGatewayPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewayPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewayPropertiesFormatARM, NatGatewayPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewayPropertiesFormatARM runs a test to see if a specific instance of NatGatewayPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewayPropertiesFormatARM(subject NatGatewayPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewayPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewayPropertiesFormatARM instances for property testing - lazily instantiated by
// NatGatewayPropertiesFormatARMGenerator()
var natGatewayPropertiesFormatARMGenerator gopter.Gen

// NatGatewayPropertiesFormatARMGenerator returns a generator of NatGatewayPropertiesFormatARM instances for property testing.
// We first initialize natGatewayPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewayPropertiesFormatARMGenerator() gopter.Gen {
	if natGatewayPropertiesFormatARMGenerator != nil {
		return natGatewayPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatARM(generators)
	natGatewayPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatARM(generators)
	natGatewayPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormatARM{}), generators)

	return natGatewayPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PublicIpAddresses"] = gen.SliceOf(SubResourceARMGenerator())
	gens["PublicIpPrefixes"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_NatGatewaySkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySkuARM, NatGatewaySkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySkuARM runs a test to see if a specific instance of NatGatewaySkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySkuARM(subject NatGatewaySkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySkuARM instances for property testing - lazily instantiated by NatGatewaySkuARMGenerator()
var natGatewaySkuARMGenerator gopter.Gen

// NatGatewaySkuARMGenerator returns a generator of NatGatewaySkuARM instances for property testing.
func NatGatewaySkuARMGenerator() gopter.Gen {
	if natGatewaySkuARMGenerator != nil {
		return natGatewaySkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySkuARM(generators)
	natGatewaySkuARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySkuARM{}), generators)

	return natGatewaySkuARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySku_Name_Standard))
}
