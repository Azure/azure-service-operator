// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterface to hub returns original",
		prop.ForAll(RunResourceConversionTestForNetworkInterface, NetworkInterfaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForNetworkInterface tests if a specific instance of NetworkInterface round trips to the hub storage version and back losslessly
func RunResourceConversionTestForNetworkInterface(subject NetworkInterface) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201101storage.NetworkInterface
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual NetworkInterface
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterface_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterface to NetworkInterface via AssignPropertiesToNetworkInterface & AssignPropertiesFromNetworkInterface returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterface, NetworkInterfaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterface tests if a specific instance of NetworkInterface can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterface(subject NetworkInterface) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterface
	err := copied.AssignPropertiesToNetworkInterface(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterface
	err = actual.AssignPropertiesFromNetworkInterface(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterface_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface, NetworkInterfaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface runs a test to see if a specific instance of NetworkInterface round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface(subject NetworkInterface) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface instances for property testing - lazily instantiated by NetworkInterfaceGenerator()
var networkInterfaceGenerator gopter.Gen

// NetworkInterfaceGenerator returns a generator of NetworkInterface instances for property testing.
func NetworkInterfaceGenerator() gopter.Gen {
	if networkInterfaceGenerator != nil {
		return networkInterfaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkInterface(generators)
	networkInterfaceGenerator = gen.Struct(reflect.TypeOf(NetworkInterface{}), generators)

	return networkInterfaceGenerator
}

// AddRelatedPropertyGeneratorsForNetworkInterface is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface(gens map[string]gopter.Gen) {
	gens["Spec"] = NetworkInterfacesSPECGenerator()
	gens["Status"] = NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator()
}

func Test_NetworkInterface_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterface_Status_NetworkInterface_SubResourceEmbedded to NetworkInterface_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterface_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["HostedWorkloads"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MacAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		NetworkInterfacePropertiesFormatStatusMigrationPhaseAbort,
		NetworkInterfacePropertiesFormatStatusMigrationPhaseCommit,
		NetworkInterfacePropertiesFormatStatusMigrationPhaseCommitted,
		NetworkInterfacePropertiesFormatStatusMigrationPhaseNone,
		NetworkInterfacePropertiesFormatStatusMigrationPhasePrepare))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NicType"] = gen.PtrOf(gen.OneConstOf(NetworkInterfacePropertiesFormatStatusNicTypeElastic, NetworkInterfacePropertiesFormatStatusNicTypeStandard))
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettingsStatusGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["TapConfigurations"] = gen.SliceOf(NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["VirtualMachine"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_NetworkInterfaces_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaces_SPEC to NetworkInterfaces_SPEC via AssignPropertiesToNetworkInterfacesSPEC & AssignPropertiesFromNetworkInterfacesSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfacesSPEC, NetworkInterfacesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfacesSPEC tests if a specific instance of NetworkInterfaces_SPEC can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfacesSPEC(subject NetworkInterfaces_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaces_SPEC
	err := copied.AssignPropertiesToNetworkInterfacesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaces_SPEC
	err = actual.AssignPropertiesFromNetworkInterfacesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaces_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaces_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfacesSPEC, NetworkInterfacesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfacesSPEC runs a test to see if a specific instance of NetworkInterfaces_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfacesSPEC(subject NetworkInterfaces_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaces_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaces_SPEC instances for property testing - lazily instantiated by
//NetworkInterfacesSPECGenerator()
var networkInterfacesSPECGenerator gopter.Gen

// NetworkInterfacesSPECGenerator returns a generator of NetworkInterfaces_SPEC instances for property testing.
// We first initialize networkInterfacesSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfacesSPECGenerator() gopter.Gen {
	if networkInterfacesSPECGenerator != nil {
		return networkInterfacesSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacesSPEC(generators)
	networkInterfacesSPECGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaces_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfacesSPEC(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfacesSPEC(generators)
	networkInterfacesSPECGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaces_SPEC{}), generators)

	return networkInterfacesSPECGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfacesSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfacesSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		NetworkInterfacePropertiesFormatSpecMigrationPhaseAbort,
		NetworkInterfacePropertiesFormatSpecMigrationPhaseCommit,
		NetworkInterfacePropertiesFormatSpecMigrationPhaseCommitted,
		NetworkInterfacePropertiesFormatSpecMigrationPhaseNone,
		NetworkInterfacePropertiesFormatSpecMigrationPhasePrepare))
	gens["NicType"] = gen.PtrOf(gen.OneConstOf(NetworkInterfacePropertiesFormatSpecNicTypeElastic, NetworkInterfacePropertiesFormatSpecNicTypeStandard))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfacesSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfacesSPEC(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettingsSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceSpecGenerator())
}

func Test_NetworkInterfaceDnsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceDnsSettings_Spec to NetworkInterfaceDnsSettings_Spec via AssignPropertiesToNetworkInterfaceDnsSettingsSpec & AssignPropertiesFromNetworkInterfaceDnsSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsSpec, NetworkInterfaceDnsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsSpec tests if a specific instance of NetworkInterfaceDnsSettings_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsSpec(subject NetworkInterfaceDnsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Spec
	err := copied.AssignPropertiesToNetworkInterfaceDnsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceDnsSettings_Spec
	err = actual.AssignPropertiesFromNetworkInterfaceDnsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceDnsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettingsSpec, NetworkInterfaceDnsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettingsSpec runs a test to see if a specific instance of NetworkInterfaceDnsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettingsSpec(subject NetworkInterfaceDnsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettingsSpecGenerator()
var networkInterfaceDnsSettingsSpecGenerator gopter.Gen

// NetworkInterfaceDnsSettingsSpecGenerator returns a generator of NetworkInterfaceDnsSettings_Spec instances for property testing.
func NetworkInterfaceDnsSettingsSpecGenerator() gopter.Gen {
	if networkInterfaceDnsSettingsSpecGenerator != nil {
		return networkInterfaceDnsSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsSpec(generators)
	networkInterfaceDnsSettingsSpecGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_Spec{}), generators)

	return networkInterfaceDnsSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsSpec(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceDnsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceDnsSettings_Status to NetworkInterfaceDnsSettings_Status via AssignPropertiesToNetworkInterfaceDnsSettingsStatus & AssignPropertiesFromNetworkInterfaceDnsSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsStatus, NetworkInterfaceDnsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsStatus tests if a specific instance of NetworkInterfaceDnsSettings_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceDnsSettingsStatus(subject NetworkInterfaceDnsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Status
	err := copied.AssignPropertiesToNetworkInterfaceDnsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceDnsSettings_Status
	err = actual.AssignPropertiesFromNetworkInterfaceDnsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettingsStatus, NetworkInterfaceDnsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettingsStatus runs a test to see if a specific instance of NetworkInterfaceDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettingsStatus(subject NetworkInterfaceDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_Status instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettingsStatusGenerator()
var networkInterfaceDnsSettingsStatusGenerator gopter.Gen

// NetworkInterfaceDnsSettingsStatusGenerator returns a generator of NetworkInterfaceDnsSettings_Status instances for property testing.
func NetworkInterfaceDnsSettingsStatusGenerator() gopter.Gen {
	if networkInterfaceDnsSettingsStatusGenerator != nil {
		return networkInterfaceDnsSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsStatus(generators)
	networkInterfaceDnsSettingsStatusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_Status{}), generators)

	return networkInterfaceDnsSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettingsStatus(gens map[string]gopter.Gen) {
	gens["AppliedDnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["InternalDomainNameSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["InternalFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded to NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded, NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded, NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing
//- lazily instantiated by NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPoolSpecGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroupSpecGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded to NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_StatusIPv4, IPVersion_StatusIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_StatusDynamic, IPAllocationMethod_StatusStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfigurationStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["PrivateLinkConnectionProperties"] = gen.PtrOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded to NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded, NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(subject NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var networkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfigurationStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded to NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded, NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(subject NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded, NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(subject NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(generators)
	networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(generators)
	networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkSecurityGroupSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroupSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SecurityRules"] = gen.SliceOf(SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded to NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded, NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(subject NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded, NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(subject NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var networkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if networkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return networkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(generators)
	networkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded to PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded, PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(subject PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded, PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(subject PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(generators)
	privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(generators)
	privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateEndpointStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
}

func Test_PrivateLinkService_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkService_Spec to PrivateLinkService_Spec via AssignPropertiesToPrivateLinkServiceSpec & AssignPropertiesFromPrivateLinkServiceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceSpec, PrivateLinkServiceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceSpec tests if a specific instance of PrivateLinkService_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceSpec(subject PrivateLinkService_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PrivateLinkService_Spec
	err := copied.AssignPropertiesToPrivateLinkServiceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkService_Spec
	err = actual.AssignPropertiesFromPrivateLinkServiceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkService_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceSpec, PrivateLinkServiceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceSpec runs a test to see if a specific instance of PrivateLinkService_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceSpec(subject PrivateLinkService_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Spec instances for property testing - lazily instantiated by
//PrivateLinkServiceSpecGenerator()
var privateLinkServiceSpecGenerator gopter.Gen

// PrivateLinkServiceSpecGenerator returns a generator of PrivateLinkService_Spec instances for property testing.
// We first initialize privateLinkServiceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceSpecGenerator() gopter.Gen {
	if privateLinkServiceSpecGenerator != nil {
		return privateLinkServiceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	privateLinkServiceSpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	privateLinkServiceSpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	return privateLinkServiceSpecGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSetSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSetSpecGenerator())
}

func Test_PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded to PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded, PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(subject PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded, PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(subject PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(generators)
	privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(generators)
	privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateLinkServiceStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
}

func Test_SubResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_Status to SubResource_Status via AssignPropertiesToSubResourceStatus & AssignPropertiesFromSubResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResourceStatus, SubResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResourceStatus tests if a specific instance of SubResource_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubResourceStatus(subject SubResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.SubResource_Status
	err := copied.AssignPropertiesToSubResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_Status
	err = actual.AssignPropertiesFromSubResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceStatus, SubResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceStatus runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceStatus(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResourceStatusGenerator()
var subResourceStatusGenerator gopter.Gen

// SubResourceStatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResourceStatusGenerator() gopter.Gen {
	if subResourceStatusGenerator != nil {
		return subResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResourceStatus(generators)
	subResourceStatusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForSubResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResourceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddressPool_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationGatewayBackendAddressPool_Spec to ApplicationGatewayBackendAddressPool_Spec via AssignPropertiesToApplicationGatewayBackendAddressPoolSpec & AssignPropertiesFromApplicationGatewayBackendAddressPoolSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolSpec, ApplicationGatewayBackendAddressPoolSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolSpec tests if a specific instance of ApplicationGatewayBackendAddressPool_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolSpec(subject ApplicationGatewayBackendAddressPool_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Spec
	err := copied.AssignPropertiesToApplicationGatewayBackendAddressPoolSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationGatewayBackendAddressPool_Spec
	err = actual.AssignPropertiesFromApplicationGatewayBackendAddressPoolSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationGatewayBackendAddressPool_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPoolSpec, ApplicationGatewayBackendAddressPoolSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPoolSpec runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPoolSpec(subject ApplicationGatewayBackendAddressPool_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_Spec instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddressPoolSpecGenerator()
var applicationGatewayBackendAddressPoolSpecGenerator gopter.Gen

// ApplicationGatewayBackendAddressPoolSpecGenerator returns a generator of ApplicationGatewayBackendAddressPool_Spec instances for property testing.
// We first initialize applicationGatewayBackendAddressPoolSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPoolSpecGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPoolSpecGenerator != nil {
		return applicationGatewayBackendAddressPoolSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec(generators)
	applicationGatewayBackendAddressPoolSpecGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec(generators)
	applicationGatewayBackendAddressPoolSpecGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Spec{}), generators)

	return applicationGatewayBackendAddressPoolSpecGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolSpec(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddressSpecGenerator())
}

func Test_ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded to ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded, ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(subject ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded, ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(subject ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(generators)
	applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(generators)
	applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddressStatusGenerator())
}

func Test_ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded to ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded, ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(subject ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded, ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(subject ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing -
//lazily instantiated by ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var applicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func ApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if applicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return applicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(generators)
	applicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationSecurityGroupStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationSecurityGroupStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded to BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded, BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded(subject BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded, BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolSpecNetworkInterfaceSubResourceEmbedded(subject BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var backendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func BackendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return backendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	backendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return backendAddressPoolSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

func Test_BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded to BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded, BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(subject BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded, BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(subject BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var backendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func BackendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return backendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(generators)
	backendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return backendAddressPoolStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded to FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded, FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded, FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing -
//lazily instantiated by FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return frontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded to InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded, InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded(subject InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded, InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleSpecNetworkInterfaceSubResourceEmbedded(subject InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var inboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func InboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return inboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	inboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return inboundNatRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

func Test_InboundNatRule_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InboundNatRule_Status_NetworkInterface_SubResourceEmbedded to InboundNatRule_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded, InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(subject InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InboundNatRule_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded, InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(subject InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var inboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func InboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return inboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(generators)
	inboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return inboundNatRuleStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRuleStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status to NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status via AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus & AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus, NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus tests if a specific instance of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(subject NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
	err := copied.AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
	err = actual.AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus, NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus runs a test to see if a specific instance of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(subject NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing -
//lazily instantiated by NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator()
var networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator gopter.Gen

// NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator returns a generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing.
func NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator != nil {
		return networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(generators)
	networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status{}), generators)

	return networkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesStatus(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMemberName"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded to PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded, PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded, PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(subject PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(generators)
	privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfigurationSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded to PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded, PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(subject PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded, PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(subject PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(generators)
	publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(generators)
	publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return publicIPAddressStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuStatusGenerator())
}

func Test_ResourceSet_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSet_Spec to ResourceSet_Spec via AssignPropertiesToResourceSetSpec & AssignPropertiesFromResourceSetSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSetSpec, ResourceSetSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSetSpec tests if a specific instance of ResourceSet_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForResourceSetSpec(subject ResourceSet_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ResourceSet_Spec
	err := copied.AssignPropertiesToResourceSetSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSet_Spec
	err = actual.AssignPropertiesFromResourceSetSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSetSpec, ResourceSetSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSetSpec runs a test to see if a specific instance of ResourceSet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSetSpec(subject ResourceSet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSet_Spec instances for property testing - lazily instantiated by ResourceSetSpecGenerator()
var resourceSetSpecGenerator gopter.Gen

// ResourceSetSpecGenerator returns a generator of ResourceSet_Spec instances for property testing.
func ResourceSetSpecGenerator() gopter.Gen {
	if resourceSetSpecGenerator != nil {
		return resourceSetSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSetSpec(generators)
	resourceSetSpecGenerator = gen.Struct(reflect.TypeOf(ResourceSet_Spec{}), generators)

	return resourceSetSpecGenerator
}

// AddIndependentPropertyGeneratorsForResourceSetSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSetSpec(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_SecurityRule_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityRule_Spec_NetworkInterface_SubResourceEmbedded to SecurityRule_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToSecurityRuleSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromSecurityRuleSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded, SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded(subject SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToSecurityRuleSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromSecurityRuleSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityRule_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded, SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityRuleSpecNetworkInterfaceSubResourceEmbedded(subject SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var securityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func SecurityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if securityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return securityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	securityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SecurityRule_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return securityRuleSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

func Test_Subnet_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Spec_NetworkInterface_SubResourceEmbedded to Subnet_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToSubnetSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromSubnetSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnetSpecNetworkInterfaceSubResourceEmbedded, SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnetSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of Subnet_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnetSpecNetworkInterfaceSubResourceEmbedded(subject Subnet_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnetSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnetSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetSpecNetworkInterfaceSubResourceEmbedded, SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of Subnet_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSpecNetworkInterfaceSubResourceEmbedded(subject Subnet_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily instantiated by
//SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var subnetSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of Subnet_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func SubnetSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if subnetSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return subnetSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	subnetSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return subnetSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

func Test_Subnet_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Subnet_Status_NetworkInterface_SubResourceEmbedded to Subnet_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToSubnetStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromSubnetStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubnetStatusNetworkInterfaceSubResourceEmbedded, SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubnetStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of Subnet_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForSubnetStatusNetworkInterfaceSubResourceEmbedded(subject Subnet_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.Subnet_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToSubnetStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Subnet_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromSubnetStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Subnet_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetStatusNetworkInterfaceSubResourceEmbedded, SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of Subnet_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetStatusNetworkInterfaceSubResourceEmbedded(subject Subnet_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily instantiated
//by SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var subnetStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func SubnetStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if subnetStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return subnetStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetStatusNetworkInterfaceSubResourceEmbedded(generators)
	subnetStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return subnetStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnetStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded to VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded via AssignPropertiesToVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded, VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded tests if a specific instance of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(subject VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded, VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(subject VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator()
var virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(generators)
	virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(generators)
	virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return virtualNetworkTapSpecNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DestinationPort"] = gen.PtrOf(gen.Int())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTapSpecNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DestinationLoadBalancerFrontEndIPConfiguration"] = gen.PtrOf(FrontendIPConfigurationSpecNetworkInterfaceSubResourceEmbeddedGenerator())
}

func Test_VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded to VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded via AssignPropertiesToVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded & AssignPropertiesFromVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded, VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded tests if a specific instance of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(subject VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
	err := copied.AssignPropertiesToVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
	err = actual.AssignPropertiesFromVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded, VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded runs a test to see if a specific instance of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(subject VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator()
var virtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator gopter.Gen

// VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator returns a generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func VirtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator() gopter.Gen {
	if virtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator != nil {
		return virtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(generators)
	virtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return virtualNetworkTapStatusNetworkInterfaceSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTapStatusNetworkInterfaceSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddress_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationGatewayBackendAddress_Spec to ApplicationGatewayBackendAddress_Spec via AssignPropertiesToApplicationGatewayBackendAddressSpec & AssignPropertiesFromApplicationGatewayBackendAddressSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationGatewayBackendAddressSpec, ApplicationGatewayBackendAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationGatewayBackendAddressSpec tests if a specific instance of ApplicationGatewayBackendAddress_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForApplicationGatewayBackendAddressSpec(subject ApplicationGatewayBackendAddress_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Spec
	err := copied.AssignPropertiesToApplicationGatewayBackendAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationGatewayBackendAddress_Spec
	err = actual.AssignPropertiesFromApplicationGatewayBackendAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationGatewayBackendAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressSpec, ApplicationGatewayBackendAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressSpec runs a test to see if a specific instance of ApplicationGatewayBackendAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressSpec(subject ApplicationGatewayBackendAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_Spec instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddressSpecGenerator()
var applicationGatewayBackendAddressSpecGenerator gopter.Gen

// ApplicationGatewayBackendAddressSpecGenerator returns a generator of ApplicationGatewayBackendAddress_Spec instances for property testing.
func ApplicationGatewayBackendAddressSpecGenerator() gopter.Gen {
	if applicationGatewayBackendAddressSpecGenerator != nil {
		return applicationGatewayBackendAddressSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressSpec(generators)
	applicationGatewayBackendAddressSpecGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_Spec{}), generators)

	return applicationGatewayBackendAddressSpecGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressSpec(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddress_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationGatewayBackendAddress_Status to ApplicationGatewayBackendAddress_Status via AssignPropertiesToApplicationGatewayBackendAddressStatus & AssignPropertiesFromApplicationGatewayBackendAddressStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationGatewayBackendAddressStatus, ApplicationGatewayBackendAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationGatewayBackendAddressStatus tests if a specific instance of ApplicationGatewayBackendAddress_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForApplicationGatewayBackendAddressStatus(subject ApplicationGatewayBackendAddress_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status
	err := copied.AssignPropertiesToApplicationGatewayBackendAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationGatewayBackendAddress_Status
	err = actual.AssignPropertiesFromApplicationGatewayBackendAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationGatewayBackendAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressStatus, ApplicationGatewayBackendAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressStatus runs a test to see if a specific instance of ApplicationGatewayBackendAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressStatus(subject ApplicationGatewayBackendAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_Status instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddressStatusGenerator()
var applicationGatewayBackendAddressStatusGenerator gopter.Gen

// ApplicationGatewayBackendAddressStatusGenerator returns a generator of ApplicationGatewayBackendAddress_Status instances for property testing.
func ApplicationGatewayBackendAddressStatusGenerator() gopter.Gen {
	if applicationGatewayBackendAddressStatusGenerator != nil {
		return applicationGatewayBackendAddressStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressStatus(generators)
	applicationGatewayBackendAddressStatusGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_Status{}), generators)

	return applicationGatewayBackendAddressStatusGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressStatus(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}
