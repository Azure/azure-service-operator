// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_StatusARM, LoadBalancer_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_StatusARM runs a test to see if a specific instance of LoadBalancer_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_StatusARM(subject LoadBalancer_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_StatusARM instances for property testing - lazily instantiated by
//LoadBalancer_StatusARMGenerator()
var loadBalancer_statusARMGenerator gopter.Gen

// LoadBalancer_StatusARMGenerator returns a generator of LoadBalancer_StatusARM instances for property testing.
// We first initialize loadBalancer_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_StatusARMGenerator() gopter.Gen {
	if loadBalancer_statusARMGenerator != nil {
		return loadBalancer_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_StatusARM(generators)
	loadBalancer_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_StatusARM(generators)
	loadBalancer_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_StatusARM{}), generators)

	return loadBalancer_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_StatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_StatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormat_StatusARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_StatusARMGenerator())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_StatusARM, ExtendedLocation_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_StatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_StatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
//ExtendedLocation_StatusARMGenerator()
var extendedLocation_statusARMGenerator gopter.Gen

// ExtendedLocation_StatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocation_StatusARMGenerator() gopter.Gen {
	if extendedLocation_statusARMGenerator != nil {
		return extendedLocation_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(generators)
	extendedLocation_statusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocation_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.OneConstOf(ExtendedLocationType_StatusEdgeZone)
}

func Test_LoadBalancerPropertiesFormat_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormat_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormat_StatusARM, LoadBalancerPropertiesFormat_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormat_StatusARM runs a test to see if a specific instance of LoadBalancerPropertiesFormat_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormat_StatusARM(subject LoadBalancerPropertiesFormat_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormat_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormat_StatusARM instances for property testing - lazily instantiated by
//LoadBalancerPropertiesFormat_StatusARMGenerator()
var loadBalancerPropertiesFormat_statusARMGenerator gopter.Gen

// LoadBalancerPropertiesFormat_StatusARMGenerator returns a generator of LoadBalancerPropertiesFormat_StatusARM instances for property testing.
// We first initialize loadBalancerPropertiesFormat_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerPropertiesFormat_StatusARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormat_statusARMGenerator != nil {
		return loadBalancerPropertiesFormat_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM(generators)
	loadBalancerPropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM(generators)
	loadBalancerPropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormat_StatusARM{}), generators)

	return loadBalancerPropertiesFormat_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPool_StatusARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRule_StatusARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRule_StatusARMGenerator())
	gens["Probes"] = gen.SliceOf(Probe_StatusARMGenerator())
}

func Test_LoadBalancerSku_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_StatusARM, LoadBalancerSku_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_StatusARM runs a test to see if a specific instance of LoadBalancerSku_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_StatusARM(subject LoadBalancerSku_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_StatusARM instances for property testing - lazily instantiated by
//LoadBalancerSku_StatusARMGenerator()
var loadBalancerSku_statusARMGenerator gopter.Gen

// LoadBalancerSku_StatusARMGenerator returns a generator of LoadBalancerSku_StatusARM instances for property testing.
func LoadBalancerSku_StatusARMGenerator() gopter.Gen {
	if loadBalancerSku_statusARMGenerator != nil {
		return loadBalancerSku_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_StatusARM(generators)
	loadBalancerSku_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_StatusARM{}), generators)

	return loadBalancerSku_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_StatusBasic, LoadBalancerSku_Name_StatusStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_StatusGlobal, LoadBalancerSku_Tier_StatusRegional))
}

func Test_BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM, BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM(subject BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var backendAddressPool_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if backendAddressPool_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return backendAddressPool_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	backendAddressPool_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return backendAddressPool_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing -
//lazily instantiated by FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfiguration_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPool_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPool_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPool_StatusARM, InboundNatPool_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPool_StatusARM runs a test to see if a specific instance of InboundNatPool_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPool_StatusARM(subject InboundNatPool_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPool_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPool_StatusARM instances for property testing - lazily instantiated by
//InboundNatPool_StatusARMGenerator()
var inboundNatPool_statusARMGenerator gopter.Gen

// InboundNatPool_StatusARMGenerator returns a generator of InboundNatPool_StatusARM instances for property testing.
// We first initialize inboundNatPool_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPool_StatusARMGenerator() gopter.Gen {
	if inboundNatPool_statusARMGenerator != nil {
		return inboundNatPool_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_StatusARM(generators)
	inboundNatPool_statusARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPool_StatusARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPool_StatusARM(generators)
	inboundNatPool_statusARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPool_StatusARM{}), generators)

	return inboundNatPool_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPool_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPool_StatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPool_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPool_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormat_StatusARMGenerator())
}

func Test_InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM, InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM(subject InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var inboundNatRule_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if inboundNatRule_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return inboundNatRule_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	inboundNatRule_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return inboundNatRule_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRule_StatusARM, LoadBalancingRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRule_StatusARM runs a test to see if a specific instance of LoadBalancingRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRule_StatusARM(subject LoadBalancingRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRule_StatusARM instances for property testing - lazily instantiated by
//LoadBalancingRule_StatusARMGenerator()
var loadBalancingRule_statusARMGenerator gopter.Gen

// LoadBalancingRule_StatusARMGenerator returns a generator of LoadBalancingRule_StatusARM instances for property testing.
// We first initialize loadBalancingRule_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRule_StatusARMGenerator() gopter.Gen {
	if loadBalancingRule_statusARMGenerator != nil {
		return loadBalancingRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_StatusARM(generators)
	loadBalancingRule_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRule_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRule_StatusARM(generators)
	loadBalancingRule_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRule_StatusARM{}), generators)

	return loadBalancingRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRule_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormat_StatusARMGenerator())
}

func Test_OutboundRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRule_StatusARM, OutboundRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRule_StatusARM runs a test to see if a specific instance of OutboundRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRule_StatusARM(subject OutboundRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRule_StatusARM instances for property testing - lazily instantiated by
//OutboundRule_StatusARMGenerator()
var outboundRule_statusARMGenerator gopter.Gen

// OutboundRule_StatusARMGenerator returns a generator of OutboundRule_StatusARM instances for property testing.
// We first initialize outboundRule_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRule_StatusARMGenerator() gopter.Gen {
	if outboundRule_statusARMGenerator != nil {
		return outboundRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_StatusARM(generators)
	outboundRule_statusARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRule_StatusARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRule_StatusARM(generators)
	outboundRule_statusARMGenerator = gen.Struct(reflect.TypeOf(OutboundRule_StatusARM{}), generators)

	return outboundRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRule_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormat_StatusARMGenerator())
}

func Test_Probe_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Probe_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbe_StatusARM, Probe_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbe_StatusARM runs a test to see if a specific instance of Probe_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbe_StatusARM(subject Probe_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Probe_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Probe_StatusARM instances for property testing - lazily instantiated by Probe_StatusARMGenerator()
var probe_statusARMGenerator gopter.Gen

// Probe_StatusARMGenerator returns a generator of Probe_StatusARM instances for property testing.
// We first initialize probe_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Probe_StatusARMGenerator() gopter.Gen {
	if probe_statusARMGenerator != nil {
		return probe_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_StatusARM(generators)
	probe_statusARMGenerator = gen.Struct(reflect.TypeOf(Probe_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbe_StatusARM(generators)
	AddRelatedPropertyGeneratorsForProbe_StatusARM(generators)
	probe_statusARMGenerator = gen.Struct(reflect.TypeOf(Probe_StatusARM{}), generators)

	return probe_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForProbe_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbe_StatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbe_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbe_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormat_StatusARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM, FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(subject FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM instances for
//property testing - lazily instantiated by
//FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_StatusIPv4, IPVersion_StatusIPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_StatusDynamic, IPAllocationMethod_StatusStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["InboundNatPools"] = gen.SliceOf(SubResource_StatusARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(SubResource_StatusARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_StatusARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(SubResource_StatusARMGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Status_LoadBalancer_SubResourceEmbeddedARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormat_StatusARM, InboundNatPoolPropertiesFormat_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormat_StatusARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormat_StatusARM(subject InboundNatPoolPropertiesFormat_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_StatusARM instances for property testing - lazily instantiated by
//InboundNatPoolPropertiesFormat_StatusARMGenerator()
var inboundNatPoolPropertiesFormat_statusARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormat_StatusARMGenerator returns a generator of InboundNatPoolPropertiesFormat_StatusARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormat_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormat_StatusARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormat_statusARMGenerator != nil {
		return inboundNatPoolPropertiesFormat_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM(generators)
	inboundNatPoolPropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM(generators)
	inboundNatPoolPropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_StatusARM{}), generators)

	return inboundNatPoolPropertiesFormat_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.Int()
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.Int()
	gens["FrontendPortRangeStart"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp)
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_StatusARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_StatusARM, LoadBalancingRulePropertiesFormat_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_StatusARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_StatusARM(subject LoadBalancingRulePropertiesFormat_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_StatusARM instances for property testing - lazily instantiated by
//LoadBalancingRulePropertiesFormat_StatusARMGenerator()
var loadBalancingRulePropertiesFormat_statusARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormat_StatusARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_StatusARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormat_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormat_StatusARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormat_statusARMGenerator != nil {
		return loadBalancingRulePropertiesFormat_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM(generators)
	loadBalancingRulePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM(generators)
	loadBalancingRulePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_StatusARM{}), generators)

	return loadBalancingRulePropertiesFormat_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.Int()
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_StatusDefault, LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIPProtocol))
	gens["Protocol"] = gen.OneConstOf(TransportProtocol_StatusAll, TransportProtocol_StatusTcp, TransportProtocol_StatusUdp)
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_StatusARMGenerator())
}

func Test_OutboundRulePropertiesFormat_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormat_StatusARM, OutboundRulePropertiesFormat_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormat_StatusARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormat_StatusARM(subject OutboundRulePropertiesFormat_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_StatusARM instances for property testing - lazily instantiated by
//OutboundRulePropertiesFormat_StatusARMGenerator()
var outboundRulePropertiesFormat_statusARMGenerator gopter.Gen

// OutboundRulePropertiesFormat_StatusARMGenerator returns a generator of OutboundRulePropertiesFormat_StatusARM instances for property testing.
// We first initialize outboundRulePropertiesFormat_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormat_StatusARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormat_statusARMGenerator != nil {
		return outboundRulePropertiesFormat_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM(generators)
	outboundRulePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM(generators)
	outboundRulePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_StatusARM{}), generators)

	return outboundRulePropertiesFormat_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_StatusAll, OutboundRulePropertiesFormat_Protocol_StatusTcp, OutboundRulePropertiesFormat_Protocol_StatusUdp)
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = SubResource_StatusARMGenerator()
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_StatusARMGenerator())
}

func Test_ProbePropertiesFormat_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormat_StatusARM, ProbePropertiesFormat_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormat_StatusARM runs a test to see if a specific instance of ProbePropertiesFormat_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormat_StatusARM(subject ProbePropertiesFormat_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_StatusARM instances for property testing - lazily instantiated by
//ProbePropertiesFormat_StatusARMGenerator()
var probePropertiesFormat_statusARMGenerator gopter.Gen

// ProbePropertiesFormat_StatusARMGenerator returns a generator of ProbePropertiesFormat_StatusARM instances for property testing.
// We first initialize probePropertiesFormat_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbePropertiesFormat_StatusARMGenerator() gopter.Gen {
	if probePropertiesFormat_statusARMGenerator != nil {
		return probePropertiesFormat_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_StatusARM(generators)
	probePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_StatusARM(generators)
	AddRelatedPropertyGeneratorsForProbePropertiesFormat_StatusARM(generators)
	probePropertiesFormat_statusARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_StatusARM{}), generators)

	return probePropertiesFormat_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.Int()
	gens["Protocol"] = gen.OneConstOf(ProbePropertiesFormat_Protocol_StatusHttp, ProbePropertiesFormat_Protocol_StatusHttps, ProbePropertiesFormat_Protocol_StatusTcp)
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbePropertiesFormat_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbePropertiesFormat_StatusARM(gens map[string]gopter.Gen) {
	gens["LoadBalancingRules"] = gen.SliceOf(SubResource_StatusARMGenerator())
}

func Test_PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM, PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(subject PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return publicIPAddress_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_StatusARMGenerator())
}

func Test_Subnet_Status_LoadBalancer_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_LoadBalancer_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM, Subnet_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_Status_LoadBalancer_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM(subject Subnet_Status_LoadBalancer_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_LoadBalancer_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing - lazily instantiated
//by Subnet_Status_LoadBalancer_SubResourceEmbeddedARMGenerator()
var subnet_status_loadBalancer_subResourceEmbeddedARMGenerator gopter.Gen

// Subnet_Status_LoadBalancer_SubResourceEmbeddedARMGenerator returns a generator of Subnet_Status_LoadBalancer_SubResourceEmbeddedARM instances for property testing.
func Subnet_Status_LoadBalancer_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_status_loadBalancer_subResourceEmbeddedARMGenerator != nil {
		return subnet_status_loadBalancer_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM(generators)
	subnet_status_loadBalancer_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_LoadBalancer_SubResourceEmbeddedARM{}), generators)

	return subnet_status_loadBalancer_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_Status_LoadBalancer_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
