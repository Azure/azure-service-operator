// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generator information:
//- Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/networkInterface.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}
type NetworkInterface struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkInterfaces_SPEC                                       `json:"spec,omitempty"`
	Status            NetworkInterface_Status_NetworkInterface_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &NetworkInterface{}

// GetConditions returns the conditions of the resource
func (networkInterface *NetworkInterface) GetConditions() conditions.Conditions {
	return networkInterface.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (networkInterface *NetworkInterface) SetConditions(conditions conditions.Conditions) {
	networkInterface.Status.Conditions = conditions
}

var _ conversion.Convertible = &NetworkInterface{}

// ConvertFrom populates our NetworkInterface from the provided hub NetworkInterface
func (networkInterface *NetworkInterface) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20201101storage.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected storage:network/v1alpha1api20201101storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignPropertiesFromNetworkInterface(source)
}

// ConvertTo populates the provided hub NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20201101storage.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected storage:network/v1alpha1api20201101storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignPropertiesToNetworkInterface(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1alpha1api20201101-networkinterface,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=networkinterfaces,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.networkinterfaces.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &NetworkInterface{}

// Default applies defaults to the NetworkInterface resource
func (networkInterface *NetworkInterface) Default() {
	networkInterface.defaultImpl()
	var temp interface{} = networkInterface
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (networkInterface *NetworkInterface) defaultAzureName() {
	if networkInterface.Spec.AzureName == "" {
		networkInterface.Spec.AzureName = networkInterface.Name
	}
}

// defaultImpl applies the code generated defaults to the NetworkInterface resource
func (networkInterface *NetworkInterface) defaultImpl() { networkInterface.defaultAzureName() }

var _ genruntime.KubernetesResource = &NetworkInterface{}

// AzureName returns the Azure name of the resource
func (networkInterface *NetworkInterface) AzureName() string {
	return networkInterface.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (networkInterface NetworkInterface) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (networkInterface *NetworkInterface) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (networkInterface *NetworkInterface) GetSpec() genruntime.ConvertibleSpec {
	return &networkInterface.Spec
}

// GetStatus returns the status of this resource
func (networkInterface *NetworkInterface) GetStatus() genruntime.ConvertibleStatus {
	return &networkInterface.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (networkInterface *NetworkInterface) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (networkInterface *NetworkInterface) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (networkInterface *NetworkInterface) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(networkInterface.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  networkInterface.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (networkInterface *NetworkInterface) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*NetworkInterface_Status_NetworkInterface_SubResourceEmbedded); ok {
		networkInterface.Status = *st
		return nil
	}

	// Convert status to required version
	var st NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	networkInterface.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1alpha1api20201101-networkinterface,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=networkinterfaces,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.networkinterfaces.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &NetworkInterface{}

// ValidateCreate validates the creation of the resource
func (networkInterface *NetworkInterface) ValidateCreate() error {
	validations := networkInterface.createValidations()
	var temp interface{} = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (networkInterface *NetworkInterface) ValidateDelete() error {
	validations := networkInterface.deleteValidations()
	var temp interface{} = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (networkInterface *NetworkInterface) ValidateUpdate(old runtime.Object) error {
	validations := networkInterface.updateValidations()
	var temp interface{} = networkInterface
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (networkInterface *NetworkInterface) createValidations() []func() error {
	return []func() error{networkInterface.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (networkInterface *NetworkInterface) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (networkInterface *NetworkInterface) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return networkInterface.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (networkInterface *NetworkInterface) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&networkInterface.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromNetworkInterface populates our NetworkInterface from the provided source NetworkInterface
func (networkInterface *NetworkInterface) AssignPropertiesFromNetworkInterface(source *v1alpha1api20201101storage.NetworkInterface) error {

	// ObjectMeta
	networkInterface.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec NetworkInterfaces_SPEC
	err := spec.AssignPropertiesFromNetworkInterfaces_SPEC(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaces_SPEC() to populate field Spec")
	}
	networkInterface.Spec = spec

	// Status
	var status NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = status.AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	networkInterface.Status = status

	// No error
	return nil
}

// AssignPropertiesToNetworkInterface populates the provided destination NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) AssignPropertiesToNetworkInterface(destination *v1alpha1api20201101storage.NetworkInterface) error {

	// ObjectMeta
	destination.ObjectMeta = *networkInterface.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20201101storage.NetworkInterfaces_SPEC
	err := networkInterface.Spec.AssignPropertiesToNetworkInterfaces_SPEC(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaces_SPEC() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = networkInterface.Status.AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (networkInterface *NetworkInterface) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: networkInterface.Spec.OriginalVersion(),
		Kind:    "NetworkInterface",
	}
}

// +kubebuilder:object:root=true
//Generator information:
//- Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/networkInterface.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}
type NetworkInterfaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkInterface `json:"items"`
}

type NetworkInterface_Status_NetworkInterface_SubResourceEmbedded struct {
	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DnsSettings: The DNS settings in network interface.
	DnsSettings *NetworkInterfaceDnsSettings_Status `json:"dnsSettings,omitempty"`

	//DscpConfiguration: A reference to the dscp configuration to which the network
	//interface is linked.
	DscpConfiguration *SubResource_Status `json:"dscpConfiguration,omitempty"`

	//EnableAcceleratedNetworking: If the network interface is accelerated networking
	//enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableIPForwarding: Indicates whether IP forwarding is enabled on this network
	//interface.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//ExtendedLocation: The extended location of the network interface.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//HostedWorkloads: A list of references to linked BareMetal resources.
	HostedWorkloads []string `json:"hostedWorkloads,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IpConfigurations: A list of IPConfigurations of the network interface.
	IpConfigurations []NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//MacAddress: The MAC address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`

	//MigrationPhase: Migration phase of Network Interface resource.
	MigrationPhase *NetworkInterfacePropertiesFormat_MigrationPhase_Status `json:"migrationPhase,omitempty"`

	//Name: Resource name.
	Name *string `json:"name,omitempty"`

	//NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded `json:"networkSecurityGroup,omitempty"`

	//NicType: Type of Network Interface resource.
	NicType *NetworkInterfacePropertiesFormat_NicType_Status `json:"nicType,omitempty"`

	//Primary: Whether this is a primary network interface on a virtual machine.
	Primary *bool `json:"primary,omitempty"`

	//PrivateEndpoint: A reference to the private endpoint to which the network
	//interface is linked.
	PrivateEndpoint *PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded `json:"privateEndpoint,omitempty"`

	//PrivateLinkService: Privatelinkservice of the network interface resource.
	PrivateLinkService *PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded `json:"privateLinkService,omitempty"`

	//ProvisioningState: The provisioning state of the network interface resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//ResourceGuid: The resource GUID property of the network interface resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//TapConfigurations: A list of TapConfigurations of the network interface.
	TapConfigurations []NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded `json:"tapConfigurations,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`

	//VirtualMachine: The reference to a virtual machine.
	VirtualMachine *SubResource_Status `json:"virtualMachine,omitempty"`
}

var _ genruntime.ConvertibleStatus = &NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}

// ConvertStatusFrom populates our NetworkInterface_Status_NetworkInterface_SubResourceEmbedded from the provided source
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return embedded.AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = embedded.AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return embedded.AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}
	err := embedded.AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 NetworkInterfaceDnsSettings_Status
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			embedded.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘DscpConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DscpConfiguration != nil {
			var dscpConfiguration1 SubResource_Status
			err := dscpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DscpConfiguration)
			if err != nil {
				return err
			}
			dscpConfiguration := dscpConfiguration1
			embedded.DscpConfiguration = &dscpConfiguration
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			embedded.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			embedded.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostedWorkloads’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostedWorkloads {
			embedded.HostedWorkloads = append(embedded.HostedWorkloads, item)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.IpConfigurations = append(embedded.IpConfigurations, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		embedded.Location = &location
	}

	// Set property ‘MacAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MacAddress != nil {
			macAddress := *typedInput.Properties.MacAddress
			embedded.MacAddress = &macAddress
		}
	}

	// Set property ‘MigrationPhase’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			embedded.MigrationPhase = &migrationPhase
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			embedded.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘NicType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NicType != nil {
			nicType := *typedInput.Properties.NicType
			embedded.NicType = &nicType
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property ‘PrivateEndpoint’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpoint != nil {
			var privateEndpoint1 PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
			err := privateEndpoint1.PopulateFromARM(owner, *typedInput.Properties.PrivateEndpoint)
			if err != nil {
				return err
			}
			privateEndpoint := privateEndpoint1
			embedded.PrivateEndpoint = &privateEndpoint
		}
	}

	// Set property ‘PrivateLinkService’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkService != nil {
			var privateLinkService1 PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
			err := privateLinkService1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkService)
			if err != nil {
				return err
			}
			privateLinkService := privateLinkService1
			embedded.PrivateLinkService = &privateLinkService
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			embedded.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		embedded.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			embedded.Tags[key] = value
		}
	}

	// Set property ‘TapConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TapConfigurations {
			var item1 NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.TapConfigurations = append(embedded.TapConfigurations, item1)
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property ‘VirtualMachine’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachine != nil {
			var virtualMachine1 SubResource_Status
			err := virtualMachine1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachine)
			if err != nil {
				return err
			}
			virtualMachine := virtualMachine1
			embedded.VirtualMachine = &virtualMachine
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded populates our NetworkInterface_Status_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) error {

	// Conditions
	embedded.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings_Status
		err := dnsSetting.AssignPropertiesFromNetworkInterfaceDnsSettings_Status(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceDnsSettings_Status() to populate field DnsSettings")
		}
		embedded.DnsSettings = &dnsSetting
	} else {
		embedded.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource_Status
		err := dscpConfiguration.AssignPropertiesFromSubResource_Status(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field DscpConfiguration")
		}
		embedded.DscpConfiguration = &dscpConfiguration
	} else {
		embedded.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		embedded.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		embedded.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		embedded.EnableIPForwarding = &enableIPForwarding
	} else {
		embedded.EnableIPForwarding = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// HostedWorkloads
	embedded.HostedWorkloads = genruntime.CloneSliceOfString(source.HostedWorkloads)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		embedded.IpConfigurations = ipConfigurationList
	} else {
		embedded.IpConfigurations = nil
	}

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// MacAddress
	embedded.MacAddress = genruntime.ClonePointerToString(source.MacAddress)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := NetworkInterfacePropertiesFormat_MigrationPhase_Status(*source.MigrationPhase)
		embedded.MigrationPhase = &migrationPhase
	} else {
		embedded.MigrationPhase = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignPropertiesFromNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		embedded.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		embedded.NetworkSecurityGroup = nil
	}

	// NicType
	if source.NicType != nil {
		nicType := NetworkInterfacePropertiesFormat_NicType_Status(*source.NicType)
		embedded.NicType = &nicType
	} else {
		embedded.NicType = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
		err := privateEndpoint.AssignPropertiesFromPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		embedded.PrivateEndpoint = &privateEndpoint
	} else {
		embedded.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
		err := privateLinkService.AssignPropertiesFromPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		embedded.PrivateLinkService = &privateLinkService
	} else {
		embedded.PrivateLinkService = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// ResourceGuid
	embedded.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TapConfigurations
	if source.TapConfigurations != nil {
		tapConfigurationList := make([]NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded, len(source.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range source.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := tapConfiguration.AssignPropertiesFromNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(&tapConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		embedded.TapConfigurations = tapConfigurationList
	} else {
		embedded.TapConfigurations = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine SubResource_Status
		err := virtualMachine.AssignPropertiesFromSubResource_Status(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field VirtualMachine")
		}
		embedded.VirtualMachine = &virtualMachine
	} else {
		embedded.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterface_Status_NetworkInterface_SubResourceEmbedded from our NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(embedded.Conditions)

	// DnsSettings
	if embedded.DnsSettings != nil {
		var dnsSetting v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Status
		err := embedded.DnsSettings.AssignPropertiesToNetworkInterfaceDnsSettings_Status(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceDnsSettings_Status() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if embedded.DscpConfiguration != nil {
		var dscpConfiguration v1alpha1api20201101storage.SubResource_Status
		err := embedded.DscpConfiguration.AssignPropertiesToSubResource_Status(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field DscpConfiguration")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if embedded.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *embedded.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if embedded.EnableIPForwarding != nil {
		enableIPForwarding := *embedded.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostedWorkloads
	destination.HostedWorkloads = genruntime.CloneSliceOfString(embedded.HostedWorkloads)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// IpConfigurations
	if embedded.IpConfigurations != nil {
		ipConfigurationList := make([]v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded, len(embedded.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range embedded.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// MacAddress
	destination.MacAddress = genruntime.ClonePointerToString(embedded.MacAddress)

	// MigrationPhase
	if embedded.MigrationPhase != nil {
		migrationPhase := string(*embedded.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// NetworkSecurityGroup
	if embedded.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201101storage.NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
		err := embedded.NetworkSecurityGroup.AssignPropertiesToNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	if embedded.NicType != nil {
		nicType := string(*embedded.NicType)
		destination.NicType = &nicType
	} else {
		destination.NicType = nil
	}

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateEndpoint
	if embedded.PrivateEndpoint != nil {
		var privateEndpoint v1alpha1api20201101storage.PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateEndpoint.AssignPropertiesToPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if embedded.PrivateLinkService != nil {
		var privateLinkService v1alpha1api20201101storage.PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateLinkService.AssignPropertiesToPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(embedded.ResourceGuid)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// TapConfigurations
	if embedded.TapConfigurations != nil {
		tapConfigurationList := make([]v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded, len(embedded.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range embedded.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
			err := tapConfigurationItem.AssignPropertiesToNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(&tapConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		destination.TapConfigurations = tapConfigurationList
	} else {
		destination.TapConfigurations = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualMachine
	if embedded.VirtualMachine != nil {
		var virtualMachine v1alpha1api20201101storage.SubResource_Status
		err := embedded.VirtualMachine.AssignPropertiesToSubResource_Status(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaces_SPEC struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DnsSettings: The DNS settings in network interface.
	DnsSettings *NetworkInterfaceDnsSettings_Spec `json:"dnsSettings,omitempty"`

	//EnableAcceleratedNetworking: If the network interface is accelerated networking
	//enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableIPForwarding: Indicates whether IP forwarding is enabled on this network
	//interface.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//ExtendedLocation: The extended location of the network interface.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//IpConfigurations: A list of IPConfigurations of the network interface.
	IpConfigurations []NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//MigrationPhase: Migration phase of Network Interface resource.
	MigrationPhase *NetworkInterfacePropertiesFormat_MigrationPhase_Spec `json:"migrationPhase,omitempty"`

	//NetworkSecurityGroup: The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded `json:"networkSecurityGroup,omitempty"`

	//NicType: Type of Network Interface resource.
	NicType *NetworkInterfacePropertiesFormat_NicType_Spec `json:"nicType,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//PrivateLinkService: Privatelinkservice of the network interface resource.
	PrivateLinkService *PrivateLinkService_Spec `json:"privateLinkService,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaces_SPEC{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spec *NetworkInterfaces_SPEC) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spec == nil {
		return nil, nil
	}
	var result NetworkInterfaces_SPECARM

	// Set property ‘AzureName’:
	result.AzureName = spec.AzureName

	// Set property ‘ExtendedLocation’:
	if spec.ExtendedLocation != nil {
		extendedLocationARM, err := (*spec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if spec.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*spec.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if spec.Location != nil {
		location := *spec.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if spec.DnsSettings != nil ||
		spec.EnableAcceleratedNetworking != nil ||
		spec.EnableIPForwarding != nil ||
		spec.IpConfigurations != nil ||
		spec.MigrationPhase != nil ||
		spec.NetworkSecurityGroup != nil ||
		spec.NicType != nil ||
		spec.PrivateLinkService != nil {
		result.Properties = &NetworkInterfacePropertiesFormat_SpecARM{}
	}
	if spec.DnsSettings != nil {
		dnsSettingsARM, err := (*spec.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(NetworkInterfaceDnsSettings_SpecARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if spec.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *spec.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if spec.EnableIPForwarding != nil {
		enableIPForwarding := *spec.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range spec.IpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, itemARM.(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}
	if spec.MigrationPhase != nil {
		migrationPhase := *spec.MigrationPhase
		result.Properties.MigrationPhase = &migrationPhase
	}
	if spec.NetworkSecurityGroup != nil {
		networkSecurityGroupARM, err := (*spec.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := networkSecurityGroupARM.(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if spec.NicType != nil {
		nicType := *spec.NicType
		result.Properties.NicType = &nicType
	}
	if spec.PrivateLinkService != nil {
		privateLinkServiceARM, err := (*spec.PrivateLinkService).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		privateLinkService := privateLinkServiceARM.(PrivateLinkService_SpecARM)
		result.Properties.PrivateLinkService = &privateLinkService
	}

	// Set property ‘Tags’:
	if spec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range spec.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spec *NetworkInterfaces_SPEC) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaces_SPECARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spec *NetworkInterfaces_SPEC) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaces_SPECARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaces_SPECARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	spec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 NetworkInterfaceDnsSettings_Spec
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			spec.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			spec.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			spec.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		spec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.IpConfigurations = append(spec.IpConfigurations, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		spec.Location = &location
	}

	// Set property ‘MigrationPhase’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			spec.MigrationPhase = &migrationPhase
		}
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			spec.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘NicType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NicType != nil {
			nicType := *typedInput.Properties.NicType
			spec.NicType = &nicType
		}
	}

	// Set property ‘Owner’:
	spec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘PrivateLinkService’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkService != nil {
			var privateLinkService1 PrivateLinkService_Spec
			err := privateLinkService1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkService)
			if err != nil {
				return err
			}
			privateLinkService := privateLinkService1
			spec.PrivateLinkService = &privateLinkService
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		spec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			spec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &NetworkInterfaces_SPEC{}

// ConvertSpecFrom populates our NetworkInterfaces_SPEC from the provided source
func (spec *NetworkInterfaces_SPEC) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201101storage.NetworkInterfaces_SPEC)
	if ok {
		// Populate our instance from source
		return spec.AssignPropertiesFromNetworkInterfaces_SPEC(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.NetworkInterfaces_SPEC{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = spec.AssignPropertiesFromNetworkInterfaces_SPEC(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our NetworkInterfaces_SPEC
func (spec *NetworkInterfaces_SPEC) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201101storage.NetworkInterfaces_SPEC)
	if ok {
		// Populate destination from our instance
		return spec.AssignPropertiesToNetworkInterfaces_SPEC(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.NetworkInterfaces_SPEC{}
	err := spec.AssignPropertiesToNetworkInterfaces_SPEC(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromNetworkInterfaces_SPEC populates our NetworkInterfaces_SPEC from the provided source NetworkInterfaces_SPEC
func (spec *NetworkInterfaces_SPEC) AssignPropertiesFromNetworkInterfaces_SPEC(source *v1alpha1api20201101storage.NetworkInterfaces_SPEC) error {

	// AzureName
	spec.AzureName = source.AzureName

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings_Spec
		err := dnsSetting.AssignPropertiesFromNetworkInterfaceDnsSettings_Spec(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceDnsSettings_Spec() to populate field DnsSettings")
		}
		spec.DnsSettings = &dnsSetting
	} else {
		spec.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		spec.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		spec.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		spec.EnableIPForwarding = &enableIPForwarding
	} else {
		spec.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Spec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		spec.ExtendedLocation = &extendedLocation
	} else {
		spec.ExtendedLocation = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		spec.IpConfigurations = ipConfigurationList
	} else {
		spec.IpConfigurations = nil
	}

	// Location
	spec.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := NetworkInterfacePropertiesFormat_MigrationPhase_Spec(*source.MigrationPhase)
		spec.MigrationPhase = &migrationPhase
	} else {
		spec.MigrationPhase = nil
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignPropertiesFromNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		spec.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		spec.NetworkSecurityGroup = nil
	}

	// NicType
	if source.NicType != nil {
		nicType := NetworkInterfacePropertiesFormat_NicType_Spec(*source.NicType)
		spec.NicType = &nicType
	} else {
		spec.NicType = nil
	}

	// Owner
	spec.Owner = source.Owner.Copy()

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkService_Spec
		err := privateLinkService.AssignPropertiesFromPrivateLinkService_Spec(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkService_Spec() to populate field PrivateLinkService")
		}
		spec.PrivateLinkService = &privateLinkService
	} else {
		spec.PrivateLinkService = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		spec.Reference = &reference
	} else {
		spec.Reference = nil
	}

	// Tags
	spec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaces_SPEC populates the provided destination NetworkInterfaces_SPEC from our NetworkInterfaces_SPEC
func (spec *NetworkInterfaces_SPEC) AssignPropertiesToNetworkInterfaces_SPEC(destination *v1alpha1api20201101storage.NetworkInterfaces_SPEC) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = spec.AzureName

	// DnsSettings
	if spec.DnsSettings != nil {
		var dnsSetting v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Spec
		err := spec.DnsSettings.AssignPropertiesToNetworkInterfaceDnsSettings_Spec(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceDnsSettings_Spec() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if spec.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *spec.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if spec.EnableIPForwarding != nil {
		enableIPForwarding := *spec.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if spec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Spec
		err := spec.ExtendedLocation.AssignPropertiesToExtendedLocation_Spec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// IpConfigurations
	if spec.IpConfigurations != nil {
		ipConfigurationList := make([]v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(spec.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range spec.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(spec.Location)

	// MigrationPhase
	if spec.MigrationPhase != nil {
		migrationPhase := string(*spec.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// NetworkSecurityGroup
	if spec.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201101storage.NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
		err := spec.NetworkSecurityGroup.AssignPropertiesToNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	if spec.NicType != nil {
		nicType := string(*spec.NicType)
		destination.NicType = &nicType
	} else {
		destination.NicType = nil
	}

	// OriginalVersion
	destination.OriginalVersion = spec.OriginalVersion()

	// Owner
	destination.Owner = spec.Owner.Copy()

	// PrivateLinkService
	if spec.PrivateLinkService != nil {
		var privateLinkService v1alpha1api20201101storage.PrivateLinkService_Spec
		err := spec.PrivateLinkService.AssignPropertiesToPrivateLinkService_Spec(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkService_Spec() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// Reference
	if spec.Reference != nil {
		reference := spec.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(spec.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (spec *NetworkInterfaces_SPEC) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (spec *NetworkInterfaces_SPEC) SetAzureName(azureName string) { spec.AzureName = azureName }

type NetworkInterfaceDnsSettings_Spec struct {
	//DnsServers: List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch
	//to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined
	//with other IPs, it must be the only value in dnsServers collection.
	DnsServers []string `json:"dnsServers,omitempty"`

	//InternalDnsNameLabel: Relative DNS name for this NIC used for internal
	//communications between VMs in the same virtual network.
	InternalDnsNameLabel *string `json:"internalDnsNameLabel,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaceDnsSettings_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *NetworkInterfaceDnsSettings_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	var result NetworkInterfaceDnsSettings_SpecARM

	// Set property ‘DnsServers’:
	for _, item := range settings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}

	// Set property ‘InternalDnsNameLabel’:
	if settings.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *settings.InternalDnsNameLabel
		result.InternalDnsNameLabel = &internalDnsNameLabel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *NetworkInterfaceDnsSettings_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceDnsSettings_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *NetworkInterfaceDnsSettings_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceDnsSettings_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceDnsSettings_SpecARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// Set property ‘InternalDnsNameLabel’:
	if typedInput.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *typedInput.InternalDnsNameLabel
		settings.InternalDnsNameLabel = &internalDnsNameLabel
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceDnsSettings_Spec populates our NetworkInterfaceDnsSettings_Spec from the provided source NetworkInterfaceDnsSettings_Spec
func (settings *NetworkInterfaceDnsSettings_Spec) AssignPropertiesFromNetworkInterfaceDnsSettings_Spec(source *v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Spec) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceDnsSettings_Spec populates the provided destination NetworkInterfaceDnsSettings_Spec from our NetworkInterfaceDnsSettings_Spec
func (settings *NetworkInterfaceDnsSettings_Spec) AssignPropertiesToNetworkInterfaceDnsSettings_Spec(destination *v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaceDnsSettings_Status struct {
	//AppliedDnsServers: If the VM that uses this NIC is part of an Availability Set,
	//then this list will have the union of all DNS servers from all NICs that are
	//part of the Availability Set. This property is what is configured on each of
	//those VMs.
	AppliedDnsServers []string `json:"appliedDnsServers,omitempty"`

	//DnsServers: List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch
	//to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined
	//with other IPs, it must be the only value in dnsServers collection.
	DnsServers []string `json:"dnsServers,omitempty"`

	//InternalDnsNameLabel: Relative DNS name for this NIC used for internal
	//communications between VMs in the same virtual network.
	InternalDnsNameLabel *string `json:"internalDnsNameLabel,omitempty"`

	//InternalDomainNameSuffix: Even if internalDnsNameLabel is not specified, a DNS
	//entry is created for the primary NIC of the VM. This DNS name can be constructed
	//by concatenating the VM name with the value of internalDomainNameSuffix.
	InternalDomainNameSuffix *string `json:"internalDomainNameSuffix,omitempty"`

	//InternalFqdn: Fully qualified DNS name supporting internal communications
	//between VMs in the same virtual network.
	InternalFqdn *string `json:"internalFqdn,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceDnsSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *NetworkInterfaceDnsSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceDnsSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *NetworkInterfaceDnsSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceDnsSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceDnsSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘AppliedDnsServers’:
	for _, item := range typedInput.AppliedDnsServers {
		settings.AppliedDnsServers = append(settings.AppliedDnsServers, item)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// Set property ‘InternalDnsNameLabel’:
	if typedInput.InternalDnsNameLabel != nil {
		internalDnsNameLabel := *typedInput.InternalDnsNameLabel
		settings.InternalDnsNameLabel = &internalDnsNameLabel
	}

	// Set property ‘InternalDomainNameSuffix’:
	if typedInput.InternalDomainNameSuffix != nil {
		internalDomainNameSuffix := *typedInput.InternalDomainNameSuffix
		settings.InternalDomainNameSuffix = &internalDomainNameSuffix
	}

	// Set property ‘InternalFqdn’:
	if typedInput.InternalFqdn != nil {
		internalFqdn := *typedInput.InternalFqdn
		settings.InternalFqdn = &internalFqdn
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceDnsSettings_Status populates our NetworkInterfaceDnsSettings_Status from the provided source NetworkInterfaceDnsSettings_Status
func (settings *NetworkInterfaceDnsSettings_Status) AssignPropertiesFromNetworkInterfaceDnsSettings_Status(source *v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Status) error {

	// AppliedDnsServers
	settings.AppliedDnsServers = genruntime.CloneSliceOfString(source.AppliedDnsServers)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	settings.InternalDomainNameSuffix = genruntime.ClonePointerToString(source.InternalDomainNameSuffix)

	// InternalFqdn
	settings.InternalFqdn = genruntime.ClonePointerToString(source.InternalFqdn)

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceDnsSettings_Status populates the provided destination NetworkInterfaceDnsSettings_Status from our NetworkInterfaceDnsSettings_Status
func (settings *NetworkInterfaceDnsSettings_Status) AssignPropertiesToNetworkInterfaceDnsSettings_Status(destination *v1alpha1api20201101storage.NetworkInterfaceDnsSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppliedDnsServers
	destination.AppliedDnsServers = genruntime.CloneSliceOfString(settings.AppliedDnsServers)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	destination.InternalDomainNameSuffix = genruntime.ClonePointerToString(settings.InternalDomainNameSuffix)

	// InternalFqdn
	destination.InternalFqdn = genruntime.ClonePointerToString(settings.InternalFqdn)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded struct {
	//ApplicationGatewayBackendAddressPools: The reference to
	//ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_Spec `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Application security groups in which the IP
	//configuration is included.
	ApplicationSecurityGroups []ApplicationSecurityGroup_Spec `json:"applicationSecurityGroups,omitempty"`

	//LoadBalancerBackendAddressPools: The reference to LoadBalancerBackendAddressPool
	//resource.
	LoadBalancerBackendAddressPools []BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatRules: A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules []InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded `json:"loadBalancerInboundNatRules,omitempty"`

	//Name: The name of the resource that is unique within a resource group. This name
	//can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Primary: Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddress: Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6.
	//Default is IPv4.
	PrivateIPAddressVersion *IPVersion_Spec `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Spec `json:"privateIPAllocationMethod,omitempty"`

	//PublicIPAddress: Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddress_Spec `json:"publicIPAddress,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Subnet: Subnet bound to the IP configuration.
	Subnet *Subnet_Spec_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`

	//VirtualNetworkTaps: The reference to Virtual Network Taps.
	VirtualNetworkTaps []VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded `json:"virtualNetworkTaps,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if embedded.ApplicationGatewayBackendAddressPools != nil ||
		embedded.ApplicationSecurityGroups != nil ||
		embedded.LoadBalancerBackendAddressPools != nil ||
		embedded.LoadBalancerInboundNatRules != nil ||
		embedded.Primary != nil ||
		embedded.PrivateIPAddress != nil ||
		embedded.PrivateIPAddressVersion != nil ||
		embedded.PrivateIPAllocationMethod != nil ||
		embedded.PublicIPAddress != nil ||
		embedded.Subnet != nil ||
		embedded.VirtualNetworkTaps != nil {
		result.Properties = &NetworkInterfaceIPConfigurationPropertiesFormat_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	for _, item := range embedded.ApplicationGatewayBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, itemARM.(ApplicationGatewayBackendAddressPool_SpecARM))
	}
	for _, item := range embedded.ApplicationSecurityGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, itemARM.(ApplicationSecurityGroup_SpecARM))
	}
	for _, item := range embedded.LoadBalancerBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, itemARM.(BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}
	for _, item := range embedded.LoadBalancerInboundNatRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatRules = append(result.Properties.LoadBalancerInboundNatRules, itemARM.(InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}
	if embedded.Primary != nil {
		primary := *embedded.Primary
		result.Properties.Primary = &primary
	}
	if embedded.PrivateIPAddress != nil {
		privateIPAddress := *embedded.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *embedded.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *embedded.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if embedded.PublicIPAddress != nil {
		publicIPAddressARM, err := (*embedded.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := publicIPAddressARM.(PublicIPAddress_SpecARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if embedded.Subnet != nil {
		subnetARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM)
		result.Properties.Subnet = &subnet
	}
	for _, item := range embedded.VirtualNetworkTaps {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.VirtualNetworkTaps = append(result.Properties.VirtualNetworkTaps, itemARM.(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}

	// Set property ‘Type’:
	if embedded.Type != nil {
		typeVar := *embedded.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationGatewayBackendAddressPools = append(embedded.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 ApplicationSecurityGroup_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationSecurityGroups = append(embedded.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerBackendAddressPools = append(embedded.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatRules {
			var item1 InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerInboundNatRules = append(embedded.LoadBalancerInboundNatRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Spec
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Spec_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property ‘VirtualNetworkTaps’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VirtualNetworkTaps {
			var item1 VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.VirtualNetworkTaps = append(embedded.VirtualNetworkTaps, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_Spec, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_Spec
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromApplicationGatewayBackendAddressPool_Spec(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddressPool_Spec() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroup_Spec, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroup_Spec
			err := applicationSecurityGroup.AssignPropertiesFromApplicationSecurityGroup_Spec(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationSecurityGroup_Spec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignPropertiesFromBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignPropertiesFromInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Spec(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Spec(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Spec
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_Spec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignPropertiesFromVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Spec, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Spec
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToApplicationGatewayBackendAddressPool_Spec(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddressPool_Spec() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v1alpha1api20201101storage.ApplicationSecurityGroup_Spec, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v1alpha1api20201101storage.ApplicationSecurityGroup_Spec
			err := applicationSecurityGroupItem.AssignPropertiesToApplicationSecurityGroup_Spec(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationSecurityGroup_Spec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v1alpha1api20201101storage.BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v1alpha1api20201101storage.InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignPropertiesToInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Spec
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_Spec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v1alpha1api20201101storage.VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v1alpha1api20201101storage.VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignPropertiesToVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded struct {
	//ApplicationGatewayBackendAddressPools: The reference to
	//ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Application security groups in which the IP
	//configuration is included.
	ApplicationSecurityGroups []ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded `json:"applicationSecurityGroups,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//LoadBalancerBackendAddressPools: The reference to LoadBalancerBackendAddressPool
	//resource.
	LoadBalancerBackendAddressPools []BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatRules: A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules []InboundNatRule_Status_NetworkInterface_SubResourceEmbedded `json:"loadBalancerInboundNatRules,omitempty"`

	//Name: The name of the resource that is unique within a resource group. This name
	//can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Primary: Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddress: Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6.
	//Default is IPv4.
	PrivateIPAddressVersion *IPVersion_Status `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//PrivateLinkConnectionProperties: PrivateLinkConnection properties for the
	//network interface.
	PrivateLinkConnectionProperties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status `json:"privateLinkConnectionProperties,omitempty"`

	//ProvisioningState: The provisioning state of the network interface IP
	//configuration.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	//Subnet: Subnet bound to the IP configuration.
	Subnet *Subnet_Status_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`

	//VirtualNetworkTaps: The reference to Virtual Network Taps.
	VirtualNetworkTaps []VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded `json:"virtualNetworkTaps,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationGatewayBackendAddressPools = append(embedded.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.ApplicationSecurityGroups = append(embedded.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerBackendAddressPools = append(embedded.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatRules {
			var item1 InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancerInboundNatRules = append(embedded.LoadBalancerInboundNatRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PrivateLinkConnectionProperties’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkConnectionProperties != nil {
			var privateLinkConnectionProperties1 NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
			err := privateLinkConnectionProperties1.PopulateFromARM(owner, *typedInput.Properties.PrivateLinkConnectionProperties)
			if err != nil {
				return err
			}
			privateLinkConnectionProperties := privateLinkConnectionProperties1
			embedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperties
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property ‘VirtualNetworkTaps’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.VirtualNetworkTaps {
			var item1 VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.VirtualNetworkTaps = append(embedded.VirtualNetworkTaps, item1)
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroup.AssignPropertiesFromApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignPropertiesFromBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_Status_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignPropertiesFromInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_Status_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if source.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
		err := privateLinkConnectionProperty.AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(source.PrivateLinkConnectionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status() to populate field PrivateLinkConnectionProperties")
		}
		embedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		embedded.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Status_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Status_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignPropertiesFromVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v1alpha1api20201101storage.ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v1alpha1api20201101storage.ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroupItem.AssignPropertiesToApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v1alpha1api20201101storage.BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Status_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v1alpha1api20201101storage.InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignPropertiesToInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_Status_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PrivateLinkConnectionProperties
	if embedded.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
		err := embedded.PrivateLinkConnectionProperties.AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(&privateLinkConnectionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status() to populate field PrivateLinkConnectionProperties")
		}
		destination.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		destination.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Status_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Status_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Status_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v1alpha1api20201101storage.VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v1alpha1api20201101storage.VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignPropertiesToVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Abort","Commit","Committed","None","Prepare"}
type NetworkInterfacePropertiesFormat_MigrationPhase_Spec string

const (
	NetworkInterfacePropertiesFormat_MigrationPhase_SpecAbort     = NetworkInterfacePropertiesFormat_MigrationPhase_Spec("Abort")
	NetworkInterfacePropertiesFormat_MigrationPhase_SpecCommit    = NetworkInterfacePropertiesFormat_MigrationPhase_Spec("Commit")
	NetworkInterfacePropertiesFormat_MigrationPhase_SpecCommitted = NetworkInterfacePropertiesFormat_MigrationPhase_Spec("Committed")
	NetworkInterfacePropertiesFormat_MigrationPhase_SpecNone      = NetworkInterfacePropertiesFormat_MigrationPhase_Spec("None")
	NetworkInterfacePropertiesFormat_MigrationPhase_SpecPrepare   = NetworkInterfacePropertiesFormat_MigrationPhase_Spec("Prepare")
)

type NetworkInterfacePropertiesFormat_MigrationPhase_Status string

const (
	NetworkInterfacePropertiesFormat_MigrationPhase_StatusAbort     = NetworkInterfacePropertiesFormat_MigrationPhase_Status("Abort")
	NetworkInterfacePropertiesFormat_MigrationPhase_StatusCommit    = NetworkInterfacePropertiesFormat_MigrationPhase_Status("Commit")
	NetworkInterfacePropertiesFormat_MigrationPhase_StatusCommitted = NetworkInterfacePropertiesFormat_MigrationPhase_Status("Committed")
	NetworkInterfacePropertiesFormat_MigrationPhase_StatusNone      = NetworkInterfacePropertiesFormat_MigrationPhase_Status("None")
	NetworkInterfacePropertiesFormat_MigrationPhase_StatusPrepare   = NetworkInterfacePropertiesFormat_MigrationPhase_Status("Prepare")
)

// +kubebuilder:validation:Enum={"Elastic","Standard"}
type NetworkInterfacePropertiesFormat_NicType_Spec string

const (
	NetworkInterfacePropertiesFormat_NicType_SpecElastic  = NetworkInterfacePropertiesFormat_NicType_Spec("Elastic")
	NetworkInterfacePropertiesFormat_NicType_SpecStandard = NetworkInterfacePropertiesFormat_NicType_Spec("Standard")
)

type NetworkInterfacePropertiesFormat_NicType_Status string

const (
	NetworkInterfacePropertiesFormat_NicType_StatusElastic  = NetworkInterfacePropertiesFormat_NicType_Status("Elastic")
	NetworkInterfacePropertiesFormat_NicType_StatusStandard = NetworkInterfacePropertiesFormat_NicType_Status("Standard")
)

type NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//SecurityRules: A collection of security rules of the network security group.
	SecurityRules []SecurityRule_Spec_NetworkInterface_SubResourceEmbedded `json:"securityRules,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if embedded.Location != nil {
		location := *embedded.Location
		result.Location = &location
	}

	// Set property ‘Properties’:
	if embedded.SecurityRules != nil {
		result.Properties = &NetworkSecurityGroupPropertiesFormat_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	for _, item := range embedded.SecurityRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SecurityRules = append(result.Properties.SecurityRules, itemARM.(SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}

	// Set property ‘Tags’:
	if embedded.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range embedded.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		embedded.Location = &location
	}

	// no assignment for property ‘Reference’

	// Set property ‘SecurityRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SecurityRules {
			var item1 SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.SecurityRules = append(embedded.SecurityRules, item1)
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		embedded.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			embedded.Tags[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// SecurityRules
	if source.SecurityRules != nil {
		securityRuleList := make([]SecurityRule_Spec_NetworkInterface_SubResourceEmbedded, len(source.SecurityRules))
		for securityRuleIndex, securityRuleItem := range source.SecurityRules {
			// Shadow the loop variable to avoid aliasing
			securityRuleItem := securityRuleItem
			var securityRule SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
			err := securityRule.AssignPropertiesFromSecurityRule_Spec_NetworkInterface_SubResourceEmbedded(&securityRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSecurityRule_Spec_NetworkInterface_SubResourceEmbedded() to populate field SecurityRules")
			}
			securityRuleList[securityRuleIndex] = securityRule
		}
		embedded.SecurityRules = securityRuleList
	} else {
		embedded.SecurityRules = nil
	}

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityRules
	if embedded.SecurityRules != nil {
		securityRuleList := make([]v1alpha1api20201101storage.SecurityRule_Spec_NetworkInterface_SubResourceEmbedded, len(embedded.SecurityRules))
		for securityRuleIndex, securityRuleItem := range embedded.SecurityRules {
			// Shadow the loop variable to avoid aliasing
			securityRuleItem := securityRuleItem
			var securityRule v1alpha1api20201101storage.SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
			err := securityRuleItem.AssignPropertiesToSecurityRule_Spec_NetworkInterface_SubResourceEmbedded(&securityRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSecurityRule_Spec_NetworkInterface_SubResourceEmbedded() to populate field SecurityRules")
			}
			securityRuleList[securityRuleIndex] = securityRule
		}
		destination.SecurityRules = securityRuleList
	} else {
		destination.SecurityRules = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded populates our PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded from the provided source PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded from our PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkService_Spec struct {
	//AutoApproval: The auto-approval list of the private link service.
	AutoApproval *ResourceSet_Spec `json:"autoApproval,omitempty"`

	//EnableProxyProtocol: Whether the private link service is enabled for proxy
	//protocol or not.
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty"`

	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//Fqdns: The list of Fqdn.
	Fqdns []string `json:"fqdns,omitempty"`

	//IpConfigurations: An array of private link service IP configurations.
	IpConfigurations []PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`

	//LoadBalancerFrontendIpConfigurations: An array of references to the load
	//balancer IP configurations.
	LoadBalancerFrontendIpConfigurations []FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded `json:"loadBalancerFrontendIpConfigurations,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//Visibility: The visibility list of the private link service.
	Visibility *ResourceSet_Spec `json:"visibility,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkService_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *PrivateLinkService_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	var result PrivateLinkService_SpecARM

	// Set property ‘ExtendedLocation’:
	if service.ExtendedLocation != nil {
		extendedLocationARM, err := (*service.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if service.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*service.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if service.Location != nil {
		location := *service.Location
		result.Location = &location
	}

	// Set property ‘Properties’:
	if service.AutoApproval != nil ||
		service.EnableProxyProtocol != nil ||
		service.Fqdns != nil ||
		service.IpConfigurations != nil ||
		service.LoadBalancerFrontendIpConfigurations != nil ||
		service.Visibility != nil {
		result.Properties = &PrivateLinkServiceProperties_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	if service.AutoApproval != nil {
		autoApprovalARM, err := (*service.AutoApproval).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoApproval := autoApprovalARM.(ResourceSet_SpecARM)
		result.Properties.AutoApproval = &autoApproval
	}
	if service.EnableProxyProtocol != nil {
		enableProxyProtocol := *service.EnableProxyProtocol
		result.Properties.EnableProxyProtocol = &enableProxyProtocol
	}
	for _, item := range service.Fqdns {
		result.Properties.Fqdns = append(result.Properties.Fqdns, item)
	}
	for _, item := range service.IpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, itemARM.(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}
	for _, item := range service.LoadBalancerFrontendIpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerFrontendIpConfigurations = append(result.Properties.LoadBalancerFrontendIpConfigurations, itemARM.(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM))
	}
	if service.Visibility != nil {
		visibilityARM, err := (*service.Visibility).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		visibility := visibilityARM.(ResourceSet_SpecARM)
		result.Properties.Visibility = &visibility
	}

	// Set property ‘Tags’:
	if service.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range service.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *PrivateLinkService_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkService_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *PrivateLinkService_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkService_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkService_SpecARM, got %T", armInput)
	}

	// Set property ‘AutoApproval’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoApproval != nil {
			var autoApproval1 ResourceSet_Spec
			err := autoApproval1.PopulateFromARM(owner, *typedInput.Properties.AutoApproval)
			if err != nil {
				return err
			}
			autoApproval := autoApproval1
			service.AutoApproval = &autoApproval
		}
	}

	// Set property ‘EnableProxyProtocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableProxyProtocol != nil {
			enableProxyProtocol := *typedInput.Properties.EnableProxyProtocol
			service.EnableProxyProtocol = &enableProxyProtocol
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		service.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Fqdns’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Fqdns {
			service.Fqdns = append(service.Fqdns, item)
		}
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.IpConfigurations = append(service.IpConfigurations, item1)
		}
	}

	// Set property ‘LoadBalancerFrontendIpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerFrontendIpConfigurations {
			var item1 FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.LoadBalancerFrontendIpConfigurations = append(service.LoadBalancerFrontendIpConfigurations, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		service.Location = &location
	}

	// no assignment for property ‘Reference’

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		service.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			service.Tags[key] = value
		}
	}

	// Set property ‘Visibility’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Visibility != nil {
			var visibility1 ResourceSet_Spec
			err := visibility1.PopulateFromARM(owner, *typedInput.Properties.Visibility)
			if err != nil {
				return err
			}
			visibility := visibility1
			service.Visibility = &visibility
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkService_Spec populates our PrivateLinkService_Spec from the provided source PrivateLinkService_Spec
func (service *PrivateLinkService_Spec) AssignPropertiesFromPrivateLinkService_Spec(source *v1alpha1api20201101storage.PrivateLinkService_Spec) error {

	// AutoApproval
	if source.AutoApproval != nil {
		var autoApproval ResourceSet_Spec
		err := autoApproval.AssignPropertiesFromResourceSet_Spec(source.AutoApproval)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceSet_Spec() to populate field AutoApproval")
		}
		service.AutoApproval = &autoApproval
	} else {
		service.AutoApproval = nil
	}

	// EnableProxyProtocol
	if source.EnableProxyProtocol != nil {
		enableProxyProtocol := *source.EnableProxyProtocol
		service.EnableProxyProtocol = &enableProxyProtocol
	} else {
		service.EnableProxyProtocol = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Spec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		service.ExtendedLocation = &extendedLocation
	} else {
		service.ExtendedLocation = nil
	}

	// Fqdns
	service.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		service.IpConfigurations = ipConfigurationList
	} else {
		service.IpConfigurations = nil
	}

	// LoadBalancerFrontendIpConfigurations
	if source.LoadBalancerFrontendIpConfigurations != nil {
		loadBalancerFrontendIpConfigurationList := make([]FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerFrontendIpConfigurations))
		for loadBalancerFrontendIpConfigurationIndex, loadBalancerFrontendIpConfigurationItem := range source.LoadBalancerFrontendIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			loadBalancerFrontendIpConfigurationItem := loadBalancerFrontendIpConfigurationItem
			var loadBalancerFrontendIpConfiguration FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerFrontendIpConfiguration.AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerFrontendIpConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerFrontendIpConfigurations")
			}
			loadBalancerFrontendIpConfigurationList[loadBalancerFrontendIpConfigurationIndex] = loadBalancerFrontendIpConfiguration
		}
		service.LoadBalancerFrontendIpConfigurations = loadBalancerFrontendIpConfigurationList
	} else {
		service.LoadBalancerFrontendIpConfigurations = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		service.Reference = &reference
	} else {
		service.Reference = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Visibility
	if source.Visibility != nil {
		var visibility ResourceSet_Spec
		err := visibility.AssignPropertiesFromResourceSet_Spec(source.Visibility)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceSet_Spec() to populate field Visibility")
		}
		service.Visibility = &visibility
	} else {
		service.Visibility = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkService_Spec populates the provided destination PrivateLinkService_Spec from our PrivateLinkService_Spec
func (service *PrivateLinkService_Spec) AssignPropertiesToPrivateLinkService_Spec(destination *v1alpha1api20201101storage.PrivateLinkService_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoApproval
	if service.AutoApproval != nil {
		var autoApproval v1alpha1api20201101storage.ResourceSet_Spec
		err := service.AutoApproval.AssignPropertiesToResourceSet_Spec(&autoApproval)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceSet_Spec() to populate field AutoApproval")
		}
		destination.AutoApproval = &autoApproval
	} else {
		destination.AutoApproval = nil
	}

	// EnableProxyProtocol
	if service.EnableProxyProtocol != nil {
		enableProxyProtocol := *service.EnableProxyProtocol
		destination.EnableProxyProtocol = &enableProxyProtocol
	} else {
		destination.EnableProxyProtocol = nil
	}

	// ExtendedLocation
	if service.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Spec
		err := service.ExtendedLocation.AssignPropertiesToExtendedLocation_Spec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(service.Fqdns)

	// IpConfigurations
	if service.IpConfigurations != nil {
		ipConfigurationList := make([]v1alpha1api20201101storage.PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(service.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range service.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v1alpha1api20201101storage.PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// LoadBalancerFrontendIpConfigurations
	if service.LoadBalancerFrontendIpConfigurations != nil {
		loadBalancerFrontendIpConfigurationList := make([]v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, len(service.LoadBalancerFrontendIpConfigurations))
		for loadBalancerFrontendIpConfigurationIndex, loadBalancerFrontendIpConfigurationItem := range service.LoadBalancerFrontendIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			loadBalancerFrontendIpConfigurationItem := loadBalancerFrontendIpConfigurationItem
			var loadBalancerFrontendIpConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := loadBalancerFrontendIpConfigurationItem.AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&loadBalancerFrontendIpConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerFrontendIpConfigurations")
			}
			loadBalancerFrontendIpConfigurationList[loadBalancerFrontendIpConfigurationIndex] = loadBalancerFrontendIpConfiguration
		}
		destination.LoadBalancerFrontendIpConfigurations = loadBalancerFrontendIpConfigurationList
	} else {
		destination.LoadBalancerFrontendIpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// Reference
	if service.Reference != nil {
		reference := service.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Visibility
	if service.Visibility != nil {
		var visibility v1alpha1api20201101storage.ResourceSet_Spec
		err := service.Visibility.AssignPropertiesToResourceSet_Spec(&visibility)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceSet_Spec() to populate field Visibility")
		}
		destination.Visibility = &visibility
	} else {
		destination.Visibility = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded populates our PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded from the provided source PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded from our PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SubResource_Status struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SubResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubResource_Status populates our SubResource_Status from the provided source SubResource_Status
func (resource *SubResource_Status) AssignPropertiesFromSubResource_Status(source *v1alpha1api20201101storage.SubResource_Status) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubResource_Status populates the provided destination SubResource_Status from our SubResource_Status
func (resource *SubResource_Status) AssignPropertiesToSubResource_Status(destination *v1alpha1api20201101storage.SubResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationGatewayBackendAddressPool_Spec struct {
	//BackendAddresses: Backend addresses.
	BackendAddresses []ApplicationGatewayBackendAddress_Spec `json:"backendAddresses,omitempty"`

	//Name: Name of the backend address pool that is unique within an Application
	//Gateway.
	Name *string `json:"name,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendAddressPool_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *ApplicationGatewayBackendAddressPool_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	var result ApplicationGatewayBackendAddressPool_SpecARM

	// Set property ‘Id’:
	if pool.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*pool.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pool.BackendAddresses != nil {
		result.Properties = &ApplicationGatewayBackendAddressPoolPropertiesFormat_SpecARM{}
	}
	for _, item := range pool.BackendAddresses {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddresses = append(result.Properties.BackendAddresses, itemARM.(ApplicationGatewayBackendAddress_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *ApplicationGatewayBackendAddressPool_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddressPool_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *ApplicationGatewayBackendAddressPool_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddressPool_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddressPool_SpecARM, got %T", armInput)
	}

	// Set property ‘BackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddresses {
			var item1 ApplicationGatewayBackendAddress_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.BackendAddresses = append(pool.BackendAddresses, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddressPool_Spec populates our ApplicationGatewayBackendAddressPool_Spec from the provided source ApplicationGatewayBackendAddressPool_Spec
func (pool *ApplicationGatewayBackendAddressPool_Spec) AssignPropertiesFromApplicationGatewayBackendAddressPool_Spec(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Spec) error {

	// BackendAddresses
	if source.BackendAddresses != nil {
		backendAddressList := make([]ApplicationGatewayBackendAddress_Spec, len(source.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress ApplicationGatewayBackendAddress_Spec
			err := backendAddress.AssignPropertiesFromApplicationGatewayBackendAddress_Spec(&backendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddress_Spec() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		pool.BackendAddresses = backendAddressList
	} else {
		pool.BackendAddresses = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		pool.Reference = &reference
	} else {
		pool.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressPool_Spec populates the provided destination ApplicationGatewayBackendAddressPool_Spec from our ApplicationGatewayBackendAddressPool_Spec
func (pool *ApplicationGatewayBackendAddressPool_Spec) AssignPropertiesToApplicationGatewayBackendAddressPool_Spec(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddresses
	if pool.BackendAddresses != nil {
		backendAddressList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Spec, len(pool.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range pool.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Spec
			err := backendAddressItem.AssignPropertiesToApplicationGatewayBackendAddress_Spec(&backendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddress_Spec() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		destination.BackendAddresses = backendAddressList
	} else {
		destination.BackendAddresses = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Reference
	if pool.Reference != nil {
		reference := pool.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded struct {
	//BackendAddresses: Backend addresses.
	BackendAddresses []ApplicationGatewayBackendAddress_Status `json:"backendAddresses,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Name: Name of the backend address pool that is unique within an Application
	//Gateway.
	Name *string `json:"name,omitempty"`

	//ProvisioningState: The provisioning state of the backend address pool resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘BackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddresses {
			var item1 ApplicationGatewayBackendAddress_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.BackendAddresses = append(embedded.BackendAddresses, item1)
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) error {

	// BackendAddresses
	if source.BackendAddresses != nil {
		backendAddressList := make([]ApplicationGatewayBackendAddress_Status, len(source.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress ApplicationGatewayBackendAddress_Status
			err := backendAddress.AssignPropertiesFromApplicationGatewayBackendAddress_Status(&backendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddress_Status() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		embedded.BackendAddresses = backendAddressList
	} else {
		embedded.BackendAddresses = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded from our ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddresses
	if embedded.BackendAddresses != nil {
		backendAddressList := make([]v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status, len(embedded.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range embedded.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status
			err := backendAddressItem.AssignPropertiesToApplicationGatewayBackendAddress_Status(&backendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddress_Status() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		destination.BackendAddresses = backendAddressList
	} else {
		destination.BackendAddresses = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded populates our ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded from the provided source ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded from our ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name *string `json:"name,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_Spec `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Spec `json:"privateIPAllocationMethod,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_Spec `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_Spec `json:"publicIPPrefix,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Spec_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if embedded.PrivateIPAddress != nil ||
		embedded.PrivateIPAddressVersion != nil ||
		embedded.PrivateIPAllocationMethod != nil ||
		embedded.PublicIPAddress != nil ||
		embedded.PublicIPPrefix != nil ||
		embedded.Subnet != nil {
		result.Properties = &FrontendIPConfigurationPropertiesFormat_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	if embedded.PrivateIPAddress != nil {
		privateIPAddress := *embedded.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *embedded.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *embedded.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if embedded.PublicIPAddress != nil {
		publicIPAddressARM, err := (*embedded.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := publicIPAddressARM.(PublicIPAddress_SpecARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if embedded.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*embedded.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResource_SpecARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if embedded.Subnet != nil {
		subnetARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM)
		result.Properties.Subnet = &subnet
	}

	// Set property ‘Zones’:
	for _, item := range embedded.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Spec
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Spec
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			embedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Spec_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates our FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded from the provided source FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Spec(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Spec(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Spec
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_Spec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Spec
		err := publicIPPrefix.AssignPropertiesFromSubResource_Spec(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field PublicIPPrefix")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded from our FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Spec
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_Spec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Spec
		err := embedded.PublicIPPrefix.AssignPropertiesToSubResource_Spec(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded from our InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRule_Status_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_Status_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_Status_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_Status_NetworkInterface_SubResourceEmbedded from our InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status struct {
	//Fqdns: List of FQDNs for current private link connection.
	Fqdns []string `json:"fqdns,omitempty"`

	//GroupId: The group ID for current private link connection.
	GroupId *string `json:"groupId,omitempty"`

	//RequiredMemberName: The required member name for current private link connection.
	RequiredMemberName *string `json:"requiredMemberName,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusARM, got %T", armInput)
	}

	// Set property ‘Fqdns’:
	for _, item := range typedInput.Fqdns {
		properties.Fqdns = append(properties.Fqdns, item)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		properties.GroupId = &groupId
	}

	// Set property ‘RequiredMemberName’:
	if typedInput.RequiredMemberName != nil {
		requiredMemberName := *typedInput.RequiredMemberName
		properties.RequiredMemberName = &requiredMemberName
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status populates our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status from the provided source NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(source *v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) error {

	// Fqdns
	properties.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// GroupId
	properties.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// RequiredMemberName
	properties.RequiredMemberName = genruntime.ClonePointerToString(source.RequiredMemberName)

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status populates the provided destination NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status from our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(destination *v1alpha1api20201101storage.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(properties.Fqdns)

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(properties.GroupId)

	// RequiredMemberName
	destination.RequiredMemberName = genruntime.ClonePointerToString(properties.RequiredMemberName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Name: The name of private link service ip configuration.
	Name *string `json:"name,omitempty"`

	//Primary: Whether the ip configuration is primary or not.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific IP configuration is IPv4 or IPv6.
	//Default is IPv4.
	PrivateIPAddressVersion *IPVersion_Spec `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The private IP address allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Spec `json:"privateIPAllocationMethod,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Spec_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if embedded.Primary != nil ||
		embedded.PrivateIPAddress != nil ||
		embedded.PrivateIPAddressVersion != nil ||
		embedded.PrivateIPAllocationMethod != nil ||
		embedded.Subnet != nil {
		result.Properties = &PrivateLinkServiceIpConfigurationProperties_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	if embedded.Primary != nil {
		primary := *embedded.Primary
		result.Properties.Primary = &primary
	}
	if embedded.PrivateIPAddress != nil {
		privateIPAddress := *embedded.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *embedded.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *embedded.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if embedded.Subnet != nil {
		subnetARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			embedded.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Spec_NetworkInterface_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates our PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded from the provided source PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Spec(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Spec(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded from our PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Status `json:"sku,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		embedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded populates our PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded from the provided source PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSku_Status(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSku_Status() to populate field Sku")
		}
		embedded.Sku = &sku
	} else {
		embedded.Sku = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded populates the provided destination PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded from our PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Sku
	if embedded.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Status
		err := embedded.Sku.AssignPropertiesToPublicIPAddressSku_Status(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSku_Status() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceSet_Spec struct {
	//Subscriptions: The list of subscriptions.
	Subscriptions []string `json:"subscriptions,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceSet_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceSet *ResourceSet_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceSet == nil {
		return nil, nil
	}
	var result ResourceSet_SpecARM

	// Set property ‘Subscriptions’:
	for _, item := range resourceSet.Subscriptions {
		result.Subscriptions = append(result.Subscriptions, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceSet *ResourceSet_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceSet_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceSet *ResourceSet_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceSet_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceSet_SpecARM, got %T", armInput)
	}

	// Set property ‘Subscriptions’:
	for _, item := range typedInput.Subscriptions {
		resourceSet.Subscriptions = append(resourceSet.Subscriptions, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceSet_Spec populates our ResourceSet_Spec from the provided source ResourceSet_Spec
func (resourceSet *ResourceSet_Spec) AssignPropertiesFromResourceSet_Spec(source *v1alpha1api20201101storage.ResourceSet_Spec) error {

	// Subscriptions
	resourceSet.Subscriptions = genruntime.CloneSliceOfString(source.Subscriptions)

	// No error
	return nil
}

// AssignPropertiesToResourceSet_Spec populates the provided destination ResourceSet_Spec from our ResourceSet_Spec
func (resourceSet *ResourceSet_Spec) AssignPropertiesToResourceSet_Spec(destination *v1alpha1api20201101storage.ResourceSet_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Subscriptions
	destination.Subscriptions = genruntime.CloneSliceOfString(resourceSet.Subscriptions)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SecurityRule_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SecurityRule_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSecurityRule_Spec_NetworkInterface_SubResourceEmbedded populates our SecurityRule_Spec_NetworkInterface_SubResourceEmbedded from the provided source SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSecurityRule_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityRule_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination SecurityRule_Spec_NetworkInterface_SubResourceEmbedded from our SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSecurityRule_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet_Spec_NetworkInterface_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &Subnet_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *Subnet_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded populates our Subnet_Spec_NetworkInterface_SubResourceEmbedded from the provided source Subnet_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSubnet_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_Spec_NetworkInterface_SubResourceEmbedded from our Subnet_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSubnet_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnet_Status_NetworkInterface_SubResourceEmbedded populates our Subnet_Status_NetworkInterface_SubResourceEmbedded from the provided source Subnet_Status_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSubnet_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubnet_Status_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_Status_NetworkInterface_SubResourceEmbedded from our Subnet_Status_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSubnet_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded struct {
	//DestinationLoadBalancerFrontEndIPConfiguration: The reference to the private IP
	//address on the internal Load Balancer that will receive the tap.
	DestinationLoadBalancerFrontEndIPConfiguration *FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded `json:"destinationLoadBalancerFrontEndIPConfiguration,omitempty"`

	//DestinationPort: The VXLAN destination port that will receive the tapped traffic.
	DestinationPort *int `json:"destinationPort,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if embedded.Location != nil {
		location := *embedded.Location
		result.Location = &location
	}

	// Set property ‘Properties’:
	if embedded.DestinationLoadBalancerFrontEndIPConfiguration != nil || embedded.DestinationPort != nil {
		result.Properties = &VirtualNetworkTapPropertiesFormat_Spec_NetworkInterface_SubResourceEmbeddedARM{}
	}
	if embedded.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		destinationLoadBalancerFrontEndIPConfigurationARM, err := (*embedded.DestinationLoadBalancerFrontEndIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		destinationLoadBalancerFrontEndIPConfiguration := destinationLoadBalancerFrontEndIPConfigurationARM.(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedARM)
		result.Properties.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	}
	if embedded.DestinationPort != nil {
		destinationPort := *embedded.DestinationPort
		result.Properties.DestinationPort = &destinationPort
	}

	// Set property ‘Tags’:
	if embedded.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range embedded.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘DestinationLoadBalancerFrontEndIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration != nil {
			var destinationLoadBalancerFrontEndIPConfiguration1 FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
			err := destinationLoadBalancerFrontEndIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DestinationLoadBalancerFrontEndIPConfiguration)
			if err != nil {
				return err
			}
			destinationLoadBalancerFrontEndIPConfiguration := destinationLoadBalancerFrontEndIPConfiguration1
			embedded.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
		}
	}

	// Set property ‘DestinationPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DestinationPort != nil {
			destinationPort := *typedInput.Properties.DestinationPort
			embedded.DestinationPort = &destinationPort
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		embedded.Location = &location
	}

	// no assignment for property ‘Reference’

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		embedded.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			embedded.Tags[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) error {

	// DestinationLoadBalancerFrontEndIPConfiguration
	if source.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
		err := destinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(source.DestinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field DestinationLoadBalancerFrontEndIPConfiguration")
		}
		embedded.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		embedded.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationPort
	embedded.DestinationPort = genruntime.ClonePointerToInt(source.DestinationPort)

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DestinationLoadBalancerFrontEndIPConfiguration
	if embedded.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
		err := embedded.DestinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(&destinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded() to populate field DestinationLoadBalancerFrontEndIPConfiguration")
		}
		destination.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		destination.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationPort
	destination.DestinationPort = genruntime.ClonePointerToInt(embedded.DestinationPort)

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(source *v1alpha1api20201101storage.VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) AssignPropertiesToVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(destination *v1alpha1api20201101storage.VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationGatewayBackendAddress_Spec struct {
	//Fqdn: Fully qualified domain name (FQDN).
	Fqdn *string `json:"fqdn,omitempty"`

	//IpAddress: IP address.
	IpAddress *string `json:"ipAddress,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationGatewayBackendAddress_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *ApplicationGatewayBackendAddress_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	var result ApplicationGatewayBackendAddress_SpecARM

	// Set property ‘Fqdn’:
	if address.Fqdn != nil {
		fqdn := *address.Fqdn
		result.Fqdn = &fqdn
	}

	// Set property ‘IpAddress’:
	if address.IpAddress != nil {
		ipAddress := *address.IpAddress
		result.IpAddress = &ipAddress
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *ApplicationGatewayBackendAddress_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddress_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *ApplicationGatewayBackendAddress_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddress_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddress_SpecARM, got %T", armInput)
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property ‘IpAddress’:
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		address.IpAddress = &ipAddress
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddress_Spec populates our ApplicationGatewayBackendAddress_Spec from the provided source ApplicationGatewayBackendAddress_Spec
func (address *ApplicationGatewayBackendAddress_Spec) AssignPropertiesFromApplicationGatewayBackendAddress_Spec(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Spec) error {

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddress_Spec populates the provided destination ApplicationGatewayBackendAddress_Spec from our ApplicationGatewayBackendAddress_Spec
func (address *ApplicationGatewayBackendAddress_Spec) AssignPropertiesToApplicationGatewayBackendAddress_Spec(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApplicationGatewayBackendAddress_Status struct {
	//Fqdn: Fully qualified domain name (FQDN).
	Fqdn *string `json:"fqdn,omitempty"`

	//IpAddress: IP address.
	IpAddress *string `json:"ipAddress,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGatewayBackendAddress_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *ApplicationGatewayBackendAddress_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApplicationGatewayBackendAddress_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *ApplicationGatewayBackendAddress_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApplicationGatewayBackendAddress_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApplicationGatewayBackendAddress_StatusARM, got %T", armInput)
	}

	// Set property ‘Fqdn’:
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		address.Fqdn = &fqdn
	}

	// Set property ‘IpAddress’:
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		address.IpAddress = &ipAddress
	}

	// No error
	return nil
}

// AssignPropertiesFromApplicationGatewayBackendAddress_Status populates our ApplicationGatewayBackendAddress_Status from the provided source ApplicationGatewayBackendAddress_Status
func (address *ApplicationGatewayBackendAddress_Status) AssignPropertiesFromApplicationGatewayBackendAddress_Status(source *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status) error {

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddress_Status populates the provided destination ApplicationGatewayBackendAddress_Status from our ApplicationGatewayBackendAddress_Status
func (address *ApplicationGatewayBackendAddress_Status) AssignPropertiesToApplicationGatewayBackendAddress_Status(destination *v1alpha1api20201101storage.ApplicationGatewayBackendAddress_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&NetworkInterface{}, &NetworkInterfaceList{})
}
