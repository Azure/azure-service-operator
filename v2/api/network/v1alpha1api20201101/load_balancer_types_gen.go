// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	alpha20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Deprecated version of LoadBalancer. Use v1beta20201101.LoadBalancer instead
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancers_Spec  `json:"spec,omitempty"`
	Status            LoadBalancer_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &LoadBalancer{}

// GetConditions returns the conditions of the resource
func (balancer *LoadBalancer) GetConditions() conditions.Conditions {
	return balancer.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (balancer *LoadBalancer) SetConditions(conditions conditions.Conditions) {
	balancer.Status.Conditions = conditions
}

var _ conversion.Convertible = &LoadBalancer{}

// ConvertFrom populates our LoadBalancer from the provided hub LoadBalancer
func (balancer *LoadBalancer) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source alpha20201101s.LoadBalancer

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = balancer.AssignPropertiesFromLoadBalancer(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to balancer")
	}

	return nil
}

// ConvertTo populates the provided hub LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination alpha20201101s.LoadBalancer
	err := balancer.AssignPropertiesToLoadBalancer(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from balancer")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &LoadBalancer{}

// Default applies defaults to the LoadBalancer resource
func (balancer *LoadBalancer) Default() {
	balancer.defaultImpl()
	var temp interface{} = balancer
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (balancer *LoadBalancer) defaultAzureName() {
	if balancer.Spec.AzureName == "" {
		balancer.Spec.AzureName = balancer.Name
	}
}

// defaultImpl applies the code generated defaults to the LoadBalancer resource
func (balancer *LoadBalancer) defaultImpl() { balancer.defaultAzureName() }

var _ genruntime.KubernetesResource = &LoadBalancer{}

// AzureName returns the Azure name of the resource
func (balancer *LoadBalancer) AzureName() string {
	return balancer.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (balancer LoadBalancer) GetAPIVersion() string {
	return "2020-11-01"
}

// GetResourceKind returns the kind of the resource
func (balancer *LoadBalancer) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (balancer *LoadBalancer) GetSpec() genruntime.ConvertibleSpec {
	return &balancer.Spec
}

// GetStatus returns the status of this resource
func (balancer *LoadBalancer) GetStatus() genruntime.ConvertibleStatus {
	return &balancer.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/loadBalancers"
func (balancer *LoadBalancer) GetType() string {
	return "Microsoft.Network/loadBalancers"
}

// NewEmptyStatus returns a new empty (blank) status
func (balancer *LoadBalancer) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &LoadBalancer_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (balancer *LoadBalancer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(balancer.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  balancer.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (balancer *LoadBalancer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*LoadBalancer_Status); ok {
		balancer.Status = *st
		return nil
	}

	// Convert status to required version
	var st LoadBalancer_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	balancer.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &LoadBalancer{}

// ValidateCreate validates the creation of the resource
func (balancer *LoadBalancer) ValidateCreate() error {
	validations := balancer.createValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (balancer *LoadBalancer) ValidateDelete() error {
	validations := balancer.deleteValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (balancer *LoadBalancer) ValidateUpdate(old runtime.Object) error {
	validations := balancer.updateValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (balancer *LoadBalancer) createValidations() []func() error {
	return []func() error{balancer.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (balancer *LoadBalancer) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (balancer *LoadBalancer) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return balancer.validateResourceReferences()
		},
		balancer.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (balancer *LoadBalancer) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&balancer.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (balancer *LoadBalancer) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*LoadBalancer)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, balancer)
}

// AssignPropertiesFromLoadBalancer populates our LoadBalancer from the provided source LoadBalancer
func (balancer *LoadBalancer) AssignPropertiesFromLoadBalancer(source *alpha20201101s.LoadBalancer) error {

	// ObjectMeta
	balancer.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec LoadBalancers_Spec
	err := spec.AssignPropertiesFromLoadBalancersSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpec() to populate field Spec")
	}
	balancer.Spec = spec

	// Status
	var status LoadBalancer_Status
	err = status.AssignPropertiesFromLoadBalancerStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancerStatus() to populate field Status")
	}
	balancer.Status = status

	// No error
	return nil
}

// AssignPropertiesToLoadBalancer populates the provided destination LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) AssignPropertiesToLoadBalancer(destination *alpha20201101s.LoadBalancer) error {

	// ObjectMeta
	destination.ObjectMeta = *balancer.ObjectMeta.DeepCopy()

	// Spec
	var spec alpha20201101s.LoadBalancers_Spec
	err := balancer.Spec.AssignPropertiesToLoadBalancersSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status alpha20201101s.LoadBalancer_Status
	err = balancer.Status.AssignPropertiesToLoadBalancerStatus(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToLoadBalancerStatus() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (balancer *LoadBalancer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: balancer.Spec.OriginalVersion(),
		Kind:    "LoadBalancer",
	}
}

// +kubebuilder:object:root=true
// Deprecated version of LoadBalancer. Use v1beta20201101.LoadBalancer instead
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// Deprecated version of LoadBalancer_Status. Use v1beta20201101.LoadBalancer_Status instead
type LoadBalancer_Status struct {
	BackendAddressPools []BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded `json:"backendAddressPools,omitempty"`

	// Conditions: The observed state of the resource
	Conditions               []conditions.Condition                                            `json:"conditions,omitempty"`
	Etag                     *string                                                           `json:"etag,omitempty"`
	ExtendedLocation         *ExtendedLocation_Status                                          `json:"extendedLocation,omitempty"`
	FrontendIPConfigurations []FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`
	Id                       *string                                                           `json:"id,omitempty"`
	InboundNatPools          []InboundNatPool_Status                                           `json:"inboundNatPools,omitempty"`
	InboundNatRules          []InboundNatRule_Status_LoadBalancer_SubResourceEmbedded          `json:"inboundNatRules,omitempty"`
	LoadBalancingRules       []LoadBalancingRule_Status                                        `json:"loadBalancingRules,omitempty"`
	Location                 *string                                                           `json:"location,omitempty"`
	Name                     *string                                                           `json:"name,omitempty"`
	OutboundRules            []OutboundRule_Status                                             `json:"outboundRules,omitempty"`
	Probes                   []Probe_Status                                                    `json:"probes,omitempty"`
	ProvisioningState        *ProvisioningState_Status                                         `json:"provisioningState,omitempty"`
	ResourceGuid             *string                                                           `json:"resourceGuid,omitempty"`
	Sku                      *LoadBalancerSku_Status                                           `json:"sku,omitempty"`
	Tags                     map[string]string                                                 `json:"tags,omitempty"`
	Type                     *string                                                           `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &LoadBalancer_Status{}

// ConvertStatusFrom populates our LoadBalancer_Status from the provided source
func (balancer *LoadBalancer_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*alpha20201101s.LoadBalancer_Status)
	if ok {
		// Populate our instance from source
		return balancer.AssignPropertiesFromLoadBalancerStatus(src)
	}

	// Convert to an intermediate form
	src = &alpha20201101s.LoadBalancer_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = balancer.AssignPropertiesFromLoadBalancerStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our LoadBalancer_Status
func (balancer *LoadBalancer_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*alpha20201101s.LoadBalancer_Status)
	if ok {
		// Populate destination from our instance
		return balancer.AssignPropertiesToLoadBalancerStatus(dst)
	}

	// Convert to an intermediate form
	dst = &alpha20201101s.LoadBalancer_Status{}
	err := balancer.AssignPropertiesToLoadBalancerStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &LoadBalancer_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *LoadBalancer_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancer_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *LoadBalancer_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancer_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancer_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.BackendAddressPools = append(balancer.BackendAddressPools, item1)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		balancer.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		balancer.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.FrontendIPConfigurations = append(balancer.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		balancer.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatPools = append(balancer.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatRules = append(balancer.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.LoadBalancingRules = append(balancer.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		balancer.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancer.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.OutboundRules = append(balancer.OutboundRules, item1)
		}
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.Probes = append(balancer.Probes, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			balancer.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			balancer.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		balancer.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		balancer.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			balancer.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		balancer.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerStatus populates our LoadBalancer_Status from the provided source LoadBalancer_Status
func (balancer *LoadBalancer_Status) AssignPropertiesFromLoadBalancerStatus(source *alpha20201101s.LoadBalancer_Status) error {

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := backendAddressPool.AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// Conditions
	balancer.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	balancer.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationStatus() to populate field ExtendedLocation")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfiguration.AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// Id
	balancer.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool_Status, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool_Status
			err := inboundNatPool.AssignPropertiesFromInboundNatPoolStatus(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatPoolStatus() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := inboundNatRule.AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule_Status
			err := loadBalancingRule.AssignPropertiesFromLoadBalancingRuleStatus(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancingRuleStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	balancer.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule_Status, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule_Status
			err := outboundRule.AssignPropertiesFromOutboundRuleStatus(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromOutboundRuleStatus() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe_Status, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe_Status
			err := probe.AssignPropertiesFromProbeStatus(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromProbeStatus() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		balancer.ProvisioningState = &provisioningState
	} else {
		balancer.ProvisioningState = nil
	}

	// ResourceGuid
	balancer.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_Status
		err := sku.AssignPropertiesFromLoadBalancerSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancerSkuStatus() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	balancer.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerStatus populates the provided destination LoadBalancer_Status from our LoadBalancer_Status
func (balancer *LoadBalancer_Status) AssignPropertiesToLoadBalancerStatus(destination *alpha20201101s.LoadBalancer_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]alpha20201101s.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool alpha20201101s.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := backendAddressPoolItem.AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(balancer.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(balancer.Etag)

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocation alpha20201101s.ExtendedLocation_Status
		err := balancer.ExtendedLocation.AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationStatus() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]alpha20201101s.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration alpha20201101s.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfigurationItem.AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(balancer.Id)

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]alpha20201101s.InboundNatPool_Status, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool alpha20201101s.InboundNatPool_Status
			err := inboundNatPoolItem.AssignPropertiesToInboundNatPoolStatus(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatPoolStatus() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]alpha20201101s.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule alpha20201101s.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := inboundNatRuleItem.AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]alpha20201101s.LoadBalancingRule_Status, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule alpha20201101s.LoadBalancingRule_Status
			err := loadBalancingRuleItem.AssignPropertiesToLoadBalancingRuleStatus(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancingRuleStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancer.Name)

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]alpha20201101s.OutboundRule_Status, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule alpha20201101s.OutboundRule_Status
			err := outboundRuleItem.AssignPropertiesToOutboundRuleStatus(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToOutboundRuleStatus() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]alpha20201101s.Probe_Status, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe alpha20201101s.Probe_Status
			err := probeItem.AssignPropertiesToProbeStatus(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToProbeStatus() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// ProvisioningState
	if balancer.ProvisioningState != nil {
		provisioningState := string(*balancer.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(balancer.ResourceGuid)

	// Sku
	if balancer.Sku != nil {
		var sku alpha20201101s.LoadBalancerSku_Status
		err := balancer.Sku.AssignPropertiesToLoadBalancerSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLoadBalancerSkuStatus() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(balancer.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancers_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                string                                                   `json:"azureName,omitempty"`
	BackendAddressPools      []LoadBalancers_Spec_Properties_BackendAddressPools      `json:"backendAddressPools,omitempty"`
	ExtendedLocation         *ExtendedLocation                                        `json:"extendedLocation,omitempty"`
	FrontendIPConfigurations []LoadBalancers_Spec_Properties_FrontendIPConfigurations `json:"frontendIPConfigurations,omitempty"`
	InboundNatPools          []LoadBalancers_Spec_Properties_InboundNatPools          `json:"inboundNatPools,omitempty"`
	LoadBalancingRules       []LoadBalancers_Spec_Properties_LoadBalancingRules       `json:"loadBalancingRules,omitempty"`
	Location                 *string                                                  `json:"location,omitempty"`
	OutboundRules            []LoadBalancers_Spec_Properties_OutboundRules            `json:"outboundRules,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner  *genruntime.KnownResourceReference     `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Probes []LoadBalancers_Spec_Properties_Probes `json:"probes,omitempty"`
	Sku    *LoadBalancerSku                       `json:"sku,omitempty"`
	Tags   map[string]string                      `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancers *LoadBalancers_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancers == nil {
		return nil, nil
	}
	var result LoadBalancers_SpecARM

	// Set property ‘ExtendedLocation’:
	if balancers.ExtendedLocation != nil {
		extendedLocationARM, err := (*balancers.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Location’:
	if balancers.Location != nil {
		location := *balancers.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if balancers.BackendAddressPools != nil ||
		balancers.FrontendIPConfigurations != nil ||
		balancers.InboundNatPools != nil ||
		balancers.LoadBalancingRules != nil ||
		balancers.OutboundRules != nil ||
		balancers.Probes != nil {
		result.Properties = &LoadBalancers_Spec_PropertiesARM{}
	}
	for _, item := range balancers.BackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddressPools = append(result.Properties.BackendAddressPools, itemARM.(LoadBalancers_Spec_Properties_BackendAddressPoolsARM))
	}
	for _, item := range balancers.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM))
	}
	for _, item := range balancers.InboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatPools = append(result.Properties.InboundNatPools, itemARM.(LoadBalancers_Spec_Properties_InboundNatPoolsARM))
	}
	for _, item := range balancers.LoadBalancingRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancingRules = append(result.Properties.LoadBalancingRules, itemARM.(LoadBalancers_Spec_Properties_LoadBalancingRulesARM))
	}
	for _, item := range balancers.OutboundRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.OutboundRules = append(result.Properties.OutboundRules, itemARM.(LoadBalancers_Spec_Properties_OutboundRulesARM))
	}
	for _, item := range balancers.Probes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Probes = append(result.Properties.Probes, itemARM.(LoadBalancers_Spec_Properties_ProbesARM))
	}

	// Set property ‘Sku’:
	if balancers.Sku != nil {
		skuARM, err := (*balancers.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(LoadBalancerSkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if balancers.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range balancers.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancers *LoadBalancers_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancers *LoadBalancers_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	balancers.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 LoadBalancers_Spec_Properties_BackendAddressPools
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.BackendAddressPools = append(balancers.BackendAddressPools, item1)
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		balancers.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 LoadBalancers_Spec_Properties_FrontendIPConfigurations
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.FrontendIPConfigurations = append(balancers.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 LoadBalancers_Spec_Properties_InboundNatPools
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.InboundNatPools = append(balancers.InboundNatPools, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancers_Spec_Properties_LoadBalancingRules
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.LoadBalancingRules = append(balancers.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		balancers.Location = &location
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 LoadBalancers_Spec_Properties_OutboundRules
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.OutboundRules = append(balancers.OutboundRules, item1)
		}
	}

	// Set property ‘Owner’:
	balancers.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 LoadBalancers_Spec_Properties_Probes
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancers.Probes = append(balancers.Probes, item1)
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		balancers.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		balancers.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			balancers.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &LoadBalancers_Spec{}

// ConvertSpecFrom populates our LoadBalancers_Spec from the provided source
func (balancers *LoadBalancers_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*alpha20201101s.LoadBalancers_Spec)
	if ok {
		// Populate our instance from source
		return balancers.AssignPropertiesFromLoadBalancersSpec(src)
	}

	// Convert to an intermediate form
	src = &alpha20201101s.LoadBalancers_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = balancers.AssignPropertiesFromLoadBalancersSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our LoadBalancers_Spec
func (balancers *LoadBalancers_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*alpha20201101s.LoadBalancers_Spec)
	if ok {
		// Populate destination from our instance
		return balancers.AssignPropertiesToLoadBalancersSpec(dst)
	}

	// Convert to an intermediate form
	dst = &alpha20201101s.LoadBalancers_Spec{}
	err := balancers.AssignPropertiesToLoadBalancersSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromLoadBalancersSpec populates our LoadBalancers_Spec from the provided source LoadBalancers_Spec
func (balancers *LoadBalancers_Spec) AssignPropertiesFromLoadBalancersSpec(source *alpha20201101s.LoadBalancers_Spec) error {

	// AzureName
	balancers.AzureName = source.AzureName

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]LoadBalancers_Spec_Properties_BackendAddressPools, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool LoadBalancers_Spec_Properties_BackendAddressPools
			err := backendAddressPool.AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancers.BackendAddressPools = backendAddressPoolList
	} else {
		balancers.BackendAddressPools = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		balancers.ExtendedLocation = &extendedLocation
	} else {
		balancers.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]LoadBalancers_Spec_Properties_FrontendIPConfigurations, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration LoadBalancers_Spec_Properties_FrontendIPConfigurations
			err := frontendIPConfiguration.AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancers.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancers.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]LoadBalancers_Spec_Properties_InboundNatPools, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool LoadBalancers_Spec_Properties_InboundNatPools
			err := inboundNatPool.AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancers.InboundNatPools = inboundNatPoolList
	} else {
		balancers.InboundNatPools = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancers_Spec_Properties_LoadBalancingRules, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancers_Spec_Properties_LoadBalancingRules
			err := loadBalancingRule.AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancers.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancers.LoadBalancingRules = nil
	}

	// Location
	balancers.Location = genruntime.ClonePointerToString(source.Location)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]LoadBalancers_Spec_Properties_OutboundRules, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule LoadBalancers_Spec_Properties_OutboundRules
			err := outboundRule.AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancers.OutboundRules = outboundRuleList
	} else {
		balancers.OutboundRules = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		balancers.Owner = &owner
	} else {
		balancers.Owner = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]LoadBalancers_Spec_Properties_Probes, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe LoadBalancers_Spec_Properties_Probes
			err := probe.AssignPropertiesFromLoadBalancersSpecPropertiesProbes(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesProbes() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancers.Probes = probeList
	} else {
		balancers.Probes = nil
	}

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku
		err := sku.AssignPropertiesFromLoadBalancerSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancerSku() to populate field Sku")
		}
		balancers.Sku = &sku
	} else {
		balancers.Sku = nil
	}

	// Tags
	balancers.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpec populates the provided destination LoadBalancers_Spec from our LoadBalancers_Spec
func (balancers *LoadBalancers_Spec) AssignPropertiesToLoadBalancersSpec(destination *alpha20201101s.LoadBalancers_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = balancers.AzureName

	// BackendAddressPools
	if balancers.BackendAddressPools != nil {
		backendAddressPoolList := make([]alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools, len(balancers.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancers.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools
			err := backendAddressPoolItem.AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// ExtendedLocation
	if balancers.ExtendedLocation != nil {
		var extendedLocation alpha20201101s.ExtendedLocation
		err := balancers.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancers.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]alpha20201101s.LoadBalancers_Spec_Properties_FrontendIPConfigurations, len(balancers.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancers.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration alpha20201101s.LoadBalancers_Spec_Properties_FrontendIPConfigurations
			err := frontendIPConfigurationItem.AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if balancers.InboundNatPools != nil {
		inboundNatPoolList := make([]alpha20201101s.LoadBalancers_Spec_Properties_InboundNatPools, len(balancers.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancers.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool alpha20201101s.LoadBalancers_Spec_Properties_InboundNatPools
			err := inboundNatPoolItem.AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// LoadBalancingRules
	if balancers.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]alpha20201101s.LoadBalancers_Spec_Properties_LoadBalancingRules, len(balancers.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancers.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule alpha20201101s.LoadBalancers_Spec_Properties_LoadBalancingRules
			err := loadBalancingRuleItem.AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancers.Location)

	// OriginalVersion
	destination.OriginalVersion = balancers.OriginalVersion()

	// OutboundRules
	if balancers.OutboundRules != nil {
		outboundRuleList := make([]alpha20201101s.LoadBalancers_Spec_Properties_OutboundRules, len(balancers.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancers.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule alpha20201101s.LoadBalancers_Spec_Properties_OutboundRules
			err := outboundRuleItem.AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Owner
	if balancers.Owner != nil {
		owner := balancers.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Probes
	if balancers.Probes != nil {
		probeList := make([]alpha20201101s.LoadBalancers_Spec_Properties_Probes, len(balancers.Probes))
		for probeIndex, probeItem := range balancers.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe alpha20201101s.LoadBalancers_Spec_Properties_Probes
			err := probeItem.AssignPropertiesToLoadBalancersSpecPropertiesProbes(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesProbes() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Sku
	if balancers.Sku != nil {
		var sku alpha20201101s.LoadBalancerSku
		err := balancers.Sku.AssignPropertiesToLoadBalancerSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLoadBalancerSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancers.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (balancers *LoadBalancers_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (balancers *LoadBalancers_Spec) SetAzureName(azureName string) { balancers.AzureName = azureName }

// Deprecated version of BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded. Use v1beta20201101.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded instead
type BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded populates our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(source *alpha20201101s.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded populates the provided destination BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(destination *alpha20201101s.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ExtendedLocation. Use v1beta20201101.ExtendedLocation instead
type ExtendedLocation struct {
	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if location.Type != nil {
		typeVar := *location.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *alpha20201101s.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *alpha20201101s.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ExtendedLocation_Status. Use v1beta20201101.ExtendedLocation_Status instead
type ExtendedLocation_Status struct {
	Name *string                      `json:"name,omitempty"`
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *alpha20201101s.ExtendedLocation_Status) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *alpha20201101s.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded. Use v1beta20201101.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded instead
type FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded struct {
	Etag                      *string                                                  `json:"etag,omitempty"`
	Id                        *string                                                  `json:"id,omitempty"`
	InboundNatPools           []SubResource_Status                                     `json:"inboundNatPools,omitempty"`
	InboundNatRules           []SubResource_Status                                     `json:"inboundNatRules,omitempty"`
	LoadBalancingRules        []SubResource_Status                                     `json:"loadBalancingRules,omitempty"`
	Name                      *string                                                  `json:"name,omitempty"`
	OutboundRules             []SubResource_Status                                     `json:"outboundRules,omitempty"`
	PrivateIPAddress          *string                                                  `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *IPVersion_Status                                        `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *IPAllocationMethod_Status                               `json:"privateIPAllocationMethod,omitempty"`
	ProvisioningState         *ProvisioningState_Status                                `json:"provisioningState,omitempty"`
	PublicIPAddress           *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded `json:"publicIPAddress,omitempty"`
	PublicIPPrefix            *SubResource_Status                                      `json:"publicIPPrefix,omitempty"`
	Subnet                    *Subnet_Status_LoadBalancer_SubResourceEmbedded          `json:"subnet,omitempty"`
	Type                      *string                                                  `json:"type,omitempty"`
	Zones                     []string                                                 `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.InboundNatPools = append(embedded.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.InboundNatRules = append(embedded.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancingRules = append(embedded.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.OutboundRules = append(embedded.OutboundRules, item1)
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			embedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_LoadBalancer_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded populates our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(source *alpha20201101s.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]SubResource_Status, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool SubResource_Status
			err := inboundNatPool.AssignPropertiesFromSubResourceStatus(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		embedded.InboundNatPools = inboundNatPoolList
	} else {
		embedded.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]SubResource_Status, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule SubResource_Status
			err := inboundNatRule.AssignPropertiesFromSubResourceStatus(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		embedded.InboundNatRules = inboundNatRuleList
	} else {
		embedded.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_Status
			err := loadBalancingRule.AssignPropertiesFromSubResourceStatus(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		embedded.LoadBalancingRules = loadBalancingRuleList
	} else {
		embedded.LoadBalancingRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_Status, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule SubResource_Status
			err := outboundRule.AssignPropertiesFromSubResourceStatus(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		embedded.OutboundRules = outboundRuleList
	} else {
		embedded.OutboundRules = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResourceStatus(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field PublicIPPrefix")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded populates the provided destination FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(destination *alpha20201101s.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// InboundNatPools
	if embedded.InboundNatPools != nil {
		inboundNatPoolList := make([]alpha20201101s.SubResource_Status, len(embedded.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range embedded.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool alpha20201101s.SubResource_Status
			err := inboundNatPoolItem.AssignPropertiesToSubResourceStatus(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if embedded.InboundNatRules != nil {
		inboundNatRuleList := make([]alpha20201101s.SubResource_Status, len(embedded.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range embedded.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule alpha20201101s.SubResource_Status
			err := inboundNatRuleItem.AssignPropertiesToSubResourceStatus(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if embedded.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]alpha20201101s.SubResource_Status, len(embedded.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range embedded.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule alpha20201101s.SubResource_Status
			err := loadBalancingRuleItem.AssignPropertiesToSubResourceStatus(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// OutboundRules
	if embedded.OutboundRules != nil {
		outboundRuleList := make([]alpha20201101s.SubResource_Status, len(embedded.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range embedded.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule alpha20201101s.SubResource_Status
			err := outboundRuleItem.AssignPropertiesToSubResourceStatus(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress alpha20201101s.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var publicIPPrefix alpha20201101s.SubResource_Status
		err := embedded.PublicIPPrefix.AssignPropertiesToSubResourceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet alpha20201101s.Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of InboundNatPool_Status. Use v1beta20201101.InboundNatPool_Status instead
type InboundNatPool_Status struct {
	BackendPort             *int                      `json:"backendPort,omitempty"`
	EnableFloatingIP        *bool                     `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                     `json:"enableTcpReset,omitempty"`
	Etag                    *string                   `json:"etag,omitempty"`
	FrontendIPConfiguration *SubResource_Status       `json:"frontendIPConfiguration,omitempty"`
	FrontendPortRangeEnd    *int                      `json:"frontendPortRangeEnd,omitempty"`
	FrontendPortRangeStart  *int                      `json:"frontendPortRangeStart,omitempty"`
	Id                      *string                   `json:"id,omitempty"`
	IdleTimeoutInMinutes    *int                      `json:"idleTimeoutInMinutes,omitempty"`
	Name                    *string                   `json:"name,omitempty"`
	Protocol                *TransportProtocol_Status `json:"protocol,omitempty"`
	ProvisioningState       *ProvisioningState_Status `json:"provisioningState,omitempty"`
	Type                    *string                   `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatPool_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *InboundNatPool_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *InboundNatPool_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			pool.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pool.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pool.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		pool.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pool.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeEnd != nil {
			frontendPortRangeEnd := *typedInput.Properties.FrontendPortRangeEnd
			pool.FrontendPortRangeEnd = &frontendPortRangeEnd
		}
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeStart != nil {
			frontendPortRangeStart := *typedInput.Properties.FrontendPortRangeStart
			pool.FrontendPortRangeStart = &frontendPortRangeStart
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pool.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			pool.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			pool.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		pool.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatPoolStatus populates our InboundNatPool_Status from the provided source InboundNatPool_Status
func (pool *InboundNatPool_Status) AssignPropertiesFromInboundNatPoolStatus(source *alpha20201101s.InboundNatPool_Status) error {

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// Etag
	pool.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field FrontendIPConfiguration")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		pool.Protocol = &protocol
	} else {
		pool.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		pool.ProvisioningState = &provisioningState
	} else {
		pool.ProvisioningState = nil
	}

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToInboundNatPoolStatus populates the provided destination InboundNatPool_Status from our InboundNatPool_Status
func (pool *InboundNatPool_Status) AssignPropertiesToInboundNatPoolStatus(destination *alpha20201101s.InboundNatPool_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(pool.Etag)

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var frontendIPConfiguration alpha20201101s.SubResource_Status
		err := pool.FrontendIPConfiguration.AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	if pool.Protocol != nil {
		protocol := string(*pool.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if pool.ProvisioningState != nil {
		provisioningState := string(*pool.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of InboundNatRule_Status_LoadBalancer_SubResourceEmbedded. Use v1beta20201101.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded instead
type InboundNatRule_Status_LoadBalancer_SubResourceEmbedded struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded populates our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded(source *alpha20201101s.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded populates the provided destination InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded(destination *alpha20201101s.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancerSku. Use v1beta20201101.LoadBalancerSku instead
type LoadBalancerSku struct {
	Name *LoadBalancerSkuName `json:"name,omitempty"`
	Tier *LoadBalancerSkuTier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancerSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancerSku *LoadBalancerSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancerSku == nil {
		return nil, nil
	}
	var result LoadBalancerSkuARM

	// Set property ‘Name’:
	if balancerSku.Name != nil {
		name := *balancerSku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if balancerSku.Tier != nil {
		tier := *balancerSku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSkuARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSku populates our LoadBalancerSku from the provided source LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignPropertiesFromLoadBalancerSku(source *alpha20201101s.LoadBalancerSku) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSkuName(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSkuTier(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSku populates the provided destination LoadBalancerSku from our LoadBalancerSku
func (balancerSku *LoadBalancerSku) AssignPropertiesToLoadBalancerSku(destination *alpha20201101s.LoadBalancerSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancerSku_Status. Use v1beta20201101.LoadBalancerSku_Status instead
type LoadBalancerSku_Status struct {
	Name *LoadBalancerSkuStatusName `json:"name,omitempty"`
	Tier *LoadBalancerSkuStatusTier `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancerSku_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSkuStatus populates our LoadBalancerSku_Status from the provided source LoadBalancerSku_Status
func (balancerSku *LoadBalancerSku_Status) AssignPropertiesFromLoadBalancerSkuStatus(source *alpha20201101s.LoadBalancerSku_Status) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSkuStatusName(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSkuStatusTier(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSkuStatus populates the provided destination LoadBalancerSku_Status from our LoadBalancerSku_Status
func (balancerSku *LoadBalancerSku_Status) AssignPropertiesToLoadBalancerSkuStatus(destination *alpha20201101s.LoadBalancerSku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_BackendAddressPools. Use v1beta20201101.LoadBalancers_Spec_Properties_BackendAddressPools instead
type LoadBalancers_Spec_Properties_BackendAddressPools struct {
	LoadBalancerBackendAddresses []LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses `json:"loadBalancerBackendAddresses,omitempty"`
	Location                     *string                                                                                     `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_BackendAddressPools{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pools *LoadBalancers_Spec_Properties_BackendAddressPools) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pools == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_BackendAddressPoolsARM

	// Set property ‘Name’:
	if pools.Name != nil {
		name := *pools.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pools.LoadBalancerBackendAddresses != nil || pools.Location != nil {
		result.Properties = &LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}
	}
	for _, item := range pools.LoadBalancerBackendAddresses {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddresses = append(result.Properties.LoadBalancerBackendAddresses, itemARM.(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM))
	}
	if pools.Location != nil {
		location := *pools.Location
		result.Properties.Location = &location
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pools *LoadBalancers_Spec_Properties_BackendAddressPools) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pools *LoadBalancers_Spec_Properties_BackendAddressPools) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_BackendAddressPoolsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_BackendAddressPoolsARM, got %T", armInput)
	}

	// Set property ‘LoadBalancerBackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddresses {
			var item1 LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pools.LoadBalancerBackendAddresses = append(pools.LoadBalancerBackendAddresses, item1)
		}
	}

	// Set property ‘Location’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Location != nil {
			location := *typedInput.Properties.Location
			pools.Location = &location
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pools.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools populates our LoadBalancers_Spec_Properties_BackendAddressPools from the provided source LoadBalancers_Spec_Properties_BackendAddressPools
func (pools *LoadBalancers_Spec_Properties_BackendAddressPools) AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools(source *alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools) error {

	// LoadBalancerBackendAddresses
	if source.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses, len(source.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
			err := loadBalancerBackendAddress.AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(&loadBalancerBackendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		pools.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		pools.LoadBalancerBackendAddresses = nil
	}

	// Location
	pools.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	pools.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools populates the provided destination LoadBalancers_Spec_Properties_BackendAddressPools from our LoadBalancers_Spec_Properties_BackendAddressPools
func (pools *LoadBalancers_Spec_Properties_BackendAddressPools) AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools(destination *alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LoadBalancerBackendAddresses
	if pools.LoadBalancerBackendAddresses != nil {
		loadBalancerBackendAddressList := make([]alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses, len(pools.LoadBalancerBackendAddresses))
		for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range pools.LoadBalancerBackendAddresses {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
			var loadBalancerBackendAddress alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
			err := loadBalancerBackendAddressItem.AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(&loadBalancerBackendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses() to populate field LoadBalancerBackendAddresses")
			}
			loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
		}
		destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList
	} else {
		destination.LoadBalancerBackendAddresses = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(pools.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(pools.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_FrontendIPConfigurations. Use v1beta20201101.LoadBalancers_Spec_Properties_FrontendIPConfigurations instead
type LoadBalancers_Spec_Properties_FrontendIPConfigurations struct {
	// +kubebuilder:validation:Required
	Name                      *string                                                           `json:"name,omitempty"`
	PrivateIPAddress          *string                                                           `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion   `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	PublicIPAddress           *SubResource                                                      `json:"publicIPAddress,omitempty"`
	PublicIPPrefix            *SubResource                                                      `json:"publicIPPrefix,omitempty"`
	Subnet                    *SubResource                                                      `json:"subnet,omitempty"`
	Zones                     []string                                                          `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_FrontendIPConfigurations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configurations == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM

	// Set property ‘Name’:
	if configurations.Name != nil {
		name := *configurations.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configurations.PrivateIPAddress != nil ||
		configurations.PrivateIPAddressVersion != nil ||
		configurations.PrivateIPAllocationMethod != nil ||
		configurations.PublicIPAddress != nil ||
		configurations.PublicIPPrefix != nil ||
		configurations.Subnet != nil {
		result.Properties = &FrontendIPConfigurationPropertiesFormatARM{}
	}
	if configurations.PrivateIPAddress != nil {
		privateIPAddress := *configurations.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if configurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *configurations.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configurations.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *configurations.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if configurations.PublicIPAddress != nil {
		publicIPAddressARM, err := (*configurations.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := publicIPAddressARM.(SubResourceARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if configurations.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*configurations.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResourceARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if configurations.Subnet != nil {
		subnetARM, err := (*configurations.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(SubResourceARM)
		result.Properties.Subnet = &subnet
	}

	// Set property ‘Zones’:
	for _, item := range configurations.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configurations.Name = &name
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			configurations.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configurations.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			configurations.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 SubResource
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			configurations.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configurations.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configurations.Subnet = &subnet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		configurations.Zones = append(configurations.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations populates our LoadBalancers_Spec_Properties_FrontendIPConfigurations from the provided source LoadBalancers_Spec_Properties_FrontendIPConfigurations
func (configurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations(source *alpha20201101s.LoadBalancers_Spec_Properties_FrontendIPConfigurations) error {

	// Name
	configurations.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	configurations.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		configurations.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configurations.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod(*source.PrivateIPAllocationMethod)
		configurations.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		configurations.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress SubResource
		err := publicIPAddress.AssignPropertiesFromSubResource(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field PublicIPAddress")
		}
		configurations.PublicIPAddress = &publicIPAddress
	} else {
		configurations.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignPropertiesFromSubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field PublicIPPrefix")
		}
		configurations.PublicIPPrefix = &publicIPPrefix
	} else {
		configurations.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignPropertiesFromSubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field Subnet")
		}
		configurations.Subnet = &subnet
	} else {
		configurations.Subnet = nil
	}

	// Zones
	configurations.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations populates the provided destination LoadBalancers_Spec_Properties_FrontendIPConfigurations from our LoadBalancers_Spec_Properties_FrontendIPConfigurations
func (configurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations(destination *alpha20201101s.LoadBalancers_Spec_Properties_FrontendIPConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(configurations.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(configurations.PrivateIPAddress)

	// PrivateIPAddressVersion
	if configurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configurations.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if configurations.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*configurations.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if configurations.PublicIPAddress != nil {
		var publicIPAddress alpha20201101s.SubResource
		err := configurations.PublicIPAddress.AssignPropertiesToSubResource(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if configurations.PublicIPPrefix != nil {
		var publicIPPrefix alpha20201101s.SubResource
		err := configurations.PublicIPPrefix.AssignPropertiesToSubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if configurations.Subnet != nil {
		var subnet alpha20201101s.SubResource
		err := configurations.Subnet.AssignPropertiesToSubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(configurations.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_InboundNatPools. Use v1beta20201101.LoadBalancers_Spec_Properties_InboundNatPools instead
type LoadBalancers_Spec_Properties_InboundNatPools struct {
	// +kubebuilder:validation:Required
	BackendPort      *int  `json:"backendPort,omitempty"`
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`
	EnableTcpReset   *bool `json:"enableTcpReset,omitempty"`

	// +kubebuilder:validation:Required
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`
	IdleTimeoutInMinutes   *int `json:"idleTimeoutInMinutes,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *InboundNatPoolPropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_InboundNatPools{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pools *LoadBalancers_Spec_Properties_InboundNatPools) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pools == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_InboundNatPoolsARM

	// Set property ‘Name’:
	if pools.Name != nil {
		name := *pools.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pools.BackendPort != nil ||
		pools.EnableFloatingIP != nil ||
		pools.EnableTcpReset != nil ||
		pools.FrontendIPConfiguration != nil ||
		pools.FrontendPortRangeEnd != nil ||
		pools.FrontendPortRangeStart != nil ||
		pools.IdleTimeoutInMinutes != nil ||
		pools.Protocol != nil {
		result.Properties = &InboundNatPoolPropertiesFormatARM{}
	}
	if pools.BackendPort != nil {
		backendPort := *pools.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if pools.EnableFloatingIP != nil {
		enableFloatingIP := *pools.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if pools.EnableTcpReset != nil {
		enableTcpReset := *pools.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if pools.FrontendIPConfiguration != nil {
		frontendIPConfigurationARM, err := (*pools.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := frontendIPConfigurationARM.(SubResourceARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if pools.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *pools.FrontendPortRangeEnd
		result.Properties.FrontendPortRangeEnd = &frontendPortRangeEnd
	}
	if pools.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *pools.FrontendPortRangeStart
		result.Properties.FrontendPortRangeStart = &frontendPortRangeStart
	}
	if pools.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *pools.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if pools.Protocol != nil {
		protocol := *pools.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pools *LoadBalancers_Spec_Properties_InboundNatPools) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_InboundNatPoolsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pools *LoadBalancers_Spec_Properties_InboundNatPools) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_InboundNatPoolsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_InboundNatPoolsARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			pools.BackendPort = &backendPort
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pools.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pools.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pools.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeEnd != nil {
			frontendPortRangeEnd := *typedInput.Properties.FrontendPortRangeEnd
			pools.FrontendPortRangeEnd = &frontendPortRangeEnd
		}
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPortRangeStart != nil {
			frontendPortRangeStart := *typedInput.Properties.FrontendPortRangeStart
			pools.FrontendPortRangeStart = &frontendPortRangeStart
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pools.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pools.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			pools.Protocol = &protocol
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools populates our LoadBalancers_Spec_Properties_InboundNatPools from the provided source LoadBalancers_Spec_Properties_InboundNatPools
func (pools *LoadBalancers_Spec_Properties_InboundNatPools) AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools(source *alpha20201101s.LoadBalancers_Spec_Properties_InboundNatPools) error {

	// BackendPort
	pools.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pools.EnableFloatingIP = &enableFloatingIP
	} else {
		pools.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pools.EnableTcpReset = &enableTcpReset
	} else {
		pools.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignPropertiesFromSubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field FrontendIPConfiguration")
		}
		pools.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pools.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pools.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pools.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	pools.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pools.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := InboundNatPoolPropertiesFormatProtocol(*source.Protocol)
		pools.Protocol = &protocol
	} else {
		pools.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools populates the provided destination LoadBalancers_Spec_Properties_InboundNatPools from our LoadBalancers_Spec_Properties_InboundNatPools
func (pools *LoadBalancers_Spec_Properties_InboundNatPools) AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools(destination *alpha20201101s.LoadBalancers_Spec_Properties_InboundNatPools) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pools.BackendPort)

	// EnableFloatingIP
	if pools.EnableFloatingIP != nil {
		enableFloatingIP := *pools.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pools.EnableTcpReset != nil {
		enableTcpReset := *pools.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if pools.FrontendIPConfiguration != nil {
		var frontendIPConfiguration alpha20201101s.SubResource
		err := pools.FrontendIPConfiguration.AssignPropertiesToSubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pools.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pools.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pools.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pools.Name)

	// Protocol
	if pools.Protocol != nil {
		protocol := string(*pools.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_LoadBalancingRules. Use v1beta20201101.LoadBalancers_Spec_Properties_LoadBalancingRules instead
type LoadBalancers_Spec_Properties_LoadBalancingRules struct {
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	// +kubebuilder:validation:Required
	BackendPort         *int  `json:"backendPort,omitempty"`
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`
	EnableFloatingIP    *bool `json:"enableFloatingIP,omitempty"`
	EnableTcpReset      *bool `json:"enableTcpReset,omitempty"`

	// +kubebuilder:validation:Required
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPort         *int                                               `json:"frontendPort,omitempty"`
	IdleTimeoutInMinutes *int                                               `json:"idleTimeoutInMinutes,omitempty"`
	LoadDistribution     *LoadBalancingRulePropertiesFormatLoadDistribution `json:"loadDistribution,omitempty"`

	// +kubebuilder:validation:Required
	Name  *string      `json:"name,omitempty"`
	Probe *SubResource `json:"probe,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *LoadBalancingRulePropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_LoadBalancingRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *LoadBalancers_Spec_Properties_LoadBalancingRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_LoadBalancingRulesARM

	// Set property ‘Name’:
	if rules.Name != nil {
		name := *rules.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rules.BackendAddressPool != nil ||
		rules.BackendPort != nil ||
		rules.DisableOutboundSnat != nil ||
		rules.EnableFloatingIP != nil ||
		rules.EnableTcpReset != nil ||
		rules.FrontendIPConfiguration != nil ||
		rules.FrontendPort != nil ||
		rules.IdleTimeoutInMinutes != nil ||
		rules.LoadDistribution != nil ||
		rules.Probe != nil ||
		rules.Protocol != nil {
		result.Properties = &LoadBalancingRulePropertiesFormatARM{}
	}
	if rules.BackendAddressPool != nil {
		backendAddressPoolARM, err := (*rules.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := backendAddressPoolARM.(SubResourceARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rules.BackendPort != nil {
		backendPort := *rules.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if rules.DisableOutboundSnat != nil {
		disableOutboundSnat := *rules.DisableOutboundSnat
		result.Properties.DisableOutboundSnat = &disableOutboundSnat
	}
	if rules.EnableFloatingIP != nil {
		enableFloatingIP := *rules.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if rules.EnableTcpReset != nil {
		enableTcpReset := *rules.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if rules.FrontendIPConfiguration != nil {
		frontendIPConfigurationARM, err := (*rules.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := frontendIPConfigurationARM.(SubResourceARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if rules.FrontendPort != nil {
		frontendPort := *rules.FrontendPort
		result.Properties.FrontendPort = &frontendPort
	}
	if rules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rules.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rules.LoadDistribution != nil {
		loadDistribution := *rules.LoadDistribution
		result.Properties.LoadDistribution = &loadDistribution
	}
	if rules.Probe != nil {
		probeARM, err := (*rules.Probe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		probe := probeARM.(SubResourceARM)
		result.Properties.Probe = &probe
	}
	if rules.Protocol != nil {
		protocol := *rules.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *LoadBalancers_Spec_Properties_LoadBalancingRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *LoadBalancers_Spec_Properties_LoadBalancingRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_LoadBalancingRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_LoadBalancingRulesARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rules.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rules.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rules.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rules.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rules.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rules.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rules.FrontendPort = &frontendPort
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rules.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rules.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rules.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rules.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rules.Protocol = &protocol
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules populates our LoadBalancers_Spec_Properties_LoadBalancingRules from the provided source LoadBalancers_Spec_Properties_LoadBalancingRules
func (rules *LoadBalancers_Spec_Properties_LoadBalancingRules) AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules(source *alpha20201101s.LoadBalancers_Spec_Properties_LoadBalancingRules) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignPropertiesFromSubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field BackendAddressPool")
		}
		rules.BackendAddressPool = &backendAddressPool
	} else {
		rules.BackendAddressPool = nil
	}

	// BackendPort
	rules.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rules.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rules.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rules.EnableFloatingIP = &enableFloatingIP
	} else {
		rules.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rules.EnableTcpReset = &enableTcpReset
	} else {
		rules.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignPropertiesFromSubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field FrontendIPConfiguration")
		}
		rules.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rules.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rules.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// IdleTimeoutInMinutes
	rules.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormatLoadDistribution(*source.LoadDistribution)
		rules.LoadDistribution = &loadDistribution
	} else {
		rules.LoadDistribution = nil
	}

	// Name
	rules.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource
		err := probe.AssignPropertiesFromSubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field Probe")
		}
		rules.Probe = &probe
	} else {
		rules.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := LoadBalancingRulePropertiesFormatProtocol(*source.Protocol)
		rules.Protocol = &protocol
	} else {
		rules.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules populates the provided destination LoadBalancers_Spec_Properties_LoadBalancingRules from our LoadBalancers_Spec_Properties_LoadBalancingRules
func (rules *LoadBalancers_Spec_Properties_LoadBalancingRules) AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules(destination *alpha20201101s.LoadBalancers_Spec_Properties_LoadBalancingRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rules.BackendAddressPool != nil {
		var backendAddressPool alpha20201101s.SubResource
		err := rules.BackendAddressPool.AssignPropertiesToSubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rules.BackendPort)

	// DisableOutboundSnat
	if rules.DisableOutboundSnat != nil {
		disableOutboundSnat := *rules.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rules.EnableFloatingIP != nil {
		enableFloatingIP := *rules.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rules.EnableTcpReset != nil {
		enableTcpReset := *rules.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if rules.FrontendIPConfiguration != nil {
		var frontendIPConfiguration alpha20201101s.SubResource
		err := rules.FrontendIPConfiguration.AssignPropertiesToSubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rules.FrontendPort)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rules.IdleTimeoutInMinutes)

	// LoadDistribution
	if rules.LoadDistribution != nil {
		loadDistribution := string(*rules.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rules.Name)

	// Probe
	if rules.Probe != nil {
		var probe alpha20201101s.SubResource
		err := rules.Probe.AssignPropertiesToSubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rules.Protocol != nil {
		protocol := string(*rules.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_OutboundRules. Use v1beta20201101.LoadBalancers_Spec_Properties_OutboundRules instead
type LoadBalancers_Spec_Properties_OutboundRules struct {
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// +kubebuilder:validation:Required
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	EnableTcpReset     *bool        `json:"enableTcpReset,omitempty"`

	// +kubebuilder:validation:Required
	FrontendIPConfigurations []SubResource `json:"frontendIPConfigurations,omitempty"`
	IdleTimeoutInMinutes     *int          `json:"idleTimeoutInMinutes,omitempty"`
	Name                     *string       `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *OutboundRulePropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_OutboundRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *LoadBalancers_Spec_Properties_OutboundRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_OutboundRulesARM

	// Set property ‘Name’:
	if rules.Name != nil {
		name := *rules.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rules.AllocatedOutboundPorts != nil ||
		rules.BackendAddressPool != nil ||
		rules.EnableTcpReset != nil ||
		rules.FrontendIPConfigurations != nil ||
		rules.IdleTimeoutInMinutes != nil ||
		rules.Protocol != nil {
		result.Properties = &OutboundRulePropertiesFormatARM{}
	}
	if rules.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *rules.AllocatedOutboundPorts
		result.Properties.AllocatedOutboundPorts = &allocatedOutboundPorts
	}
	if rules.BackendAddressPool != nil {
		backendAddressPoolARM, err := (*rules.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := backendAddressPoolARM.(SubResourceARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rules.EnableTcpReset != nil {
		enableTcpReset := *rules.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	for _, item := range rules.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(SubResourceARM))
	}
	if rules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rules.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rules.Protocol != nil {
		protocol := *rules.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *LoadBalancers_Spec_Properties_OutboundRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_OutboundRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *LoadBalancers_Spec_Properties_OutboundRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_OutboundRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_OutboundRulesARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rules.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rules.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rules.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rules.FrontendIPConfigurations = append(rules.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rules.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rules.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rules.Protocol = &protocol
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules populates our LoadBalancers_Spec_Properties_OutboundRules from the provided source LoadBalancers_Spec_Properties_OutboundRules
func (rules *LoadBalancers_Spec_Properties_OutboundRules) AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules(source *alpha20201101s.LoadBalancers_Spec_Properties_OutboundRules) error {

	// AllocatedOutboundPorts
	rules.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignPropertiesFromSubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field BackendAddressPool")
		}
		rules.BackendAddressPool = &backendAddressPool
	} else {
		rules.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rules.EnableTcpReset = &enableTcpReset
	} else {
		rules.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource
			err := frontendIPConfiguration.AssignPropertiesFromSubResource(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rules.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rules.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	rules.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rules.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormatProtocol(*source.Protocol)
		rules.Protocol = &protocol
	} else {
		rules.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules populates the provided destination LoadBalancers_Spec_Properties_OutboundRules from our LoadBalancers_Spec_Properties_OutboundRules
func (rules *LoadBalancers_Spec_Properties_OutboundRules) AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules(destination *alpha20201101s.LoadBalancers_Spec_Properties_OutboundRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rules.AllocatedOutboundPorts)

	// BackendAddressPool
	if rules.BackendAddressPool != nil {
		var backendAddressPool alpha20201101s.SubResource
		err := rules.BackendAddressPool.AssignPropertiesToSubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rules.EnableTcpReset != nil {
		enableTcpReset := *rules.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if rules.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]alpha20201101s.SubResource, len(rules.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rules.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration alpha20201101s.SubResource
			err := frontendIPConfigurationItem.AssignPropertiesToSubResource(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rules.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rules.Name)

	// Protocol
	if rules.Protocol != nil {
		protocol := string(*rules.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancers_Spec_Properties_Probes. Use v1beta20201101.LoadBalancers_Spec_Properties_Probes instead
type LoadBalancers_Spec_Properties_Probes struct {
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	// +kubebuilder:validation:Required
	Port *int `json:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol    *ProbePropertiesFormatProtocol `json:"protocol,omitempty"`
	RequestPath *string                        `json:"requestPath,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_Probes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probes *LoadBalancers_Spec_Properties_Probes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probes == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_ProbesARM

	// Set property ‘Name’:
	if probes.Name != nil {
		name := *probes.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if probes.IntervalInSeconds != nil ||
		probes.NumberOfProbes != nil ||
		probes.Port != nil ||
		probes.Protocol != nil ||
		probes.RequestPath != nil {
		result.Properties = &ProbePropertiesFormatARM{}
	}
	if probes.IntervalInSeconds != nil {
		intervalInSeconds := *probes.IntervalInSeconds
		result.Properties.IntervalInSeconds = &intervalInSeconds
	}
	if probes.NumberOfProbes != nil {
		numberOfProbes := *probes.NumberOfProbes
		result.Properties.NumberOfProbes = &numberOfProbes
	}
	if probes.Port != nil {
		port := *probes.Port
		result.Properties.Port = &port
	}
	if probes.Protocol != nil {
		protocol := *probes.Protocol
		result.Properties.Protocol = &protocol
	}
	if probes.RequestPath != nil {
		requestPath := *probes.RequestPath
		result.Properties.RequestPath = &requestPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probes *LoadBalancers_Spec_Properties_Probes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_ProbesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probes *LoadBalancers_Spec_Properties_Probes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_ProbesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_ProbesARM, got %T", armInput)
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probes.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probes.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probes.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			probes.Port = &port
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			probes.Protocol = &protocol
		}
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probes.RequestPath = &requestPath
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesProbes populates our LoadBalancers_Spec_Properties_Probes from the provided source LoadBalancers_Spec_Properties_Probes
func (probes *LoadBalancers_Spec_Properties_Probes) AssignPropertiesFromLoadBalancersSpecPropertiesProbes(source *alpha20201101s.LoadBalancers_Spec_Properties_Probes) error {

	// IntervalInSeconds
	probes.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Name
	probes.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probes.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probes.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormatProtocol(*source.Protocol)
		probes.Protocol = &protocol
	} else {
		probes.Protocol = nil
	}

	// RequestPath
	probes.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesProbes populates the provided destination LoadBalancers_Spec_Properties_Probes from our LoadBalancers_Spec_Properties_Probes
func (probes *LoadBalancers_Spec_Properties_Probes) AssignPropertiesToLoadBalancersSpecPropertiesProbes(destination *alpha20201101s.LoadBalancers_Spec_Properties_Probes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probes.IntervalInSeconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(probes.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probes.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probes.Port)

	// Protocol
	if probes.Protocol != nil {
		protocol := string(*probes.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probes.RequestPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancingRule_Status. Use v1beta20201101.LoadBalancingRule_Status instead
type LoadBalancingRule_Status struct {
	BackendAddressPool      *SubResource_Status                                      `json:"backendAddressPool,omitempty"`
	BackendPort             *int                                                     `json:"backendPort,omitempty"`
	DisableOutboundSnat     *bool                                                    `json:"disableOutboundSnat,omitempty"`
	EnableFloatingIP        *bool                                                    `json:"enableFloatingIP,omitempty"`
	EnableTcpReset          *bool                                                    `json:"enableTcpReset,omitempty"`
	Etag                    *string                                                  `json:"etag,omitempty"`
	FrontendIPConfiguration *SubResource_Status                                      `json:"frontendIPConfiguration,omitempty"`
	FrontendPort            *int                                                     `json:"frontendPort,omitempty"`
	Id                      *string                                                  `json:"id,omitempty"`
	IdleTimeoutInMinutes    *int                                                     `json:"idleTimeoutInMinutes,omitempty"`
	LoadDistribution        *LoadBalancingRulePropertiesFormatStatusLoadDistribution `json:"loadDistribution,omitempty"`
	Name                    *string                                                  `json:"name,omitempty"`
	Probe                   *SubResource_Status                                      `json:"probe,omitempty"`
	Protocol                *TransportProtocol_Status                                `json:"protocol,omitempty"`
	ProvisioningState       *ProvisioningState_Status                                `json:"provisioningState,omitempty"`
	Type                    *string                                                  `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancingRule_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *LoadBalancingRule_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *LoadBalancingRule_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_Status
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rule.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendPort != nil {
			frontendPort := *typedInput.Properties.FrontendPort
			rule.FrontendPort = &frontendPort
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rule.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource_Status
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rule.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancingRuleStatus populates our LoadBalancingRule_Status from the provided source LoadBalancingRule_Status
func (rule *LoadBalancingRule_Status) AssignPropertiesFromLoadBalancingRuleStatus(source *alpha20201101s.LoadBalancingRule_Status) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResourceStatus(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormatStatusLoadDistribution(*source.LoadDistribution)
		rule.LoadDistribution = &loadDistribution
	} else {
		rule.LoadDistribution = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource_Status
		err := probe.AssignPropertiesFromSubResourceStatus(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field Probe")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancingRuleStatus populates the provided destination LoadBalancingRule_Status from our LoadBalancingRule_Status
func (rule *LoadBalancingRule_Status) AssignPropertiesToLoadBalancingRuleStatus(destination *alpha20201101s.LoadBalancingRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool alpha20201101s.SubResource_Status
		err := rule.BackendAddressPool.AssignPropertiesToSubResourceStatus(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration alpha20201101s.SubResource_Status
		err := rule.FrontendIPConfiguration.AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	if rule.LoadDistribution != nil {
		loadDistribution := string(*rule.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var probe alpha20201101s.SubResource_Status
		err := rule.Probe.AssignPropertiesToSubResourceStatus(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of OutboundRule_Status. Use v1beta20201101.OutboundRule_Status instead
type OutboundRule_Status struct {
	AllocatedOutboundPorts   *int                                        `json:"allocatedOutboundPorts,omitempty"`
	BackendAddressPool       *SubResource_Status                         `json:"backendAddressPool,omitempty"`
	EnableTcpReset           *bool                                       `json:"enableTcpReset,omitempty"`
	Etag                     *string                                     `json:"etag,omitempty"`
	FrontendIPConfigurations []SubResource_Status                        `json:"frontendIPConfigurations,omitempty"`
	Id                       *string                                     `json:"id,omitempty"`
	IdleTimeoutInMinutes     *int                                        `json:"idleTimeoutInMinutes,omitempty"`
	Name                     *string                                     `json:"name,omitempty"`
	Protocol                 *OutboundRulePropertiesFormatStatusProtocol `json:"protocol,omitempty"`
	ProvisioningState        *ProvisioningState_Status                   `json:"provisioningState,omitempty"`
	Type                     *string                                     `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &OutboundRule_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_StatusARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rule.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_Status
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendIPConfigurations = append(rule.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			rule.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromOutboundRuleStatus populates our OutboundRule_Status from the provided source OutboundRule_Status
func (rule *OutboundRule_Status) AssignPropertiesFromOutboundRuleStatus(source *alpha20201101s.OutboundRule_Status) error {

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResourceStatus(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource_Status, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource_Status
			err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormatStatusProtocol(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToOutboundRuleStatus populates the provided destination OutboundRule_Status from our OutboundRule_Status
func (rule *OutboundRule_Status) AssignPropertiesToOutboundRuleStatus(destination *alpha20201101s.OutboundRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool alpha20201101s.SubResource_Status
		err := rule.BackendAddressPool.AssignPropertiesToSubResourceStatus(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]alpha20201101s.SubResource_Status, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration alpha20201101s.SubResource_Status
			err := frontendIPConfigurationItem.AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Probe_Status. Use v1beta20201101.Probe_Status instead
type Probe_Status struct {
	Etag               *string                              `json:"etag,omitempty"`
	Id                 *string                              `json:"id,omitempty"`
	IntervalInSeconds  *int                                 `json:"intervalInSeconds,omitempty"`
	LoadBalancingRules []SubResource_Status                 `json:"loadBalancingRules,omitempty"`
	Name               *string                              `json:"name,omitempty"`
	NumberOfProbes     *int                                 `json:"numberOfProbes,omitempty"`
	Port               *int                                 `json:"port,omitempty"`
	Protocol           *ProbePropertiesFormatStatusProtocol `json:"protocol,omitempty"`
	ProvisioningState  *ProvisioningState_Status            `json:"provisioningState,omitempty"`
	RequestPath        *string                              `json:"requestPath,omitempty"`
	Type               *string                              `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Probe_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *Probe_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *Probe_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_StatusARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		probe.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		probe.Id = &id
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probe.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			probe.LoadBalancingRules = append(probe.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probe.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Port != nil {
			port := *typedInput.Properties.Port
			probe.Port = &port
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			probe.Protocol = &protocol
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			probe.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probe.RequestPath = &requestPath
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		probe.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromProbeStatus populates our Probe_Status from the provided source Probe_Status
func (probe *Probe_Status) AssignPropertiesFromProbeStatus(source *alpha20201101s.Probe_Status) error {

	// Etag
	probe.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	probe.Id = genruntime.ClonePointerToString(source.Id)

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_Status
			err := loadBalancingRule.AssignPropertiesFromSubResourceStatus(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		probe.LoadBalancingRules = loadBalancingRuleList
	} else {
		probe.LoadBalancingRules = nil
	}

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormatStatusProtocol(*source.Protocol)
		probe.Protocol = &protocol
	} else {
		probe.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		probe.ProvisioningState = &provisioningState
	} else {
		probe.ProvisioningState = nil
	}

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToProbeStatus populates the provided destination Probe_Status from our Probe_Status
func (probe *Probe_Status) AssignPropertiesToProbeStatus(destination *alpha20201101s.Probe_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(probe.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(probe.Id)

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// LoadBalancingRules
	if probe.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]alpha20201101s.SubResource_Status, len(probe.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range probe.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule alpha20201101s.SubResource_Status
			err := loadBalancingRuleItem.AssignPropertiesToSubResourceStatus(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if probe.ProvisioningState != nil {
		provisioningState := string(*probe.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ProvisioningState_Status. Use v1beta20201101.ProvisioningState_Status instead
type ProvisioningState_Status string

const (
	ProvisioningState_StatusDeleting  = ProvisioningState_Status("Deleting")
	ProvisioningState_StatusFailed    = ProvisioningState_Status("Failed")
	ProvisioningState_StatusSucceeded = ProvisioningState_Status("Succeeded")
	ProvisioningState_StatusUpdating  = ProvisioningState_Status("Updating")
)

// Deprecated version of FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion. Use
// v1beta20201101.FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion instead
// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion string

const (
	FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv4 = FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion("IPv4")
	FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv6 = FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion("IPv6")
)

// Deprecated version of FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod. Use
// v1beta20201101.FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod instead
// +kubebuilder:validation:Enum={"Dynamic","Static"}
type FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod string

const (
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodDynamic = FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod("Dynamic")
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodStatic  = FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod("Static")
)

// Deprecated version of InboundNatPoolPropertiesFormatProtocol. Use v1beta20201101.InboundNatPoolPropertiesFormatProtocol
// instead
// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type InboundNatPoolPropertiesFormatProtocol string

const (
	InboundNatPoolPropertiesFormatProtocolAll = InboundNatPoolPropertiesFormatProtocol("All")
	InboundNatPoolPropertiesFormatProtocolTcp = InboundNatPoolPropertiesFormatProtocol("Tcp")
	InboundNatPoolPropertiesFormatProtocolUdp = InboundNatPoolPropertiesFormatProtocol("Udp")
)

// Deprecated version of LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses. Use v1beta20201101.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses instead
type LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses struct {
	IpAddress                           *string      `json:"ipAddress,omitempty"`
	LoadBalancerFrontendIPConfiguration *SubResource `json:"loadBalancerFrontendIPConfiguration,omitempty"`
	Name                                *string      `json:"name,omitempty"`
	Subnet                              *SubResource `json:"subnet,omitempty"`
	VirtualNetwork                      *SubResource `json:"virtualNetwork,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (addresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if addresses == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM

	// Set property ‘Name’:
	if addresses.Name != nil {
		name := *addresses.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if addresses.IpAddress != nil ||
		addresses.LoadBalancerFrontendIPConfiguration != nil ||
		addresses.Subnet != nil ||
		addresses.VirtualNetwork != nil {
		result.Properties = &LoadBalancerBackendAddressPropertiesFormatARM{}
	}
	if addresses.IpAddress != nil {
		ipAddress := *addresses.IpAddress
		result.Properties.IpAddress = &ipAddress
	}
	if addresses.LoadBalancerFrontendIPConfiguration != nil {
		loadBalancerFrontendIPConfigurationARM, err := (*addresses.LoadBalancerFrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfigurationARM.(SubResourceARM)
		result.Properties.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	}
	if addresses.Subnet != nil {
		subnetARM, err := (*addresses.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(SubResourceARM)
		result.Properties.Subnet = &subnet
	}
	if addresses.VirtualNetwork != nil {
		virtualNetworkARM, err := (*addresses.VirtualNetwork).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualNetwork := virtualNetworkARM.(SubResourceARM)
		result.Properties.VirtualNetwork = &virtualNetwork
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM, got %T", armInput)
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			addresses.IpAddress = &ipAddress
		}
	}

	// Set property ‘LoadBalancerFrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadBalancerFrontendIPConfiguration != nil {
			var loadBalancerFrontendIPConfiguration1 SubResource
			err := loadBalancerFrontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.LoadBalancerFrontendIPConfiguration)
			if err != nil {
				return err
			}
			loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfiguration1
			addresses.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		addresses.Name = &name
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			addresses.Subnet = &subnet
		}
	}

	// Set property ‘VirtualNetwork’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetwork != nil {
			var virtualNetwork1 SubResource
			err := virtualNetwork1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetwork)
			if err != nil {
				return err
			}
			virtualNetwork := virtualNetwork1
			addresses.VirtualNetwork = &virtualNetwork
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses populates our LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses from the provided source LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
func (addresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(source *alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) error {

	// IpAddress
	addresses.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration SubResource
		err := loadBalancerFrontendIPConfiguration.AssignPropertiesFromSubResource(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field LoadBalancerFrontendIPConfiguration")
		}
		addresses.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		addresses.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	addresses.Name = genruntime.ClonePointerToString(source.Name)

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignPropertiesFromSubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field Subnet")
		}
		addresses.Subnet = &subnet
	} else {
		addresses.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var virtualNetwork SubResource
		err := virtualNetwork.AssignPropertiesFromSubResource(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field VirtualNetwork")
		}
		addresses.VirtualNetwork = &virtualNetwork
	} else {
		addresses.VirtualNetwork = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses populates the provided destination LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses from our LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
func (addresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(destination *alpha20201101s.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(addresses.IpAddress)

	// LoadBalancerFrontendIPConfiguration
	if addresses.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration alpha20201101s.SubResource
		err := addresses.LoadBalancerFrontendIPConfiguration.AssignPropertiesToSubResource(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field LoadBalancerFrontendIPConfiguration")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(addresses.Name)

	// Subnet
	if addresses.Subnet != nil {
		var subnet alpha20201101s.SubResource
		err := addresses.Subnet.AssignPropertiesToSubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if addresses.VirtualNetwork != nil {
		var virtualNetwork alpha20201101s.SubResource
		err := addresses.VirtualNetwork.AssignPropertiesToSubResource(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field VirtualNetwork")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LoadBalancingRulePropertiesFormatLoadDistribution. Use
// v1beta20201101.LoadBalancingRulePropertiesFormatLoadDistribution instead
// +kubebuilder:validation:Enum={"Default","SourceIP","SourceIPProtocol"}
type LoadBalancingRulePropertiesFormatLoadDistribution string

const (
	LoadBalancingRulePropertiesFormatLoadDistributionDefault          = LoadBalancingRulePropertiesFormatLoadDistribution("Default")
	LoadBalancingRulePropertiesFormatLoadDistributionSourceIP         = LoadBalancingRulePropertiesFormatLoadDistribution("SourceIP")
	LoadBalancingRulePropertiesFormatLoadDistributionSourceIPProtocol = LoadBalancingRulePropertiesFormatLoadDistribution("SourceIPProtocol")
)

// Deprecated version of LoadBalancingRulePropertiesFormatProtocol. Use
// v1beta20201101.LoadBalancingRulePropertiesFormatProtocol instead
// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type LoadBalancingRulePropertiesFormatProtocol string

const (
	LoadBalancingRulePropertiesFormatProtocolAll = LoadBalancingRulePropertiesFormatProtocol("All")
	LoadBalancingRulePropertiesFormatProtocolTcp = LoadBalancingRulePropertiesFormatProtocol("Tcp")
	LoadBalancingRulePropertiesFormatProtocolUdp = LoadBalancingRulePropertiesFormatProtocol("Udp")
)

// Deprecated version of LoadBalancingRulePropertiesFormatStatusLoadDistribution. Use
// v1beta20201101.LoadBalancingRulePropertiesFormatStatusLoadDistribution instead
type LoadBalancingRulePropertiesFormatStatusLoadDistribution string

const (
	LoadBalancingRulePropertiesFormatStatusLoadDistributionDefault          = LoadBalancingRulePropertiesFormatStatusLoadDistribution("Default")
	LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIP         = LoadBalancingRulePropertiesFormatStatusLoadDistribution("SourceIP")
	LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIPProtocol = LoadBalancingRulePropertiesFormatStatusLoadDistribution("SourceIPProtocol")
)

// Deprecated version of OutboundRulePropertiesFormatProtocol. Use v1beta20201101.OutboundRulePropertiesFormatProtocol
// instead
// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type OutboundRulePropertiesFormatProtocol string

const (
	OutboundRulePropertiesFormatProtocolAll = OutboundRulePropertiesFormatProtocol("All")
	OutboundRulePropertiesFormatProtocolTcp = OutboundRulePropertiesFormatProtocol("Tcp")
	OutboundRulePropertiesFormatProtocolUdp = OutboundRulePropertiesFormatProtocol("Udp")
)

// Deprecated version of OutboundRulePropertiesFormatStatusProtocol. Use
// v1beta20201101.OutboundRulePropertiesFormatStatusProtocol instead
type OutboundRulePropertiesFormatStatusProtocol string

const (
	OutboundRulePropertiesFormatStatusProtocolAll = OutboundRulePropertiesFormatStatusProtocol("All")
	OutboundRulePropertiesFormatStatusProtocolTcp = OutboundRulePropertiesFormatStatusProtocol("Tcp")
	OutboundRulePropertiesFormatStatusProtocolUdp = OutboundRulePropertiesFormatStatusProtocol("Udp")
)

// Deprecated version of ProbePropertiesFormatProtocol. Use v1beta20201101.ProbePropertiesFormatProtocol instead
// +kubebuilder:validation:Enum={"Http","Https","Tcp"}
type ProbePropertiesFormatProtocol string

const (
	ProbePropertiesFormatProtocolHttp  = ProbePropertiesFormatProtocol("Http")
	ProbePropertiesFormatProtocolHttps = ProbePropertiesFormatProtocol("Https")
	ProbePropertiesFormatProtocolTcp   = ProbePropertiesFormatProtocol("Tcp")
)

// Deprecated version of ProbePropertiesFormatStatusProtocol. Use v1beta20201101.ProbePropertiesFormatStatusProtocol instead
type ProbePropertiesFormatStatusProtocol string

const (
	ProbePropertiesFormatStatusProtocolHttp  = ProbePropertiesFormatStatusProtocol("Http")
	ProbePropertiesFormatStatusProtocolHttps = ProbePropertiesFormatStatusProtocol("Https")
	ProbePropertiesFormatStatusProtocolTcp   = ProbePropertiesFormatStatusProtocol("Tcp")
)

// Deprecated version of PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded. Use v1beta20201101.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded instead
type PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded struct {
	ExtendedLocation *ExtendedLocation_Status   `json:"extendedLocation,omitempty"`
	Id               *string                    `json:"id,omitempty"`
	Sku              *PublicIPAddressSku_Status `json:"sku,omitempty"`
	Zones            []string                   `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		embedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded populates our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from the provided source PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded(source *alpha20201101s.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationStatus() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSkuStatus() to populate field Sku")
		}
		embedded.Sku = &sku
	} else {
		embedded.Sku = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded populates the provided destination PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded(destination *alpha20201101s.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation alpha20201101s.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationStatus() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Sku
	if embedded.Sku != nil {
		var sku alpha20201101s.PublicIPAddressSku_Status
		err := embedded.Sku.AssignPropertiesToPublicIPAddressSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSkuStatus() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Subnet_Status_LoadBalancer_SubResourceEmbedded. Use v1beta20201101.Subnet_Status_LoadBalancer_SubResourceEmbedded instead
type Subnet_Status_LoadBalancer_SubResourceEmbedded struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded populates our Subnet_Status_LoadBalancer_SubResourceEmbedded from the provided source Subnet_Status_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded(source *alpha20201101s.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded populates the provided destination Subnet_Status_LoadBalancer_SubResourceEmbedded from our Subnet_Status_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded(destination *alpha20201101s.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of TransportProtocol_Status. Use v1beta20201101.TransportProtocol_Status instead
type TransportProtocol_Status string

const (
	TransportProtocol_StatusAll = TransportProtocol_Status("All")
	TransportProtocol_StatusTcp = TransportProtocol_Status("Tcp")
	TransportProtocol_StatusUdp = TransportProtocol_Status("Udp")
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
