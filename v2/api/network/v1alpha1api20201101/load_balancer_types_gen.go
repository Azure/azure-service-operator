// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generator information:
//- Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancers_SPEC  `json:"spec,omitempty"`
	Status            LoadBalancer_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &LoadBalancer{}

// GetConditions returns the conditions of the resource
func (balancer *LoadBalancer) GetConditions() conditions.Conditions {
	return balancer.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (balancer *LoadBalancer) SetConditions(conditions conditions.Conditions) {
	balancer.Status.Conditions = conditions
}

var _ conversion.Convertible = &LoadBalancer{}

// ConvertFrom populates our LoadBalancer from the provided hub LoadBalancer
func (balancer *LoadBalancer) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20201101storage.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected storage:network/v1alpha1api20201101storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignPropertiesFromLoadBalancer(source)
}

// ConvertTo populates the provided hub LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20201101storage.LoadBalancer)
	if !ok {
		return fmt.Errorf("expected storage:network/v1alpha1api20201101storage/LoadBalancer but received %T instead", hub)
	}

	return balancer.AssignPropertiesToLoadBalancer(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &LoadBalancer{}

// Default applies defaults to the LoadBalancer resource
func (balancer *LoadBalancer) Default() {
	balancer.defaultImpl()
	var temp interface{} = balancer
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (balancer *LoadBalancer) defaultAzureName() {
	if balancer.Spec.AzureName == "" {
		balancer.Spec.AzureName = balancer.Name
	}
}

// defaultImpl applies the code generated defaults to the LoadBalancer resource
func (balancer *LoadBalancer) defaultImpl() { balancer.defaultAzureName() }

var _ genruntime.KubernetesResource = &LoadBalancer{}

// AzureName returns the Azure name of the resource
func (balancer *LoadBalancer) AzureName() string {
	return balancer.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (balancer LoadBalancer) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (balancer *LoadBalancer) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (balancer *LoadBalancer) GetSpec() genruntime.ConvertibleSpec {
	return &balancer.Spec
}

// GetStatus returns the status of this resource
func (balancer *LoadBalancer) GetStatus() genruntime.ConvertibleStatus {
	return &balancer.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (balancer *LoadBalancer) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (balancer *LoadBalancer) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &LoadBalancer_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (balancer *LoadBalancer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(balancer.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  balancer.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (balancer *LoadBalancer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*LoadBalancer_Status); ok {
		balancer.Status = *st
		return nil
	}

	// Convert status to required version
	var st LoadBalancer_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	balancer.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.loadbalancers.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &LoadBalancer{}

// ValidateCreate validates the creation of the resource
func (balancer *LoadBalancer) ValidateCreate() error {
	validations := balancer.createValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (balancer *LoadBalancer) ValidateDelete() error {
	validations := balancer.deleteValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (balancer *LoadBalancer) ValidateUpdate(old runtime.Object) error {
	validations := balancer.updateValidations()
	var temp interface{} = balancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (balancer *LoadBalancer) createValidations() []func() error {
	return []func() error{balancer.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (balancer *LoadBalancer) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (balancer *LoadBalancer) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return balancer.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (balancer *LoadBalancer) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&balancer.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromLoadBalancer populates our LoadBalancer from the provided source LoadBalancer
func (balancer *LoadBalancer) AssignPropertiesFromLoadBalancer(source *v1alpha1api20201101storage.LoadBalancer) error {

	// ObjectMeta
	balancer.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec LoadBalancers_SPEC
	err := spec.AssignPropertiesFromLoadBalancers_SPEC(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancers_SPEC() to populate field Spec")
	}
	balancer.Spec = spec

	// Status
	var status LoadBalancer_Status
	err = status.AssignPropertiesFromLoadBalancer_Status(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancer_Status() to populate field Status")
	}
	balancer.Status = status

	// No error
	return nil
}

// AssignPropertiesToLoadBalancer populates the provided destination LoadBalancer from our LoadBalancer
func (balancer *LoadBalancer) AssignPropertiesToLoadBalancer(destination *v1alpha1api20201101storage.LoadBalancer) error {

	// ObjectMeta
	destination.ObjectMeta = *balancer.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20201101storage.LoadBalancers_SPEC
	err := balancer.Spec.AssignPropertiesToLoadBalancers_SPEC(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToLoadBalancers_SPEC() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201101storage.LoadBalancer_Status
	err = balancer.Status.AssignPropertiesToLoadBalancer_Status(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToLoadBalancer_Status() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (balancer *LoadBalancer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: balancer.Spec.OriginalVersion(),
		Kind:    "LoadBalancer",
	}
}

// +kubebuilder:object:root=true
//Generator information:
//- Generated from: /network/resource-manager/Microsoft.Network/stable/2020-11-01/loadBalancer.json
//- ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

type LoadBalancer_Status struct {
	//BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded `json:"backendAddressPools,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//FrontendIPConfigurations: Object representing the frontend IPs to be used for
	//the load balancer.
	FrontendIPConfigurations []FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//InboundNatPools: Defines an external port range for inbound NAT to a single
	//backend port on NICs associated with a load balancer. Inbound NAT rules are
	//created automatically for each NIC associated with the Load Balancer using an
	//external port from this range. Defining an Inbound NAT pool on your Load
	//Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT
	//pools are referenced from virtual machine scale sets. NICs that are associated
	//with individual virtual machines cannot reference an inbound NAT pool. They have
	//to reference individual inbound NAT rules.
	InboundNatPools []InboundNatPool_Status `json:"inboundNatPools,omitempty"`

	//InboundNatRules: Collection of inbound NAT Rules used by a load balancer.
	//Defining inbound NAT rules on your load balancer is mutually exclusive with
	//defining an inbound NAT pool. Inbound NAT pools are referenced from virtual
	//machine scale sets. NICs that are associated with individual virtual machines
	//cannot reference an Inbound NAT pool. They have to reference individual inbound
	//NAT rules.
	InboundNatRules []InboundNatRule_Status_LoadBalancer_SubResourceEmbedded `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: Object collection representing the load balancing rules Gets
	//the provisioning.
	LoadBalancingRules []LoadBalancingRule_Status `json:"loadBalancingRules,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Name: Resource name.
	Name *string `json:"name,omitempty"`

	//OutboundRules: The outbound rules.
	OutboundRules []OutboundRule_Status `json:"outboundRules,omitempty"`

	//Probes: Collection of probe objects used in the load balancer.
	Probes []Probe_Status `json:"probes,omitempty"`

	//ProvisioningState: The provisioning state of the load balancer resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//ResourceGuid: The resource GUID property of the load balancer resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	//Sku: The load balancer SKU.
	Sku *LoadBalancerSku_Status `json:"sku,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &LoadBalancer_Status{}

// ConvertStatusFrom populates our LoadBalancer_Status from the provided source
func (balancer *LoadBalancer_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201101storage.LoadBalancer_Status)
	if ok {
		// Populate our instance from source
		return balancer.AssignPropertiesFromLoadBalancer_Status(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.LoadBalancer_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = balancer.AssignPropertiesFromLoadBalancer_Status(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our LoadBalancer_Status
func (balancer *LoadBalancer_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201101storage.LoadBalancer_Status)
	if ok {
		// Populate destination from our instance
		return balancer.AssignPropertiesToLoadBalancer_Status(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.LoadBalancer_Status{}
	err := balancer.AssignPropertiesToLoadBalancer_Status(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &LoadBalancer_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *LoadBalancer_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancer_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *LoadBalancer_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancer_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancer_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.BackendAddressPools = append(balancer.BackendAddressPools, item1)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		balancer.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		balancer.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.FrontendIPConfigurations = append(balancer.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		balancer.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatPools = append(balancer.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.InboundNatRules = append(balancer.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.LoadBalancingRules = append(balancer.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		balancer.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancer.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.OutboundRules = append(balancer.OutboundRules, item1)
		}
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			balancer.Probes = append(balancer.Probes, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			balancer.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			balancer.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		balancer.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		balancer.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			balancer.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		balancer.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancer_Status populates our LoadBalancer_Status from the provided source LoadBalancer_Status
func (balancer *LoadBalancer_Status) AssignPropertiesFromLoadBalancer_Status(source *v1alpha1api20201101storage.LoadBalancer_Status) error {

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := backendAddressPool.AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		balancer.BackendAddressPools = backendAddressPoolList
	} else {
		balancer.BackendAddressPools = nil
	}

	// Conditions
	balancer.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	balancer.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		balancer.ExtendedLocation = &extendedLocation
	} else {
		balancer.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfiguration.AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		balancer.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		balancer.FrontendIPConfigurations = nil
	}

	// Id
	balancer.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool_Status, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool_Status
			err := inboundNatPool.AssignPropertiesFromInboundNatPool_Status(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatPool_Status() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		balancer.InboundNatPools = inboundNatPoolList
	} else {
		balancer.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := inboundNatRule.AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		balancer.InboundNatRules = inboundNatRuleList
	} else {
		balancer.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule_Status
			err := loadBalancingRule.AssignPropertiesFromLoadBalancingRule_Status(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancingRule_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		balancer.LoadBalancingRules = loadBalancingRuleList
	} else {
		balancer.LoadBalancingRules = nil
	}

	// Location
	balancer.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	balancer.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule_Status, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule_Status
			err := outboundRule.AssignPropertiesFromOutboundRule_Status(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromOutboundRule_Status() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		balancer.OutboundRules = outboundRuleList
	} else {
		balancer.OutboundRules = nil
	}

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe_Status, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe_Status
			err := probe.AssignPropertiesFromProbe_Status(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromProbe_Status() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		balancer.Probes = probeList
	} else {
		balancer.Probes = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		balancer.ProvisioningState = &provisioningState
	} else {
		balancer.ProvisioningState = nil
	}

	// ResourceGuid
	balancer.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_Status
		err := sku.AssignPropertiesFromLoadBalancerSku_Status(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancerSku_Status() to populate field Sku")
		}
		balancer.Sku = &sku
	} else {
		balancer.Sku = nil
	}

	// Tags
	balancer.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	balancer.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancer_Status populates the provided destination LoadBalancer_Status from our LoadBalancer_Status
func (balancer *LoadBalancer_Status) AssignPropertiesToLoadBalancer_Status(destination *v1alpha1api20201101storage.LoadBalancer_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPools
	if balancer.BackendAddressPools != nil {
		backendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(balancer.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range balancer.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := backendAddressPoolItem.AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(balancer.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(balancer.Etag)

	// ExtendedLocation
	if balancer.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := balancer.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if balancer.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(balancer.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range balancer.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfigurationItem.AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(balancer.Id)

	// InboundNatPools
	if balancer.InboundNatPools != nil {
		inboundNatPoolList := make([]v1alpha1api20201101storage.InboundNatPool_Status, len(balancer.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range balancer.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v1alpha1api20201101storage.InboundNatPool_Status
			err := inboundNatPoolItem.AssignPropertiesToInboundNatPool_Status(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatPool_Status() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if balancer.InboundNatRules != nil {
		inboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(balancer.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range balancer.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := inboundNatRuleItem.AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if balancer.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v1alpha1api20201101storage.LoadBalancingRule_Status, len(balancer.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range balancer.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v1alpha1api20201101storage.LoadBalancingRule_Status
			err := loadBalancingRuleItem.AssignPropertiesToLoadBalancingRule_Status(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancingRule_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(balancer.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(balancer.Name)

	// OutboundRules
	if balancer.OutboundRules != nil {
		outboundRuleList := make([]v1alpha1api20201101storage.OutboundRule_Status, len(balancer.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range balancer.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v1alpha1api20201101storage.OutboundRule_Status
			err := outboundRuleItem.AssignPropertiesToOutboundRule_Status(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToOutboundRule_Status() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Probes
	if balancer.Probes != nil {
		probeList := make([]v1alpha1api20201101storage.Probe_Status, len(balancer.Probes))
		for probeIndex, probeItem := range balancer.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v1alpha1api20201101storage.Probe_Status
			err := probeItem.AssignPropertiesToProbe_Status(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToProbe_Status() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// ProvisioningState
	if balancer.ProvisioningState != nil {
		provisioningState := string(*balancer.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(balancer.ResourceGuid)

	// Sku
	if balancer.Sku != nil {
		var sku v1alpha1api20201101storage.LoadBalancerSku_Status
		err := balancer.Sku.AssignPropertiesToLoadBalancerSku_Status(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLoadBalancerSku_Status() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(balancer.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(balancer.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancers_SPEC struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded `json:"backendAddressPools,omitempty"`

	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//FrontendIPConfigurations: Object representing the frontend IPs to be used for
	//the load balancer.
	FrontendIPConfigurations []FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`

	//InboundNatPools: Defines an external port range for inbound NAT to a single
	//backend port on NICs associated with a load balancer. Inbound NAT rules are
	//created automatically for each NIC associated with the Load Balancer using an
	//external port from this range. Defining an Inbound NAT pool on your Load
	//Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT
	//pools are referenced from virtual machine scale sets. NICs that are associated
	//with individual virtual machines cannot reference an inbound NAT pool. They have
	//to reference individual inbound NAT rules.
	InboundNatPools []InboundNatPool_Spec `json:"inboundNatPools,omitempty"`

	//InboundNatRules: Collection of inbound NAT Rules used by a load balancer.
	//Defining inbound NAT rules on your load balancer is mutually exclusive with
	//defining an inbound NAT pool. Inbound NAT pools are referenced from virtual
	//machine scale sets. NICs that are associated with individual virtual machines
	//cannot reference an Inbound NAT pool. They have to reference individual inbound
	//NAT rules.
	InboundNatRules []InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: Object collection representing the load balancing rules Gets
	//the provisioning.
	LoadBalancingRules []LoadBalancingRule_Spec `json:"loadBalancingRules,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//OutboundRules: The outbound rules.
	OutboundRules []OutboundRule_Spec `json:"outboundRules,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Probes: Collection of probe objects used in the load balancer.
	Probes []Probe_Spec `json:"probes,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Sku: The load balancer SKU.
	Sku *LoadBalancerSku_Spec `json:"sku,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_SPEC{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spec *LoadBalancers_SPEC) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spec == nil {
		return nil, nil
	}
	var result LoadBalancers_SPECARM

	// Set property ‘AzureName’:
	result.AzureName = spec.AzureName

	// Set property ‘ExtendedLocation’:
	if spec.ExtendedLocation != nil {
		extendedLocationARM, err := (*spec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if spec.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*spec.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if spec.Location != nil {
		location := *spec.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if spec.BackendAddressPools != nil ||
		spec.FrontendIPConfigurations != nil ||
		spec.InboundNatPools != nil ||
		spec.InboundNatRules != nil ||
		spec.LoadBalancingRules != nil ||
		spec.OutboundRules != nil ||
		spec.Probes != nil {
		result.Properties = &LoadBalancerPropertiesFormat_SpecARM{}
	}
	for _, item := range spec.BackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddressPools = append(result.Properties.BackendAddressPools, itemARM.(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM))
	}
	for _, item := range spec.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM))
	}
	for _, item := range spec.InboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatPools = append(result.Properties.InboundNatPools, itemARM.(InboundNatPool_SpecARM))
	}
	for _, item := range spec.InboundNatRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatRules = append(result.Properties.InboundNatRules, itemARM.(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM))
	}
	for _, item := range spec.LoadBalancingRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancingRules = append(result.Properties.LoadBalancingRules, itemARM.(LoadBalancingRule_SpecARM))
	}
	for _, item := range spec.OutboundRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.OutboundRules = append(result.Properties.OutboundRules, itemARM.(OutboundRule_SpecARM))
	}
	for _, item := range spec.Probes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Probes = append(result.Properties.Probes, itemARM.(Probe_SpecARM))
	}

	// Set property ‘Sku’:
	if spec.Sku != nil {
		skuARM, err := (*spec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(LoadBalancerSku_SpecARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if spec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range spec.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spec *LoadBalancers_SPEC) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_SPECARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spec *LoadBalancers_SPEC) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_SPECARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_SPECARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	spec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.BackendAddressPools = append(spec.BackendAddressPools, item1)
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		spec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.FrontendIPConfigurations = append(spec.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.InboundNatPools = append(spec.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.InboundNatRules = append(spec.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.LoadBalancingRules = append(spec.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		spec.Location = &location
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.OutboundRules = append(spec.OutboundRules, item1)
		}
	}

	// Set property ‘Owner’:
	spec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			spec.Probes = append(spec.Probes, item1)
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku_Spec
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		spec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		spec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			spec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &LoadBalancers_SPEC{}

// ConvertSpecFrom populates our LoadBalancers_SPEC from the provided source
func (spec *LoadBalancers_SPEC) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201101storage.LoadBalancers_SPEC)
	if ok {
		// Populate our instance from source
		return spec.AssignPropertiesFromLoadBalancers_SPEC(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.LoadBalancers_SPEC{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = spec.AssignPropertiesFromLoadBalancers_SPEC(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our LoadBalancers_SPEC
func (spec *LoadBalancers_SPEC) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201101storage.LoadBalancers_SPEC)
	if ok {
		// Populate destination from our instance
		return spec.AssignPropertiesToLoadBalancers_SPEC(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.LoadBalancers_SPEC{}
	err := spec.AssignPropertiesToLoadBalancers_SPEC(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromLoadBalancers_SPEC populates our LoadBalancers_SPEC from the provided source LoadBalancers_SPEC
func (spec *LoadBalancers_SPEC) AssignPropertiesFromLoadBalancers_SPEC(source *v1alpha1api20201101storage.LoadBalancers_SPEC) error {

	// AzureName
	spec.AzureName = source.AzureName

	// BackendAddressPools
	if source.BackendAddressPools != nil {
		backendAddressPoolList := make([]BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
			err := backendAddressPool.AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(&backendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		spec.BackendAddressPools = backendAddressPoolList
	} else {
		spec.BackendAddressPools = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Spec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		spec.ExtendedLocation = &extendedLocation
	} else {
		spec.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfiguration.AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		spec.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		spec.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]InboundNatPool_Spec, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool InboundNatPool_Spec
			err := inboundNatPool.AssignPropertiesFromInboundNatPool_Spec(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatPool_Spec() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		spec.InboundNatPools = inboundNatPoolList
	} else {
		spec.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
			err := inboundNatRule.AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		spec.InboundNatRules = inboundNatRuleList
	} else {
		spec.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]LoadBalancingRule_Spec, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule LoadBalancingRule_Spec
			err := loadBalancingRule.AssignPropertiesFromLoadBalancingRule_Spec(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancingRule_Spec() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		spec.LoadBalancingRules = loadBalancingRuleList
	} else {
		spec.LoadBalancingRules = nil
	}

	// Location
	spec.Location = genruntime.ClonePointerToString(source.Location)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]OutboundRule_Spec, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule OutboundRule_Spec
			err := outboundRule.AssignPropertiesFromOutboundRule_Spec(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromOutboundRule_Spec() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		spec.OutboundRules = outboundRuleList
	} else {
		spec.OutboundRules = nil
	}

	// Owner
	spec.Owner = source.Owner.Copy()

	// Probes
	if source.Probes != nil {
		probeList := make([]Probe_Spec, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe Probe_Spec
			err := probe.AssignPropertiesFromProbe_Spec(&probeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromProbe_Spec() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		spec.Probes = probeList
	} else {
		spec.Probes = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		spec.Reference = &reference
	} else {
		spec.Reference = nil
	}

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_Spec
		err := sku.AssignPropertiesFromLoadBalancerSku_Spec(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLoadBalancerSku_Spec() to populate field Sku")
		}
		spec.Sku = &sku
	} else {
		spec.Sku = nil
	}

	// Tags
	spec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancers_SPEC populates the provided destination LoadBalancers_SPEC from our LoadBalancers_SPEC
func (spec *LoadBalancers_SPEC) AssignPropertiesToLoadBalancers_SPEC(destination *v1alpha1api20201101storage.LoadBalancers_SPEC) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = spec.AzureName

	// BackendAddressPools
	if spec.BackendAddressPools != nil {
		backendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded, len(spec.BackendAddressPools))
		for backendAddressPoolIndex, backendAddressPoolItem := range spec.BackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			backendAddressPoolItem := backendAddressPoolItem
			var backendAddressPool v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
			err := backendAddressPoolItem.AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(&backendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded() to populate field BackendAddressPools")
			}
			backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
		}
		destination.BackendAddressPools = backendAddressPoolList
	} else {
		destination.BackendAddressPools = nil
	}

	// ExtendedLocation
	if spec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Spec
		err := spec.ExtendedLocation.AssignPropertiesToExtendedLocation_Spec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	if spec.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded, len(spec.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range spec.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
			err := frontendIPConfigurationItem.AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// InboundNatPools
	if spec.InboundNatPools != nil {
		inboundNatPoolList := make([]v1alpha1api20201101storage.InboundNatPool_Spec, len(spec.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range spec.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v1alpha1api20201101storage.InboundNatPool_Spec
			err := inboundNatPoolItem.AssignPropertiesToInboundNatPool_Spec(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatPool_Spec() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if spec.InboundNatRules != nil {
		inboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded, len(spec.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range spec.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
			err := inboundNatRuleItem.AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if spec.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v1alpha1api20201101storage.LoadBalancingRule_Spec, len(spec.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range spec.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v1alpha1api20201101storage.LoadBalancingRule_Spec
			err := loadBalancingRuleItem.AssignPropertiesToLoadBalancingRule_Spec(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToLoadBalancingRule_Spec() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(spec.Location)

	// OriginalVersion
	destination.OriginalVersion = spec.OriginalVersion()

	// OutboundRules
	if spec.OutboundRules != nil {
		outboundRuleList := make([]v1alpha1api20201101storage.OutboundRule_Spec, len(spec.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range spec.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v1alpha1api20201101storage.OutboundRule_Spec
			err := outboundRuleItem.AssignPropertiesToOutboundRule_Spec(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToOutboundRule_Spec() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// Owner
	destination.Owner = spec.Owner.Copy()

	// Probes
	if spec.Probes != nil {
		probeList := make([]v1alpha1api20201101storage.Probe_Spec, len(spec.Probes))
		for probeIndex, probeItem := range spec.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe v1alpha1api20201101storage.Probe_Spec
			err := probeItem.AssignPropertiesToProbe_Spec(&probe)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToProbe_Spec() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Reference
	if spec.Reference != nil {
		reference := spec.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Sku
	if spec.Sku != nil {
		var sku v1alpha1api20201101storage.LoadBalancerSku_Spec
		err := spec.Sku.AssignPropertiesToLoadBalancerSku_Spec(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLoadBalancerSku_Spec() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(spec.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (spec *LoadBalancers_SPEC) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (spec *LoadBalancers_SPEC) SetAzureName(azureName string) { spec.AzureName = azureName }

type BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Spec_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded populates our BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded populates the provided destination BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Spec_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded populates our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded populates the provided destination BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (embedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_Status_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_Spec struct {
	// +kubebuilder:validation:Required
	//Name: The name of the extended location.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Type: The type of the extended location.
	Type ExtendedLocationType_Spec `json:"type"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	var result ExtendedLocation_SpecARM

	// Set property ‘Name’:
	result.Name = location.Name

	// Set property ‘Type’:
	result.Type = location.Type
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_SpecARM, got %T", armInput)
	}

	// Set property ‘Name’:
	location.Name = typedInput.Name

	// Set property ‘Type’:
	location.Type = typedInput.Type

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation_Spec populates our ExtendedLocation_Spec from the provided source ExtendedLocation_Spec
func (location *ExtendedLocation_Spec) AssignPropertiesFromExtendedLocation_Spec(source *v1alpha1api20201101storage.ExtendedLocation_Spec) error {

	// Name
	location.Name = genruntime.GetOptionalStringValue(source.Name)

	// Type
	if source.Type != nil {
		location.Type = ExtendedLocationType_Spec(*source.Type)
	} else {
		location.Type = ""
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation_Spec populates the provided destination ExtendedLocation_Spec from our ExtendedLocation_Spec
func (location *ExtendedLocation_Spec) AssignPropertiesToExtendedLocation_Spec(destination *v1alpha1api20201101storage.ExtendedLocation_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := location.Name
	destination.Name = &name

	// Type
	typeVar := string(location.Type)
	destination.Type = &typeVar

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_Status struct {
	// +kubebuilder:validation:Required
	//Name: The name of the extended location.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Type: The type of the extended location.
	Type ExtendedLocationType_Status `json:"type"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	location.Name = typedInput.Name

	// Set property ‘Type’:
	location.Type = typedInput.Type

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation_Status populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesFromExtendedLocation_Status(source *v1alpha1api20201101storage.ExtendedLocation_Status) error {

	// Name
	location.Name = genruntime.GetOptionalStringValue(source.Name)

	// Type
	if source.Type != nil {
		location.Type = ExtendedLocationType_Status(*source.Type)
	} else {
		location.Type = ""
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation_Status populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (location *ExtendedLocation_Status) AssignPropertiesToExtendedLocation_Status(destination *v1alpha1api20201101storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := location.Name
	destination.Name = &name

	// Type
	typeVar := string(location.Type)
	destination.Type = &typeVar

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded struct {
	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name *string `json:"name,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_Spec `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Spec `json:"privateIPAllocationMethod,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_Spec `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_Spec `json:"publicIPPrefix,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Spec_LoadBalancer_SubResourceEmbedded `json:"subnet,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if embedded.Name != nil {
		name := *embedded.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if embedded.PrivateIPAddress != nil ||
		embedded.PrivateIPAddressVersion != nil ||
		embedded.PrivateIPAllocationMethod != nil ||
		embedded.PublicIPAddress != nil ||
		embedded.PublicIPPrefix != nil ||
		embedded.Subnet != nil {
		result.Properties = &FrontendIPConfigurationPropertiesFormat_Spec_LoadBalancer_SubResourceEmbeddedARM{}
	}
	if embedded.PrivateIPAddress != nil {
		privateIPAddress := *embedded.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *embedded.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *embedded.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if embedded.PublicIPAddress != nil {
		publicIPAddressARM, err := (*embedded.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := publicIPAddressARM.(PublicIPAddress_SpecARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if embedded.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*embedded.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResource_SpecARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if embedded.Subnet != nil {
		subnetARM, err := (*embedded.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM)
		result.Properties.Subnet = &subnet
	}

	// Set property ‘Zones’:
	for _, item := range embedded.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Spec
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Spec
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			embedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Spec_LoadBalancer_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded populates our FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) error {

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Spec(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Spec(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Spec
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_Spec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Spec
		err := publicIPPrefix.AssignPropertiesFromSubResource_Spec(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field PublicIPPrefix")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Spec_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesToFrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.FrontendIPConfiguration_Spec_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Spec
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_Spec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Spec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Spec
		err := embedded.PublicIPPrefix.AssignPropertiesToSubResource_Spec(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Spec_LoadBalancer_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//InboundNatPools: An array of references to inbound pools that use this frontend
	//IP.
	InboundNatPools []SubResource_Status `json:"inboundNatPools,omitempty"`

	//InboundNatRules: An array of references to inbound rules that use this frontend
	//IP.
	InboundNatRules []SubResource_Status `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: An array of references to load balancing rules that use this
	//frontend IP.
	LoadBalancingRules []SubResource_Status `json:"loadBalancingRules,omitempty"`

	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name *string `json:"name,omitempty"`

	//OutboundRules: An array of references to outbound rules that use this frontend
	//IP.
	OutboundRules []SubResource_Status `json:"outboundRules,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_Status `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//ProvisioningState: The provisioning state of the frontend IP configuration
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_Status `json:"publicIPPrefix,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Status_LoadBalancer_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		embedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.InboundNatPools = append(embedded.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.InboundNatRules = append(embedded.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.LoadBalancingRules = append(embedded.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		embedded.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			embedded.OutboundRules = append(embedded.OutboundRules, item1)
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			embedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			embedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			embedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			embedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			embedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_LoadBalancer_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			embedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		embedded.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded populates our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// InboundNatPools
	if source.InboundNatPools != nil {
		inboundNatPoolList := make([]SubResource_Status, len(source.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool SubResource_Status
			err := inboundNatPool.AssignPropertiesFromSubResource_Status(&inboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		embedded.InboundNatPools = inboundNatPoolList
	} else {
		embedded.InboundNatPools = nil
	}

	// InboundNatRules
	if source.InboundNatRules != nil {
		inboundNatRuleList := make([]SubResource_Status, len(source.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule SubResource_Status
			err := inboundNatRule.AssignPropertiesFromSubResource_Status(&inboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		embedded.InboundNatRules = inboundNatRuleList
	} else {
		embedded.InboundNatRules = nil
	}

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_Status
			err := loadBalancingRule.AssignPropertiesFromSubResource_Status(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		embedded.LoadBalancingRules = loadBalancingRuleList
	} else {
		embedded.LoadBalancingRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleList := make([]SubResource_Status, len(source.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule SubResource_Status
			err := outboundRule.AssignPropertiesFromSubResource_Status(&outboundRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		embedded.OutboundRules = outboundRuleList
	} else {
		embedded.OutboundRules = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		embedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		embedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		embedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		embedded.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		embedded.ProvisioningState = &provisioningState
	} else {
		embedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResource_Status(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field PublicIPPrefix")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToFrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// InboundNatPools
	if embedded.InboundNatPools != nil {
		inboundNatPoolList := make([]v1alpha1api20201101storage.SubResource_Status, len(embedded.InboundNatPools))
		for inboundNatPoolIndex, inboundNatPoolItem := range embedded.InboundNatPools {
			// Shadow the loop variable to avoid aliasing
			inboundNatPoolItem := inboundNatPoolItem
			var inboundNatPool v1alpha1api20201101storage.SubResource_Status
			err := inboundNatPoolItem.AssignPropertiesToSubResource_Status(&inboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field InboundNatPools")
			}
			inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
		}
		destination.InboundNatPools = inboundNatPoolList
	} else {
		destination.InboundNatPools = nil
	}

	// InboundNatRules
	if embedded.InboundNatRules != nil {
		inboundNatRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(embedded.InboundNatRules))
		for inboundNatRuleIndex, inboundNatRuleItem := range embedded.InboundNatRules {
			// Shadow the loop variable to avoid aliasing
			inboundNatRuleItem := inboundNatRuleItem
			var inboundNatRule v1alpha1api20201101storage.SubResource_Status
			err := inboundNatRuleItem.AssignPropertiesToSubResource_Status(&inboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field InboundNatRules")
			}
			inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
		}
		destination.InboundNatRules = inboundNatRuleList
	} else {
		destination.InboundNatRules = nil
	}

	// LoadBalancingRules
	if embedded.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(embedded.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range embedded.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v1alpha1api20201101storage.SubResource_Status
			err := loadBalancingRuleItem.AssignPropertiesToSubResource_Status(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// OutboundRules
	if embedded.OutboundRules != nil {
		outboundRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(embedded.OutboundRules))
		for outboundRuleIndex, outboundRuleItem := range embedded.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleItem := outboundRuleItem
			var outboundRule v1alpha1api20201101storage.SubResource_Status
			err := outboundRuleItem.AssignPropertiesToSubResource_Status(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field OutboundRules")
			}
			outboundRuleList[outboundRuleIndex] = outboundRule
		}
		destination.OutboundRules = outboundRuleList
	} else {
		destination.OutboundRules = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	if embedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*embedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if embedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*embedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if embedded.ProvisioningState != nil {
		provisioningState := string(*embedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Status
		err := embedded.PublicIPPrefix.AssignPropertiesToSubResource_Status(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatPool_Spec struct {
	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Spec `json:"frontendIPConfiguration,omitempty"`

	//FrontendPortRangeEnd: The last port number in the range of external ports that
	//will be used to provide Inbound Nat to NICs associated with a load balancer.
	//Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	//FrontendPortRangeStart: The first port number in the range of external ports
	//that will be used to provide Inbound Nat to NICs associated with a load
	//balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of inbound NAT
	//pools used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *TransportProtocol_Spec `json:"protocol,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatPool_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *InboundNatPool_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	var result InboundNatPool_SpecARM

	// Set property ‘Id’:
	if pool.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*pool.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if pool.BackendPort != nil ||
		pool.EnableFloatingIP != nil ||
		pool.EnableTcpReset != nil ||
		pool.FrontendIPConfiguration != nil ||
		pool.FrontendPortRangeEnd != nil ||
		pool.FrontendPortRangeStart != nil ||
		pool.IdleTimeoutInMinutes != nil ||
		pool.Protocol != nil {
		result.Properties = &InboundNatPoolPropertiesFormat_SpecARM{}
	}
	if pool.BackendPort != nil {
		result.Properties.BackendPort = *pool.BackendPort
	}
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if pool.FrontendIPConfiguration != nil {
		frontendIPConfigurationARM, err := (*pool.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := frontendIPConfigurationARM.(SubResource_SpecARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if pool.FrontendPortRangeEnd != nil {
		result.Properties.FrontendPortRangeEnd = *pool.FrontendPortRangeEnd
	}
	if pool.FrontendPortRangeStart != nil {
		result.Properties.FrontendPortRangeStart = *pool.FrontendPortRangeStart
	}
	if pool.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *pool.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if pool.Protocol != nil {
		result.Properties.Protocol = *pool.Protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *InboundNatPool_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *InboundNatPool_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_SpecARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.BackendPort = &typedInput.Properties.BackendPort
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pool.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pool.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Spec
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pool.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.FrontendPortRangeEnd = &typedInput.Properties.FrontendPortRangeEnd
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.FrontendPortRangeStart = &typedInput.Properties.FrontendPortRangeStart
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pool.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.Protocol = &typedInput.Properties.Protocol
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromInboundNatPool_Spec populates our InboundNatPool_Spec from the provided source InboundNatPool_Spec
func (pool *InboundNatPool_Spec) AssignPropertiesFromInboundNatPool_Spec(source *v1alpha1api20201101storage.InboundNatPool_Spec) error {

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Spec
		err := frontendIPConfiguration.AssignPropertiesFromSubResource_Spec(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field FrontendIPConfiguration")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Spec(*source.Protocol)
		pool.Protocol = &protocol
	} else {
		pool.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		pool.Reference = &reference
	} else {
		pool.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatPool_Spec populates the provided destination InboundNatPool_Spec from our InboundNatPool_Spec
func (pool *InboundNatPool_Spec) AssignPropertiesToInboundNatPool_Spec(destination *v1alpha1api20201101storage.InboundNatPool_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Spec
		err := pool.FrontendIPConfiguration.AssignPropertiesToSubResource_Spec(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	if pool.Protocol != nil {
		protocol := string(*pool.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if pool.Reference != nil {
		reference := pool.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatPool_Status struct {
	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Status `json:"frontendIPConfiguration,omitempty"`

	//FrontendPortRangeEnd: The last port number in the range of external ports that
	//will be used to provide Inbound Nat to NICs associated with a load balancer.
	//Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	//FrontendPortRangeStart: The first port number in the range of external ports
	//that will be used to provide Inbound Nat to NICs associated with a load
	//balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of inbound NAT
	//pools used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *TransportProtocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the inbound NAT pool resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatPool_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *InboundNatPool_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *InboundNatPool_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.BackendPort = &typedInput.Properties.BackendPort
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			pool.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			pool.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		pool.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			pool.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.FrontendPortRangeEnd = &typedInput.Properties.FrontendPortRangeEnd
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.FrontendPortRangeStart = &typedInput.Properties.FrontendPortRangeStart
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			pool.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		pool.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			pool.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		pool.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatPool_Status populates our InboundNatPool_Status from the provided source InboundNatPool_Status
func (pool *InboundNatPool_Status) AssignPropertiesFromInboundNatPool_Status(source *v1alpha1api20201101storage.InboundNatPool_Status) error {

	// BackendPort
	pool.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		pool.EnableFloatingIP = &enableFloatingIP
	} else {
		pool.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		pool.EnableTcpReset = &enableTcpReset
	} else {
		pool.EnableTcpReset = nil
	}

	// Etag
	pool.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResource_Status(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field FrontendIPConfiguration")
		}
		pool.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		pool.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	pool.FrontendPortRangeEnd = genruntime.ClonePointerToInt(source.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	pool.FrontendPortRangeStart = genruntime.ClonePointerToInt(source.FrontendPortRangeStart)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	pool.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		pool.Protocol = &protocol
	} else {
		pool.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		pool.ProvisioningState = &provisioningState
	} else {
		pool.ProvisioningState = nil
	}

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToInboundNatPool_Status populates the provided destination InboundNatPool_Status from our InboundNatPool_Status
func (pool *InboundNatPool_Status) AssignPropertiesToInboundNatPool_Status(destination *v1alpha1api20201101storage.InboundNatPool_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(pool.BackendPort)

	// EnableFloatingIP
	if pool.EnableFloatingIP != nil {
		enableFloatingIP := *pool.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if pool.EnableTcpReset != nil {
		enableTcpReset := *pool.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(pool.Etag)

	// FrontendIPConfiguration
	if pool.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
		err := pool.FrontendIPConfiguration.AssignPropertiesToSubResource_Status(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	destination.FrontendPortRangeEnd = genruntime.ClonePointerToInt(pool.FrontendPortRangeEnd)

	// FrontendPortRangeStart
	destination.FrontendPortRangeStart = genruntime.ClonePointerToInt(pool.FrontendPortRangeStart)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(pool.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Protocol
	if pool.Protocol != nil {
		protocol := string(*pool.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if pool.ProvisioningState != nil {
		provisioningState := string(*pool.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Spec_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded populates our InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded populates the provided destination InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded from our InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesToInboundNatRule_Spec_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Spec_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InboundNatRule_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded populates our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded populates the provided destination InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (embedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToInboundNatRule_Status_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancerSku_Spec struct {
	//Name: Name of a load balancer SKU.
	Name *LoadBalancerSku_Name_Spec `json:"name,omitempty"`

	//Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSku_Tier_Spec `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancerSku_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancerSku *LoadBalancerSku_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancerSku == nil {
		return nil, nil
	}
	var result LoadBalancerSku_SpecARM

	// Set property ‘Name’:
	if balancerSku.Name != nil {
		name := *balancerSku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if balancerSku.Tier != nil {
		tier := *balancerSku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_SpecARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSku_Spec populates our LoadBalancerSku_Spec from the provided source LoadBalancerSku_Spec
func (balancerSku *LoadBalancerSku_Spec) AssignPropertiesFromLoadBalancerSku_Spec(source *v1alpha1api20201101storage.LoadBalancerSku_Spec) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSku_Name_Spec(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSku_Tier_Spec(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSku_Spec populates the provided destination LoadBalancerSku_Spec from our LoadBalancerSku_Spec
func (balancerSku *LoadBalancerSku_Spec) AssignPropertiesToLoadBalancerSku_Spec(destination *v1alpha1api20201101storage.LoadBalancerSku_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancerSku_Status struct {
	//Name: Name of a load balancer SKU.
	Name *LoadBalancerSku_Name_Status `json:"name,omitempty"`

	//Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSku_Tier_Status `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancerSku_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancerSku *LoadBalancerSku_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancerSku *LoadBalancerSku_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		balancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		balancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSku_Status populates our LoadBalancerSku_Status from the provided source LoadBalancerSku_Status
func (balancerSku *LoadBalancerSku_Status) AssignPropertiesFromLoadBalancerSku_Status(source *v1alpha1api20201101storage.LoadBalancerSku_Status) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSku_Name_Status(*source.Name)
		balancerSku.Name = &name
	} else {
		balancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSku_Tier_Status(*source.Tier)
		balancerSku.Tier = &tier
	} else {
		balancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSku_Status populates the provided destination LoadBalancerSku_Status from our LoadBalancerSku_Status
func (balancerSku *LoadBalancerSku_Status) AssignPropertiesToLoadBalancerSku_Status(destination *v1alpha1api20201101storage.LoadBalancerSku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if balancerSku.Name != nil {
		name := string(*balancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if balancerSku.Tier != nil {
		tier := string(*balancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancingRule_Spec struct {
	//BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Spec `json:"backendAddressPool,omitempty"`

	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 0 and 65535. Note that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	//DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the
	//publicIP address specified in the frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Spec `json:"frontendIPConfiguration,omitempty"`

	//FrontendPort: The port for the external endpoint. Port numbers for each rule
	//must be unique within the Load Balancer. Acceptable values are between 0 and
	//65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormat_LoadDistribution_Spec `json:"loadDistribution,omitempty"`

	//Name: The name of the resource that is unique within the set of load balancing
	//rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource_Spec `json:"probe,omitempty"`

	//Protocol: The reference to the transport protocol used by the load balancing
	//rule.
	Protocol *TransportProtocol_Spec `json:"protocol,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancingRule_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *LoadBalancingRule_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	var result LoadBalancingRule_SpecARM

	// Set property ‘Id’:
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rule.BackendAddressPool != nil ||
		rule.BackendPort != nil ||
		rule.DisableOutboundSnat != nil ||
		rule.EnableFloatingIP != nil ||
		rule.EnableTcpReset != nil ||
		rule.FrontendIPConfiguration != nil ||
		rule.FrontendPort != nil ||
		rule.IdleTimeoutInMinutes != nil ||
		rule.LoadDistribution != nil ||
		rule.Probe != nil ||
		rule.Protocol != nil {
		result.Properties = &LoadBalancingRulePropertiesFormat_SpecARM{}
	}
	if rule.BackendAddressPool != nil {
		backendAddressPoolARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendAddressPool := backendAddressPoolARM.(SubResource_SpecARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if rule.BackendPort != nil {
		backendPort := *rule.BackendPort
		result.Properties.BackendPort = &backendPort
	}
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		result.Properties.DisableOutboundSnat = &disableOutboundSnat
	}
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	if rule.FrontendIPConfiguration != nil {
		frontendIPConfigurationARM, err := (*rule.FrontendIPConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		frontendIPConfiguration := frontendIPConfigurationARM.(SubResource_SpecARM)
		result.Properties.FrontendIPConfiguration = &frontendIPConfiguration
	}
	if rule.FrontendPort != nil {
		result.Properties.FrontendPort = *rule.FrontendPort
	}
	if rule.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rule.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rule.LoadDistribution != nil {
		loadDistribution := *rule.LoadDistribution
		result.Properties.LoadDistribution = &loadDistribution
	}
	if rule.Probe != nil {
		probeARM, err := (*rule.Probe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		probe := probeARM.(SubResource_SpecARM)
		result.Properties.Probe = &probe
	}
	if rule.Protocol != nil {
		result.Properties.Protocol = *rule.Protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *LoadBalancingRule_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *LoadBalancingRule_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_SpecARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_Spec
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rule.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Spec
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.FrontendPort = &typedInput.Properties.FrontendPort
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rule.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource_Spec
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rule.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.Protocol = &typedInput.Properties.Protocol
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancingRule_Spec populates our LoadBalancingRule_Spec from the provided source LoadBalancingRule_Spec
func (rule *LoadBalancingRule_Spec) AssignPropertiesFromLoadBalancingRule_Spec(source *v1alpha1api20201101storage.LoadBalancingRule_Spec) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Spec
		err := backendAddressPool.AssignPropertiesFromSubResource_Spec(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Spec
		err := frontendIPConfiguration.AssignPropertiesFromSubResource_Spec(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormat_LoadDistribution_Spec(*source.LoadDistribution)
		rule.LoadDistribution = &loadDistribution
	} else {
		rule.LoadDistribution = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource_Spec
		err := probe.AssignPropertiesFromSubResource_Spec(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field Probe")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Spec(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancingRule_Spec populates the provided destination LoadBalancingRule_Spec from our LoadBalancingRule_Spec
func (rule *LoadBalancingRule_Spec) AssignPropertiesToLoadBalancingRule_Spec(destination *v1alpha1api20201101storage.LoadBalancingRule_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Spec
		err := rule.BackendAddressPool.AssignPropertiesToSubResource_Spec(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Spec
		err := rule.FrontendIPConfiguration.AssignPropertiesToSubResource_Spec(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	if rule.LoadDistribution != nil {
		loadDistribution := string(*rule.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var probe v1alpha1api20201101storage.SubResource_Spec
		err := rule.Probe.AssignPropertiesToSubResource_Spec(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LoadBalancingRule_Status struct {
	//BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Status `json:"backendAddressPool,omitempty"`

	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 0 and 65535. Note that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	//DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the
	//publicIP address specified in the frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Status `json:"frontendIPConfiguration,omitempty"`

	//FrontendPort: The port for the external endpoint. Port numbers for each rule
	//must be unique within the Load Balancer. Acceptable values are between 0 and
	//65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormat_LoadDistribution_Status `json:"loadDistribution,omitempty"`

	//Name: The name of the resource that is unique within the set of load balancing
	//rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource_Status `json:"probe,omitempty"`

	//Protocol: The reference to the transport protocol used by the load balancing
	//rule.
	Protocol *TransportProtocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the load balancing rule resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancingRule_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *LoadBalancingRule_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *LoadBalancingRule_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_Status
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			rule.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			rule.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			rule.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			rule.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			rule.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.FrontendPort = &typedInput.Properties.FrontendPort
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			rule.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource_Status
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			rule.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancingRule_Status populates our LoadBalancingRule_Status from the provided source LoadBalancingRule_Status
func (rule *LoadBalancingRule_Status) AssignPropertiesFromLoadBalancingRule_Status(source *v1alpha1api20201101storage.LoadBalancingRule_Status) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResource_Status(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// BackendPort
	rule.BackendPort = genruntime.ClonePointerToInt(source.BackendPort)

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		rule.DisableOutboundSnat = &disableOutboundSnat
	} else {
		rule.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		rule.EnableFloatingIP = &enableFloatingIP
	} else {
		rule.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResource_Status(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field FrontendIPConfiguration")
		}
		rule.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		rule.FrontendIPConfiguration = nil
	}

	// FrontendPort
	rule.FrontendPort = genruntime.ClonePointerToInt(source.FrontendPort)

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormat_LoadDistribution_Status(*source.LoadDistribution)
		rule.LoadDistribution = &loadDistribution
	} else {
		rule.LoadDistribution = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Probe
	if source.Probe != nil {
		var probe SubResource_Status
		err := probe.AssignPropertiesFromSubResource_Status(source.Probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field Probe")
		}
		rule.Probe = &probe
	} else {
		rule.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToLoadBalancingRule_Status populates the provided destination LoadBalancingRule_Status from our LoadBalancingRule_Status
func (rule *LoadBalancingRule_Status) AssignPropertiesToLoadBalancingRule_Status(destination *v1alpha1api20201101storage.LoadBalancingRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Status
		err := rule.BackendAddressPool.AssignPropertiesToSubResource_Status(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	destination.BackendPort = genruntime.ClonePointerToInt(rule.BackendPort)

	// DisableOutboundSnat
	if rule.DisableOutboundSnat != nil {
		disableOutboundSnat := *rule.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if rule.EnableFloatingIP != nil {
		enableFloatingIP := *rule.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfiguration
	if rule.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
		err := rule.FrontendIPConfiguration.AssignPropertiesToSubResource_Status(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field FrontendIPConfiguration")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	destination.FrontendPort = genruntime.ClonePointerToInt(rule.FrontendPort)

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// LoadDistribution
	if rule.LoadDistribution != nil {
		loadDistribution := string(*rule.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Probe
	if rule.Probe != nil {
		var probe v1alpha1api20201101storage.SubResource_Status
		err := rule.Probe.AssignPropertiesToSubResource_Status(&probe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field Probe")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OutboundRule_Spec struct {
	//AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Spec `json:"backendAddressPool,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource_Spec `json:"frontendIPConfigurations,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of outbound rules
	//used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormat_Protocol_Spec `json:"protocol,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &OutboundRule_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *OutboundRule_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	var result OutboundRule_SpecARM

	// Set property ‘Id’:
	if rule.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*rule.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if rule.AllocatedOutboundPorts != nil ||
		rule.BackendAddressPool != nil ||
		rule.EnableTcpReset != nil ||
		rule.FrontendIPConfigurations != nil ||
		rule.IdleTimeoutInMinutes != nil ||
		rule.Protocol != nil {
		result.Properties = &OutboundRulePropertiesFormat_SpecARM{}
	}
	if rule.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *rule.AllocatedOutboundPorts
		result.Properties.AllocatedOutboundPorts = &allocatedOutboundPorts
	}
	var temp SubResource_SpecARM
	tempARM, err := (*rule.BackendAddressPool).ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	temp = tempARM.(SubResource_SpecARM)
	result.Properties.BackendAddressPool = temp
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	for _, item := range rule.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(SubResource_SpecARM))
	}
	if rule.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *rule.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if rule.Protocol != nil {
		result.Properties.Protocol = *rule.Protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_SpecARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rule.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource_Spec
		var temp1 SubResource_Spec
		err := temp1.PopulateFromARM(owner, typedInput.Properties.BackendAddressPool)
		if err != nil {
			return err
		}
		temp = temp1
		rule.BackendAddressPool = &temp
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendIPConfigurations = append(rule.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.Protocol = &typedInput.Properties.Protocol
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromOutboundRule_Spec populates our OutboundRule_Spec from the provided source OutboundRule_Spec
func (rule *OutboundRule_Spec) AssignPropertiesFromOutboundRule_Spec(source *v1alpha1api20201101storage.OutboundRule_Spec) error {

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Spec
		err := backendAddressPool.AssignPropertiesFromSubResource_Spec(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource_Spec, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource_Spec
			err := frontendIPConfiguration.AssignPropertiesFromSubResource_Spec(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormat_Protocol_Spec(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		rule.Reference = &reference
	} else {
		rule.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOutboundRule_Spec populates the provided destination OutboundRule_Spec from our OutboundRule_Spec
func (rule *OutboundRule_Spec) AssignPropertiesToOutboundRule_Spec(destination *v1alpha1api20201101storage.OutboundRule_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Spec
		err := rule.BackendAddressPool.AssignPropertiesToSubResource_Spec(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v1alpha1api20201101storage.SubResource_Spec, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Spec
			err := frontendIPConfigurationItem.AssignPropertiesToSubResource_Spec(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if rule.Reference != nil {
		reference := rule.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OutboundRule_Status struct {
	//AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Status `json:"backendAddressPool,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource_Status `json:"frontendIPConfigurations,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of outbound rules
	//used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormat_Protocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the outbound rule resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &OutboundRule_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_StatusARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			rule.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource_Status
		var temp1 SubResource_Status
		err := temp1.PopulateFromARM(owner, typedInput.Properties.BackendAddressPool)
		if err != nil {
			return err
		}
		temp = temp1
		rule.BackendAddressPool = &temp
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			rule.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendIPConfigurations = append(rule.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			rule.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		rule.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromOutboundRule_Status populates our OutboundRule_Status from the provided source OutboundRule_Status
func (rule *OutboundRule_Status) AssignPropertiesFromOutboundRule_Status(source *v1alpha1api20201101storage.OutboundRule_Status) error {

	// AllocatedOutboundPorts
	rule.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResource_Status(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field BackendAddressPool")
		}
		rule.BackendAddressPool = &backendAddressPool
	} else {
		rule.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		rule.EnableTcpReset = &enableTcpReset
	} else {
		rule.EnableTcpReset = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendIPConfigurations
	if source.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]SubResource_Status, len(source.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration SubResource_Status
			err := frontendIPConfiguration.AssignPropertiesFromSubResource_Status(&frontendIPConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		rule.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		rule.FrontendIPConfigurations = nil
	}

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// IdleTimeoutInMinutes
	rule.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormat_Protocol_Status(*source.Protocol)
		rule.Protocol = &protocol
	} else {
		rule.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToOutboundRule_Status populates the provided destination OutboundRule_Status from our OutboundRule_Status
func (rule *OutboundRule_Status) AssignPropertiesToOutboundRule_Status(destination *v1alpha1api20201101storage.OutboundRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(rule.AllocatedOutboundPorts)

	// BackendAddressPool
	if rule.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Status
		err := rule.BackendAddressPool.AssignPropertiesToSubResource_Status(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field BackendAddressPool")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if rule.EnableTcpReset != nil {
		enableTcpReset := *rule.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// FrontendIPConfigurations
	if rule.FrontendIPConfigurations != nil {
		frontendIPConfigurationList := make([]v1alpha1api20201101storage.SubResource_Status, len(rule.FrontendIPConfigurations))
		for frontendIPConfigurationIndex, frontendIPConfigurationItem := range rule.FrontendIPConfigurations {
			// Shadow the loop variable to avoid aliasing
			frontendIPConfigurationItem := frontendIPConfigurationItem
			var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
			err := frontendIPConfigurationItem.AssignPropertiesToSubResource_Status(&frontendIPConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field FrontendIPConfigurations")
			}
			frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
		}
		destination.FrontendIPConfigurations = frontendIPConfigurationList
	} else {
		destination.FrontendIPConfigurations = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(rule.IdleTimeoutInMinutes)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocol
	if rule.Protocol != nil {
		protocol := string(*rule.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Probe_Spec struct {
	//IntervalInSeconds: The interval, in seconds, for how frequently to probe the
	//endpoint for health status. Typically, the interval is slightly less than half
	//the allocated timeout period (in seconds) which allows two full probes before
	//taking the instance out of rotation. The default value is 15, the minimum value
	//is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	//Name: The name of the resource that is unique within the set of probes used by
	//the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//NumberOfProbes: The number of probes where if no response, will result in
	//stopping further traffic from being delivered to the endpoint. This values
	//allows endpoints to be taken out of rotation faster or slower than the typical
	//times used in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	//Port: The port for communicating the probe. Possible values range from 1 to
	//65535, inclusive.
	Port *int `json:"port,omitempty"`

	//Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK
	//is required for the probe to be successful. If 'Http' or 'Https' is specified, a
	//200 OK response from the specifies URI is required for the probe to be
	//successful.
	Protocol *ProbePropertiesFormat_Protocol_Spec `json:"protocol,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//RequestPath: The URI used for requesting health status from the VM. Path is
	//required if a protocol is set to http. Otherwise, it is not allowed. There is no
	//default value.
	RequestPath *string `json:"requestPath,omitempty"`
}

var _ genruntime.ARMTransformer = &Probe_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *Probe_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	var result Probe_SpecARM

	// Set property ‘Id’:
	if probe.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*probe.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if probe.Name != nil {
		name := *probe.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if probe.IntervalInSeconds != nil ||
		probe.NumberOfProbes != nil ||
		probe.Port != nil ||
		probe.Protocol != nil ||
		probe.RequestPath != nil {
		result.Properties = &ProbePropertiesFormat_SpecARM{}
	}
	if probe.IntervalInSeconds != nil {
		intervalInSeconds := *probe.IntervalInSeconds
		result.Properties.IntervalInSeconds = &intervalInSeconds
	}
	if probe.NumberOfProbes != nil {
		numberOfProbes := *probe.NumberOfProbes
		result.Properties.NumberOfProbes = &numberOfProbes
	}
	if probe.Port != nil {
		result.Properties.Port = *probe.Port
	}
	if probe.Protocol != nil {
		result.Properties.Protocol = *probe.Protocol
	}
	if probe.RequestPath != nil {
		requestPath := *probe.RequestPath
		result.Properties.RequestPath = &requestPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *Probe_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *Probe_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_SpecARM, got %T", armInput)
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probe.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probe.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probe.Port = &typedInput.Properties.Port
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probe.Protocol = &typedInput.Properties.Protocol
	}

	// no assignment for property ‘Reference’

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probe.RequestPath = &requestPath
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromProbe_Spec populates our Probe_Spec from the provided source Probe_Spec
func (probe *Probe_Spec) AssignPropertiesFromProbe_Spec(source *v1alpha1api20201101storage.Probe_Spec) error {

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormat_Protocol_Spec(*source.Protocol)
		probe.Protocol = &protocol
	} else {
		probe.Protocol = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		probe.Reference = &reference
	} else {
		probe.Reference = nil
	}

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// No error
	return nil
}

// AssignPropertiesToProbe_Spec populates the provided destination Probe_Spec from our Probe_Spec
func (probe *Probe_Spec) AssignPropertiesToProbe_Spec(destination *v1alpha1api20201101storage.Probe_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Reference
	if probe.Reference != nil {
		reference := probe.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Probe_Status struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IntervalInSeconds: The interval, in seconds, for how frequently to probe the
	//endpoint for health status. Typically, the interval is slightly less than half
	//the allocated timeout period (in seconds) which allows two full probes before
	//taking the instance out of rotation. The default value is 15, the minimum value
	//is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	//LoadBalancingRules: The load balancer rules that use this probe.
	LoadBalancingRules []SubResource_Status `json:"loadBalancingRules,omitempty"`

	//Name: The name of the resource that is unique within the set of probes used by
	//the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//NumberOfProbes: The number of probes where if no response, will result in
	//stopping further traffic from being delivered to the endpoint. This values
	//allows endpoints to be taken out of rotation faster or slower than the typical
	//times used in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	//Port: The port for communicating the probe. Possible values range from 1 to
	//65535, inclusive.
	Port *int `json:"port,omitempty"`

	//Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK
	//is required for the probe to be successful. If 'Http' or 'Https' is specified, a
	//200 OK response from the specifies URI is required for the probe to be
	//successful.
	Protocol *ProbePropertiesFormat_Protocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the probe resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//RequestPath: The URI used for requesting health status from the VM. Path is
	//required if a protocol is set to http. Otherwise, it is not allowed. There is no
	//default value.
	RequestPath *string `json:"requestPath,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Probe_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *Probe_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *Probe_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_StatusARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		probe.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		probe.Id = &id
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probe.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			probe.LoadBalancingRules = append(probe.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probe.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probe.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probe.Port = &typedInput.Properties.Port
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probe.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			probe.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probe.RequestPath = &requestPath
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		probe.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromProbe_Status populates our Probe_Status from the provided source Probe_Status
func (probe *Probe_Status) AssignPropertiesFromProbe_Status(source *v1alpha1api20201101storage.Probe_Status) error {

	// Etag
	probe.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	probe.Id = genruntime.ClonePointerToString(source.Id)

	// IntervalInSeconds
	probe.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// LoadBalancingRules
	if source.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule SubResource_Status
			err := loadBalancingRule.AssignPropertiesFromSubResource_Status(&loadBalancingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		probe.LoadBalancingRules = loadBalancingRuleList
	} else {
		probe.LoadBalancingRules = nil
	}

	// Name
	probe.Name = genruntime.ClonePointerToString(source.Name)

	// NumberOfProbes
	probe.NumberOfProbes = genruntime.ClonePointerToInt(source.NumberOfProbes)

	// Port
	probe.Port = genruntime.ClonePointerToInt(source.Port)

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormat_Protocol_Status(*source.Protocol)
		probe.Protocol = &protocol
	} else {
		probe.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		probe.ProvisioningState = &provisioningState
	} else {
		probe.ProvisioningState = nil
	}

	// RequestPath
	probe.RequestPath = genruntime.ClonePointerToString(source.RequestPath)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToProbe_Status populates the provided destination Probe_Status from our Probe_Status
func (probe *Probe_Status) AssignPropertiesToProbe_Status(destination *v1alpha1api20201101storage.Probe_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	destination.Etag = genruntime.ClonePointerToString(probe.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(probe.Id)

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(probe.IntervalInSeconds)

	// LoadBalancingRules
	if probe.LoadBalancingRules != nil {
		loadBalancingRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(probe.LoadBalancingRules))
		for loadBalancingRuleIndex, loadBalancingRuleItem := range probe.LoadBalancingRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancingRuleItem := loadBalancingRuleItem
			var loadBalancingRule v1alpha1api20201101storage.SubResource_Status
			err := loadBalancingRuleItem.AssignPropertiesToSubResource_Status(&loadBalancingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_Status() to populate field LoadBalancingRules")
			}
			loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
		}
		destination.LoadBalancingRules = loadBalancingRuleList
	} else {
		destination.LoadBalancingRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(probe.Name)

	// NumberOfProbes
	destination.NumberOfProbes = genruntime.ClonePointerToInt(probe.NumberOfProbes)

	// Port
	destination.Port = genruntime.ClonePointerToInt(probe.Port)

	// Protocol
	if probe.Protocol != nil {
		protocol := string(*probe.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if probe.ProvisioningState != nil {
		provisioningState := string(*probe.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RequestPath
	destination.RequestPath = genruntime.ClonePointerToString(probe.RequestPath)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ProvisioningState_Status string

const (
	ProvisioningState_StatusDeleting  = ProvisioningState_Status("Deleting")
	ProvisioningState_StatusFailed    = ProvisioningState_Status("Failed")
	ProvisioningState_StatusSucceeded = ProvisioningState_Status("Succeeded")
	ProvisioningState_StatusUpdating  = ProvisioningState_Status("Updating")
)

// +kubebuilder:validation:Enum={"Default","SourceIP","SourceIPProtocol"}
type LoadBalancingRulePropertiesFormat_LoadDistribution_Spec string

const (
	LoadBalancingRulePropertiesFormat_LoadDistribution_SpecDefault          = LoadBalancingRulePropertiesFormat_LoadDistribution_Spec("Default")
	LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIP         = LoadBalancingRulePropertiesFormat_LoadDistribution_Spec("SourceIP")
	LoadBalancingRulePropertiesFormat_LoadDistribution_SpecSourceIPProtocol = LoadBalancingRulePropertiesFormat_LoadDistribution_Spec("SourceIPProtocol")
)

type LoadBalancingRulePropertiesFormat_LoadDistribution_Status string

const (
	LoadBalancingRulePropertiesFormat_LoadDistribution_StatusDefault          = LoadBalancingRulePropertiesFormat_LoadDistribution_Status("Default")
	LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIP         = LoadBalancingRulePropertiesFormat_LoadDistribution_Status("SourceIP")
	LoadBalancingRulePropertiesFormat_LoadDistribution_StatusSourceIPProtocol = LoadBalancingRulePropertiesFormat_LoadDistribution_Status("SourceIPProtocol")
)

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type OutboundRulePropertiesFormat_Protocol_Spec string

const (
	OutboundRulePropertiesFormat_Protocol_SpecAll = OutboundRulePropertiesFormat_Protocol_Spec("All")
	OutboundRulePropertiesFormat_Protocol_SpecTcp = OutboundRulePropertiesFormat_Protocol_Spec("Tcp")
	OutboundRulePropertiesFormat_Protocol_SpecUdp = OutboundRulePropertiesFormat_Protocol_Spec("Udp")
)

type OutboundRulePropertiesFormat_Protocol_Status string

const (
	OutboundRulePropertiesFormat_Protocol_StatusAll = OutboundRulePropertiesFormat_Protocol_Status("All")
	OutboundRulePropertiesFormat_Protocol_StatusTcp = OutboundRulePropertiesFormat_Protocol_Status("Tcp")
	OutboundRulePropertiesFormat_Protocol_StatusUdp = OutboundRulePropertiesFormat_Protocol_Status("Udp")
)

// +kubebuilder:validation:Enum={"Http","Https","Tcp"}
type ProbePropertiesFormat_Protocol_Spec string

const (
	ProbePropertiesFormat_Protocol_SpecHttp  = ProbePropertiesFormat_Protocol_Spec("Http")
	ProbePropertiesFormat_Protocol_SpecHttps = ProbePropertiesFormat_Protocol_Spec("Https")
	ProbePropertiesFormat_Protocol_SpecTcp   = ProbePropertiesFormat_Protocol_Spec("Tcp")
)

type ProbePropertiesFormat_Protocol_Status string

const (
	ProbePropertiesFormat_Protocol_StatusHttp  = ProbePropertiesFormat_Protocol_Status("Http")
	ProbePropertiesFormat_Protocol_StatusHttps = ProbePropertiesFormat_Protocol_Status("Https")
	ProbePropertiesFormat_Protocol_StatusTcp   = ProbePropertiesFormat_Protocol_Status("Tcp")
)

type PublicIPAddress_Spec struct {
	//DdosSettings: The DDoS protection custom policy associated with the public IP
	//address.
	DdosSettings *DdosSettings_Spec `json:"ddosSettings,omitempty"`

	//DnsSettings: The FQDN of the DNS record associated with the public IP address.
	DnsSettings *PublicIPAddressDnsSettings_Spec `json:"dnsSettings,omitempty"`

	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//IpAddress: The IP address associated with the public IP address resource.
	IpAddress *string `json:"ipAddress,omitempty"`

	//IpTags: The list of tags associated with the public IP address.
	IpTags []IpTag_Spec `json:"ipTags,omitempty"`

	//LinkedPublicIPAddress: The linked public IP address of the public IP address
	//resource.
	LinkedPublicIPAddress *PublicIPAddress_Spec `json:"linkedPublicIPAddress,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//MigrationPhase: Migration phase of Public IP Address.
	MigrationPhase *PublicIPAddressPropertiesFormat_MigrationPhase_Spec `json:"migrationPhase,omitempty"`

	//NatGateway: The NatGateway for the Public IP address.
	NatGateway *NatGateway_Spec `json:"natGateway,omitempty"`

	//PublicIPAddressVersion: The public IP address version.
	PublicIPAddressVersion *IPVersion_Spec `json:"publicIPAddressVersion,omitempty"`

	//PublicIPAllocationMethod: The public IP address allocation method.
	PublicIPAllocationMethod *IPAllocationMethod_Spec `json:"publicIPAllocationMethod,omitempty"`

	//PublicIPPrefix: The Public IP Prefix this Public IP Address should be allocated
	//from.
	PublicIPPrefix *SubResource_Spec `json:"publicIPPrefix,omitempty"`

	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//ServicePublicIPAddress: The service public IP address of the public IP address
	//resource.
	ServicePublicIPAddress *PublicIPAddress_Spec `json:"servicePublicIPAddress,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Spec `json:"sku,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &PublicIPAddress_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *PublicIPAddress_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	var result PublicIPAddress_SpecARM

	// Set property ‘ExtendedLocation’:
	if address.ExtendedLocation != nil {
		extendedLocationARM, err := (*address.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if address.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*address.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Location’:
	if address.Location != nil {
		location := *address.Location
		result.Location = &location
	}

	// Set property ‘Properties’:
	if address.DdosSettings != nil ||
		address.DnsSettings != nil ||
		address.IdleTimeoutInMinutes != nil ||
		address.IpAddress != nil ||
		address.IpTags != nil ||
		address.LinkedPublicIPAddress != nil ||
		address.MigrationPhase != nil ||
		address.NatGateway != nil ||
		address.PublicIPAddressVersion != nil ||
		address.PublicIPAllocationMethod != nil ||
		address.PublicIPPrefix != nil ||
		address.ServicePublicIPAddress != nil {
		result.Properties = &PublicIPAddressPropertiesFormat_SpecARM{}
	}
	if address.DdosSettings != nil {
		ddosSettingsARM, err := (*address.DdosSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ddosSettings := ddosSettingsARM.(DdosSettings_SpecARM)
		result.Properties.DdosSettings = &ddosSettings
	}
	if address.DnsSettings != nil {
		dnsSettingsARM, err := (*address.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(PublicIPAddressDnsSettings_SpecARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if address.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *address.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if address.IpAddress != nil {
		ipAddress := *address.IpAddress
		result.Properties.IpAddress = &ipAddress
	}
	for _, item := range address.IpTags {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, itemARM.(IpTag_SpecARM))
	}
	if address.LinkedPublicIPAddress != nil {
		linkedPublicIPAddressARM, err := (*address.LinkedPublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linkedPublicIPAddress := linkedPublicIPAddressARM.(PublicIPAddress_SpecARM)
		result.Properties.LinkedPublicIPAddress = &linkedPublicIPAddress
	}
	if address.MigrationPhase != nil {
		migrationPhase := *address.MigrationPhase
		result.Properties.MigrationPhase = &migrationPhase
	}
	if address.NatGateway != nil {
		natGatewayARM, err := (*address.NatGateway).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGateway := natGatewayARM.(NatGateway_SpecARM)
		result.Properties.NatGateway = &natGateway
	}
	if address.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *address.PublicIPAddressVersion
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if address.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := *address.PublicIPAllocationMethod
		result.Properties.PublicIPAllocationMethod = &publicIPAllocationMethod
	}
	if address.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*address.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResource_SpecARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if address.ServicePublicIPAddress != nil {
		servicePublicIPAddressARM, err := (*address.ServicePublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePublicIPAddress := servicePublicIPAddressARM.(PublicIPAddress_SpecARM)
		result.Properties.ServicePublicIPAddress = &servicePublicIPAddress
	}

	// Set property ‘Sku’:
	if address.Sku != nil {
		skuARM, err := (*address.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(PublicIPAddressSku_SpecARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if address.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range address.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range address.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *PublicIPAddress_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *PublicIPAddress_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_SpecARM, got %T", armInput)
	}

	// Set property ‘DdosSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DdosSettings != nil {
			var ddosSettings1 DdosSettings_Spec
			err := ddosSettings1.PopulateFromARM(owner, *typedInput.Properties.DdosSettings)
			if err != nil {
				return err
			}
			ddosSettings := ddosSettings1
			address.DdosSettings = &ddosSettings
		}
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 PublicIPAddressDnsSettings_Spec
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			address.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		address.ExtendedLocation = &extendedLocation
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			address.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			address.IpAddress = &ipAddress
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 IpTag_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			address.IpTags = append(address.IpTags, item1)
		}
	}

	// Set property ‘LinkedPublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinkedPublicIPAddress != nil {
			var linkedPublicIPAddress1 PublicIPAddress_Spec
			err := linkedPublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.LinkedPublicIPAddress)
			if err != nil {
				return err
			}
			linkedPublicIPAddress := linkedPublicIPAddress1
			address.LinkedPublicIPAddress = &linkedPublicIPAddress
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		address.Location = &location
	}

	// Set property ‘MigrationPhase’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationPhase != nil {
			migrationPhase := *typedInput.Properties.MigrationPhase
			address.MigrationPhase = &migrationPhase
		}
	}

	// Set property ‘NatGateway’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NatGateway != nil {
			var natGateway1 NatGateway_Spec
			err := natGateway1.PopulateFromARM(owner, *typedInput.Properties.NatGateway)
			if err != nil {
				return err
			}
			natGateway := natGateway1
			address.NatGateway = &natGateway
		}
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			address.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAllocationMethod != nil {
			publicIPAllocationMethod := *typedInput.Properties.PublicIPAllocationMethod
			address.PublicIPAllocationMethod = &publicIPAllocationMethod
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Spec
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			address.PublicIPPrefix = &publicIPPrefix
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘ServicePublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePublicIPAddress != nil {
			var servicePublicIPAddress1 PublicIPAddress_Spec
			err := servicePublicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.ServicePublicIPAddress)
			if err != nil {
				return err
			}
			servicePublicIPAddress := servicePublicIPAddress1
			address.ServicePublicIPAddress = &servicePublicIPAddress
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Spec
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		address.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		address.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			address.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		address.Zones = append(address.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddress_Spec populates our PublicIPAddress_Spec from the provided source PublicIPAddress_Spec
func (address *PublicIPAddress_Spec) AssignPropertiesFromPublicIPAddress_Spec(source *v1alpha1api20201101storage.PublicIPAddress_Spec) error {

	// DdosSettings
	if source.DdosSettings != nil {
		var ddosSetting DdosSettings_Spec
		err := ddosSetting.AssignPropertiesFromDdosSettings_Spec(source.DdosSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDdosSettings_Spec() to populate field DdosSettings")
		}
		address.DdosSettings = &ddosSetting
	} else {
		address.DdosSettings = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting PublicIPAddressDnsSettings_Spec
		err := dnsSetting.AssignPropertiesFromPublicIPAddressDnsSettings_Spec(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressDnsSettings_Spec() to populate field DnsSettings")
		}
		address.DnsSettings = &dnsSetting
	} else {
		address.DnsSettings = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Spec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		address.ExtendedLocation = &extendedLocation
	} else {
		address.ExtendedLocation = nil
	}

	// IdleTimeoutInMinutes
	address.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]IpTag_Spec, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag IpTag_Spec
			err := ipTag.AssignPropertiesFromIpTag_Spec(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIpTag_Spec() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		address.IpTags = ipTagList
	} else {
		address.IpTags = nil
	}

	// LinkedPublicIPAddress
	if source.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress PublicIPAddress_Spec
		err := linkedPublicIPAddress.AssignPropertiesFromPublicIPAddress_Spec(source.LinkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Spec() to populate field LinkedPublicIPAddress")
		}
		address.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		address.LinkedPublicIPAddress = nil
	}

	// Location
	address.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationPhase
	if source.MigrationPhase != nil {
		migrationPhase := PublicIPAddressPropertiesFormat_MigrationPhase_Spec(*source.MigrationPhase)
		address.MigrationPhase = &migrationPhase
	} else {
		address.MigrationPhase = nil
	}

	// NatGateway
	if source.NatGateway != nil {
		var natGateway NatGateway_Spec
		err := natGateway.AssignPropertiesFromNatGateway_Spec(source.NatGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNatGateway_Spec() to populate field NatGateway")
		}
		address.NatGateway = &natGateway
	} else {
		address.NatGateway = nil
	}

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := IPVersion_Spec(*source.PublicIPAddressVersion)
		address.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		address.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := IPAllocationMethod_Spec(*source.PublicIPAllocationMethod)
		address.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		address.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Spec
		err := publicIPPrefix.AssignPropertiesFromSubResource_Spec(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_Spec() to populate field PublicIPPrefix")
		}
		address.PublicIPPrefix = &publicIPPrefix
	} else {
		address.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		address.Reference = &reference
	} else {
		address.Reference = nil
	}

	// ServicePublicIPAddress
	if source.ServicePublicIPAddress != nil {
		var servicePublicIPAddress PublicIPAddress_Spec
		err := servicePublicIPAddress.AssignPropertiesFromPublicIPAddress_Spec(source.ServicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_Spec() to populate field ServicePublicIPAddress")
		}
		address.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		address.ServicePublicIPAddress = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Spec
		err := sku.AssignPropertiesFromPublicIPAddressSku_Spec(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSku_Spec() to populate field Sku")
		}
		address.Sku = &sku
	} else {
		address.Sku = nil
	}

	// Tags
	address.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Zones
	address.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddress_Spec populates the provided destination PublicIPAddress_Spec from our PublicIPAddress_Spec
func (address *PublicIPAddress_Spec) AssignPropertiesToPublicIPAddress_Spec(destination *v1alpha1api20201101storage.PublicIPAddress_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DdosSettings
	if address.DdosSettings != nil {
		var ddosSetting v1alpha1api20201101storage.DdosSettings_Spec
		err := address.DdosSettings.AssignPropertiesToDdosSettings_Spec(&ddosSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDdosSettings_Spec() to populate field DdosSettings")
		}
		destination.DdosSettings = &ddosSetting
	} else {
		destination.DdosSettings = nil
	}

	// DnsSettings
	if address.DnsSettings != nil {
		var dnsSetting v1alpha1api20201101storage.PublicIPAddressDnsSettings_Spec
		err := address.DnsSettings.AssignPropertiesToPublicIPAddressDnsSettings_Spec(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressDnsSettings_Spec() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// ExtendedLocation
	if address.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Spec
		err := address.ExtendedLocation.AssignPropertiesToExtendedLocation_Spec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Spec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(address.IdleTimeoutInMinutes)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// IpTags
	if address.IpTags != nil {
		ipTagList := make([]v1alpha1api20201101storage.IpTag_Spec, len(address.IpTags))
		for ipTagIndex, ipTagItem := range address.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v1alpha1api20201101storage.IpTag_Spec
			err := ipTagItem.AssignPropertiesToIpTag_Spec(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIpTag_Spec() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// LinkedPublicIPAddress
	if address.LinkedPublicIPAddress != nil {
		var linkedPublicIPAddress v1alpha1api20201101storage.PublicIPAddress_Spec
		err := address.LinkedPublicIPAddress.AssignPropertiesToPublicIPAddress_Spec(&linkedPublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Spec() to populate field LinkedPublicIPAddress")
		}
		destination.LinkedPublicIPAddress = &linkedPublicIPAddress
	} else {
		destination.LinkedPublicIPAddress = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(address.Location)

	// MigrationPhase
	if address.MigrationPhase != nil {
		migrationPhase := string(*address.MigrationPhase)
		destination.MigrationPhase = &migrationPhase
	} else {
		destination.MigrationPhase = nil
	}

	// NatGateway
	if address.NatGateway != nil {
		var natGateway v1alpha1api20201101storage.NatGateway_Spec
		err := address.NatGateway.AssignPropertiesToNatGateway_Spec(&natGateway)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNatGateway_Spec() to populate field NatGateway")
		}
		destination.NatGateway = &natGateway
	} else {
		destination.NatGateway = nil
	}

	// PublicIPAddressVersion
	if address.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*address.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if address.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := string(*address.PublicIPAllocationMethod)
		destination.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		destination.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if address.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Spec
		err := address.PublicIPPrefix.AssignPropertiesToSubResource_Spec(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_Spec() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if address.Reference != nil {
		reference := address.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ServicePublicIPAddress
	if address.ServicePublicIPAddress != nil {
		var servicePublicIPAddress v1alpha1api20201101storage.PublicIPAddress_Spec
		err := address.ServicePublicIPAddress.AssignPropertiesToPublicIPAddress_Spec(&servicePublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_Spec() to populate field ServicePublicIPAddress")
		}
		destination.ServicePublicIPAddress = &servicePublicIPAddress
	} else {
		destination.ServicePublicIPAddress = nil
	}

	// Sku
	if address.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Spec
		err := address.Sku.AssignPropertiesToPublicIPAddressSku_Spec(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSku_Spec() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(address.Tags)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(address.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Status `json:"sku,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		embedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		embedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		embedded.Zones = append(embedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded populates our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from the provided source PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocation_Status(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_Status() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSku_Status(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSku_Status() to populate field Sku")
		}
		embedded.Sku = &sku
	} else {
		embedded.Sku = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded populates the provided destination PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (embedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToPublicIPAddress_Status_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_Status(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_Status() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Sku
	if embedded.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Status
		err := embedded.Sku.AssignPropertiesToPublicIPAddressSku_Status(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSku_Status() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet_Spec_LoadBalancer_SubResourceEmbedded struct {
	//Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &Subnet_Spec_LoadBalancer_SubResourceEmbedded{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (embedded *Subnet_Spec_LoadBalancer_SubResourceEmbedded) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if embedded == nil {
		return nil, nil
	}
	var result Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM

	// Set property ‘Id’:
	if embedded.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*embedded.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_Spec_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_Spec_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Spec_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded populates our Subnet_Spec_LoadBalancer_SubResourceEmbedded from the provided source Subnet_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromSubnet_Spec_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Spec_LoadBalancer_SubResourceEmbedded) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded populates the provided destination Subnet_Spec_LoadBalancer_SubResourceEmbedded from our Subnet_Spec_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Spec_LoadBalancer_SubResourceEmbedded) AssignPropertiesToSubnet_Spec_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Spec_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Subnet_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_Status_LoadBalancer_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded populates our Subnet_Status_LoadBalancer_SubResourceEmbedded from the provided source Subnet_Status_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromSubnet_Status_LoadBalancer_SubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded populates the provided destination Subnet_Status_LoadBalancer_SubResourceEmbedded from our Subnet_Status_LoadBalancer_SubResourceEmbedded
func (embedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToSubnet_Status_LoadBalancer_SubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type TransportProtocol_Spec string

const (
	TransportProtocol_SpecAll = TransportProtocol_Spec("All")
	TransportProtocol_SpecTcp = TransportProtocol_Spec("Tcp")
	TransportProtocol_SpecUdp = TransportProtocol_Spec("Udp")
)

type TransportProtocol_Status string

const (
	TransportProtocol_StatusAll = TransportProtocol_Status("All")
	TransportProtocol_StatusTcp = TransportProtocol_Status("Tcp")
	TransportProtocol_StatusUdp = TransportProtocol_Status("Udp")
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
