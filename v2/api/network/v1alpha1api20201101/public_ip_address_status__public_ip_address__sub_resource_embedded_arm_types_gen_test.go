// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM, PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(subject PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSTATUSARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM, PublicIPAddressPropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM(subject PublicIPAddressPropertiesFormat_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
// PublicIPAddressPropertiesFormatSTATUSARMGenerator()
var publicIPAddressPropertiesFormatSTATUSARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatSTATUSARMGenerator returns a generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatSTATUSARMGenerator != nil {
		return publicIPAddressPropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	publicIPAddressPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	publicIPAddressPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	return publicIPAddressPropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Abort,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Commit,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Committed,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_None,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Prepare))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_STATUS_IPv4, IPVersion_STATUS_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsSTATUSARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsSTATUSARMGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagSTATUSARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_PublicIPAddressSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM, PublicIPAddressSkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM runs a test to see if a specific instance of PublicIPAddressSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM(subject PublicIPAddressSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku_STATUSARM instances for property testing - lazily instantiated by
// PublicIPAddressSkuSTATUSARMGenerator()
var publicIPAddressSkuSTATUSARMGenerator gopter.Gen

// PublicIPAddressSkuSTATUSARMGenerator returns a generator of PublicIPAddressSku_STATUSARM instances for property testing.
func PublicIPAddressSkuSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressSkuSTATUSARMGenerator != nil {
		return publicIPAddressSkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM(generators)
	publicIPAddressSkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_STATUSARM{}), generators)

	return publicIPAddressSkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSTATUSName_Basic, PublicIPAddressSkuSTATUSName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSTATUSTier_Global, PublicIPAddressSkuSTATUSTier_Regional))
}

func Test_DdosSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDdosSettingsSTATUSARM, DdosSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettingsSTATUSARM runs a test to see if a specific instance of DdosSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettingsSTATUSARM(subject DdosSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettings_STATUSARM instances for property testing - lazily instantiated by
// DdosSettingsSTATUSARMGenerator()
var ddosSettingsSTATUSARMGenerator gopter.Gen

// DdosSettingsSTATUSARMGenerator returns a generator of DdosSettings_STATUSARM instances for property testing.
// We first initialize ddosSettingsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettingsSTATUSARMGenerator() gopter.Gen {
	if ddosSettingsSTATUSARMGenerator != nil {
		return ddosSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	ddosSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	ddosSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	return ddosSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettingsSTATUSProtectionCoverage_Basic, DdosSettingsSTATUSProtectionCoverage_Standard))
}

// AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM, IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(subject IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
}

func Test_IpTag_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTag_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpTagSTATUSARM, IpTagSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTagSTATUSARM runs a test to see if a specific instance of IpTag_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTagSTATUSARM(subject IpTag_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTag_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpTag_STATUSARM instances for property testing - lazily instantiated by IpTagSTATUSARMGenerator()
var ipTagSTATUSARMGenerator gopter.Gen

// IpTagSTATUSARMGenerator returns a generator of IpTag_STATUSARM instances for property testing.
func IpTagSTATUSARMGenerator() gopter.Gen {
	if ipTagSTATUSARMGenerator != nil {
		return ipTagSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTagSTATUSARM(generators)
	ipTagSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IpTag_STATUSARM{}), generators)

	return ipTagSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTagSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTagSTATUSARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM, NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(subject NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(NatGatewaySkuSTATUSARMGenerator())
}

func Test_PublicIPAddressDnsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM, PublicIPAddressDnsSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM runs a test to see if a specific instance of PublicIPAddressDnsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM(subject PublicIPAddressDnsSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettings_STATUSARM instances for property testing - lazily instantiated by
// PublicIPAddressDnsSettingsSTATUSARMGenerator()
var publicIPAddressDnsSettingsSTATUSARMGenerator gopter.Gen

// PublicIPAddressDnsSettingsSTATUSARMGenerator returns a generator of PublicIPAddressDnsSettings_STATUSARM instances for property testing.
func PublicIPAddressDnsSettingsSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettingsSTATUSARMGenerator != nil {
		return publicIPAddressDnsSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM(generators)
	publicIPAddressDnsSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettings_STATUSARM{}), generators)

	return publicIPAddressDnsSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM, IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(subject IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property
// testing - lazily instantiated by IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
}

func Test_NatGatewaySku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySkuSTATUSARM, NatGatewaySkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySkuSTATUSARM runs a test to see if a specific instance of NatGatewaySku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySkuSTATUSARM(subject NatGatewaySku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySku_STATUSARM instances for property testing - lazily instantiated by
// NatGatewaySkuSTATUSARMGenerator()
var natGatewaySkuSTATUSARMGenerator gopter.Gen

// NatGatewaySkuSTATUSARMGenerator returns a generator of NatGatewaySku_STATUSARM instances for property testing.
func NatGatewaySkuSTATUSARMGenerator() gopter.Gen {
	if natGatewaySkuSTATUSARMGenerator != nil {
		return natGatewaySkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM(generators)
	natGatewaySkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_STATUSARM{}), generators)

	return natGatewaySkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySkuSTATUSName_Standard))
}

func Test_Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM, SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(subject Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
func SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
