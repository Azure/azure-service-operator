// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM, PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(subject PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM, PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(subject PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
<<<<<<< HEAD
// instantiated by PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return publicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
=======
// instantiated by PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_STATUSARMGenerator())
=======
// AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSTATUSARMGenerator())
>>>>>>> main
}

func Test_PublicIPAddressPropertiesFormat_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM, PublicIPAddressPropertiesFormat_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_STATUSARM(subject PublicIPAddressPropertiesFormat_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM, PublicIPAddressPropertiesFormatSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatSTATUSARM(subject PublicIPAddressPropertiesFormat_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing - lazily instantiated by
<<<<<<< HEAD
// PublicIPAddressPropertiesFormat_STATUSARMGenerator()
var publicIPAddressPropertiesFormat_STATUSARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_STATUSARMGenerator returns a generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_STATUSARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_STATUSARMGenerator != nil {
		return publicIPAddressPropertiesFormat_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	publicIPAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(generators)
	publicIPAddressPropertiesFormat_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	return publicIPAddressPropertiesFormat_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_None_STATUS,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4_STATUS, IPVersion_IPv6_STATUS))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic_STATUS, IPAllocationMethod_Static_STATUS))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_STATUSARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_STATUSARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_STATUSARMGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_STATUSARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_STATUSARMGenerator())
=======
// PublicIPAddressPropertiesFormatSTATUSARMGenerator()
var publicIPAddressPropertiesFormatSTATUSARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatSTATUSARMGenerator returns a generator of PublicIPAddressPropertiesFormat_STATUSARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatSTATUSARMGenerator != nil {
		return publicIPAddressPropertiesFormatSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	publicIPAddressPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(generators)
	publicIPAddressPropertiesFormatSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_STATUSARM{}), generators)

	return publicIPAddressPropertiesFormatSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Abort,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Commit,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Committed,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_None,
		PublicIPAddressPropertiesFormatSTATUSMigrationPhase_Prepare))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_STATUS_IPv4, IPVersion_STATUS_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSTATUSARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsSTATUSARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsSTATUSARMGenerator())
	gens["IpConfiguration"] = gen.PtrOf(IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagSTATUSARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
>>>>>>> main
}

func Test_PublicIPAddressSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSku_STATUSARM, PublicIPAddressSku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSku_STATUSARM runs a test to see if a specific instance of PublicIPAddressSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSku_STATUSARM(subject PublicIPAddressSku_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM, PublicIPAddressSkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM runs a test to see if a specific instance of PublicIPAddressSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuSTATUSARM(subject PublicIPAddressSku_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku_STATUSARM instances for property testing - lazily instantiated by
<<<<<<< HEAD
// PublicIPAddressSku_STATUSARMGenerator()
var publicIPAddressSku_STATUSARMGenerator gopter.Gen

// PublicIPAddressSku_STATUSARMGenerator returns a generator of PublicIPAddressSku_STATUSARM instances for property testing.
func PublicIPAddressSku_STATUSARMGenerator() gopter.Gen {
	if publicIPAddressSku_STATUSARMGenerator != nil {
		return publicIPAddressSku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSku_STATUSARM(generators)
	publicIPAddressSku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_STATUSARM{}), generators)

	return publicIPAddressSku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Name_Basic_STATUS, PublicIPAddressSku_Name_Standard_STATUS))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Tier_Global_STATUS, PublicIPAddressSku_Tier_Regional_STATUS))
=======
// PublicIPAddressSkuSTATUSARMGenerator()
var publicIPAddressSkuSTATUSARMGenerator gopter.Gen

// PublicIPAddressSkuSTATUSARMGenerator returns a generator of PublicIPAddressSku_STATUSARM instances for property testing.
func PublicIPAddressSkuSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressSkuSTATUSARMGenerator != nil {
		return publicIPAddressSkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM(generators)
	publicIPAddressSkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_STATUSARM{}), generators)

	return publicIPAddressSkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSTATUSName_Basic, PublicIPAddressSkuSTATUSName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSTATUSTier_Global, PublicIPAddressSkuSTATUSTier_Regional))
>>>>>>> main
}

func Test_DdosSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettings_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForDdosSettings_STATUSARM, DdosSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettings_STATUSARM runs a test to see if a specific instance of DdosSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettings_STATUSARM(subject DdosSettings_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForDdosSettingsSTATUSARM, DdosSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettingsSTATUSARM runs a test to see if a specific instance of DdosSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettingsSTATUSARM(subject DdosSettings_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettings_STATUSARM instances for property testing - lazily instantiated by
<<<<<<< HEAD
// DdosSettings_STATUSARMGenerator()
var ddosSettings_STATUSARMGenerator gopter.Gen

// DdosSettings_STATUSARMGenerator returns a generator of DdosSettings_STATUSARM instances for property testing.
// We first initialize ddosSettings_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettings_STATUSARMGenerator() gopter.Gen {
	if ddosSettings_STATUSARMGenerator != nil {
		return ddosSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettings_STATUSARM(generators)
	ddosSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettings_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettings_STATUSARM(generators)
	ddosSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	return ddosSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettings_ProtectionCoverage_Basic_STATUS, DdosSettings_ProtectionCoverage_Standard_STATUS))
}

// AddRelatedPropertyGeneratorsForDdosSettings_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResource_STATUSARMGenerator())
=======
// DdosSettingsSTATUSARMGenerator()
var ddosSettingsSTATUSARMGenerator gopter.Gen

// DdosSettingsSTATUSARMGenerator returns a generator of DdosSettings_STATUSARM instances for property testing.
// We first initialize ddosSettingsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettingsSTATUSARMGenerator() gopter.Gen {
	if ddosSettingsSTATUSARMGenerator != nil {
		return ddosSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	ddosSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM(generators)
	ddosSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_STATUSARM{}), generators)

	return ddosSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettingsSTATUSProtectionCoverage_Basic, DdosSettingsSTATUSProtectionCoverage_Standard))
}

// AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
>>>>>>> main
}

func Test_IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM, IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(subject IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM, IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(subject IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
<<<<<<< HEAD
// instantiated by IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
=======
// instantiated by IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfiguration_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator())
=======
// AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
>>>>>>> main
}

func Test_IpTag_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTag_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIpTag_STATUSARM, IpTag_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTag_STATUSARM runs a test to see if a specific instance of IpTag_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTag_STATUSARM(subject IpTag_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForIpTagSTATUSARM, IpTagSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTagSTATUSARM runs a test to see if a specific instance of IpTag_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTagSTATUSARM(subject IpTag_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTag_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of IpTag_STATUSARM instances for property testing - lazily instantiated by IpTag_STATUSARMGenerator()
var ipTag_STATUSARMGenerator gopter.Gen

// IpTag_STATUSARMGenerator returns a generator of IpTag_STATUSARM instances for property testing.
func IpTag_STATUSARMGenerator() gopter.Gen {
	if ipTag_STATUSARMGenerator != nil {
		return ipTag_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTag_STATUSARM(generators)
	ipTag_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IpTag_STATUSARM{}), generators)

	return ipTag_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTag_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTag_STATUSARM(gens map[string]gopter.Gen) {
=======
// Generator of IpTag_STATUSARM instances for property testing - lazily instantiated by IpTagSTATUSARMGenerator()
var ipTagSTATUSARMGenerator gopter.Gen

// IpTagSTATUSARMGenerator returns a generator of IpTag_STATUSARM instances for property testing.
func IpTagSTATUSARMGenerator() gopter.Gen {
	if ipTagSTATUSARMGenerator != nil {
		return ipTagSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTagSTATUSARM(generators)
	ipTagSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IpTag_STATUSARM{}), generators)

	return ipTagSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTagSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTagSTATUSARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM, NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(subject NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM, NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(subject NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
<<<<<<< HEAD
// instantiated by NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return natGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
=======
// instantiated by NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return natGatewaySTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGateway_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(NatGatewaySku_STATUSARMGenerator())
=======
// AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewaySTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(NatGatewaySkuSTATUSARMGenerator())
>>>>>>> main
}

func Test_PublicIPAddressDnsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettings_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettings_STATUSARM, PublicIPAddressDnsSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettings_STATUSARM runs a test to see if a specific instance of PublicIPAddressDnsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettings_STATUSARM(subject PublicIPAddressDnsSettings_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM, PublicIPAddressDnsSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM runs a test to see if a specific instance of PublicIPAddressDnsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettingsSTATUSARM(subject PublicIPAddressDnsSettings_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettings_STATUSARM instances for property testing - lazily instantiated by
<<<<<<< HEAD
// PublicIPAddressDnsSettings_STATUSARMGenerator()
var publicIPAddressDnsSettings_STATUSARMGenerator gopter.Gen

// PublicIPAddressDnsSettings_STATUSARMGenerator returns a generator of PublicIPAddressDnsSettings_STATUSARM instances for property testing.
func PublicIPAddressDnsSettings_STATUSARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettings_STATUSARMGenerator != nil {
		return publicIPAddressDnsSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_STATUSARM(generators)
	publicIPAddressDnsSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettings_STATUSARM{}), generators)

	return publicIPAddressDnsSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_STATUSARM(gens map[string]gopter.Gen) {
=======
// PublicIPAddressDnsSettingsSTATUSARMGenerator()
var publicIPAddressDnsSettingsSTATUSARMGenerator gopter.Gen

// PublicIPAddressDnsSettingsSTATUSARMGenerator returns a generator of PublicIPAddressDnsSettings_STATUSARM instances for property testing.
func PublicIPAddressDnsSettingsSTATUSARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettingsSTATUSARMGenerator != nil {
		return publicIPAddressDnsSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM(generators)
	publicIPAddressDnsSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettings_STATUSARM{}), generators)

	return publicIPAddressDnsSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSTATUSARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM, IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(subject IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM, IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(subject IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property
<<<<<<< HEAD
// testing - lazily instantiated by IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic_STATUS, IPAllocationMethod_Static_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Deleting_STATUS,
		ProvisioningState_Failed_STATUS,
		ProvisioningState_Succeeded_STATUS,
		ProvisioningState_Updating_STATUS))
}

// AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator())
=======
// testing - lazily instantiated by IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
// We first initialize ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(IPConfigurationPropertiesFormat_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return ipConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_STATUS_Dynamic, IPAllocationMethod_STATUS_Static))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIPConfigurationPropertiesFormatSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator())
>>>>>>> main
}

func Test_NatGatewaySku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySku_STATUSARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForNatGatewaySku_STATUSARM, NatGatewaySku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySku_STATUSARM runs a test to see if a specific instance of NatGatewaySku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySku_STATUSARM(subject NatGatewaySku_STATUSARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForNatGatewaySkuSTATUSARM, NatGatewaySkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySkuSTATUSARM runs a test to see if a specific instance of NatGatewaySku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySkuSTATUSARM(subject NatGatewaySku_STATUSARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySku_STATUSARM instances for property testing - lazily instantiated by
<<<<<<< HEAD
// NatGatewaySku_STATUSARMGenerator()
var natGatewaySku_STATUSARMGenerator gopter.Gen

// NatGatewaySku_STATUSARMGenerator returns a generator of NatGatewaySku_STATUSARM instances for property testing.
func NatGatewaySku_STATUSARMGenerator() gopter.Gen {
	if natGatewaySku_STATUSARMGenerator != nil {
		return natGatewaySku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySku_STATUSARM(generators)
	natGatewaySku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_STATUSARM{}), generators)

	return natGatewaySku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySku_Name_Standard_STATUS))
=======
// NatGatewaySkuSTATUSARMGenerator()
var natGatewaySkuSTATUSARMGenerator gopter.Gen

// NatGatewaySkuSTATUSARMGenerator returns a generator of NatGatewaySku_STATUSARM instances for property testing.
func NatGatewaySkuSTATUSARMGenerator() gopter.Gen {
	if natGatewaySkuSTATUSARMGenerator != nil {
		return natGatewaySkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM(generators)
	natGatewaySkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_STATUSARM{}), generators)

	return natGatewaySkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySkuSTATUSName_Standard))
>>>>>>> main
}

func Test_Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
<<<<<<< HEAD
	parameters.MinSuccessfulTests = 100
=======
	parameters.MinSuccessfulTests = 80
>>>>>>> main
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM, Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM(subject Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
=======
		prop.ForAll(RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM, SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM runs a test to see if a specific instance of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(subject Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing - lazily
<<<<<<< HEAD
// instantiated by Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator()
var subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator gopter.Gen

// Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator returns a generator of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
func Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator != nil {
		return subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM(generators)
	subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
=======
// instantiated by SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator()
var subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator gopter.Gen

// SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator returns a generator of Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM instances for property testing.
func SubnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator() gopter.Gen {
	if subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator != nil {
		return subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(generators)
	subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(Subnet_STATUS_PublicIPAddress_SubResourceEmbeddedARM{}), generators)

	return subnetSTATUSPublicIPAddressSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnetSTATUSPublicIPAddressSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
