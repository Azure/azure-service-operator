// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddresses_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddresses_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressesSPECARM, PublicIPAddressesSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressesSPECARM runs a test to see if a specific instance of PublicIPAddresses_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressesSPECARM(subject PublicIPAddresses_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddresses_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddresses_SPECARM instances for property testing - lazily instantiated by
//PublicIPAddressesSPECARMGenerator()
var publicIPAddressesSPECARMGenerator gopter.Gen

// PublicIPAddressesSPECARMGenerator returns a generator of PublicIPAddresses_SPECARM instances for property testing.
// We first initialize publicIPAddressesSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressesSPECARMGenerator() gopter.Gen {
	if publicIPAddressesSPECARMGenerator != nil {
		return publicIPAddressesSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressesSPECARM(generators)
	publicIPAddressesSPECARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddresses_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressesSPECARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressesSPECARM(generators)
	publicIPAddressesSPECARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddresses_SPECARM{}), generators)

	return publicIPAddressesSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressesSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressesSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressesSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressesSPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSpecARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM, PublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(subject PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by PublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator()
var publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressPropertiesFormatSpecSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormatSpecMigrationPhaseAbort,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommit,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseCommitted,
		PublicIPAddressPropertiesFormatSpecMigrationPhaseNone,
		PublicIPAddressPropertiesFormatSpecMigrationPhasePrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatSpecSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsSpecARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsSpecARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagSpecARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecSubResourceEmbeddedARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecSubResourceEmbeddedARMGenerator())
}

func Test_PublicIPAddressSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuSpecARM, PublicIPAddressSkuSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuSpecARM runs a test to see if a specific instance of PublicIPAddressSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuSpecARM(subject PublicIPAddressSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressSkuSpecARMGenerator()
var publicIPAddressSkuSpecARMGenerator gopter.Gen

// PublicIPAddressSkuSpecARMGenerator returns a generator of PublicIPAddressSku_SpecARM instances for property testing.
func PublicIPAddressSkuSpecARMGenerator() gopter.Gen {
	if publicIPAddressSkuSpecARMGenerator != nil {
		return publicIPAddressSkuSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuSpecARM(generators)
	publicIPAddressSkuSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_SpecARM{}), generators)

	return publicIPAddressSkuSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSpecNameBasic, PublicIPAddressSkuSpecNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuSpecTierGlobal, PublicIPAddressSkuSpecTierRegional))
}

func Test_DdosSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDdosSettingsSpecARM, DdosSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettingsSpecARM runs a test to see if a specific instance of DdosSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettingsSpecARM(subject DdosSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettings_SpecARM instances for property testing - lazily instantiated by
//DdosSettingsSpecARMGenerator()
var ddosSettingsSpecARMGenerator gopter.Gen

// DdosSettingsSpecARMGenerator returns a generator of DdosSettings_SpecARM instances for property testing.
// We first initialize ddosSettingsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettingsSpecARMGenerator() gopter.Gen {
	if ddosSettingsSpecARMGenerator != nil {
		return ddosSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSpecARM(generators)
	ddosSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettingsSpecARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettingsSpecARM(generators)
	ddosSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_SpecARM{}), generators)

	return ddosSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettingsSpecProtectionCoverageBasic, DdosSettingsSpecProtectionCoverageStandard))
}

// AddRelatedPropertyGeneratorsForDdosSettingsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResourceSpecARMGenerator())
}

func Test_IpTag_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTag_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpTagSpecARM, IpTagSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTagSpecARM runs a test to see if a specific instance of IpTag_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTagSpecARM(subject IpTag_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTag_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpTag_SpecARM instances for property testing - lazily instantiated by IpTagSpecARMGenerator()
var ipTagSpecARMGenerator gopter.Gen

// IpTagSpecARMGenerator returns a generator of IpTag_SpecARM instances for property testing.
func IpTagSpecARMGenerator() gopter.Gen {
	if ipTagSpecARMGenerator != nil {
		return ipTagSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTagSpecARM(generators)
	ipTagSpecARMGenerator = gen.Struct(reflect.TypeOf(IpTag_SpecARM{}), generators)

	return ipTagSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTagSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTagSpecARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGateway_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySpecARM, NatGatewaySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySpecARM runs a test to see if a specific instance of NatGateway_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySpecARM(subject NatGateway_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_SpecARM instances for property testing - lazily instantiated by NatGatewaySpecARMGenerator()
var natGatewaySpecARMGenerator gopter.Gen

// NatGatewaySpecARMGenerator returns a generator of NatGateway_SpecARM instances for property testing.
// We first initialize natGatewaySpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewaySpecARMGenerator() gopter.Gen {
	if natGatewaySpecARMGenerator != nil {
		return natGatewaySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpecARM(generators)
	natGatewaySpecARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySpecARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewaySpecARM(generators)
	natGatewaySpecARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_SpecARM{}), generators)

	return natGatewaySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGatewaySpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewaySpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NatGatewayPropertiesFormatSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(NatGatewaySkuSpecARMGenerator())
}

func Test_PublicIPAddressDnsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettingsSpecARM, PublicIPAddressDnsSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettingsSpecARM runs a test to see if a specific instance of PublicIPAddressDnsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettingsSpecARM(subject PublicIPAddressDnsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettings_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressDnsSettingsSpecARMGenerator()
var publicIPAddressDnsSettingsSpecARMGenerator gopter.Gen

// PublicIPAddressDnsSettingsSpecARMGenerator returns a generator of PublicIPAddressDnsSettings_SpecARM instances for property testing.
func PublicIPAddressDnsSettingsSpecARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettingsSpecARMGenerator != nil {
		return publicIPAddressDnsSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSpecARM(generators)
	publicIPAddressDnsSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettings_SpecARM{}), generators)

	return publicIPAddressDnsSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddress_Spec_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Spec_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpecSubResourceEmbeddedARM, PublicIPAddressSpecSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpecSubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_Spec_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpecSubResourceEmbeddedARM(subject PublicIPAddress_Spec_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Spec_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Spec_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
//PublicIPAddressSpecSubResourceEmbeddedARMGenerator()
var publicIPAddressSpecSubResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressSpecSubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_Spec_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressSpecSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpecSubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressSpecSubResourceEmbeddedARMGenerator != nil {
		return publicIPAddressSpecSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM(generators)
	publicIPAddressSpecSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM(generators)
	publicIPAddressSpecSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressSpecSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpecSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuSpecARMGenerator())
}

func Test_SubResource_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceSpecARM, SubResourceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceSpecARM runs a test to see if a specific instance of SubResource_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceSpecARM(subject SubResource_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_SpecARM instances for property testing - lazily instantiated by SubResourceSpecARMGenerator()
var subResourceSpecARMGenerator gopter.Gen

// SubResourceSpecARMGenerator returns a generator of SubResource_SpecARM instances for property testing.
func SubResourceSpecARMGenerator() gopter.Gen {
	if subResourceSpecARMGenerator != nil {
		return subResourceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResourceSpecARM(generators)
	subResourceSpecARMGenerator = gen.Struct(reflect.TypeOf(SubResource_SpecARM{}), generators)

	return subResourceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSubResourceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResourceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGatewayPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewayPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewayPropertiesFormatSpecARM, NatGatewayPropertiesFormatSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewayPropertiesFormatSpecARM runs a test to see if a specific instance of NatGatewayPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewayPropertiesFormatSpecARM(subject NatGatewayPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewayPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewayPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//NatGatewayPropertiesFormatSpecARMGenerator()
var natGatewayPropertiesFormatSpecARMGenerator gopter.Gen

// NatGatewayPropertiesFormatSpecARMGenerator returns a generator of NatGatewayPropertiesFormat_SpecARM instances for property testing.
// We first initialize natGatewayPropertiesFormatSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewayPropertiesFormatSpecARMGenerator() gopter.Gen {
	if natGatewayPropertiesFormatSpecARMGenerator != nil {
		return natGatewayPropertiesFormatSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM(generators)
	natGatewayPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM(generators)
	natGatewayPropertiesFormatSpecARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_SpecARM{}), generators)

	return natGatewayPropertiesFormatSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormatSpecARM(gens map[string]gopter.Gen) {
	gens["PublicIpAddresses"] = gen.SliceOf(SubResourceSpecARMGenerator())
	gens["PublicIpPrefixes"] = gen.SliceOf(SubResourceSpecARMGenerator())
}

func Test_NatGatewaySku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySkuSpecARM, NatGatewaySkuSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySkuSpecARM runs a test to see if a specific instance of NatGatewaySku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySkuSpecARM(subject NatGatewaySku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySku_SpecARM instances for property testing - lazily instantiated by
//NatGatewaySkuSpecARMGenerator()
var natGatewaySkuSpecARMGenerator gopter.Gen

// NatGatewaySkuSpecARMGenerator returns a generator of NatGatewaySku_SpecARM instances for property testing.
func NatGatewaySkuSpecARMGenerator() gopter.Gen {
	if natGatewaySkuSpecARMGenerator != nil {
		return natGatewaySkuSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySkuSpecARM(generators)
	natGatewaySkuSpecARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_SpecARM{}), generators)

	return natGatewaySkuSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySkuSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySkuSpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySkuSpecNameStandard))
}
