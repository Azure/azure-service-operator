// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_PublicIPAddresses_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddresses_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddresses_SPECARM, PublicIPAddresses_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddresses_SPECARM runs a test to see if a specific instance of PublicIPAddresses_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddresses_SPECARM(subject PublicIPAddresses_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddresses_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddresses_SPECARM instances for property testing - lazily instantiated by
//PublicIPAddresses_SPECARMGenerator()
var publicIPAddresses_specarmGenerator gopter.Gen

// PublicIPAddresses_SPECARMGenerator returns a generator of PublicIPAddresses_SPECARM instances for property testing.
// We first initialize publicIPAddresses_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddresses_SPECARMGenerator() gopter.Gen {
	if publicIPAddresses_specarmGenerator != nil {
		return publicIPAddresses_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddresses_SPECARM(generators)
	publicIPAddresses_specarmGenerator = gen.Struct(reflect.TypeOf(PublicIPAddresses_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddresses_SPECARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddresses_SPECARM(generators)
	publicIPAddresses_specarmGenerator = gen.Struct(reflect.TypeOf(PublicIPAddresses_SPECARM{}), generators)

	return publicIPAddresses_specarmGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddresses_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddresses_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddresses_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddresses_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_SpecARMGenerator())
}

func Test_PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM, PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(subject PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM instances for property testing - lazily
//instantiated by PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARMGenerator()
var publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator != nil {
		return publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(generators)
	publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM{}), generators)

	return publicIPAddressPropertiesFormat_spec_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecAbort,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommit,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecCommitted,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecNone,
		PublicIPAddressPropertiesFormat_MigrationPhase_SpecPrepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_SpecIPv4, IPVersion_SpecIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormat_Spec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettings_SpecARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettings_SpecARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTag_SpecARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGateway_SpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator())
}

func Test_PublicIPAddressSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSku_SpecARM, PublicIPAddressSku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSku_SpecARM runs a test to see if a specific instance of PublicIPAddressSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSku_SpecARM(subject PublicIPAddressSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressSku_SpecARMGenerator()
var publicIPAddressSku_specARMGenerator gopter.Gen

// PublicIPAddressSku_SpecARMGenerator returns a generator of PublicIPAddressSku_SpecARM instances for property testing.
func PublicIPAddressSku_SpecARMGenerator() gopter.Gen {
	if publicIPAddressSku_specARMGenerator != nil {
		return publicIPAddressSku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSku_SpecARM(generators)
	publicIPAddressSku_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_SpecARM{}), generators)

	return publicIPAddressSku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Name_SpecBasic, PublicIPAddressSku_Name_SpecStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Tier_SpecGlobal, PublicIPAddressSku_Tier_SpecRegional))
}

func Test_DdosSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DdosSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDdosSettings_SpecARM, DdosSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDdosSettings_SpecARM runs a test to see if a specific instance of DdosSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDdosSettings_SpecARM(subject DdosSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DdosSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DdosSettings_SpecARM instances for property testing - lazily instantiated by
//DdosSettings_SpecARMGenerator()
var ddosSettings_specARMGenerator gopter.Gen

// DdosSettings_SpecARMGenerator returns a generator of DdosSettings_SpecARM instances for property testing.
// We first initialize ddosSettings_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DdosSettings_SpecARMGenerator() gopter.Gen {
	if ddosSettings_specARMGenerator != nil {
		return ddosSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettings_SpecARM(generators)
	ddosSettings_specARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDdosSettings_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDdosSettings_SpecARM(generators)
	ddosSettings_specARMGenerator = gen.Struct(reflect.TypeOf(DdosSettings_SpecARM{}), generators)

	return ddosSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDdosSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDdosSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["ProtectedIP"] = gen.PtrOf(gen.Bool())
	gens["ProtectionCoverage"] = gen.PtrOf(gen.OneConstOf(DdosSettings_ProtectionCoverage_SpecBasic, DdosSettings_ProtectionCoverage_SpecStandard))
}

// AddRelatedPropertyGeneratorsForDdosSettings_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDdosSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["DdosCustomPolicy"] = gen.PtrOf(SubResource_SpecARMGenerator())
}

func Test_IpTag_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpTag_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpTag_SpecARM, IpTag_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpTag_SpecARM runs a test to see if a specific instance of IpTag_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpTag_SpecARM(subject IpTag_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpTag_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpTag_SpecARM instances for property testing - lazily instantiated by IpTag_SpecARMGenerator()
var ipTag_specARMGenerator gopter.Gen

// IpTag_SpecARMGenerator returns a generator of IpTag_SpecARM instances for property testing.
func IpTag_SpecARMGenerator() gopter.Gen {
	if ipTag_specARMGenerator != nil {
		return ipTag_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpTag_SpecARM(generators)
	ipTag_specARMGenerator = gen.Struct(reflect.TypeOf(IpTag_SpecARM{}), generators)

	return ipTag_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIpTag_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpTag_SpecARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGateway_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGateway_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGateway_SpecARM, NatGateway_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGateway_SpecARM runs a test to see if a specific instance of NatGateway_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGateway_SpecARM(subject NatGateway_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGateway_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGateway_SpecARM instances for property testing - lazily instantiated by NatGateway_SpecARMGenerator()
var natGateway_specARMGenerator gopter.Gen

// NatGateway_SpecARMGenerator returns a generator of NatGateway_SpecARM instances for property testing.
// We first initialize natGateway_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGateway_SpecARMGenerator() gopter.Gen {
	if natGateway_specARMGenerator != nil {
		return natGateway_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_SpecARM(generators)
	natGateway_specARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGateway_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNatGateway_SpecARM(generators)
	natGateway_specARMGenerator = gen.Struct(reflect.TypeOf(NatGateway_SpecARM{}), generators)

	return natGateway_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGateway_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGateway_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNatGateway_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGateway_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NatGatewayPropertiesFormat_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(NatGatewaySku_SpecARMGenerator())
}

func Test_PublicIPAddressDnsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressDnsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressDnsSettings_SpecARM, PublicIPAddressDnsSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressDnsSettings_SpecARM runs a test to see if a specific instance of PublicIPAddressDnsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressDnsSettings_SpecARM(subject PublicIPAddressDnsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressDnsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressDnsSettings_SpecARM instances for property testing - lazily instantiated by
//PublicIPAddressDnsSettings_SpecARMGenerator()
var publicIPAddressDnsSettings_specARMGenerator gopter.Gen

// PublicIPAddressDnsSettings_SpecARMGenerator returns a generator of PublicIPAddressDnsSettings_SpecARM instances for property testing.
func PublicIPAddressDnsSettings_SpecARMGenerator() gopter.Gen {
	if publicIPAddressDnsSettings_specARMGenerator != nil {
		return publicIPAddressDnsSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_SpecARM(generators)
	publicIPAddressDnsSettings_specARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressDnsSettings_SpecARM{}), generators)

	return publicIPAddressDnsSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressDnsSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["ReverseFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddress_Spec_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Spec_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Spec_SubResourceEmbeddedARM, PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Spec_SubResourceEmbeddedARM runs a test to see if a specific instance of PublicIPAddress_Spec_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Spec_SubResourceEmbeddedARM(subject PublicIPAddress_Spec_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Spec_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Spec_SubResourceEmbeddedARM instances for property testing - lazily instantiated by
//PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator()
var publicIPAddress_spec_subResourceEmbeddedARMGenerator gopter.Gen

// PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator returns a generator of PublicIPAddress_Spec_SubResourceEmbeddedARM instances for property testing.
// We first initialize publicIPAddress_spec_subResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_Spec_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if publicIPAddress_spec_subResourceEmbeddedARMGenerator != nil {
		return publicIPAddress_spec_subResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM(generators)
	publicIPAddress_spec_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM(generators)
	publicIPAddress_spec_subResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Spec_SubResourceEmbeddedARM{}), generators)

	return publicIPAddress_spec_subResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Spec_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_SpecARMGenerator())
}

func Test_SubResource_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_SpecARM, SubResource_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_SpecARM runs a test to see if a specific instance of SubResource_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_SpecARM(subject SubResource_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_SpecARM instances for property testing - lazily instantiated by
//SubResource_SpecARMGenerator()
var subResource_specARMGenerator gopter.Gen

// SubResource_SpecARMGenerator returns a generator of SubResource_SpecARM instances for property testing.
func SubResource_SpecARMGenerator() gopter.Gen {
	if subResource_specARMGenerator != nil {
		return subResource_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_SpecARM(generators)
	subResource_specARMGenerator = gen.Struct(reflect.TypeOf(SubResource_SpecARM{}), generators)

	return subResource_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatGatewayPropertiesFormat_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewayPropertiesFormat_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewayPropertiesFormat_SpecARM, NatGatewayPropertiesFormat_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewayPropertiesFormat_SpecARM runs a test to see if a specific instance of NatGatewayPropertiesFormat_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewayPropertiesFormat_SpecARM(subject NatGatewayPropertiesFormat_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewayPropertiesFormat_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewayPropertiesFormat_SpecARM instances for property testing - lazily instantiated by
//NatGatewayPropertiesFormat_SpecARMGenerator()
var natGatewayPropertiesFormat_specARMGenerator gopter.Gen

// NatGatewayPropertiesFormat_SpecARMGenerator returns a generator of NatGatewayPropertiesFormat_SpecARM instances for property testing.
// We first initialize natGatewayPropertiesFormat_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NatGatewayPropertiesFormat_SpecARMGenerator() gopter.Gen {
	if natGatewayPropertiesFormat_specARMGenerator != nil {
		return natGatewayPropertiesFormat_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM(generators)
	natGatewayPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM(generators)
	natGatewayPropertiesFormat_specARMGenerator = gen.Struct(reflect.TypeOf(NatGatewayPropertiesFormat_SpecARM{}), generators)

	return natGatewayPropertiesFormat_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNatGatewayPropertiesFormat_SpecARM(gens map[string]gopter.Gen) {
	gens["PublicIpAddresses"] = gen.SliceOf(SubResource_SpecARMGenerator())
	gens["PublicIpPrefixes"] = gen.SliceOf(SubResource_SpecARMGenerator())
}

func Test_NatGatewaySku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatGatewaySku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatGatewaySku_SpecARM, NatGatewaySku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatGatewaySku_SpecARM runs a test to see if a specific instance of NatGatewaySku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNatGatewaySku_SpecARM(subject NatGatewaySku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatGatewaySku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatGatewaySku_SpecARM instances for property testing - lazily instantiated by
//NatGatewaySku_SpecARMGenerator()
var natGatewaySku_specARMGenerator gopter.Gen

// NatGatewaySku_SpecARMGenerator returns a generator of NatGatewaySku_SpecARM instances for property testing.
func NatGatewaySku_SpecARMGenerator() gopter.Gen {
	if natGatewaySku_specARMGenerator != nil {
		return natGatewaySku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatGatewaySku_SpecARM(generators)
	natGatewaySku_specARMGenerator = gen.Struct(reflect.TypeOf(NatGatewaySku_SpecARM{}), generators)

	return natGatewaySku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNatGatewaySku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatGatewaySku_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(NatGatewaySku_Name_SpecStandard))
}
