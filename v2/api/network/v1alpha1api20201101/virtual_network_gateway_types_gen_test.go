// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/network/v1alpha1api20201101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualNetworkGateway_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGateway to hub returns original",
		prop.ForAll(RunResourceConversionTestForVirtualNetworkGateway, VirtualNetworkGatewayGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVirtualNetworkGateway tests if a specific instance of VirtualNetworkGateway round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVirtualNetworkGateway(subject VirtualNetworkGateway) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201101storage.VirtualNetworkGateway
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VirtualNetworkGateway
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGateway_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGateway to VirtualNetworkGateway via AssignPropertiesToVirtualNetworkGateway & AssignPropertiesFromVirtualNetworkGateway returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGateway, VirtualNetworkGatewayGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGateway tests if a specific instance of VirtualNetworkGateway can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGateway(subject VirtualNetworkGateway) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGateway
	err := copied.AssignPropertiesToVirtualNetworkGateway(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGateway
	err = actual.AssignPropertiesFromVirtualNetworkGateway(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGateway_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateway via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGateway, VirtualNetworkGatewayGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGateway runs a test to see if a specific instance of VirtualNetworkGateway round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGateway(subject VirtualNetworkGateway) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateway
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateway instances for property testing - lazily instantiated by
//VirtualNetworkGatewayGenerator()
var virtualNetworkGatewayGenerator gopter.Gen

// VirtualNetworkGatewayGenerator returns a generator of VirtualNetworkGateway instances for property testing.
func VirtualNetworkGatewayGenerator() gopter.Gen {
	if virtualNetworkGatewayGenerator != nil {
		return virtualNetworkGatewayGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualNetworkGateway(generators)
	virtualNetworkGatewayGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway{}), generators)

	return virtualNetworkGatewayGenerator
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGateway is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGateway(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualNetworkGatewaysSPECGenerator()
	gens["Status"] = VirtualNetworkGatewayStatusGenerator()
}

func Test_VirtualNetworkGateway_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGateway_Status to VirtualNetworkGateway_Status via AssignPropertiesToVirtualNetworkGatewayStatus & AssignPropertiesFromVirtualNetworkGatewayStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewayStatus, VirtualNetworkGatewayStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewayStatus tests if a specific instance of VirtualNetworkGateway_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewayStatus(subject VirtualNetworkGateway_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGateway_Status
	err := copied.AssignPropertiesToVirtualNetworkGatewayStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGateway_Status
	err = actual.AssignPropertiesFromVirtualNetworkGatewayStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGateway_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateway_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayStatus, VirtualNetworkGatewayStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayStatus runs a test to see if a specific instance of VirtualNetworkGateway_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayStatus(subject VirtualNetworkGateway_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateway_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateway_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewayStatusGenerator()
var virtualNetworkGatewayStatusGenerator gopter.Gen

// VirtualNetworkGatewayStatusGenerator returns a generator of VirtualNetworkGateway_Status instances for property testing.
// We first initialize virtualNetworkGatewayStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayStatusGenerator() gopter.Gen {
	if virtualNetworkGatewayStatusGenerator != nil {
		return virtualNetworkGatewayStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	virtualNetworkGatewayStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	virtualNetworkGatewayStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway_Status{}), generators)

	return virtualNetworkGatewayStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(gens map[string]gopter.Gen) {
	gens["ActiveActive"] = gen.PtrOf(gen.Bool())
	gens["EnableBgp"] = gen.PtrOf(gen.Bool())
	gens["EnableDnsForwarding"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateIpAddress"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayType"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatStatusGatewayTypeExpressRoute, VirtualNetworkGatewayPropertiesFormatStatusGatewayTypeLocalGateway, VirtualNetworkGatewayPropertiesFormatStatusGatewayTypeVpn))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["InboundDnsForwardingEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VNetExtendedLocationResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VpnGatewayGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatStatusVpnGatewayGenerationGeneration1, VirtualNetworkGatewayPropertiesFormatStatusVpnGatewayGenerationGeneration2, VirtualNetworkGatewayPropertiesFormatStatusVpnGatewayGenerationNone))
	gens["VpnType"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatStatusVpnTypePolicyBased, VirtualNetworkGatewayPropertiesFormatStatusVpnTypeRouteBased))
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus(gens map[string]gopter.Gen) {
	gens["BgpSettings"] = gen.PtrOf(BgpSettingsStatusGenerator())
	gens["CustomRoutes"] = gen.PtrOf(AddressSpaceStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["GatewayDefaultSite"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualNetworkGatewayIPConfigurationStatusGenerator())
	gens["Sku"] = gen.PtrOf(VirtualNetworkGatewaySkuStatusGenerator())
	gens["VpnClientConfiguration"] = gen.PtrOf(VpnClientConfigurationStatusGenerator())
}

func Test_VirtualNetworkGateways_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGateways_SPEC to VirtualNetworkGateways_SPEC via AssignPropertiesToVirtualNetworkGatewaysSPEC & AssignPropertiesFromVirtualNetworkGatewaysSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewaysSPEC, VirtualNetworkGatewaysSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewaysSPEC tests if a specific instance of VirtualNetworkGateways_SPEC can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewaysSPEC(subject VirtualNetworkGateways_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGateways_SPEC
	err := copied.AssignPropertiesToVirtualNetworkGatewaysSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGateways_SPEC
	err = actual.AssignPropertiesFromVirtualNetworkGatewaysSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGateways_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateways_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaysSPEC, VirtualNetworkGatewaysSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaysSPEC runs a test to see if a specific instance of VirtualNetworkGateways_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaysSPEC(subject VirtualNetworkGateways_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateways_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateways_SPEC instances for property testing - lazily instantiated by
//VirtualNetworkGatewaysSPECGenerator()
var virtualNetworkGatewaysSPECGenerator gopter.Gen

// VirtualNetworkGatewaysSPECGenerator returns a generator of VirtualNetworkGateways_SPEC instances for property testing.
// We first initialize virtualNetworkGatewaysSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewaysSPECGenerator() gopter.Gen {
	if virtualNetworkGatewaysSPECGenerator != nil {
		return virtualNetworkGatewaysSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	virtualNetworkGatewaysSPECGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateways_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	virtualNetworkGatewaysSPECGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateways_SPEC{}), generators)

	return virtualNetworkGatewaysSPECGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(gens map[string]gopter.Gen) {
	gens["ActiveActive"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["EnableBgp"] = gen.PtrOf(gen.Bool())
	gens["EnableDnsForwarding"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateIpAddress"] = gen.PtrOf(gen.Bool())
	gens["GatewayType"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatSpecGatewayTypeExpressRoute, VirtualNetworkGatewayPropertiesFormatSpecGatewayTypeLocalGateway, VirtualNetworkGatewayPropertiesFormatSpecGatewayTypeVpn))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["VpnGatewayGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatSpecVpnGatewayGenerationGeneration1, VirtualNetworkGatewayPropertiesFormatSpecVpnGatewayGenerationGeneration2, VirtualNetworkGatewayPropertiesFormatSpecVpnGatewayGenerationNone))
	gens["VpnType"] = gen.PtrOf(gen.OneConstOf(VirtualNetworkGatewayPropertiesFormatSpecVpnTypePolicyBased, VirtualNetworkGatewayPropertiesFormatSpecVpnTypeRouteBased))
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC(gens map[string]gopter.Gen) {
	gens["BgpSettings"] = gen.PtrOf(BgpSettingsSpecGenerator())
	gens["CustomRoutes"] = gen.PtrOf(AddressSpaceSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["GatewayDefaultSite"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualNetworkGatewayIPConfigurationSpecGenerator())
	gens["Sku"] = gen.PtrOf(VirtualNetworkGatewaySkuSpecGenerator())
	gens["VpnClientConfiguration"] = gen.PtrOf(VpnClientConfigurationSpecGenerator())
}

func Test_BgpSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BgpSettings_Spec to BgpSettings_Spec via AssignPropertiesToBgpSettingsSpec & AssignPropertiesFromBgpSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBgpSettingsSpec, BgpSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBgpSettingsSpec tests if a specific instance of BgpSettings_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBgpSettingsSpec(subject BgpSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BgpSettings_Spec
	err := copied.AssignPropertiesToBgpSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BgpSettings_Spec
	err = actual.AssignPropertiesFromBgpSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BgpSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BgpSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBgpSettingsSpec, BgpSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBgpSettingsSpec runs a test to see if a specific instance of BgpSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBgpSettingsSpec(subject BgpSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BgpSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BgpSettings_Spec instances for property testing - lazily instantiated by BgpSettingsSpecGenerator()
var bgpSettingsSpecGenerator gopter.Gen

// BgpSettingsSpecGenerator returns a generator of BgpSettings_Spec instances for property testing.
// We first initialize bgpSettingsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BgpSettingsSpecGenerator() gopter.Gen {
	if bgpSettingsSpecGenerator != nil {
		return bgpSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsSpec(generators)
	bgpSettingsSpecGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsSpec(generators)
	AddRelatedPropertyGeneratorsForBgpSettingsSpec(generators)
	bgpSettingsSpecGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Spec{}), generators)

	return bgpSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForBgpSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBgpSettingsSpec(gens map[string]gopter.Gen) {
	gens["Asn"] = gen.PtrOf(gen.UInt32())
	gens["BgpPeeringAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PeerWeight"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForBgpSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBgpSettingsSpec(gens map[string]gopter.Gen) {
	gens["BgpPeeringAddresses"] = gen.SliceOf(IPConfigurationBgpPeeringAddressSpecGenerator())
}

func Test_BgpSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BgpSettings_Status to BgpSettings_Status via AssignPropertiesToBgpSettingsStatus & AssignPropertiesFromBgpSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBgpSettingsStatus, BgpSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBgpSettingsStatus tests if a specific instance of BgpSettings_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForBgpSettingsStatus(subject BgpSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.BgpSettings_Status
	err := copied.AssignPropertiesToBgpSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BgpSettings_Status
	err = actual.AssignPropertiesFromBgpSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BgpSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BgpSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBgpSettingsStatus, BgpSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBgpSettingsStatus runs a test to see if a specific instance of BgpSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBgpSettingsStatus(subject BgpSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BgpSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BgpSettings_Status instances for property testing - lazily instantiated by BgpSettingsStatusGenerator()
var bgpSettingsStatusGenerator gopter.Gen

// BgpSettingsStatusGenerator returns a generator of BgpSettings_Status instances for property testing.
// We first initialize bgpSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BgpSettingsStatusGenerator() gopter.Gen {
	if bgpSettingsStatusGenerator != nil {
		return bgpSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsStatus(generators)
	bgpSettingsStatusGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForBgpSettingsStatus(generators)
	bgpSettingsStatusGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Status{}), generators)

	return bgpSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForBgpSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBgpSettingsStatus(gens map[string]gopter.Gen) {
	gens["Asn"] = gen.PtrOf(gen.UInt32())
	gens["BgpPeeringAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PeerWeight"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForBgpSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBgpSettingsStatus(gens map[string]gopter.Gen) {
	gens["BgpPeeringAddresses"] = gen.SliceOf(IPConfigurationBgpPeeringAddressStatusGenerator())
}

func Test_VirtualNetworkGatewayIPConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGatewayIPConfiguration_Spec to VirtualNetworkGatewayIPConfiguration_Spec via AssignPropertiesToVirtualNetworkGatewayIPConfigurationSpec & AssignPropertiesFromVirtualNetworkGatewayIPConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationSpec, VirtualNetworkGatewayIPConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationSpec tests if a specific instance of VirtualNetworkGatewayIPConfiguration_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationSpec(subject VirtualNetworkGatewayIPConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGatewayIPConfiguration_Spec
	err := copied.AssignPropertiesToVirtualNetworkGatewayIPConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGatewayIPConfiguration_Spec
	err = actual.AssignPropertiesFromVirtualNetworkGatewayIPConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGatewayIPConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewayIPConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec, VirtualNetworkGatewayIPConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec runs a test to see if a specific instance of VirtualNetworkGatewayIPConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec(subject VirtualNetworkGatewayIPConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewayIPConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewayIPConfiguration_Spec instances for property testing - lazily instantiated by
//VirtualNetworkGatewayIPConfigurationSpecGenerator()
var virtualNetworkGatewayIPConfigurationSpecGenerator gopter.Gen

// VirtualNetworkGatewayIPConfigurationSpecGenerator returns a generator of VirtualNetworkGatewayIPConfiguration_Spec instances for property testing.
// We first initialize virtualNetworkGatewayIPConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayIPConfigurationSpecGenerator() gopter.Gen {
	if virtualNetworkGatewayIPConfigurationSpecGenerator != nil {
		return virtualNetworkGatewayIPConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	virtualNetworkGatewayIPConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	virtualNetworkGatewayIPConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Spec{}), generators)

	return virtualNetworkGatewayIPConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_SpecDynamic, IPAllocationMethod_SpecStatic))
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_VirtualNetworkGatewayIPConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGatewayIPConfiguration_Status to VirtualNetworkGatewayIPConfiguration_Status via AssignPropertiesToVirtualNetworkGatewayIPConfigurationStatus & AssignPropertiesFromVirtualNetworkGatewayIPConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationStatus, VirtualNetworkGatewayIPConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationStatus tests if a specific instance of VirtualNetworkGatewayIPConfiguration_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewayIPConfigurationStatus(subject VirtualNetworkGatewayIPConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGatewayIPConfiguration_Status
	err := copied.AssignPropertiesToVirtualNetworkGatewayIPConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGatewayIPConfiguration_Status
	err = actual.AssignPropertiesFromVirtualNetworkGatewayIPConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGatewayIPConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewayIPConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus, VirtualNetworkGatewayIPConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus runs a test to see if a specific instance of VirtualNetworkGatewayIPConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus(subject VirtualNetworkGatewayIPConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewayIPConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewayIPConfiguration_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewayIPConfigurationStatusGenerator()
var virtualNetworkGatewayIPConfigurationStatusGenerator gopter.Gen

// VirtualNetworkGatewayIPConfigurationStatusGenerator returns a generator of VirtualNetworkGatewayIPConfiguration_Status instances for property testing.
// We first initialize virtualNetworkGatewayIPConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayIPConfigurationStatusGenerator() gopter.Gen {
	if virtualNetworkGatewayIPConfigurationStatusGenerator != nil {
		return virtualNetworkGatewayIPConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	virtualNetworkGatewayIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	virtualNetworkGatewayIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Status{}), generators)

	return virtualNetworkGatewayIPConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_StatusDynamic, IPAllocationMethod_StatusStatic))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualNetworkGatewaySku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGatewaySku_Spec to VirtualNetworkGatewaySku_Spec via AssignPropertiesToVirtualNetworkGatewaySkuSpec & AssignPropertiesFromVirtualNetworkGatewaySkuSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewaySkuSpec, VirtualNetworkGatewaySkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewaySkuSpec tests if a specific instance of VirtualNetworkGatewaySku_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewaySkuSpec(subject VirtualNetworkGatewaySku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGatewaySku_Spec
	err := copied.AssignPropertiesToVirtualNetworkGatewaySkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGatewaySku_Spec
	err = actual.AssignPropertiesFromVirtualNetworkGatewaySkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGatewaySku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewaySku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec, VirtualNetworkGatewaySkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec runs a test to see if a specific instance of VirtualNetworkGatewaySku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec(subject VirtualNetworkGatewaySku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewaySku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewaySku_Spec instances for property testing - lazily instantiated by
//VirtualNetworkGatewaySkuSpecGenerator()
var virtualNetworkGatewaySkuSpecGenerator gopter.Gen

// VirtualNetworkGatewaySkuSpecGenerator returns a generator of VirtualNetworkGatewaySku_Spec instances for property testing.
func VirtualNetworkGatewaySkuSpecGenerator() gopter.Gen {
	if virtualNetworkGatewaySkuSpecGenerator != nil {
		return virtualNetworkGatewaySkuSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec(generators)
	virtualNetworkGatewaySkuSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewaySku_Spec{}), generators)

	return virtualNetworkGatewaySkuSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkGatewaySkuSpecNameBasic,
		VirtualNetworkGatewaySkuSpecNameErGw1AZ,
		VirtualNetworkGatewaySkuSpecNameErGw2AZ,
		VirtualNetworkGatewaySkuSpecNameErGw3AZ,
		VirtualNetworkGatewaySkuSpecNameHighPerformance,
		VirtualNetworkGatewaySkuSpecNameStandard,
		VirtualNetworkGatewaySkuSpecNameUltraPerformance,
		VirtualNetworkGatewaySkuSpecNameVpnGw1,
		VirtualNetworkGatewaySkuSpecNameVpnGw1AZ,
		VirtualNetworkGatewaySkuSpecNameVpnGw2,
		VirtualNetworkGatewaySkuSpecNameVpnGw2AZ,
		VirtualNetworkGatewaySkuSpecNameVpnGw3,
		VirtualNetworkGatewaySkuSpecNameVpnGw3AZ,
		VirtualNetworkGatewaySkuSpecNameVpnGw4,
		VirtualNetworkGatewaySkuSpecNameVpnGw4AZ,
		VirtualNetworkGatewaySkuSpecNameVpnGw5,
		VirtualNetworkGatewaySkuSpecNameVpnGw5AZ))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkGatewaySkuSpecTierBasic,
		VirtualNetworkGatewaySkuSpecTierErGw1AZ,
		VirtualNetworkGatewaySkuSpecTierErGw2AZ,
		VirtualNetworkGatewaySkuSpecTierErGw3AZ,
		VirtualNetworkGatewaySkuSpecTierHighPerformance,
		VirtualNetworkGatewaySkuSpecTierStandard,
		VirtualNetworkGatewaySkuSpecTierUltraPerformance,
		VirtualNetworkGatewaySkuSpecTierVpnGw1,
		VirtualNetworkGatewaySkuSpecTierVpnGw1AZ,
		VirtualNetworkGatewaySkuSpecTierVpnGw2,
		VirtualNetworkGatewaySkuSpecTierVpnGw2AZ,
		VirtualNetworkGatewaySkuSpecTierVpnGw3,
		VirtualNetworkGatewaySkuSpecTierVpnGw3AZ,
		VirtualNetworkGatewaySkuSpecTierVpnGw4,
		VirtualNetworkGatewaySkuSpecTierVpnGw4AZ,
		VirtualNetworkGatewaySkuSpecTierVpnGw5,
		VirtualNetworkGatewaySkuSpecTierVpnGw5AZ))
}

func Test_VirtualNetworkGatewaySku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkGatewaySku_Status to VirtualNetworkGatewaySku_Status via AssignPropertiesToVirtualNetworkGatewaySkuStatus & AssignPropertiesFromVirtualNetworkGatewaySkuStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkGatewaySkuStatus, VirtualNetworkGatewaySkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkGatewaySkuStatus tests if a specific instance of VirtualNetworkGatewaySku_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkGatewaySkuStatus(subject VirtualNetworkGatewaySku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VirtualNetworkGatewaySku_Status
	err := copied.AssignPropertiesToVirtualNetworkGatewaySkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkGatewaySku_Status
	err = actual.AssignPropertiesFromVirtualNetworkGatewaySkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkGatewaySku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewaySku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus, VirtualNetworkGatewaySkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus runs a test to see if a specific instance of VirtualNetworkGatewaySku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus(subject VirtualNetworkGatewaySku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewaySku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewaySku_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewaySkuStatusGenerator()
var virtualNetworkGatewaySkuStatusGenerator gopter.Gen

// VirtualNetworkGatewaySkuStatusGenerator returns a generator of VirtualNetworkGatewaySku_Status instances for property testing.
func VirtualNetworkGatewaySkuStatusGenerator() gopter.Gen {
	if virtualNetworkGatewaySkuStatusGenerator != nil {
		return virtualNetworkGatewaySkuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus(generators)
	virtualNetworkGatewaySkuStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewaySku_Status{}), generators)

	return virtualNetworkGatewaySkuStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkGatewaySkuStatusNameBasic,
		VirtualNetworkGatewaySkuStatusNameErGw1AZ,
		VirtualNetworkGatewaySkuStatusNameErGw2AZ,
		VirtualNetworkGatewaySkuStatusNameErGw3AZ,
		VirtualNetworkGatewaySkuStatusNameHighPerformance,
		VirtualNetworkGatewaySkuStatusNameStandard,
		VirtualNetworkGatewaySkuStatusNameUltraPerformance,
		VirtualNetworkGatewaySkuStatusNameVpnGw1,
		VirtualNetworkGatewaySkuStatusNameVpnGw1AZ,
		VirtualNetworkGatewaySkuStatusNameVpnGw2,
		VirtualNetworkGatewaySkuStatusNameVpnGw2AZ,
		VirtualNetworkGatewaySkuStatusNameVpnGw3,
		VirtualNetworkGatewaySkuStatusNameVpnGw3AZ,
		VirtualNetworkGatewaySkuStatusNameVpnGw4,
		VirtualNetworkGatewaySkuStatusNameVpnGw4AZ,
		VirtualNetworkGatewaySkuStatusNameVpnGw5,
		VirtualNetworkGatewaySkuStatusNameVpnGw5AZ))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		VirtualNetworkGatewaySkuStatusTierBasic,
		VirtualNetworkGatewaySkuStatusTierErGw1AZ,
		VirtualNetworkGatewaySkuStatusTierErGw2AZ,
		VirtualNetworkGatewaySkuStatusTierErGw3AZ,
		VirtualNetworkGatewaySkuStatusTierHighPerformance,
		VirtualNetworkGatewaySkuStatusTierStandard,
		VirtualNetworkGatewaySkuStatusTierUltraPerformance,
		VirtualNetworkGatewaySkuStatusTierVpnGw1,
		VirtualNetworkGatewaySkuStatusTierVpnGw1AZ,
		VirtualNetworkGatewaySkuStatusTierVpnGw2,
		VirtualNetworkGatewaySkuStatusTierVpnGw2AZ,
		VirtualNetworkGatewaySkuStatusTierVpnGw3,
		VirtualNetworkGatewaySkuStatusTierVpnGw3AZ,
		VirtualNetworkGatewaySkuStatusTierVpnGw4,
		VirtualNetworkGatewaySkuStatusTierVpnGw4AZ,
		VirtualNetworkGatewaySkuStatusTierVpnGw5,
		VirtualNetworkGatewaySkuStatusTierVpnGw5AZ))
}

func Test_VpnClientConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientConfiguration_Spec to VpnClientConfiguration_Spec via AssignPropertiesToVpnClientConfigurationSpec & AssignPropertiesFromVpnClientConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientConfigurationSpec, VpnClientConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientConfigurationSpec tests if a specific instance of VpnClientConfiguration_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientConfigurationSpec(subject VpnClientConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientConfiguration_Spec
	err := copied.AssignPropertiesToVpnClientConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientConfiguration_Spec
	err = actual.AssignPropertiesFromVpnClientConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientConfigurationSpec, VpnClientConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientConfigurationSpec runs a test to see if a specific instance of VpnClientConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientConfigurationSpec(subject VpnClientConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientConfiguration_Spec instances for property testing - lazily instantiated by
//VpnClientConfigurationSpecGenerator()
var vpnClientConfigurationSpecGenerator gopter.Gen

// VpnClientConfigurationSpecGenerator returns a generator of VpnClientConfiguration_Spec instances for property testing.
// We first initialize vpnClientConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VpnClientConfigurationSpecGenerator() gopter.Gen {
	if vpnClientConfigurationSpecGenerator != nil {
		return vpnClientConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	vpnClientConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	vpnClientConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Spec{}), generators)

	return vpnClientConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(gens map[string]gopter.Gen) {
	gens["AadAudience"] = gen.PtrOf(gen.AlphaString())
	gens["AadIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenant"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
	gens["VpnAuthenticationTypes"] = gen.SliceOf(gen.OneConstOf(VpnClientConfigurationSpecVpnAuthenticationTypesAAD, VpnClientConfigurationSpecVpnAuthenticationTypesCertificate, VpnClientConfigurationSpecVpnAuthenticationTypesRadius))
	gens["VpnClientProtocols"] = gen.SliceOf(gen.OneConstOf(VpnClientConfigurationSpecVpnClientProtocolsIkeV2, VpnClientConfigurationSpecVpnClientProtocolsOpenVPN, VpnClientConfigurationSpecVpnClientProtocolsSSTP))
}

// AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec(gens map[string]gopter.Gen) {
	gens["RadiusServers"] = gen.SliceOf(RadiusServerSpecGenerator())
	gens["VpnClientAddressPool"] = gen.PtrOf(AddressSpaceSpecGenerator())
	gens["VpnClientIpsecPolicies"] = gen.SliceOf(IpsecPolicySpecGenerator())
	gens["VpnClientRevokedCertificates"] = gen.SliceOf(VpnClientRevokedCertificateSpecGenerator())
	gens["VpnClientRootCertificates"] = gen.SliceOf(VpnClientRootCertificateSpecGenerator())
}

func Test_VpnClientConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientConfiguration_Status to VpnClientConfiguration_Status via AssignPropertiesToVpnClientConfigurationStatus & AssignPropertiesFromVpnClientConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientConfigurationStatus, VpnClientConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientConfigurationStatus tests if a specific instance of VpnClientConfiguration_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientConfigurationStatus(subject VpnClientConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientConfiguration_Status
	err := copied.AssignPropertiesToVpnClientConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientConfiguration_Status
	err = actual.AssignPropertiesFromVpnClientConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientConfigurationStatus, VpnClientConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientConfigurationStatus runs a test to see if a specific instance of VpnClientConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientConfigurationStatus(subject VpnClientConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientConfiguration_Status instances for property testing - lazily instantiated by
//VpnClientConfigurationStatusGenerator()
var vpnClientConfigurationStatusGenerator gopter.Gen

// VpnClientConfigurationStatusGenerator returns a generator of VpnClientConfiguration_Status instances for property testing.
// We first initialize vpnClientConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VpnClientConfigurationStatusGenerator() gopter.Gen {
	if vpnClientConfigurationStatusGenerator != nil {
		return vpnClientConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	vpnClientConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	vpnClientConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Status{}), generators)

	return vpnClientConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(gens map[string]gopter.Gen) {
	gens["AadAudience"] = gen.PtrOf(gen.AlphaString())
	gens["AadIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenant"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
	gens["VpnAuthenticationTypes"] = gen.SliceOf(gen.OneConstOf(VpnClientConfigurationStatusVpnAuthenticationTypesAAD, VpnClientConfigurationStatusVpnAuthenticationTypesCertificate, VpnClientConfigurationStatusVpnAuthenticationTypesRadius))
	gens["VpnClientProtocols"] = gen.SliceOf(gen.OneConstOf(VpnClientConfigurationStatusVpnClientProtocolsIkeV2, VpnClientConfigurationStatusVpnClientProtocolsOpenVPN, VpnClientConfigurationStatusVpnClientProtocolsSSTP))
}

// AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus(gens map[string]gopter.Gen) {
	gens["RadiusServers"] = gen.SliceOf(RadiusServerStatusGenerator())
	gens["VpnClientAddressPool"] = gen.PtrOf(AddressSpaceStatusGenerator())
	gens["VpnClientIpsecPolicies"] = gen.SliceOf(IpsecPolicyStatusGenerator())
	gens["VpnClientRevokedCertificates"] = gen.SliceOf(VpnClientRevokedCertificateStatusGenerator())
	gens["VpnClientRootCertificates"] = gen.SliceOf(VpnClientRootCertificateStatusGenerator())
}

func Test_IPConfigurationBgpPeeringAddress_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPConfigurationBgpPeeringAddress_Spec to IPConfigurationBgpPeeringAddress_Spec via AssignPropertiesToIPConfigurationBgpPeeringAddressSpec & AssignPropertiesFromIPConfigurationBgpPeeringAddressSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressSpec, IPConfigurationBgpPeeringAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressSpec tests if a specific instance of IPConfigurationBgpPeeringAddress_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressSpec(subject IPConfigurationBgpPeeringAddress_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.IPConfigurationBgpPeeringAddress_Spec
	err := copied.AssignPropertiesToIPConfigurationBgpPeeringAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPConfigurationBgpPeeringAddress_Spec
	err = actual.AssignPropertiesFromIPConfigurationBgpPeeringAddressSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPConfigurationBgpPeeringAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationBgpPeeringAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec, IPConfigurationBgpPeeringAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec runs a test to see if a specific instance of IPConfigurationBgpPeeringAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec(subject IPConfigurationBgpPeeringAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationBgpPeeringAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationBgpPeeringAddress_Spec instances for property testing - lazily instantiated by
//IPConfigurationBgpPeeringAddressSpecGenerator()
var ipConfigurationBgpPeeringAddressSpecGenerator gopter.Gen

// IPConfigurationBgpPeeringAddressSpecGenerator returns a generator of IPConfigurationBgpPeeringAddress_Spec instances for property testing.
func IPConfigurationBgpPeeringAddressSpecGenerator() gopter.Gen {
	if ipConfigurationBgpPeeringAddressSpecGenerator != nil {
		return ipConfigurationBgpPeeringAddressSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec(generators)
	ipConfigurationBgpPeeringAddressSpecGenerator = gen.Struct(reflect.TypeOf(IPConfigurationBgpPeeringAddress_Spec{}), generators)

	return ipConfigurationBgpPeeringAddressSpecGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec(gens map[string]gopter.Gen) {
	gens["CustomBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["IpconfigurationId"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPConfigurationBgpPeeringAddress_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPConfigurationBgpPeeringAddress_Status to IPConfigurationBgpPeeringAddress_Status via AssignPropertiesToIPConfigurationBgpPeeringAddressStatus & AssignPropertiesFromIPConfigurationBgpPeeringAddressStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressStatus, IPConfigurationBgpPeeringAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressStatus tests if a specific instance of IPConfigurationBgpPeeringAddress_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForIPConfigurationBgpPeeringAddressStatus(subject IPConfigurationBgpPeeringAddress_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.IPConfigurationBgpPeeringAddress_Status
	err := copied.AssignPropertiesToIPConfigurationBgpPeeringAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPConfigurationBgpPeeringAddress_Status
	err = actual.AssignPropertiesFromIPConfigurationBgpPeeringAddressStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPConfigurationBgpPeeringAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationBgpPeeringAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus, IPConfigurationBgpPeeringAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus runs a test to see if a specific instance of IPConfigurationBgpPeeringAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus(subject IPConfigurationBgpPeeringAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationBgpPeeringAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationBgpPeeringAddress_Status instances for property testing - lazily instantiated by
//IPConfigurationBgpPeeringAddressStatusGenerator()
var ipConfigurationBgpPeeringAddressStatusGenerator gopter.Gen

// IPConfigurationBgpPeeringAddressStatusGenerator returns a generator of IPConfigurationBgpPeeringAddress_Status instances for property testing.
func IPConfigurationBgpPeeringAddressStatusGenerator() gopter.Gen {
	if ipConfigurationBgpPeeringAddressStatusGenerator != nil {
		return ipConfigurationBgpPeeringAddressStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus(generators)
	ipConfigurationBgpPeeringAddressStatusGenerator = gen.Struct(reflect.TypeOf(IPConfigurationBgpPeeringAddress_Status{}), generators)

	return ipConfigurationBgpPeeringAddressStatusGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus(gens map[string]gopter.Gen) {
	gens["CustomBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["IpconfigurationId"] = gen.PtrOf(gen.AlphaString())
	gens["TunnelIpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_IpsecPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpsecPolicy_Spec to IpsecPolicy_Spec via AssignPropertiesToIpsecPolicySpec & AssignPropertiesFromIpsecPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpsecPolicySpec, IpsecPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpsecPolicySpec tests if a specific instance of IpsecPolicy_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForIpsecPolicySpec(subject IpsecPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.IpsecPolicy_Spec
	err := copied.AssignPropertiesToIpsecPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpsecPolicy_Spec
	err = actual.AssignPropertiesFromIpsecPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpsecPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpsecPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpsecPolicySpec, IpsecPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpsecPolicySpec runs a test to see if a specific instance of IpsecPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpsecPolicySpec(subject IpsecPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpsecPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpsecPolicy_Spec instances for property testing - lazily instantiated by IpsecPolicySpecGenerator()
var ipsecPolicySpecGenerator gopter.Gen

// IpsecPolicySpecGenerator returns a generator of IpsecPolicy_Spec instances for property testing.
func IpsecPolicySpecGenerator() gopter.Gen {
	if ipsecPolicySpecGenerator != nil {
		return ipsecPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpsecPolicySpec(generators)
	ipsecPolicySpecGenerator = gen.Struct(reflect.TypeOf(IpsecPolicy_Spec{}), generators)

	return ipsecPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForIpsecPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpsecPolicySpec(gens map[string]gopter.Gen) {
	gens["DhGroup"] = gen.OneConstOf(
		DhGroup_SpecDHGroup1,
		DhGroup_SpecDHGroup14,
		DhGroup_SpecDHGroup2,
		DhGroup_SpecDHGroup2048,
		DhGroup_SpecDHGroup24,
		DhGroup_SpecECP256,
		DhGroup_SpecECP384,
		DhGroup_SpecNone)
	gens["IkeEncryption"] = gen.OneConstOf(
		IkeEncryption_SpecAES128,
		IkeEncryption_SpecAES192,
		IkeEncryption_SpecAES256,
		IkeEncryption_SpecDES,
		IkeEncryption_SpecDES3,
		IkeEncryption_SpecGCMAES128,
		IkeEncryption_SpecGCMAES256)
	gens["IkeIntegrity"] = gen.OneConstOf(
		IkeIntegrity_SpecGCMAES128,
		IkeIntegrity_SpecGCMAES256,
		IkeIntegrity_SpecMD5,
		IkeIntegrity_SpecSHA1,
		IkeIntegrity_SpecSHA256,
		IkeIntegrity_SpecSHA384)
	gens["IpsecEncryption"] = gen.OneConstOf(
		IpsecEncryption_SpecAES128,
		IpsecEncryption_SpecAES192,
		IpsecEncryption_SpecAES256,
		IpsecEncryption_SpecDES,
		IpsecEncryption_SpecDES3,
		IpsecEncryption_SpecGCMAES128,
		IpsecEncryption_SpecGCMAES192,
		IpsecEncryption_SpecGCMAES256,
		IpsecEncryption_SpecNone)
	gens["IpsecIntegrity"] = gen.OneConstOf(
		IpsecIntegrity_SpecGCMAES128,
		IpsecIntegrity_SpecGCMAES192,
		IpsecIntegrity_SpecGCMAES256,
		IpsecIntegrity_SpecMD5,
		IpsecIntegrity_SpecSHA1,
		IpsecIntegrity_SpecSHA256)
	gens["PfsGroup"] = gen.OneConstOf(
		PfsGroup_SpecECP256,
		PfsGroup_SpecECP384,
		PfsGroup_SpecNone,
		PfsGroup_SpecPFS1,
		PfsGroup_SpecPFS14,
		PfsGroup_SpecPFS2,
		PfsGroup_SpecPFS2048,
		PfsGroup_SpecPFS24,
		PfsGroup_SpecPFSMM)
	gens["SaDataSizeKilobytes"] = gen.Int()
	gens["SaLifeTimeSeconds"] = gen.Int()
}

func Test_IpsecPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpsecPolicy_Status to IpsecPolicy_Status via AssignPropertiesToIpsecPolicyStatus & AssignPropertiesFromIpsecPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpsecPolicyStatus, IpsecPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpsecPolicyStatus tests if a specific instance of IpsecPolicy_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForIpsecPolicyStatus(subject IpsecPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.IpsecPolicy_Status
	err := copied.AssignPropertiesToIpsecPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpsecPolicy_Status
	err = actual.AssignPropertiesFromIpsecPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpsecPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpsecPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpsecPolicyStatus, IpsecPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpsecPolicyStatus runs a test to see if a specific instance of IpsecPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpsecPolicyStatus(subject IpsecPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpsecPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpsecPolicy_Status instances for property testing - lazily instantiated by IpsecPolicyStatusGenerator()
var ipsecPolicyStatusGenerator gopter.Gen

// IpsecPolicyStatusGenerator returns a generator of IpsecPolicy_Status instances for property testing.
func IpsecPolicyStatusGenerator() gopter.Gen {
	if ipsecPolicyStatusGenerator != nil {
		return ipsecPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpsecPolicyStatus(generators)
	ipsecPolicyStatusGenerator = gen.Struct(reflect.TypeOf(IpsecPolicy_Status{}), generators)

	return ipsecPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpsecPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpsecPolicyStatus(gens map[string]gopter.Gen) {
	gens["DhGroup"] = gen.OneConstOf(
		DhGroup_StatusDHGroup1,
		DhGroup_StatusDHGroup14,
		DhGroup_StatusDHGroup2,
		DhGroup_StatusDHGroup2048,
		DhGroup_StatusDHGroup24,
		DhGroup_StatusECP256,
		DhGroup_StatusECP384,
		DhGroup_StatusNone)
	gens["IkeEncryption"] = gen.OneConstOf(
		IkeEncryption_StatusAES128,
		IkeEncryption_StatusAES192,
		IkeEncryption_StatusAES256,
		IkeEncryption_StatusDES,
		IkeEncryption_StatusDES3,
		IkeEncryption_StatusGCMAES128,
		IkeEncryption_StatusGCMAES256)
	gens["IkeIntegrity"] = gen.OneConstOf(
		IkeIntegrity_StatusGCMAES128,
		IkeIntegrity_StatusGCMAES256,
		IkeIntegrity_StatusMD5,
		IkeIntegrity_StatusSHA1,
		IkeIntegrity_StatusSHA256,
		IkeIntegrity_StatusSHA384)
	gens["IpsecEncryption"] = gen.OneConstOf(
		IpsecEncryption_StatusAES128,
		IpsecEncryption_StatusAES192,
		IpsecEncryption_StatusAES256,
		IpsecEncryption_StatusDES,
		IpsecEncryption_StatusDES3,
		IpsecEncryption_StatusGCMAES128,
		IpsecEncryption_StatusGCMAES192,
		IpsecEncryption_StatusGCMAES256,
		IpsecEncryption_StatusNone)
	gens["IpsecIntegrity"] = gen.OneConstOf(
		IpsecIntegrity_StatusGCMAES128,
		IpsecIntegrity_StatusGCMAES192,
		IpsecIntegrity_StatusGCMAES256,
		IpsecIntegrity_StatusMD5,
		IpsecIntegrity_StatusSHA1,
		IpsecIntegrity_StatusSHA256)
	gens["PfsGroup"] = gen.OneConstOf(
		PfsGroup_StatusECP256,
		PfsGroup_StatusECP384,
		PfsGroup_StatusNone,
		PfsGroup_StatusPFS1,
		PfsGroup_StatusPFS14,
		PfsGroup_StatusPFS2,
		PfsGroup_StatusPFS2048,
		PfsGroup_StatusPFS24,
		PfsGroup_StatusPFSMM)
	gens["SaDataSizeKilobytes"] = gen.Int()
	gens["SaLifeTimeSeconds"] = gen.Int()
}

func Test_RadiusServer_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RadiusServer_Spec to RadiusServer_Spec via AssignPropertiesToRadiusServerSpec & AssignPropertiesFromRadiusServerSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRadiusServerSpec, RadiusServerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRadiusServerSpec tests if a specific instance of RadiusServer_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForRadiusServerSpec(subject RadiusServer_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.RadiusServer_Spec
	err := copied.AssignPropertiesToRadiusServerSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RadiusServer_Spec
	err = actual.AssignPropertiesFromRadiusServerSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RadiusServer_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RadiusServer_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRadiusServerSpec, RadiusServerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRadiusServerSpec runs a test to see if a specific instance of RadiusServer_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRadiusServerSpec(subject RadiusServer_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RadiusServer_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RadiusServer_Spec instances for property testing - lazily instantiated by RadiusServerSpecGenerator()
var radiusServerSpecGenerator gopter.Gen

// RadiusServerSpecGenerator returns a generator of RadiusServer_Spec instances for property testing.
func RadiusServerSpecGenerator() gopter.Gen {
	if radiusServerSpecGenerator != nil {
		return radiusServerSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRadiusServerSpec(generators)
	radiusServerSpecGenerator = gen.Struct(reflect.TypeOf(RadiusServer_Spec{}), generators)

	return radiusServerSpecGenerator
}

// AddIndependentPropertyGeneratorsForRadiusServerSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRadiusServerSpec(gens map[string]gopter.Gen) {
	gens["RadiusServerAddress"] = gen.AlphaString()
	gens["RadiusServerScore"] = gen.PtrOf(gen.Int())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_RadiusServer_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RadiusServer_Status to RadiusServer_Status via AssignPropertiesToRadiusServerStatus & AssignPropertiesFromRadiusServerStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForRadiusServerStatus, RadiusServerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRadiusServerStatus tests if a specific instance of RadiusServer_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForRadiusServerStatus(subject RadiusServer_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.RadiusServer_Status
	err := copied.AssignPropertiesToRadiusServerStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RadiusServer_Status
	err = actual.AssignPropertiesFromRadiusServerStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RadiusServer_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RadiusServer_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRadiusServerStatus, RadiusServerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRadiusServerStatus runs a test to see if a specific instance of RadiusServer_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRadiusServerStatus(subject RadiusServer_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RadiusServer_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RadiusServer_Status instances for property testing - lazily instantiated by RadiusServerStatusGenerator()
var radiusServerStatusGenerator gopter.Gen

// RadiusServerStatusGenerator returns a generator of RadiusServer_Status instances for property testing.
func RadiusServerStatusGenerator() gopter.Gen {
	if radiusServerStatusGenerator != nil {
		return radiusServerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRadiusServerStatus(generators)
	radiusServerStatusGenerator = gen.Struct(reflect.TypeOf(RadiusServer_Status{}), generators)

	return radiusServerStatusGenerator
}

// AddIndependentPropertyGeneratorsForRadiusServerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRadiusServerStatus(gens map[string]gopter.Gen) {
	gens["RadiusServerAddress"] = gen.AlphaString()
	gens["RadiusServerScore"] = gen.PtrOf(gen.Int())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRevokedCertificate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientRevokedCertificate_Spec to VpnClientRevokedCertificate_Spec via AssignPropertiesToVpnClientRevokedCertificateSpec & AssignPropertiesFromVpnClientRevokedCertificateSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientRevokedCertificateSpec, VpnClientRevokedCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientRevokedCertificateSpec tests if a specific instance of VpnClientRevokedCertificate_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientRevokedCertificateSpec(subject VpnClientRevokedCertificate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientRevokedCertificate_Spec
	err := copied.AssignPropertiesToVpnClientRevokedCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientRevokedCertificate_Spec
	err = actual.AssignPropertiesFromVpnClientRevokedCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientRevokedCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRevokedCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRevokedCertificateSpec, VpnClientRevokedCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRevokedCertificateSpec runs a test to see if a specific instance of VpnClientRevokedCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRevokedCertificateSpec(subject VpnClientRevokedCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRevokedCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRevokedCertificate_Spec instances for property testing - lazily instantiated by
//VpnClientRevokedCertificateSpecGenerator()
var vpnClientRevokedCertificateSpecGenerator gopter.Gen

// VpnClientRevokedCertificateSpecGenerator returns a generator of VpnClientRevokedCertificate_Spec instances for property testing.
func VpnClientRevokedCertificateSpecGenerator() gopter.Gen {
	if vpnClientRevokedCertificateSpecGenerator != nil {
		return vpnClientRevokedCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec(generators)
	vpnClientRevokedCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientRevokedCertificate_Spec{}), generators)

	return vpnClientRevokedCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRevokedCertificate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientRevokedCertificate_Status to VpnClientRevokedCertificate_Status via AssignPropertiesToVpnClientRevokedCertificateStatus & AssignPropertiesFromVpnClientRevokedCertificateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientRevokedCertificateStatus, VpnClientRevokedCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientRevokedCertificateStatus tests if a specific instance of VpnClientRevokedCertificate_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientRevokedCertificateStatus(subject VpnClientRevokedCertificate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientRevokedCertificate_Status
	err := copied.AssignPropertiesToVpnClientRevokedCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientRevokedCertificate_Status
	err = actual.AssignPropertiesFromVpnClientRevokedCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientRevokedCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRevokedCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRevokedCertificateStatus, VpnClientRevokedCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRevokedCertificateStatus runs a test to see if a specific instance of VpnClientRevokedCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRevokedCertificateStatus(subject VpnClientRevokedCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRevokedCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRevokedCertificate_Status instances for property testing - lazily instantiated by
//VpnClientRevokedCertificateStatusGenerator()
var vpnClientRevokedCertificateStatusGenerator gopter.Gen

// VpnClientRevokedCertificateStatusGenerator returns a generator of VpnClientRevokedCertificate_Status instances for property testing.
func VpnClientRevokedCertificateStatusGenerator() gopter.Gen {
	if vpnClientRevokedCertificateStatusGenerator != nil {
		return vpnClientRevokedCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus(generators)
	vpnClientRevokedCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientRevokedCertificate_Status{}), generators)

	return vpnClientRevokedCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRootCertificate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientRootCertificate_Spec to VpnClientRootCertificate_Spec via AssignPropertiesToVpnClientRootCertificateSpec & AssignPropertiesFromVpnClientRootCertificateSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientRootCertificateSpec, VpnClientRootCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientRootCertificateSpec tests if a specific instance of VpnClientRootCertificate_Spec can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientRootCertificateSpec(subject VpnClientRootCertificate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientRootCertificate_Spec
	err := copied.AssignPropertiesToVpnClientRootCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientRootCertificate_Spec
	err = actual.AssignPropertiesFromVpnClientRootCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientRootCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRootCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRootCertificateSpec, VpnClientRootCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRootCertificateSpec runs a test to see if a specific instance of VpnClientRootCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRootCertificateSpec(subject VpnClientRootCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRootCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRootCertificate_Spec instances for property testing - lazily instantiated by
//VpnClientRootCertificateSpecGenerator()
var vpnClientRootCertificateSpecGenerator gopter.Gen

// VpnClientRootCertificateSpecGenerator returns a generator of VpnClientRootCertificate_Spec instances for property testing.
func VpnClientRootCertificateSpecGenerator() gopter.Gen {
	if vpnClientRootCertificateSpecGenerator != nil {
		return vpnClientRootCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec(generators)
	vpnClientRootCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientRootCertificate_Spec{}), generators)

	return vpnClientRootCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PublicCertData"] = gen.AlphaString()
}

func Test_VpnClientRootCertificate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VpnClientRootCertificate_Status to VpnClientRootCertificate_Status via AssignPropertiesToVpnClientRootCertificateStatus & AssignPropertiesFromVpnClientRootCertificateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVpnClientRootCertificateStatus, VpnClientRootCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVpnClientRootCertificateStatus tests if a specific instance of VpnClientRootCertificate_Status can be assigned to v1alpha1api20201101storage and back losslessly
func RunPropertyAssignmentTestForVpnClientRootCertificateStatus(subject VpnClientRootCertificate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201101storage.VpnClientRootCertificate_Status
	err := copied.AssignPropertiesToVpnClientRootCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VpnClientRootCertificate_Status
	err = actual.AssignPropertiesFromVpnClientRootCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VpnClientRootCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRootCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRootCertificateStatus, VpnClientRootCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRootCertificateStatus runs a test to see if a specific instance of VpnClientRootCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRootCertificateStatus(subject VpnClientRootCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRootCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRootCertificate_Status instances for property testing - lazily instantiated by
//VpnClientRootCertificateStatusGenerator()
var vpnClientRootCertificateStatusGenerator gopter.Gen

// VpnClientRootCertificateStatusGenerator returns a generator of VpnClientRootCertificate_Status instances for property testing.
func VpnClientRootCertificateStatusGenerator() gopter.Gen {
	if vpnClientRootCertificateStatusGenerator != nil {
		return vpnClientRootCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus(generators)
	vpnClientRootCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientRootCertificate_Status{}), generators)

	return vpnClientRootCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUpdating))
	gens["PublicCertData"] = gen.AlphaString()
}
