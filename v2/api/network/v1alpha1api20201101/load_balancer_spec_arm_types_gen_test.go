// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Spec_ARM, LoadBalancer_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Spec_ARM(subject LoadBalancer_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Spec_ARMGenerator()
var loadBalancer_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Spec_ARMGenerator returns a generator of LoadBalancer_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Spec_ARMGenerator != nil {
		return loadBalancer_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	loadBalancer_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM(generators)
	loadBalancer_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Spec_ARM{}), generators)

	return loadBalancer_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancer_Properties_Spec_ARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSku_ARMGenerator())
}

func Test_ExtendedLocation_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_ARM, ExtendedLocation_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_ARM runs a test to see if a specific instance of ExtendedLocation_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_ARM(subject ExtendedLocation_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_ARM instances for property testing - lazily instantiated by
// ExtendedLocation_ARMGenerator()
var extendedLocation_ARMGenerator gopter.Gen

// ExtendedLocation_ARMGenerator returns a generator of ExtendedLocation_ARM instances for property testing.
func ExtendedLocation_ARMGenerator() gopter.Gen {
	if extendedLocation_ARMGenerator != nil {
		return extendedLocation_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_ARM(generators)
	extendedLocation_ARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_ARM{}), generators)

	return extendedLocation_ARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocation_Type_EdgeZone))
}

func Test_LoadBalancer_Properties_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_Spec_ARM, LoadBalancer_Properties_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_Spec_ARM(subject LoadBalancer_Properties_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Properties_Spec_ARMGenerator()
var loadBalancer_Properties_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_Spec_ARM instances for property testing.
func LoadBalancer_Properties_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Spec_ARM(generators)
	loadBalancer_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_Spec_ARM{}), generators)

	return loadBalancer_Properties_Spec_ARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(LoadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(LoadBalancer_Properties_InboundNatPools_Spec_ARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(LoadBalancer_Properties_OutboundRules_Spec_ARMGenerator())
	gens["Probes"] = gen.SliceOf(LoadBalancer_Properties_Probes_Spec_ARMGenerator())
}

func Test_LoadBalancerSku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSku_ARM, LoadBalancerSku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSku_ARM runs a test to see if a specific instance of LoadBalancerSku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSku_ARM(subject LoadBalancerSku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSku_ARM instances for property testing - lazily instantiated by
// LoadBalancerSku_ARMGenerator()
var loadBalancerSku_ARMGenerator gopter.Gen

// LoadBalancerSku_ARMGenerator returns a generator of LoadBalancerSku_ARM instances for property testing.
func LoadBalancerSku_ARMGenerator() gopter.Gen {
	if loadBalancerSku_ARMGenerator != nil {
		return loadBalancerSku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM(generators)
	loadBalancerSku_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSku_ARM{}), generators)

	return loadBalancerSku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSku_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_LoadBalancer_Properties_BackendAddressPools_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_BackendAddressPools_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Spec_ARM, LoadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_BackendAddressPools_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(subject LoadBalancer_Properties_BackendAddressPools_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_BackendAddressPools_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_BackendAddressPools_Spec_ARM instances for property testing - lazily
// instantiated by LoadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator()
var loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_BackendAddressPools_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Spec_ARM{}), generators)

	return loadBalancer_Properties_BackendAddressPools_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator())
}

func Test_LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM, LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(subject LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM instances for property testing - lazily
// instantiated by LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator()
var loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(generators)
	loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(generators)
	loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM{}), generators)

	return loadBalancer_Properties_FrontendIPConfigurations_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_FrontendIPConfigurations_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormat_ARMGenerator())
}

func Test_LoadBalancer_Properties_InboundNatPools_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_InboundNatPools_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_InboundNatPools_Spec_ARM, LoadBalancer_Properties_InboundNatPools_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_InboundNatPools_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_InboundNatPools_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_InboundNatPools_Spec_ARM(subject LoadBalancer_Properties_InboundNatPools_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_InboundNatPools_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_InboundNatPools_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Properties_InboundNatPools_Spec_ARMGenerator()
var loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_InboundNatPools_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_InboundNatPools_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_InboundNatPools_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM(generators)
	loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_InboundNatPools_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM(generators)
	loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_InboundNatPools_Spec_ARM{}), generators)

	return loadBalancer_Properties_InboundNatPools_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_InboundNatPools_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormat_ARMGenerator())
}

func Test_LoadBalancer_Properties_LoadBalancingRules_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_LoadBalancingRules_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM, LoadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_LoadBalancingRules_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(subject LoadBalancer_Properties_LoadBalancingRules_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_LoadBalancingRules_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_LoadBalancingRules_Spec_ARM instances for property testing - lazily instantiated
// by LoadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator()
var loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_LoadBalancingRules_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(generators)
	loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_LoadBalancingRules_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(generators)
	loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_LoadBalancingRules_Spec_ARM{}), generators)

	return loadBalancer_Properties_LoadBalancingRules_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_LoadBalancingRules_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormat_ARMGenerator())
}

func Test_LoadBalancer_Properties_OutboundRules_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_OutboundRules_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_OutboundRules_Spec_ARM, LoadBalancer_Properties_OutboundRules_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_OutboundRules_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_OutboundRules_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_OutboundRules_Spec_ARM(subject LoadBalancer_Properties_OutboundRules_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_OutboundRules_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_OutboundRules_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Properties_OutboundRules_Spec_ARMGenerator()
var loadBalancer_Properties_OutboundRules_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_OutboundRules_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_OutboundRules_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_OutboundRules_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_OutboundRules_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_OutboundRules_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_OutboundRules_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM(generators)
	loadBalancer_Properties_OutboundRules_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_OutboundRules_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM(generators)
	loadBalancer_Properties_OutboundRules_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_OutboundRules_Spec_ARM{}), generators)

	return loadBalancer_Properties_OutboundRules_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_OutboundRules_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormat_ARMGenerator())
}

func Test_LoadBalancer_Properties_Probes_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_Probes_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_Probes_Spec_ARM, LoadBalancer_Properties_Probes_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_Probes_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_Probes_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_Probes_Spec_ARM(subject LoadBalancer_Properties_Probes_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_Probes_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_Probes_Spec_ARM instances for property testing - lazily instantiated by
// LoadBalancer_Properties_Probes_Spec_ARMGenerator()
var loadBalancer_Properties_Probes_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_Probes_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_Probes_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_Probes_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_Probes_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_Probes_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_Probes_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM(generators)
	loadBalancer_Properties_Probes_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_Probes_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM(generators)
	loadBalancer_Properties_Probes_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_Probes_Spec_ARM{}), generators)

	return loadBalancer_Properties_Probes_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_Probes_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormat_ARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM, FrontendIPConfigurationPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormat_ARM(subject FrontendIPConfigurationPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormat_ARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormat_ARMGenerator()
var frontendIPConfigurationPropertiesFormat_ARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormat_ARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormat_ARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormat_ARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormat_ARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	frontendIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(generators)
	frontendIPConfigurationPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormat_ARM{}), generators)

	return frontendIPConfigurationPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormat_PrivateIPAddressVersion_IPv4, FrontendIPConfigurationPropertiesFormat_PrivateIPAddressVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(FrontendIPConfigurationPropertiesFormat_PrivateIPAllocationMethod_Dynamic, FrontendIPConfigurationPropertiesFormat_PrivateIPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_InboundNatPoolPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM, InboundNatPoolPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormat_ARM(subject InboundNatPoolPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormat_ARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormat_ARMGenerator()
var inboundNatPoolPropertiesFormat_ARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormat_ARMGenerator returns a generator of InboundNatPoolPropertiesFormat_ARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormat_ARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormat_ARMGenerator != nil {
		return inboundNatPoolPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	inboundNatPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(generators)
	inboundNatPoolPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormat_ARM{}), generators)

	return inboundNatPoolPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(InboundNatPoolPropertiesFormat_Protocol_All, InboundNatPoolPropertiesFormat_Protocol_Tcp, InboundNatPoolPropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM, LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(subject LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM instances for property testing - lazily
// instantiated by LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator()
var loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM{}), generators)

	return loadBalancer_Properties_BackendAddressPools_Properties_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM, LoadBalancingRulePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormat_ARM(subject LoadBalancingRulePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormat_ARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormat_ARMGenerator()
var loadBalancingRulePropertiesFormat_ARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormat_ARMGenerator returns a generator of LoadBalancingRulePropertiesFormat_ARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormat_ARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormat_ARMGenerator != nil {
		return loadBalancingRulePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	loadBalancingRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(generators)
	loadBalancingRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormat_ARM{}), generators)

	return loadBalancingRulePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_Protocol_All, LoadBalancingRulePropertiesFormat_Protocol_Tcp, LoadBalancingRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_OutboundRulePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM, OutboundRulePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM runs a test to see if a specific instance of OutboundRulePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormat_ARM(subject OutboundRulePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormat_ARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormat_ARMGenerator()
var outboundRulePropertiesFormat_ARMGenerator gopter.Gen

// OutboundRulePropertiesFormat_ARMGenerator returns a generator of OutboundRulePropertiesFormat_ARM instances for property testing.
// We first initialize outboundRulePropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormat_ARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormat_ARMGenerator != nil {
		return outboundRulePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	outboundRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(generators)
	outboundRulePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormat_ARM{}), generators)

	return outboundRulePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResource_ARMGenerator())
}

func Test_ProbePropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormat_ARM, ProbePropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormat_ARM runs a test to see if a specific instance of ProbePropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormat_ARM(subject ProbePropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormat_ARM instances for property testing - lazily instantiated by
// ProbePropertiesFormat_ARMGenerator()
var probePropertiesFormat_ARMGenerator gopter.Gen

// ProbePropertiesFormat_ARMGenerator returns a generator of ProbePropertiesFormat_ARM instances for property testing.
func ProbePropertiesFormat_ARMGenerator() gopter.Gen {
	if probePropertiesFormat_ARMGenerator != nil {
		return probePropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM(generators)
	probePropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormat_ARM{}), generators)

	return probePropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM, LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM runs a test to see if a specific instance of LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(subject LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM instances
// for property testing - lazily instantiated by
// LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator()
var loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator gopter.Gen

// LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator returns a generator of LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM instances for property testing.
// We first initialize loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator() gopter.Gen {
	if loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator != nil {
		return loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(generators)
	loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM{}), generators)

	return loadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormat_ARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM, LoadBalancerBackendAddressPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormat_ARM(subject LoadBalancerBackendAddressPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormat_ARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressPropertiesFormat_ARMGenerator()
var loadBalancerBackendAddressPropertiesFormat_ARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormat_ARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormat_ARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormat_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormat_ARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormat_ARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	loadBalancerBackendAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(generators)
	loadBalancerBackendAddressPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormat_ARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormat_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResource_ARMGenerator())
}
