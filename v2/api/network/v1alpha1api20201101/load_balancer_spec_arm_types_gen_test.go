// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_LoadBalancer_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancer_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancer_SpecARM, LoadBalancer_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancer_SpecARM runs a test to see if a specific instance of LoadBalancer_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancer_SpecARM(subject LoadBalancer_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancer_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancer_SpecARM instances for property testing - lazily instantiated by
// LoadBalancer_SpecARMGenerator()
var loadBalancer_SpecARMGenerator gopter.Gen

// LoadBalancer_SpecARMGenerator returns a generator of LoadBalancer_SpecARM instances for property testing.
// We first initialize loadBalancer_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancer_SpecARMGenerator() gopter.Gen {
	if loadBalancer_SpecARMGenerator != nil {
		return loadBalancer_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	loadBalancer_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM(generators)
	loadBalancer_SpecARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancer_SpecARM{}), generators)

	return loadBalancer_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancer_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancer_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(LoadBalancerPropertiesFormatARMGenerator())
	gens["Sku"] = gen.PtrOf(LoadBalancerSkuARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_EdgeZone))
}

func Test_LoadBalancerPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerPropertiesFormatARM, LoadBalancerPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerPropertiesFormatARM runs a test to see if a specific instance of LoadBalancerPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerPropertiesFormatARM(subject LoadBalancerPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerPropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancerPropertiesFormatARMGenerator()
var loadBalancerPropertiesFormatARMGenerator gopter.Gen

// LoadBalancerPropertiesFormatARMGenerator returns a generator of LoadBalancerPropertiesFormatARM instances for property testing.
func LoadBalancerPropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancerPropertiesFormatARMGenerator != nil {
		return loadBalancerPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM(generators)
	loadBalancerPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerPropertiesFormatARM{}), generators)

	return loadBalancerPropertiesFormatARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPools"] = gen.SliceOf(BackendAddressPoolARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(FrontendIPConfigurationARMGenerator())
	gens["InboundNatPools"] = gen.SliceOf(InboundNatPoolARMGenerator())
	gens["InboundNatRules"] = gen.SliceOf(InboundNatRuleARMGenerator())
	gens["LoadBalancingRules"] = gen.SliceOf(LoadBalancingRuleARMGenerator())
	gens["OutboundRules"] = gen.SliceOf(OutboundRuleARMGenerator())
	gens["Probes"] = gen.SliceOf(ProbeARMGenerator())
}

func Test_LoadBalancerSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerSkuARM, LoadBalancerSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerSkuARM runs a test to see if a specific instance of LoadBalancerSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerSkuARM(subject LoadBalancerSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerSkuARM instances for property testing - lazily instantiated by LoadBalancerSkuARMGenerator()
var loadBalancerSkuARMGenerator gopter.Gen

// LoadBalancerSkuARMGenerator returns a generator of LoadBalancerSkuARM instances for property testing.
func LoadBalancerSkuARMGenerator() gopter.Gen {
	if loadBalancerSkuARMGenerator != nil {
		return loadBalancerSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(generators)
	loadBalancerSkuARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerSkuARM{}), generators)

	return loadBalancerSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Name_Basic, LoadBalancerSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(LoadBalancerSku_Tier_Global, LoadBalancerSku_Tier_Regional))
}

func Test_BackendAddressPoolARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPoolARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolARM, BackendAddressPoolARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolARM runs a test to see if a specific instance of BackendAddressPoolARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolARM(subject BackendAddressPoolARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPoolARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPoolARM instances for property testing - lazily instantiated by
// BackendAddressPoolARMGenerator()
var backendAddressPoolARMGenerator gopter.Gen

// BackendAddressPoolARMGenerator returns a generator of BackendAddressPoolARM instances for property testing.
// We first initialize backendAddressPoolARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendAddressPoolARMGenerator() gopter.Gen {
	if backendAddressPoolARMGenerator != nil {
		return backendAddressPoolARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolARM(generators)
	backendAddressPoolARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPoolARM(generators)
	AddRelatedPropertyGeneratorsForBackendAddressPoolARM(generators)
	backendAddressPoolARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolARM{}), generators)

	return backendAddressPoolARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPoolARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPoolARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendAddressPoolARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPoolARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackendAddressPoolPropertiesFormatARMGenerator())
}

func Test_FrontendIPConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationARM, FrontendIPConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationARM runs a test to see if a specific instance of FrontendIPConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationARM(subject FrontendIPConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationARMGenerator()
var frontendIPConfigurationARMGenerator gopter.Gen

// FrontendIPConfigurationARMGenerator returns a generator of FrontendIPConfigurationARM instances for property testing.
// We first initialize frontendIPConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationARMGenerator() gopter.Gen {
	if frontendIPConfigurationARMGenerator != nil {
		return frontendIPConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationARM(generators)
	frontendIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationARM(generators)
	frontendIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationARM{}), generators)

	return frontendIPConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendIPConfigurationPropertiesFormatARMGenerator())
}

func Test_InboundNatPoolARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolARM, InboundNatPoolARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolARM runs a test to see if a specific instance of InboundNatPoolARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolARM(subject InboundNatPoolARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolARM instances for property testing - lazily instantiated by InboundNatPoolARMGenerator()
var inboundNatPoolARMGenerator gopter.Gen

// InboundNatPoolARMGenerator returns a generator of InboundNatPoolARM instances for property testing.
// We first initialize inboundNatPoolARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolARMGenerator() gopter.Gen {
	if inboundNatPoolARMGenerator != nil {
		return inboundNatPoolARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolARM(generators)
	inboundNatPoolARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolARM(generators)
	inboundNatPoolARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolARM{}), generators)

	return inboundNatPoolARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatPoolARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatPoolPropertiesFormatARMGenerator())
}

func Test_InboundNatRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRuleARM, InboundNatRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRuleARM runs a test to see if a specific instance of InboundNatRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRuleARM(subject InboundNatRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRuleARM instances for property testing - lazily instantiated by InboundNatRuleARMGenerator()
var inboundNatRuleARMGenerator gopter.Gen

// InboundNatRuleARMGenerator returns a generator of InboundNatRuleARM instances for property testing.
// We first initialize inboundNatRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRuleARMGenerator() gopter.Gen {
	if inboundNatRuleARMGenerator != nil {
		return inboundNatRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleARM(generators)
	inboundNatRuleARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRuleARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRuleARM(generators)
	inboundNatRuleARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRuleARM{}), generators)

	return inboundNatRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRuleARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInboundNatRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(InboundNatRulePropertiesFormatARMGenerator())
}

func Test_LoadBalancingRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRuleARM, LoadBalancingRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRuleARM runs a test to see if a specific instance of LoadBalancingRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRuleARM(subject LoadBalancingRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRuleARM instances for property testing - lazily instantiated by
// LoadBalancingRuleARMGenerator()
var loadBalancingRuleARMGenerator gopter.Gen

// LoadBalancingRuleARMGenerator returns a generator of LoadBalancingRuleARM instances for property testing.
// We first initialize loadBalancingRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRuleARMGenerator() gopter.Gen {
	if loadBalancingRuleARMGenerator != nil {
		return loadBalancingRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(generators)
	loadBalancingRuleARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRuleARM(generators)
	loadBalancingRuleARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRuleARM{}), generators)

	return loadBalancingRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRuleARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingRulePropertiesFormatARMGenerator())
}

func Test_OutboundRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRuleARM, OutboundRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRuleARM runs a test to see if a specific instance of OutboundRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRuleARM(subject OutboundRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRuleARM instances for property testing - lazily instantiated by OutboundRuleARMGenerator()
var outboundRuleARMGenerator gopter.Gen

// OutboundRuleARMGenerator returns a generator of OutboundRuleARM instances for property testing.
// We first initialize outboundRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRuleARMGenerator() gopter.Gen {
	if outboundRuleARMGenerator != nil {
		return outboundRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleARM(generators)
	outboundRuleARMGenerator = gen.Struct(reflect.TypeOf(OutboundRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRuleARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRuleARM(generators)
	outboundRuleARMGenerator = gen.Struct(reflect.TypeOf(OutboundRuleARM{}), generators)

	return outboundRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRuleARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOutboundRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRuleARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OutboundRulePropertiesFormatARMGenerator())
}

func Test_ProbeARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbeARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbeARM, ProbeARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbeARM runs a test to see if a specific instance of ProbeARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbeARM(subject ProbeARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbeARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbeARM instances for property testing - lazily instantiated by ProbeARMGenerator()
var probeARMGenerator gopter.Gen

// ProbeARMGenerator returns a generator of ProbeARM instances for property testing.
// We first initialize probeARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProbeARMGenerator() gopter.Gen {
	if probeARMGenerator != nil {
		return probeARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeARM(generators)
	probeARMGenerator = gen.Struct(reflect.TypeOf(ProbeARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbeARM(generators)
	AddRelatedPropertyGeneratorsForProbeARM(generators)
	probeARMGenerator = gen.Struct(reflect.TypeOf(ProbeARM{}), generators)

	return probeARMGenerator
}

// AddIndependentPropertyGeneratorsForProbeARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbeARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProbeARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProbeARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProbePropertiesFormatARMGenerator())
}

func Test_BackendAddressPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPoolPropertiesFormatARM, BackendAddressPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPoolPropertiesFormatARM runs a test to see if a specific instance of BackendAddressPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPoolPropertiesFormatARM(subject BackendAddressPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPoolPropertiesFormatARM instances for property testing - lazily instantiated by
// BackendAddressPoolPropertiesFormatARMGenerator()
var backendAddressPoolPropertiesFormatARMGenerator gopter.Gen

// BackendAddressPoolPropertiesFormatARMGenerator returns a generator of BackendAddressPoolPropertiesFormatARM instances for property testing.
func BackendAddressPoolPropertiesFormatARMGenerator() gopter.Gen {
	if backendAddressPoolPropertiesFormatARMGenerator != nil {
		return backendAddressPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormatARM(generators)
	backendAddressPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(BackendAddressPoolPropertiesFormatARM{}), generators)

	return backendAddressPoolPropertiesFormatARMGenerator
}

// AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendAddressPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerBackendAddresses"] = gen.SliceOf(LoadBalancerBackendAddressARMGenerator())
}

func Test_FrontendIPConfigurationPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfigurationPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM, FrontendIPConfigurationPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM runs a test to see if a specific instance of FrontendIPConfigurationPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfigurationPropertiesFormatARM(subject FrontendIPConfigurationPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfigurationPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing - lazily instantiated by
// FrontendIPConfigurationPropertiesFormatARMGenerator()
var frontendIPConfigurationPropertiesFormatARMGenerator gopter.Gen

// FrontendIPConfigurationPropertiesFormatARMGenerator returns a generator of FrontendIPConfigurationPropertiesFormatARM instances for property testing.
// We first initialize frontendIPConfigurationPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfigurationPropertiesFormatARMGenerator() gopter.Gen {
	if frontendIPConfigurationPropertiesFormatARMGenerator != nil {
		return frontendIPConfigurationPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(generators)
	frontendIPConfigurationPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfigurationPropertiesFormatARM{}), generators)

	return frontendIPConfigurationPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfigurationPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubnetARMGenerator())
}

func Test_InboundNatPoolPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatPoolPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM, InboundNatPoolPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM runs a test to see if a specific instance of InboundNatPoolPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatPoolPropertiesFormatARM(subject InboundNatPoolPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatPoolPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatPoolPropertiesFormatARM instances for property testing - lazily instantiated by
// InboundNatPoolPropertiesFormatARMGenerator()
var inboundNatPoolPropertiesFormatARMGenerator gopter.Gen

// InboundNatPoolPropertiesFormatARMGenerator returns a generator of InboundNatPoolPropertiesFormatARM instances for property testing.
// We first initialize inboundNatPoolPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatPoolPropertiesFormatARMGenerator() gopter.Gen {
	if inboundNatPoolPropertiesFormatARMGenerator != nil {
		return inboundNatPoolPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(generators)
	inboundNatPoolPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatPoolPropertiesFormatARM{}), generators)

	return inboundNatPoolPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPortRangeEnd"] = gen.PtrOf(gen.Int())
	gens["FrontendPortRangeStart"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatPoolPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_InboundNatRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRulePropertiesFormatARM, InboundNatRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRulePropertiesFormatARM runs a test to see if a specific instance of InboundNatRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRulePropertiesFormatARM(subject InboundNatRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRulePropertiesFormatARM instances for property testing - lazily instantiated by
// InboundNatRulePropertiesFormatARMGenerator()
var inboundNatRulePropertiesFormatARMGenerator gopter.Gen

// InboundNatRulePropertiesFormatARMGenerator returns a generator of InboundNatRulePropertiesFormatARM instances for property testing.
// We first initialize inboundNatRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InboundNatRulePropertiesFormatARMGenerator() gopter.Gen {
	if inboundNatRulePropertiesFormatARMGenerator != nil {
		return inboundNatRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormatARM(generators)
	inboundNatRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormatARM(generators)
	inboundNatRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(InboundNatRulePropertiesFormatARM{}), generators)

	return inboundNatRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInboundNatRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LoadBalancingRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM, LoadBalancingRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM runs a test to see if a specific instance of LoadBalancingRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingRulePropertiesFormatARM(subject LoadBalancingRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingRulePropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancingRulePropertiesFormatARMGenerator()
var loadBalancingRulePropertiesFormatARMGenerator gopter.Gen

// LoadBalancingRulePropertiesFormatARMGenerator returns a generator of LoadBalancingRulePropertiesFormatARM instances for property testing.
// We first initialize loadBalancingRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingRulePropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancingRulePropertiesFormatARMGenerator != nil {
		return loadBalancingRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(generators)
	loadBalancingRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingRulePropertiesFormatARM{}), generators)

	return loadBalancingRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendPort"] = gen.PtrOf(gen.Int())
	gens["DisableOutboundSnat"] = gen.PtrOf(gen.Bool())
	gens["EnableFloatingIP"] = gen.PtrOf(gen.Bool())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["FrontendPort"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["LoadDistribution"] = gen.PtrOf(gen.OneConstOf(LoadBalancingRulePropertiesFormat_LoadDistribution_Default, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIP, LoadBalancingRulePropertiesFormat_LoadDistribution_SourceIPProtocol))
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(TransportProtocol_All, TransportProtocol_Tcp, TransportProtocol_Udp))
}

// AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Probe"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_OutboundRulePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OutboundRulePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOutboundRulePropertiesFormatARM, OutboundRulePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOutboundRulePropertiesFormatARM runs a test to see if a specific instance of OutboundRulePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOutboundRulePropertiesFormatARM(subject OutboundRulePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OutboundRulePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OutboundRulePropertiesFormatARM instances for property testing - lazily instantiated by
// OutboundRulePropertiesFormatARMGenerator()
var outboundRulePropertiesFormatARMGenerator gopter.Gen

// OutboundRulePropertiesFormatARMGenerator returns a generator of OutboundRulePropertiesFormatARM instances for property testing.
// We first initialize outboundRulePropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OutboundRulePropertiesFormatARMGenerator() gopter.Gen {
	if outboundRulePropertiesFormatARMGenerator != nil {
		return outboundRulePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(generators)
	outboundRulePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(OutboundRulePropertiesFormatARM{}), generators)

	return outboundRulePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["EnableTcpReset"] = gen.PtrOf(gen.Bool())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(OutboundRulePropertiesFormat_Protocol_All, OutboundRulePropertiesFormat_Protocol_Tcp, OutboundRulePropertiesFormat_Protocol_Udp))
}

// AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOutboundRulePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["BackendAddressPool"] = gen.PtrOf(SubResourceARMGenerator())
	gens["FrontendIPConfigurations"] = gen.SliceOf(SubResourceARMGenerator())
}

func Test_ProbePropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProbePropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProbePropertiesFormatARM, ProbePropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProbePropertiesFormatARM runs a test to see if a specific instance of ProbePropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProbePropertiesFormatARM(subject ProbePropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProbePropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProbePropertiesFormatARM instances for property testing - lazily instantiated by
// ProbePropertiesFormatARMGenerator()
var probePropertiesFormatARMGenerator gopter.Gen

// ProbePropertiesFormatARMGenerator returns a generator of ProbePropertiesFormatARM instances for property testing.
func ProbePropertiesFormatARMGenerator() gopter.Gen {
	if probePropertiesFormatARMGenerator != nil {
		return probePropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(generators)
	probePropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(ProbePropertiesFormatARM{}), generators)

	return probePropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForProbePropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProbePropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["NumberOfProbes"] = gen.PtrOf(gen.Int())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(ProbePropertiesFormat_Protocol_Http, ProbePropertiesFormat_Protocol_Https, ProbePropertiesFormat_Protocol_Tcp))
	gens["RequestPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancerBackendAddressARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressARM, LoadBalancerBackendAddressARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressARM runs a test to see if a specific instance of LoadBalancerBackendAddressARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressARM(subject LoadBalancerBackendAddressARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressARMGenerator()
var loadBalancerBackendAddressARMGenerator gopter.Gen

// LoadBalancerBackendAddressARMGenerator returns a generator of LoadBalancerBackendAddressARM instances for property testing.
// We first initialize loadBalancerBackendAddressARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressARMGenerator != nil {
		return loadBalancerBackendAddressARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressARM(generators)
	loadBalancerBackendAddressARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressARM(generators)
	loadBalancerBackendAddressARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressARM{}), generators)

	return loadBalancerBackendAddressARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancerBackendAddressPropertiesFormatARMGenerator())
}

func Test_PublicIPAddressSpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSpecARM, PublicIPAddressSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSpecARM runs a test to see if a specific instance of PublicIPAddressSpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSpecARM(subject PublicIPAddressSpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSpecARM instances for property testing - lazily instantiated by
// PublicIPAddressSpecARMGenerator()
var publicIPAddressSpecARMGenerator gopter.Gen

// PublicIPAddressSpecARMGenerator returns a generator of PublicIPAddressSpecARM instances for property testing.
// We first initialize publicIPAddressSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressSpecARMGenerator() gopter.Gen {
	if publicIPAddressSpecARMGenerator != nil {
		return publicIPAddressSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	publicIPAddressSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM(generators)
	publicIPAddressSpecARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSpecARM{}), generators)

	return publicIPAddressSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(PublicIPAddressPropertiesFormatARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_LoadBalancerBackendAddressPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerBackendAddressPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM, LoadBalancerBackendAddressPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM runs a test to see if a specific instance of LoadBalancerBackendAddressPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerBackendAddressPropertiesFormatARM(subject LoadBalancerBackendAddressPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerBackendAddressPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing - lazily instantiated by
// LoadBalancerBackendAddressPropertiesFormatARMGenerator()
var loadBalancerBackendAddressPropertiesFormatARMGenerator gopter.Gen

// LoadBalancerBackendAddressPropertiesFormatARMGenerator returns a generator of LoadBalancerBackendAddressPropertiesFormatARM instances for property testing.
// We first initialize loadBalancerBackendAddressPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancerBackendAddressPropertiesFormatARMGenerator() gopter.Gen {
	if loadBalancerBackendAddressPropertiesFormatARMGenerator != nil {
		return loadBalancerBackendAddressPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(generators)
	loadBalancerBackendAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerBackendAddressPropertiesFormatARM{}), generators)

	return loadBalancerBackendAddressPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerBackendAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerFrontendIPConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VirtualNetwork"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_PublicIPAddressPropertiesFormatARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressPropertiesFormatARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM, PublicIPAddressPropertiesFormatARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM runs a test to see if a specific instance of PublicIPAddressPropertiesFormatARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressPropertiesFormatARM(subject PublicIPAddressPropertiesFormatARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressPropertiesFormatARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressPropertiesFormatARM instances for property testing - lazily instantiated by
// PublicIPAddressPropertiesFormatARMGenerator()
var publicIPAddressPropertiesFormatARMGenerator gopter.Gen

// PublicIPAddressPropertiesFormatARMGenerator returns a generator of PublicIPAddressPropertiesFormatARM instances for property testing.
// We first initialize publicIPAddressPropertiesFormatARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddressPropertiesFormatARMGenerator() gopter.Gen {
	if publicIPAddressPropertiesFormatARMGenerator != nil {
		return publicIPAddressPropertiesFormatARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	publicIPAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormatARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(generators)
	publicIPAddressPropertiesFormatARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressPropertiesFormatARM{}), generators)

	return publicIPAddressPropertiesFormatARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.OneConstOf(
		PublicIPAddressPropertiesFormat_MigrationPhase_Abort,
		PublicIPAddressPropertiesFormat_MigrationPhase_Commit,
		PublicIPAddressPropertiesFormat_MigrationPhase_Committed,
		PublicIPAddressPropertiesFormat_MigrationPhase_None,
		PublicIPAddressPropertiesFormat_MigrationPhase_Prepare))
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(IPVersion_IPv4, IPVersion_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(IPAllocationMethod_Dynamic, IPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddressPropertiesFormatARM(gens map[string]gopter.Gen) {
	gens["DdosSettings"] = gen.PtrOf(DdosSettingsARMGenerator())
	gens["DnsSettings"] = gen.PtrOf(PublicIPAddressDnsSettingsARMGenerator())
	gens["IpTags"] = gen.SliceOf(IpTagARMGenerator())
	gens["LinkedPublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
	gens["NatGateway"] = gen.PtrOf(NatGatewaySpecARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
	gens["ServicePublicIPAddress"] = gen.PtrOf(PublicIPAddressSpecARMGenerator())
}
