// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20241001

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20241001/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20241001/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,network}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-10-01/networkWatcher.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}
type NetworkWatchersFlowLog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkWatchersFlowLog_Spec   `json:"spec,omitempty"`
	Status            NetworkWatchersFlowLog_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &NetworkWatchersFlowLog{}

// GetConditions returns the conditions of the resource
func (flowLog *NetworkWatchersFlowLog) GetConditions() conditions.Conditions {
	return flowLog.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (flowLog *NetworkWatchersFlowLog) SetConditions(conditions conditions.Conditions) {
	flowLog.Status.Conditions = conditions
}

var _ conversion.Convertible = &NetworkWatchersFlowLog{}

// ConvertFrom populates our NetworkWatchersFlowLog from the provided hub NetworkWatchersFlowLog
func (flowLog *NetworkWatchersFlowLog) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.NetworkWatchersFlowLog)
	if !ok {
		return fmt.Errorf("expected network/v1api20241001/storage/NetworkWatchersFlowLog but received %T instead", hub)
	}

	return flowLog.AssignProperties_From_NetworkWatchersFlowLog(source)
}

// ConvertTo populates the provided hub NetworkWatchersFlowLog from our NetworkWatchersFlowLog
func (flowLog *NetworkWatchersFlowLog) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.NetworkWatchersFlowLog)
	if !ok {
		return fmt.Errorf("expected network/v1api20241001/storage/NetworkWatchersFlowLog but received %T instead", hub)
	}

	return flowLog.AssignProperties_To_NetworkWatchersFlowLog(destination)
}

var _ configmaps.Exporter = &NetworkWatchersFlowLog{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (flowLog *NetworkWatchersFlowLog) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if flowLog.Spec.OperatorSpec == nil {
		return nil
	}
	return flowLog.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &NetworkWatchersFlowLog{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (flowLog *NetworkWatchersFlowLog) SecretDestinationExpressions() []*core.DestinationExpression {
	if flowLog.Spec.OperatorSpec == nil {
		return nil
	}
	return flowLog.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &NetworkWatchersFlowLog{}

// InitializeSpec initializes the spec for this resource from the given status
func (flowLog *NetworkWatchersFlowLog) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*NetworkWatchersFlowLog_STATUS); ok {
		return flowLog.Spec.Initialize_From_NetworkWatchersFlowLog_STATUS(s)
	}

	return fmt.Errorf("expected Status of type NetworkWatchersFlowLog_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &NetworkWatchersFlowLog{}

// AzureName returns the Azure name of the resource
func (flowLog *NetworkWatchersFlowLog) AzureName() string {
	return flowLog.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-10-01"
func (flowLog NetworkWatchersFlowLog) GetAPIVersion() string {
	return "2024-10-01"
}

// GetResourceScope returns the scope of the resource
func (flowLog *NetworkWatchersFlowLog) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (flowLog *NetworkWatchersFlowLog) GetSpec() genruntime.ConvertibleSpec {
	return &flowLog.Spec
}

// GetStatus returns the status of this resource
func (flowLog *NetworkWatchersFlowLog) GetStatus() genruntime.ConvertibleStatus {
	return &flowLog.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (flowLog *NetworkWatchersFlowLog) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/networkWatchers/flowLogs"
func (flowLog *NetworkWatchersFlowLog) GetType() string {
	return "Microsoft.Network/networkWatchers/flowLogs"
}

// NewEmptyStatus returns a new empty (blank) status
func (flowLog *NetworkWatchersFlowLog) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &NetworkWatchersFlowLog_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (flowLog *NetworkWatchersFlowLog) Owner() *genruntime.ResourceReference {
	if flowLog.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(flowLog.Spec)
	return flowLog.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (flowLog *NetworkWatchersFlowLog) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*NetworkWatchersFlowLog_STATUS); ok {
		flowLog.Status = *st
		return nil
	}

	// Convert status to required version
	var st NetworkWatchersFlowLog_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	flowLog.Status = st
	return nil
}

// AssignProperties_From_NetworkWatchersFlowLog populates our NetworkWatchersFlowLog from the provided source NetworkWatchersFlowLog
func (flowLog *NetworkWatchersFlowLog) AssignProperties_From_NetworkWatchersFlowLog(source *storage.NetworkWatchersFlowLog) error {

	// ObjectMeta
	flowLog.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec NetworkWatchersFlowLog_Spec
	err := spec.AssignProperties_From_NetworkWatchersFlowLog_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_NetworkWatchersFlowLog_Spec() to populate field Spec")
	}
	flowLog.Spec = spec

	// Status
	var status NetworkWatchersFlowLog_STATUS
	err = status.AssignProperties_From_NetworkWatchersFlowLog_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_NetworkWatchersFlowLog_STATUS() to populate field Status")
	}
	flowLog.Status = status

	// No error
	return nil
}

// AssignProperties_To_NetworkWatchersFlowLog populates the provided destination NetworkWatchersFlowLog from our NetworkWatchersFlowLog
func (flowLog *NetworkWatchersFlowLog) AssignProperties_To_NetworkWatchersFlowLog(destination *storage.NetworkWatchersFlowLog) error {

	// ObjectMeta
	destination.ObjectMeta = *flowLog.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.NetworkWatchersFlowLog_Spec
	err := flowLog.Spec.AssignProperties_To_NetworkWatchersFlowLog_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_NetworkWatchersFlowLog_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.NetworkWatchersFlowLog_STATUS
	err = flowLog.Status.AssignProperties_To_NetworkWatchersFlowLog_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_NetworkWatchersFlowLog_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (flowLog *NetworkWatchersFlowLog) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: flowLog.Spec.OriginalVersion(),
		Kind:    "NetworkWatchersFlowLog",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-10-01/networkWatcher.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}
type NetworkWatchersFlowLogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkWatchersFlowLog `json:"items"`
}

type NetworkWatchersFlowLog_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Enabled: Flag to enable/disable flow logging.
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledFilteringCriteria: Optional field to filter network traffic logs based on SrcIP, SrcPort, DstIP, DstPort,
	// Protocol, Encryption, Direction and Action. If not specified, all network traffic will be logged.
	EnabledFilteringCriteria *string `json:"enabledFilteringCriteria,omitempty"`

	// FlowAnalyticsConfiguration: Parameters that define the configuration of traffic analytics.
	FlowAnalyticsConfiguration *TrafficAnalyticsProperties `json:"flowAnalyticsConfiguration,omitempty"`

	// Format: Parameters that define the flow log format.
	Format *FlowLogFormatParameters `json:"format,omitempty"`

	// Identity: FlowLog resource Managed Identity
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *NetworkWatchersFlowLogOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a network.azure.com/NetworkWatcher resource
	Owner *genruntime.KnownResourceReference `group:"network.azure.com" json:"owner,omitempty" kind:"NetworkWatcher"`

	// RetentionPolicy: Parameters that define the retention policy for flow log.
	RetentionPolicy *RetentionPolicyParameters `json:"retentionPolicy,omitempty"`

	// +kubebuilder:validation:Required
	// StorageId: ID of the storage account which is used to store the flow log.
	StorageId *string `json:"storageId,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// +kubebuilder:validation:Required
	// TargetResourceReference: ID of network security group to which flow log will be applied.
	TargetResourceReference *genruntime.ResourceReference `armReference:"TargetResourceId" json:"targetResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkWatchersFlowLog_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (flowLog *NetworkWatchersFlowLog_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if flowLog == nil {
		return nil, nil
	}
	result := &arm.NetworkWatchersFlowLog_Spec{}

	// Set property "Identity":
	if flowLog.Identity != nil {
		identity_ARM, err := flowLog.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if flowLog.Location != nil {
		location := *flowLog.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if flowLog.Enabled != nil ||
		flowLog.EnabledFilteringCriteria != nil ||
		flowLog.FlowAnalyticsConfiguration != nil ||
		flowLog.Format != nil ||
		flowLog.RetentionPolicy != nil ||
		flowLog.StorageId != nil ||
		flowLog.TargetResourceReference != nil {
		result.Properties = &arm.FlowLogPropertiesFormat{}
	}
	if flowLog.Enabled != nil {
		enabled := *flowLog.Enabled
		result.Properties.Enabled = &enabled
	}
	if flowLog.EnabledFilteringCriteria != nil {
		enabledFilteringCriteria := *flowLog.EnabledFilteringCriteria
		result.Properties.EnabledFilteringCriteria = &enabledFilteringCriteria
	}
	if flowLog.FlowAnalyticsConfiguration != nil {
		flowAnalyticsConfiguration_ARM, err := flowLog.FlowAnalyticsConfiguration.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		flowAnalyticsConfiguration := *flowAnalyticsConfiguration_ARM.(*arm.TrafficAnalyticsProperties)
		result.Properties.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	}
	if flowLog.Format != nil {
		format_ARM, err := flowLog.Format.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		format := *format_ARM.(*arm.FlowLogFormatParameters)
		result.Properties.Format = &format
	}
	if flowLog.RetentionPolicy != nil {
		retentionPolicy_ARM, err := flowLog.RetentionPolicy.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		retentionPolicy := *retentionPolicy_ARM.(*arm.RetentionPolicyParameters)
		result.Properties.RetentionPolicy = &retentionPolicy
	}
	if flowLog.StorageId != nil {
		storageId := *flowLog.StorageId
		result.Properties.StorageId = &storageId
	}
	if flowLog.TargetResourceReference != nil {
		targetResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*flowLog.TargetResourceReference)
		if err != nil {
			return nil, err
		}
		targetResourceId := targetResourceIdARMID
		result.Properties.TargetResourceId = &targetResourceId
	}

	// Set property "Tags":
	if flowLog.Tags != nil {
		result.Tags = make(map[string]string, len(flowLog.Tags))
		for key, value := range flowLog.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (flowLog *NetworkWatchersFlowLog_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkWatchersFlowLog_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (flowLog *NetworkWatchersFlowLog_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkWatchersFlowLog_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkWatchersFlowLog_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	flowLog.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			flowLog.Enabled = &enabled
		}
	}

	// Set property "EnabledFilteringCriteria":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledFilteringCriteria != nil {
			enabledFilteringCriteria := *typedInput.Properties.EnabledFilteringCriteria
			flowLog.EnabledFilteringCriteria = &enabledFilteringCriteria
		}
	}

	// Set property "FlowAnalyticsConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FlowAnalyticsConfiguration != nil {
			var flowAnalyticsConfiguration1 TrafficAnalyticsProperties
			err := flowAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FlowAnalyticsConfiguration)
			if err != nil {
				return err
			}
			flowAnalyticsConfiguration := flowAnalyticsConfiguration1
			flowLog.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
		}
	}

	// Set property "Format":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Format != nil {
			var format1 FlowLogFormatParameters
			err := format1.PopulateFromARM(owner, *typedInput.Properties.Format)
			if err != nil {
				return err
			}
			format := format1
			flowLog.Format = &format
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		flowLog.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		flowLog.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	flowLog.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "RetentionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetentionPolicy != nil {
			var retentionPolicy1 RetentionPolicyParameters
			err := retentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.RetentionPolicy)
			if err != nil {
				return err
			}
			retentionPolicy := retentionPolicy1
			flowLog.RetentionPolicy = &retentionPolicy
		}
	}

	// Set property "StorageId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageId != nil {
			storageId := *typedInput.Properties.StorageId
			flowLog.StorageId = &storageId
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		flowLog.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			flowLog.Tags[key] = value
		}
	}

	// no assignment for property "TargetResourceReference"

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &NetworkWatchersFlowLog_Spec{}

// ConvertSpecFrom populates our NetworkWatchersFlowLog_Spec from the provided source
func (flowLog *NetworkWatchersFlowLog_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.NetworkWatchersFlowLog_Spec)
	if ok {
		// Populate our instance from source
		return flowLog.AssignProperties_From_NetworkWatchersFlowLog_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.NetworkWatchersFlowLog_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = flowLog.AssignProperties_From_NetworkWatchersFlowLog_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our NetworkWatchersFlowLog_Spec
func (flowLog *NetworkWatchersFlowLog_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.NetworkWatchersFlowLog_Spec)
	if ok {
		// Populate destination from our instance
		return flowLog.AssignProperties_To_NetworkWatchersFlowLog_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.NetworkWatchersFlowLog_Spec{}
	err := flowLog.AssignProperties_To_NetworkWatchersFlowLog_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_NetworkWatchersFlowLog_Spec populates our NetworkWatchersFlowLog_Spec from the provided source NetworkWatchersFlowLog_Spec
func (flowLog *NetworkWatchersFlowLog_Spec) AssignProperties_From_NetworkWatchersFlowLog_Spec(source *storage.NetworkWatchersFlowLog_Spec) error {

	// AzureName
	flowLog.AzureName = source.AzureName

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		flowLog.Enabled = &enabled
	} else {
		flowLog.Enabled = nil
	}

	// EnabledFilteringCriteria
	flowLog.EnabledFilteringCriteria = genruntime.ClonePointerToString(source.EnabledFilteringCriteria)

	// FlowAnalyticsConfiguration
	if source.FlowAnalyticsConfiguration != nil {
		var flowAnalyticsConfiguration TrafficAnalyticsProperties
		err := flowAnalyticsConfiguration.AssignProperties_From_TrafficAnalyticsProperties(source.FlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficAnalyticsProperties() to populate field FlowAnalyticsConfiguration")
		}
		flowLog.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	} else {
		flowLog.FlowAnalyticsConfiguration = nil
	}

	// Format
	if source.Format != nil {
		var format FlowLogFormatParameters
		err := format.AssignProperties_From_FlowLogFormatParameters(source.Format)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FlowLogFormatParameters() to populate field Format")
		}
		flowLog.Format = &format
	} else {
		flowLog.Format = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		flowLog.Identity = &identity
	} else {
		flowLog.Identity = nil
	}

	// Location
	flowLog.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec NetworkWatchersFlowLogOperatorSpec
		err := operatorSpec.AssignProperties_From_NetworkWatchersFlowLogOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkWatchersFlowLogOperatorSpec() to populate field OperatorSpec")
		}
		flowLog.OperatorSpec = &operatorSpec
	} else {
		flowLog.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		flowLog.Owner = &owner
	} else {
		flowLog.Owner = nil
	}

	// RetentionPolicy
	if source.RetentionPolicy != nil {
		var retentionPolicy RetentionPolicyParameters
		err := retentionPolicy.AssignProperties_From_RetentionPolicyParameters(source.RetentionPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionPolicyParameters() to populate field RetentionPolicy")
		}
		flowLog.RetentionPolicy = &retentionPolicy
	} else {
		flowLog.RetentionPolicy = nil
	}

	// StorageId
	flowLog.StorageId = genruntime.ClonePointerToString(source.StorageId)

	// Tags
	flowLog.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceReference
	if source.TargetResourceReference != nil {
		targetResourceReference := source.TargetResourceReference.Copy()
		flowLog.TargetResourceReference = &targetResourceReference
	} else {
		flowLog.TargetResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkWatchersFlowLog_Spec populates the provided destination NetworkWatchersFlowLog_Spec from our NetworkWatchersFlowLog_Spec
func (flowLog *NetworkWatchersFlowLog_Spec) AssignProperties_To_NetworkWatchersFlowLog_Spec(destination *storage.NetworkWatchersFlowLog_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = flowLog.AzureName

	// Enabled
	if flowLog.Enabled != nil {
		enabled := *flowLog.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EnabledFilteringCriteria
	destination.EnabledFilteringCriteria = genruntime.ClonePointerToString(flowLog.EnabledFilteringCriteria)

	// FlowAnalyticsConfiguration
	if flowLog.FlowAnalyticsConfiguration != nil {
		var flowAnalyticsConfiguration storage.TrafficAnalyticsProperties
		err := flowLog.FlowAnalyticsConfiguration.AssignProperties_To_TrafficAnalyticsProperties(&flowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficAnalyticsProperties() to populate field FlowAnalyticsConfiguration")
		}
		destination.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	} else {
		destination.FlowAnalyticsConfiguration = nil
	}

	// Format
	if flowLog.Format != nil {
		var format storage.FlowLogFormatParameters
		err := flowLog.Format.AssignProperties_To_FlowLogFormatParameters(&format)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FlowLogFormatParameters() to populate field Format")
		}
		destination.Format = &format
	} else {
		destination.Format = nil
	}

	// Identity
	if flowLog.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := flowLog.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(flowLog.Location)

	// OperatorSpec
	if flowLog.OperatorSpec != nil {
		var operatorSpec storage.NetworkWatchersFlowLogOperatorSpec
		err := flowLog.OperatorSpec.AssignProperties_To_NetworkWatchersFlowLogOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkWatchersFlowLogOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = flowLog.OriginalVersion()

	// Owner
	if flowLog.Owner != nil {
		owner := flowLog.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RetentionPolicy
	if flowLog.RetentionPolicy != nil {
		var retentionPolicy storage.RetentionPolicyParameters
		err := flowLog.RetentionPolicy.AssignProperties_To_RetentionPolicyParameters(&retentionPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionPolicyParameters() to populate field RetentionPolicy")
		}
		destination.RetentionPolicy = &retentionPolicy
	} else {
		destination.RetentionPolicy = nil
	}

	// StorageId
	destination.StorageId = genruntime.ClonePointerToString(flowLog.StorageId)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(flowLog.Tags)

	// TargetResourceReference
	if flowLog.TargetResourceReference != nil {
		targetResourceReference := flowLog.TargetResourceReference.Copy()
		destination.TargetResourceReference = &targetResourceReference
	} else {
		destination.TargetResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkWatchersFlowLog_STATUS populates our NetworkWatchersFlowLog_Spec from the provided source NetworkWatchersFlowLog_STATUS
func (flowLog *NetworkWatchersFlowLog_Spec) Initialize_From_NetworkWatchersFlowLog_STATUS(source *NetworkWatchersFlowLog_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		flowLog.Enabled = &enabled
	} else {
		flowLog.Enabled = nil
	}

	// EnabledFilteringCriteria
	flowLog.EnabledFilteringCriteria = genruntime.ClonePointerToString(source.EnabledFilteringCriteria)

	// FlowAnalyticsConfiguration
	if source.FlowAnalyticsConfiguration != nil {
		var flowAnalyticsConfiguration TrafficAnalyticsProperties
		err := flowAnalyticsConfiguration.Initialize_From_TrafficAnalyticsProperties_STATUS(source.FlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TrafficAnalyticsProperties_STATUS() to populate field FlowAnalyticsConfiguration")
		}
		flowLog.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	} else {
		flowLog.FlowAnalyticsConfiguration = nil
	}

	// Format
	if source.Format != nil {
		var format FlowLogFormatParameters
		err := format.Initialize_From_FlowLogFormatParameters_STATUS(source.Format)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FlowLogFormatParameters_STATUS() to populate field Format")
		}
		flowLog.Format = &format
	} else {
		flowLog.Format = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		flowLog.Identity = &identity
	} else {
		flowLog.Identity = nil
	}

	// Location
	flowLog.Location = genruntime.ClonePointerToString(source.Location)

	// RetentionPolicy
	if source.RetentionPolicy != nil {
		var retentionPolicy RetentionPolicyParameters
		err := retentionPolicy.Initialize_From_RetentionPolicyParameters_STATUS(source.RetentionPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_RetentionPolicyParameters_STATUS() to populate field RetentionPolicy")
		}
		flowLog.RetentionPolicy = &retentionPolicy
	} else {
		flowLog.RetentionPolicy = nil
	}

	// StorageId
	flowLog.StorageId = genruntime.ClonePointerToString(source.StorageId)

	// Tags
	flowLog.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceReference
	if source.TargetResourceId != nil {
		targetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.TargetResourceId)
		flowLog.TargetResourceReference = &targetResourceReference
	} else {
		flowLog.TargetResourceReference = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (flowLog *NetworkWatchersFlowLog_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (flowLog *NetworkWatchersFlowLog_Spec) SetAzureName(azureName string) {
	flowLog.AzureName = azureName
}

type NetworkWatchersFlowLog_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Enabled: Flag to enable/disable flow logging.
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledFilteringCriteria: Optional field to filter network traffic logs based on SrcIP, SrcPort, DstIP, DstPort,
	// Protocol, Encryption, Direction and Action. If not specified, all network traffic will be logged.
	EnabledFilteringCriteria *string `json:"enabledFilteringCriteria,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FlowAnalyticsConfiguration: Parameters that define the configuration of traffic analytics.
	FlowAnalyticsConfiguration *TrafficAnalyticsProperties_STATUS `json:"flowAnalyticsConfiguration,omitempty"`

	// Format: Parameters that define the flow log format.
	Format *FlowLogFormatParameters_STATUS `json:"format,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Identity: FlowLog resource Managed Identity
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: The provisioning state of the flow log.
	ProvisioningState *ApplicationGatewayProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RetentionPolicy: Parameters that define the retention policy for flow log.
	RetentionPolicy *RetentionPolicyParameters_STATUS `json:"retentionPolicy,omitempty"`

	// StorageId: ID of the storage account which is used to store the flow log.
	StorageId *string `json:"storageId,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TargetResourceGuid: Guid of network security group to which flow log will be applied.
	TargetResourceGuid *string `json:"targetResourceGuid,omitempty"`

	// TargetResourceId: ID of network security group to which flow log will be applied.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &NetworkWatchersFlowLog_STATUS{}

// ConvertStatusFrom populates our NetworkWatchersFlowLog_STATUS from the provided source
func (flowLog *NetworkWatchersFlowLog_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.NetworkWatchersFlowLog_STATUS)
	if ok {
		// Populate our instance from source
		return flowLog.AssignProperties_From_NetworkWatchersFlowLog_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.NetworkWatchersFlowLog_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = flowLog.AssignProperties_From_NetworkWatchersFlowLog_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our NetworkWatchersFlowLog_STATUS
func (flowLog *NetworkWatchersFlowLog_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.NetworkWatchersFlowLog_STATUS)
	if ok {
		// Populate destination from our instance
		return flowLog.AssignProperties_To_NetworkWatchersFlowLog_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.NetworkWatchersFlowLog_STATUS{}
	err := flowLog.AssignProperties_To_NetworkWatchersFlowLog_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &NetworkWatchersFlowLog_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (flowLog *NetworkWatchersFlowLog_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkWatchersFlowLog_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (flowLog *NetworkWatchersFlowLog_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkWatchersFlowLog_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkWatchersFlowLog_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			flowLog.Enabled = &enabled
		}
	}

	// Set property "EnabledFilteringCriteria":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledFilteringCriteria != nil {
			enabledFilteringCriteria := *typedInput.Properties.EnabledFilteringCriteria
			flowLog.EnabledFilteringCriteria = &enabledFilteringCriteria
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		flowLog.Etag = &etag
	}

	// Set property "FlowAnalyticsConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FlowAnalyticsConfiguration != nil {
			var flowAnalyticsConfiguration1 TrafficAnalyticsProperties_STATUS
			err := flowAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FlowAnalyticsConfiguration)
			if err != nil {
				return err
			}
			flowAnalyticsConfiguration := flowAnalyticsConfiguration1
			flowLog.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
		}
	}

	// Set property "Format":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Format != nil {
			var format1 FlowLogFormatParameters_STATUS
			err := format1.PopulateFromARM(owner, *typedInput.Properties.Format)
			if err != nil {
				return err
			}
			format := format1
			flowLog.Format = &format
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		flowLog.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		flowLog.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		flowLog.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		flowLog.Name = &name
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ApplicationGatewayProvisioningState_STATUS(temp)
			flowLog.ProvisioningState = &provisioningState
		}
	}

	// Set property "RetentionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RetentionPolicy != nil {
			var retentionPolicy1 RetentionPolicyParameters_STATUS
			err := retentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.RetentionPolicy)
			if err != nil {
				return err
			}
			retentionPolicy := retentionPolicy1
			flowLog.RetentionPolicy = &retentionPolicy
		}
	}

	// Set property "StorageId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageId != nil {
			storageId := *typedInput.Properties.StorageId
			flowLog.StorageId = &storageId
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		flowLog.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			flowLog.Tags[key] = value
		}
	}

	// Set property "TargetResourceGuid":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceGuid != nil {
			targetResourceGuid := *typedInput.Properties.TargetResourceGuid
			flowLog.TargetResourceGuid = &targetResourceGuid
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			flowLog.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		flowLog.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkWatchersFlowLog_STATUS populates our NetworkWatchersFlowLog_STATUS from the provided source NetworkWatchersFlowLog_STATUS
func (flowLog *NetworkWatchersFlowLog_STATUS) AssignProperties_From_NetworkWatchersFlowLog_STATUS(source *storage.NetworkWatchersFlowLog_STATUS) error {

	// Conditions
	flowLog.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		flowLog.Enabled = &enabled
	} else {
		flowLog.Enabled = nil
	}

	// EnabledFilteringCriteria
	flowLog.EnabledFilteringCriteria = genruntime.ClonePointerToString(source.EnabledFilteringCriteria)

	// Etag
	flowLog.Etag = genruntime.ClonePointerToString(source.Etag)

	// FlowAnalyticsConfiguration
	if source.FlowAnalyticsConfiguration != nil {
		var flowAnalyticsConfiguration TrafficAnalyticsProperties_STATUS
		err := flowAnalyticsConfiguration.AssignProperties_From_TrafficAnalyticsProperties_STATUS(source.FlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficAnalyticsProperties_STATUS() to populate field FlowAnalyticsConfiguration")
		}
		flowLog.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	} else {
		flowLog.FlowAnalyticsConfiguration = nil
	}

	// Format
	if source.Format != nil {
		var format FlowLogFormatParameters_STATUS
		err := format.AssignProperties_From_FlowLogFormatParameters_STATUS(source.Format)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FlowLogFormatParameters_STATUS() to populate field Format")
		}
		flowLog.Format = &format
	} else {
		flowLog.Format = nil
	}

	// Id
	flowLog.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		flowLog.Identity = &identity
	} else {
		flowLog.Identity = nil
	}

	// Location
	flowLog.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	flowLog.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, applicationGatewayProvisioningState_STATUS_Values)
		flowLog.ProvisioningState = &provisioningStateTemp
	} else {
		flowLog.ProvisioningState = nil
	}

	// RetentionPolicy
	if source.RetentionPolicy != nil {
		var retentionPolicy RetentionPolicyParameters_STATUS
		err := retentionPolicy.AssignProperties_From_RetentionPolicyParameters_STATUS(source.RetentionPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RetentionPolicyParameters_STATUS() to populate field RetentionPolicy")
		}
		flowLog.RetentionPolicy = &retentionPolicy
	} else {
		flowLog.RetentionPolicy = nil
	}

	// StorageId
	flowLog.StorageId = genruntime.ClonePointerToString(source.StorageId)

	// Tags
	flowLog.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceGuid
	flowLog.TargetResourceGuid = genruntime.ClonePointerToString(source.TargetResourceGuid)

	// TargetResourceId
	flowLog.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	flowLog.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_NetworkWatchersFlowLog_STATUS populates the provided destination NetworkWatchersFlowLog_STATUS from our NetworkWatchersFlowLog_STATUS
func (flowLog *NetworkWatchersFlowLog_STATUS) AssignProperties_To_NetworkWatchersFlowLog_STATUS(destination *storage.NetworkWatchersFlowLog_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(flowLog.Conditions)

	// Enabled
	if flowLog.Enabled != nil {
		enabled := *flowLog.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EnabledFilteringCriteria
	destination.EnabledFilteringCriteria = genruntime.ClonePointerToString(flowLog.EnabledFilteringCriteria)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(flowLog.Etag)

	// FlowAnalyticsConfiguration
	if flowLog.FlowAnalyticsConfiguration != nil {
		var flowAnalyticsConfiguration storage.TrafficAnalyticsProperties_STATUS
		err := flowLog.FlowAnalyticsConfiguration.AssignProperties_To_TrafficAnalyticsProperties_STATUS(&flowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficAnalyticsProperties_STATUS() to populate field FlowAnalyticsConfiguration")
		}
		destination.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
	} else {
		destination.FlowAnalyticsConfiguration = nil
	}

	// Format
	if flowLog.Format != nil {
		var format storage.FlowLogFormatParameters_STATUS
		err := flowLog.Format.AssignProperties_To_FlowLogFormatParameters_STATUS(&format)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FlowLogFormatParameters_STATUS() to populate field Format")
		}
		destination.Format = &format
	} else {
		destination.Format = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(flowLog.Id)

	// Identity
	if flowLog.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := flowLog.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(flowLog.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(flowLog.Name)

	// ProvisioningState
	if flowLog.ProvisioningState != nil {
		provisioningState := string(*flowLog.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RetentionPolicy
	if flowLog.RetentionPolicy != nil {
		var retentionPolicy storage.RetentionPolicyParameters_STATUS
		err := flowLog.RetentionPolicy.AssignProperties_To_RetentionPolicyParameters_STATUS(&retentionPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RetentionPolicyParameters_STATUS() to populate field RetentionPolicy")
		}
		destination.RetentionPolicy = &retentionPolicy
	} else {
		destination.RetentionPolicy = nil
	}

	// StorageId
	destination.StorageId = genruntime.ClonePointerToString(flowLog.StorageId)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(flowLog.Tags)

	// TargetResourceGuid
	destination.TargetResourceGuid = genruntime.ClonePointerToString(flowLog.TargetResourceGuid)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(flowLog.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(flowLog.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The current provisioning state.
type ApplicationGatewayProvisioningState_STATUS string

const (
	ApplicationGatewayProvisioningState_STATUS_Deleting  = ApplicationGatewayProvisioningState_STATUS("Deleting")
	ApplicationGatewayProvisioningState_STATUS_Failed    = ApplicationGatewayProvisioningState_STATUS("Failed")
	ApplicationGatewayProvisioningState_STATUS_Succeeded = ApplicationGatewayProvisioningState_STATUS("Succeeded")
	ApplicationGatewayProvisioningState_STATUS_Updating  = ApplicationGatewayProvisioningState_STATUS("Updating")
)

// Mapping from string to ApplicationGatewayProvisioningState_STATUS
var applicationGatewayProvisioningState_STATUS_Values = map[string]ApplicationGatewayProvisioningState_STATUS{
	"deleting":  ApplicationGatewayProvisioningState_STATUS_Deleting,
	"failed":    ApplicationGatewayProvisioningState_STATUS_Failed,
	"succeeded": ApplicationGatewayProvisioningState_STATUS_Succeeded,
	"updating":  ApplicationGatewayProvisioningState_STATUS_Updating,
}

// Parameters that define the flow log format.
type FlowLogFormatParameters struct {
	// Type: The file type of flow log.
	Type *FlowLogFormatParameters_Type `json:"type,omitempty"`

	// Version: The version (revision) of the flow log.
	Version *int `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &FlowLogFormatParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *FlowLogFormatParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.FlowLogFormatParameters{}

	// Set property "Type":
	if parameters.Type != nil {
		var temp string
		temp = string(*parameters.Type)
		typeVar := arm.FlowLogFormatParameters_Type(temp)
		result.Type = &typeVar
	}

	// Set property "Version":
	if parameters.Version != nil {
		version := *parameters.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *FlowLogFormatParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FlowLogFormatParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *FlowLogFormatParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FlowLogFormatParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FlowLogFormatParameters, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := FlowLogFormatParameters_Type(temp)
		parameters.Type = &typeVar
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		parameters.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_FlowLogFormatParameters populates our FlowLogFormatParameters from the provided source FlowLogFormatParameters
func (parameters *FlowLogFormatParameters) AssignProperties_From_FlowLogFormatParameters(source *storage.FlowLogFormatParameters) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, flowLogFormatParameters_Type_Values)
		parameters.Type = &typeTemp
	} else {
		parameters.Type = nil
	}

	// Version
	parameters.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// AssignProperties_To_FlowLogFormatParameters populates the provided destination FlowLogFormatParameters from our FlowLogFormatParameters
func (parameters *FlowLogFormatParameters) AssignProperties_To_FlowLogFormatParameters(destination *storage.FlowLogFormatParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameters.Type != nil {
		typeVar := string(*parameters.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToInt(parameters.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FlowLogFormatParameters_STATUS populates our FlowLogFormatParameters from the provided source FlowLogFormatParameters_STATUS
func (parameters *FlowLogFormatParameters) Initialize_From_FlowLogFormatParameters_STATUS(source *FlowLogFormatParameters_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), flowLogFormatParameters_Type_Values)
		parameters.Type = &typeVar
	} else {
		parameters.Type = nil
	}

	// Version
	parameters.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// Parameters that define the flow log format.
type FlowLogFormatParameters_STATUS struct {
	// Type: The file type of flow log.
	Type *FlowLogFormatParameters_Type_STATUS `json:"type,omitempty"`

	// Version: The version (revision) of the flow log.
	Version *int `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &FlowLogFormatParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *FlowLogFormatParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FlowLogFormatParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *FlowLogFormatParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FlowLogFormatParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FlowLogFormatParameters_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := FlowLogFormatParameters_Type_STATUS(temp)
		parameters.Type = &typeVar
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		parameters.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_FlowLogFormatParameters_STATUS populates our FlowLogFormatParameters_STATUS from the provided source FlowLogFormatParameters_STATUS
func (parameters *FlowLogFormatParameters_STATUS) AssignProperties_From_FlowLogFormatParameters_STATUS(source *storage.FlowLogFormatParameters_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, flowLogFormatParameters_Type_STATUS_Values)
		parameters.Type = &typeTemp
	} else {
		parameters.Type = nil
	}

	// Version
	parameters.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// AssignProperties_To_FlowLogFormatParameters_STATUS populates the provided destination FlowLogFormatParameters_STATUS from our FlowLogFormatParameters_STATUS
func (parameters *FlowLogFormatParameters_STATUS) AssignProperties_To_FlowLogFormatParameters_STATUS(destination *storage.FlowLogFormatParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameters.Type != nil {
		typeVar := string(*parameters.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToInt(parameters.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity struct {
	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The principal id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			var userAssignedIdentity ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type NetworkWatchersFlowLogOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_NetworkWatchersFlowLogOperatorSpec populates our NetworkWatchersFlowLogOperatorSpec from the provided source NetworkWatchersFlowLogOperatorSpec
func (operator *NetworkWatchersFlowLogOperatorSpec) AssignProperties_From_NetworkWatchersFlowLogOperatorSpec(source *storage.NetworkWatchersFlowLogOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkWatchersFlowLogOperatorSpec populates the provided destination NetworkWatchersFlowLogOperatorSpec from our NetworkWatchersFlowLogOperatorSpec
func (operator *NetworkWatchersFlowLogOperatorSpec) AssignProperties_To_NetworkWatchersFlowLogOperatorSpec(destination *storage.NetworkWatchersFlowLogOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters that define the retention policy for flow log.
type RetentionPolicyParameters struct {
	// Days: Number of days to retain flow log records.
	Days *int `json:"days,omitempty"`

	// Enabled: Flag to enable/disable retention.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &RetentionPolicyParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RetentionPolicyParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RetentionPolicyParameters{}

	// Set property "Days":
	if parameters.Days != nil {
		days := *parameters.Days
		result.Days = &days
	}

	// Set property "Enabled":
	if parameters.Enabled != nil {
		enabled := *parameters.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RetentionPolicyParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RetentionPolicyParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RetentionPolicyParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RetentionPolicyParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RetentionPolicyParameters, got %T", armInput)
	}

	// Set property "Days":
	if typedInput.Days != nil {
		days := *typedInput.Days
		parameters.Days = &days
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		parameters.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionPolicyParameters populates our RetentionPolicyParameters from the provided source RetentionPolicyParameters
func (parameters *RetentionPolicyParameters) AssignProperties_From_RetentionPolicyParameters(source *storage.RetentionPolicyParameters) error {

	// Days
	parameters.Days = genruntime.ClonePointerToInt(source.Days)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		parameters.Enabled = &enabled
	} else {
		parameters.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RetentionPolicyParameters populates the provided destination RetentionPolicyParameters from our RetentionPolicyParameters
func (parameters *RetentionPolicyParameters) AssignProperties_To_RetentionPolicyParameters(destination *storage.RetentionPolicyParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	destination.Days = genruntime.ClonePointerToInt(parameters.Days)

	// Enabled
	if parameters.Enabled != nil {
		enabled := *parameters.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RetentionPolicyParameters_STATUS populates our RetentionPolicyParameters from the provided source RetentionPolicyParameters_STATUS
func (parameters *RetentionPolicyParameters) Initialize_From_RetentionPolicyParameters_STATUS(source *RetentionPolicyParameters_STATUS) error {

	// Days
	parameters.Days = genruntime.ClonePointerToInt(source.Days)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		parameters.Enabled = &enabled
	} else {
		parameters.Enabled = nil
	}

	// No error
	return nil
}

// Parameters that define the retention policy for flow log.
type RetentionPolicyParameters_STATUS struct {
	// Days: Number of days to retain flow log records.
	Days *int `json:"days,omitempty"`

	// Enabled: Flag to enable/disable retention.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &RetentionPolicyParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RetentionPolicyParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RetentionPolicyParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RetentionPolicyParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RetentionPolicyParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RetentionPolicyParameters_STATUS, got %T", armInput)
	}

	// Set property "Days":
	if typedInput.Days != nil {
		days := *typedInput.Days
		parameters.Days = &days
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		parameters.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_RetentionPolicyParameters_STATUS populates our RetentionPolicyParameters_STATUS from the provided source RetentionPolicyParameters_STATUS
func (parameters *RetentionPolicyParameters_STATUS) AssignProperties_From_RetentionPolicyParameters_STATUS(source *storage.RetentionPolicyParameters_STATUS) error {

	// Days
	parameters.Days = genruntime.ClonePointerToInt(source.Days)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		parameters.Enabled = &enabled
	} else {
		parameters.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RetentionPolicyParameters_STATUS populates the provided destination RetentionPolicyParameters_STATUS from our RetentionPolicyParameters_STATUS
func (parameters *RetentionPolicyParameters_STATUS) AssignProperties_To_RetentionPolicyParameters_STATUS(destination *storage.RetentionPolicyParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	destination.Days = genruntime.ClonePointerToInt(parameters.Days)

	// Enabled
	if parameters.Enabled != nil {
		enabled := *parameters.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters that define the configuration of traffic analytics.
type TrafficAnalyticsProperties struct {
	// NetworkWatcherFlowAnalyticsConfiguration: Parameters that define the configuration of traffic analytics.
	NetworkWatcherFlowAnalyticsConfiguration *TrafficAnalyticsConfigurationProperties `json:"networkWatcherFlowAnalyticsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficAnalyticsProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *TrafficAnalyticsProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.TrafficAnalyticsProperties{}

	// Set property "NetworkWatcherFlowAnalyticsConfiguration":
	if properties.NetworkWatcherFlowAnalyticsConfiguration != nil {
		networkWatcherFlowAnalyticsConfiguration_ARM, err := properties.NetworkWatcherFlowAnalyticsConfiguration.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkWatcherFlowAnalyticsConfiguration := *networkWatcherFlowAnalyticsConfiguration_ARM.(*arm.TrafficAnalyticsConfigurationProperties)
		result.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *TrafficAnalyticsProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficAnalyticsProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *TrafficAnalyticsProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficAnalyticsProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficAnalyticsProperties, got %T", armInput)
	}

	// Set property "NetworkWatcherFlowAnalyticsConfiguration":
	if typedInput.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration1 TrafficAnalyticsConfigurationProperties
		err := networkWatcherFlowAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.NetworkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return err
		}
		networkWatcherFlowAnalyticsConfiguration := networkWatcherFlowAnalyticsConfiguration1
		properties.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficAnalyticsProperties populates our TrafficAnalyticsProperties from the provided source TrafficAnalyticsProperties
func (properties *TrafficAnalyticsProperties) AssignProperties_From_TrafficAnalyticsProperties(source *storage.TrafficAnalyticsProperties) error {

	// NetworkWatcherFlowAnalyticsConfiguration
	if source.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration TrafficAnalyticsConfigurationProperties
		err := networkWatcherFlowAnalyticsConfiguration.AssignProperties_From_TrafficAnalyticsConfigurationProperties(source.NetworkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficAnalyticsConfigurationProperties() to populate field NetworkWatcherFlowAnalyticsConfiguration")
		}
		properties.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	} else {
		properties.NetworkWatcherFlowAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficAnalyticsProperties populates the provided destination TrafficAnalyticsProperties from our TrafficAnalyticsProperties
func (properties *TrafficAnalyticsProperties) AssignProperties_To_TrafficAnalyticsProperties(destination *storage.TrafficAnalyticsProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkWatcherFlowAnalyticsConfiguration
	if properties.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration storage.TrafficAnalyticsConfigurationProperties
		err := properties.NetworkWatcherFlowAnalyticsConfiguration.AssignProperties_To_TrafficAnalyticsConfigurationProperties(&networkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficAnalyticsConfigurationProperties() to populate field NetworkWatcherFlowAnalyticsConfiguration")
		}
		destination.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	} else {
		destination.NetworkWatcherFlowAnalyticsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficAnalyticsProperties_STATUS populates our TrafficAnalyticsProperties from the provided source TrafficAnalyticsProperties_STATUS
func (properties *TrafficAnalyticsProperties) Initialize_From_TrafficAnalyticsProperties_STATUS(source *TrafficAnalyticsProperties_STATUS) error {

	// NetworkWatcherFlowAnalyticsConfiguration
	if source.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration TrafficAnalyticsConfigurationProperties
		err := networkWatcherFlowAnalyticsConfiguration.Initialize_From_TrafficAnalyticsConfigurationProperties_STATUS(source.NetworkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TrafficAnalyticsConfigurationProperties_STATUS() to populate field NetworkWatcherFlowAnalyticsConfiguration")
		}
		properties.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	} else {
		properties.NetworkWatcherFlowAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// Parameters that define the configuration of traffic analytics.
type TrafficAnalyticsProperties_STATUS struct {
	// NetworkWatcherFlowAnalyticsConfiguration: Parameters that define the configuration of traffic analytics.
	NetworkWatcherFlowAnalyticsConfiguration *TrafficAnalyticsConfigurationProperties_STATUS `json:"networkWatcherFlowAnalyticsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &TrafficAnalyticsProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *TrafficAnalyticsProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficAnalyticsProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *TrafficAnalyticsProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficAnalyticsProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficAnalyticsProperties_STATUS, got %T", armInput)
	}

	// Set property "NetworkWatcherFlowAnalyticsConfiguration":
	if typedInput.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration1 TrafficAnalyticsConfigurationProperties_STATUS
		err := networkWatcherFlowAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.NetworkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return err
		}
		networkWatcherFlowAnalyticsConfiguration := networkWatcherFlowAnalyticsConfiguration1
		properties.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficAnalyticsProperties_STATUS populates our TrafficAnalyticsProperties_STATUS from the provided source TrafficAnalyticsProperties_STATUS
func (properties *TrafficAnalyticsProperties_STATUS) AssignProperties_From_TrafficAnalyticsProperties_STATUS(source *storage.TrafficAnalyticsProperties_STATUS) error {

	// NetworkWatcherFlowAnalyticsConfiguration
	if source.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration TrafficAnalyticsConfigurationProperties_STATUS
		err := networkWatcherFlowAnalyticsConfiguration.AssignProperties_From_TrafficAnalyticsConfigurationProperties_STATUS(source.NetworkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficAnalyticsConfigurationProperties_STATUS() to populate field NetworkWatcherFlowAnalyticsConfiguration")
		}
		properties.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	} else {
		properties.NetworkWatcherFlowAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficAnalyticsProperties_STATUS populates the provided destination TrafficAnalyticsProperties_STATUS from our TrafficAnalyticsProperties_STATUS
func (properties *TrafficAnalyticsProperties_STATUS) AssignProperties_To_TrafficAnalyticsProperties_STATUS(destination *storage.TrafficAnalyticsProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkWatcherFlowAnalyticsConfiguration
	if properties.NetworkWatcherFlowAnalyticsConfiguration != nil {
		var networkWatcherFlowAnalyticsConfiguration storage.TrafficAnalyticsConfigurationProperties_STATUS
		err := properties.NetworkWatcherFlowAnalyticsConfiguration.AssignProperties_To_TrafficAnalyticsConfigurationProperties_STATUS(&networkWatcherFlowAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficAnalyticsConfigurationProperties_STATUS() to populate field NetworkWatcherFlowAnalyticsConfiguration")
		}
		destination.NetworkWatcherFlowAnalyticsConfiguration = &networkWatcherFlowAnalyticsConfiguration
	} else {
		destination.NetworkWatcherFlowAnalyticsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"JSON"}
type FlowLogFormatParameters_Type string

const FlowLogFormatParameters_Type_JSON = FlowLogFormatParameters_Type("JSON")

// Mapping from string to FlowLogFormatParameters_Type
var flowLogFormatParameters_Type_Values = map[string]FlowLogFormatParameters_Type{
	"json": FlowLogFormatParameters_Type_JSON,
}

type FlowLogFormatParameters_Type_STATUS string

const FlowLogFormatParameters_Type_STATUS_JSON = FlowLogFormatParameters_Type_STATUS("JSON")

// Mapping from string to FlowLogFormatParameters_Type_STATUS
var flowLogFormatParameters_Type_STATUS_Values = map[string]FlowLogFormatParameters_Type_STATUS{
	"json": FlowLogFormatParameters_Type_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ManagedServiceIdentity_Type string

const (
	ManagedServiceIdentity_Type_None                       = ManagedServiceIdentity_Type("None")
	ManagedServiceIdentity_Type_SystemAssigned             = ManagedServiceIdentity_Type("SystemAssigned")
	ManagedServiceIdentity_Type_SystemAssignedUserAssigned = ManagedServiceIdentity_Type("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_UserAssigned               = ManagedServiceIdentity_Type("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type
var managedServiceIdentity_Type_Values = map[string]ManagedServiceIdentity_Type{
	"none":                         ManagedServiceIdentity_Type_None,
	"systemassigned":               ManagedServiceIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_UserAssigned,
}

type ManagedServiceIdentity_Type_STATUS string

const (
	ManagedServiceIdentity_Type_STATUS_None                       = ManagedServiceIdentity_Type_STATUS("None")
	ManagedServiceIdentity_Type_STATUS_SystemAssigned             = ManagedServiceIdentity_Type_STATUS("SystemAssigned")
	ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_STATUS_UserAssigned               = ManagedServiceIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type_STATUS
var managedServiceIdentity_Type_STATUS_Values = map[string]ManagedServiceIdentity_Type_STATUS{
	"none":                         ManagedServiceIdentity_Type_STATUS_None,
	"systemassigned":               ManagedServiceIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_STATUS_UserAssigned,
}

type ManagedServiceIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates our ManagedServiceIdentity_UserAssignedIdentities_STATUS from the provided source ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(source *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates the provided destination ManagedServiceIdentity_UserAssignedIdentities_STATUS from our ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(destination *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters that define the configuration of traffic analytics.
type TrafficAnalyticsConfigurationProperties struct {
	// Enabled: Flag to enable/disable traffic analytics.
	Enabled *bool `json:"enabled,omitempty"`

	// TrafficAnalyticsInterval: The interval in minutes which would decide how frequently TA service should do flow analytics.
	TrafficAnalyticsInterval *int `json:"trafficAnalyticsInterval,omitempty"`

	// WorkspaceId: The resource guid of the attached workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceRegion: The location of the attached workspace.
	WorkspaceRegion *string `json:"workspaceRegion,omitempty"`

	// WorkspaceResourceReference: Resource Id of the attached workspace.
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficAnalyticsConfigurationProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *TrafficAnalyticsConfigurationProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.TrafficAnalyticsConfigurationProperties{}

	// Set property "Enabled":
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}

	// Set property "TrafficAnalyticsInterval":
	if properties.TrafficAnalyticsInterval != nil {
		trafficAnalyticsInterval := *properties.TrafficAnalyticsInterval
		result.TrafficAnalyticsInterval = &trafficAnalyticsInterval
	}

	// Set property "WorkspaceId":
	if properties.WorkspaceId != nil {
		workspaceId := *properties.WorkspaceId
		result.WorkspaceId = &workspaceId
	}

	// Set property "WorkspaceRegion":
	if properties.WorkspaceRegion != nil {
		workspaceRegion := *properties.WorkspaceRegion
		result.WorkspaceRegion = &workspaceRegion
	}

	// Set property "WorkspaceResourceId":
	if properties.WorkspaceResourceReference != nil {
		workspaceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.WorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		workspaceResourceReference := workspaceResourceReferenceARMID
		result.WorkspaceResourceId = &workspaceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *TrafficAnalyticsConfigurationProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficAnalyticsConfigurationProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *TrafficAnalyticsConfigurationProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficAnalyticsConfigurationProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficAnalyticsConfigurationProperties, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "TrafficAnalyticsInterval":
	if typedInput.TrafficAnalyticsInterval != nil {
		trafficAnalyticsInterval := *typedInput.TrafficAnalyticsInterval
		properties.TrafficAnalyticsInterval = &trafficAnalyticsInterval
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		properties.WorkspaceId = &workspaceId
	}

	// Set property "WorkspaceRegion":
	if typedInput.WorkspaceRegion != nil {
		workspaceRegion := *typedInput.WorkspaceRegion
		properties.WorkspaceRegion = &workspaceRegion
	}

	// no assignment for property "WorkspaceResourceReference"

	// No error
	return nil
}

// AssignProperties_From_TrafficAnalyticsConfigurationProperties populates our TrafficAnalyticsConfigurationProperties from the provided source TrafficAnalyticsConfigurationProperties
func (properties *TrafficAnalyticsConfigurationProperties) AssignProperties_From_TrafficAnalyticsConfigurationProperties(source *storage.TrafficAnalyticsConfigurationProperties) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// TrafficAnalyticsInterval
	properties.TrafficAnalyticsInterval = genruntime.ClonePointerToInt(source.TrafficAnalyticsInterval)

	// WorkspaceId
	properties.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceRegion
	properties.WorkspaceRegion = genruntime.ClonePointerToString(source.WorkspaceRegion)

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		properties.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		properties.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficAnalyticsConfigurationProperties populates the provided destination TrafficAnalyticsConfigurationProperties from our TrafficAnalyticsConfigurationProperties
func (properties *TrafficAnalyticsConfigurationProperties) AssignProperties_To_TrafficAnalyticsConfigurationProperties(destination *storage.TrafficAnalyticsConfigurationProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TrafficAnalyticsInterval
	destination.TrafficAnalyticsInterval = genruntime.ClonePointerToInt(properties.TrafficAnalyticsInterval)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(properties.WorkspaceId)

	// WorkspaceRegion
	destination.WorkspaceRegion = genruntime.ClonePointerToString(properties.WorkspaceRegion)

	// WorkspaceResourceReference
	if properties.WorkspaceResourceReference != nil {
		workspaceResourceReference := properties.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficAnalyticsConfigurationProperties_STATUS populates our TrafficAnalyticsConfigurationProperties from the provided source TrafficAnalyticsConfigurationProperties_STATUS
func (properties *TrafficAnalyticsConfigurationProperties) Initialize_From_TrafficAnalyticsConfigurationProperties_STATUS(source *TrafficAnalyticsConfigurationProperties_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// TrafficAnalyticsInterval
	properties.TrafficAnalyticsInterval = genruntime.ClonePointerToInt(source.TrafficAnalyticsInterval)

	// WorkspaceId
	properties.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceRegion
	properties.WorkspaceRegion = genruntime.ClonePointerToString(source.WorkspaceRegion)

	// WorkspaceResourceReference
	if source.WorkspaceResourceId != nil {
		workspaceResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.WorkspaceResourceId)
		properties.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		properties.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// Parameters that define the configuration of traffic analytics.
type TrafficAnalyticsConfigurationProperties_STATUS struct {
	// Enabled: Flag to enable/disable traffic analytics.
	Enabled *bool `json:"enabled,omitempty"`

	// TrafficAnalyticsInterval: The interval in minutes which would decide how frequently TA service should do flow analytics.
	TrafficAnalyticsInterval *int `json:"trafficAnalyticsInterval,omitempty"`

	// WorkspaceId: The resource guid of the attached workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceRegion: The location of the attached workspace.
	WorkspaceRegion *string `json:"workspaceRegion,omitempty"`

	// WorkspaceResourceId: Resource Id of the attached workspace.
	WorkspaceResourceId *string `json:"workspaceResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &TrafficAnalyticsConfigurationProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *TrafficAnalyticsConfigurationProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficAnalyticsConfigurationProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *TrafficAnalyticsConfigurationProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficAnalyticsConfigurationProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficAnalyticsConfigurationProperties_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "TrafficAnalyticsInterval":
	if typedInput.TrafficAnalyticsInterval != nil {
		trafficAnalyticsInterval := *typedInput.TrafficAnalyticsInterval
		properties.TrafficAnalyticsInterval = &trafficAnalyticsInterval
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		properties.WorkspaceId = &workspaceId
	}

	// Set property "WorkspaceRegion":
	if typedInput.WorkspaceRegion != nil {
		workspaceRegion := *typedInput.WorkspaceRegion
		properties.WorkspaceRegion = &workspaceRegion
	}

	// Set property "WorkspaceResourceId":
	if typedInput.WorkspaceResourceId != nil {
		workspaceResourceId := *typedInput.WorkspaceResourceId
		properties.WorkspaceResourceId = &workspaceResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficAnalyticsConfigurationProperties_STATUS populates our TrafficAnalyticsConfigurationProperties_STATUS from the provided source TrafficAnalyticsConfigurationProperties_STATUS
func (properties *TrafficAnalyticsConfigurationProperties_STATUS) AssignProperties_From_TrafficAnalyticsConfigurationProperties_STATUS(source *storage.TrafficAnalyticsConfigurationProperties_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// TrafficAnalyticsInterval
	properties.TrafficAnalyticsInterval = genruntime.ClonePointerToInt(source.TrafficAnalyticsInterval)

	// WorkspaceId
	properties.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceRegion
	properties.WorkspaceRegion = genruntime.ClonePointerToString(source.WorkspaceRegion)

	// WorkspaceResourceId
	properties.WorkspaceResourceId = genruntime.ClonePointerToString(source.WorkspaceResourceId)

	// No error
	return nil
}

// AssignProperties_To_TrafficAnalyticsConfigurationProperties_STATUS populates the provided destination TrafficAnalyticsConfigurationProperties_STATUS from our TrafficAnalyticsConfigurationProperties_STATUS
func (properties *TrafficAnalyticsConfigurationProperties_STATUS) AssignProperties_To_TrafficAnalyticsConfigurationProperties_STATUS(destination *storage.TrafficAnalyticsConfigurationProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TrafficAnalyticsInterval
	destination.TrafficAnalyticsInterval = genruntime.ClonePointerToInt(properties.TrafficAnalyticsInterval)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(properties.WorkspaceId)

	// WorkspaceRegion
	destination.WorkspaceRegion = genruntime.ClonePointerToString(properties.WorkspaceRegion)

	// WorkspaceResourceId
	destination.WorkspaceResourceId = genruntime.ClonePointerToString(properties.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&NetworkWatchersFlowLog{}, &NetworkWatchersFlowLogList{})
}
