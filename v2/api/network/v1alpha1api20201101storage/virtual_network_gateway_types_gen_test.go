// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualNetworkGateway_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateway via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGateway, VirtualNetworkGatewayGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGateway runs a test to see if a specific instance of VirtualNetworkGateway round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGateway(subject VirtualNetworkGateway) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateway
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateway instances for property testing - lazily instantiated by
//VirtualNetworkGatewayGenerator()
var virtualNetworkGatewayGenerator gopter.Gen

// VirtualNetworkGatewayGenerator returns a generator of VirtualNetworkGateway instances for property testing.
func VirtualNetworkGatewayGenerator() gopter.Gen {
	if virtualNetworkGatewayGenerator != nil {
		return virtualNetworkGatewayGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualNetworkGateway(generators)
	virtualNetworkGatewayGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway{}), generators)

	return virtualNetworkGatewayGenerator
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGateway is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGateway(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualNetworkGatewaysSPECGenerator()
	gens["Status"] = VirtualNetworkGatewayStatusGenerator()
}

func Test_VirtualNetworkGateway_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateway_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayStatus, VirtualNetworkGatewayStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayStatus runs a test to see if a specific instance of VirtualNetworkGateway_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayStatus(subject VirtualNetworkGateway_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateway_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateway_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewayStatusGenerator()
var virtualNetworkGatewayStatusGenerator gopter.Gen

// VirtualNetworkGatewayStatusGenerator returns a generator of VirtualNetworkGateway_Status instances for property testing.
// We first initialize virtualNetworkGatewayStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayStatusGenerator() gopter.Gen {
	if virtualNetworkGatewayStatusGenerator != nil {
		return virtualNetworkGatewayStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	virtualNetworkGatewayStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus(generators)
	virtualNetworkGatewayStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateway_Status{}), generators)

	return virtualNetworkGatewayStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayStatus(gens map[string]gopter.Gen) {
	gens["ActiveActive"] = gen.PtrOf(gen.Bool())
	gens["EnableBgp"] = gen.PtrOf(gen.Bool())
	gens["EnableDnsForwarding"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateIpAddress"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayType"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["InboundDnsForwardingEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VNetExtendedLocationResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VpnGatewayGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["VpnType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayStatus(gens map[string]gopter.Gen) {
	gens["BgpSettings"] = gen.PtrOf(BgpSettingsStatusGenerator())
	gens["CustomRoutes"] = gen.PtrOf(AddressSpaceStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["GatewayDefaultSite"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualNetworkGatewayIPConfigurationStatusGenerator())
	gens["Sku"] = gen.PtrOf(VirtualNetworkGatewaySkuStatusGenerator())
	gens["VpnClientConfiguration"] = gen.PtrOf(VpnClientConfigurationStatusGenerator())
}

func Test_VirtualNetworkGateways_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGateways_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaysSPEC, VirtualNetworkGatewaysSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaysSPEC runs a test to see if a specific instance of VirtualNetworkGateways_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaysSPEC(subject VirtualNetworkGateways_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGateways_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGateways_SPEC instances for property testing - lazily instantiated by
//VirtualNetworkGatewaysSPECGenerator()
var virtualNetworkGatewaysSPECGenerator gopter.Gen

// VirtualNetworkGatewaysSPECGenerator returns a generator of VirtualNetworkGateways_SPEC instances for property testing.
// We first initialize virtualNetworkGatewaysSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewaysSPECGenerator() gopter.Gen {
	if virtualNetworkGatewaysSPECGenerator != nil {
		return virtualNetworkGatewaysSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	virtualNetworkGatewaysSPECGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateways_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC(generators)
	virtualNetworkGatewaysSPECGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGateways_SPEC{}), generators)

	return virtualNetworkGatewaysSPECGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaysSPEC(gens map[string]gopter.Gen) {
	gens["ActiveActive"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["EnableBgp"] = gen.PtrOf(gen.Bool())
	gens["EnableDnsForwarding"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateIpAddress"] = gen.PtrOf(gen.Bool())
	gens["GatewayType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["VpnGatewayGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["VpnType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewaysSPEC(gens map[string]gopter.Gen) {
	gens["BgpSettings"] = gen.PtrOf(BgpSettingsSpecGenerator())
	gens["CustomRoutes"] = gen.PtrOf(AddressSpaceSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["GatewayDefaultSite"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualNetworkGatewayIPConfigurationSpecGenerator())
	gens["Sku"] = gen.PtrOf(VirtualNetworkGatewaySkuSpecGenerator())
	gens["VpnClientConfiguration"] = gen.PtrOf(VpnClientConfigurationSpecGenerator())
}

func Test_BgpSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BgpSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBgpSettingsSpec, BgpSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBgpSettingsSpec runs a test to see if a specific instance of BgpSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBgpSettingsSpec(subject BgpSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BgpSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BgpSettings_Spec instances for property testing - lazily instantiated by BgpSettingsSpecGenerator()
var bgpSettingsSpecGenerator gopter.Gen

// BgpSettingsSpecGenerator returns a generator of BgpSettings_Spec instances for property testing.
// We first initialize bgpSettingsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BgpSettingsSpecGenerator() gopter.Gen {
	if bgpSettingsSpecGenerator != nil {
		return bgpSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsSpec(generators)
	bgpSettingsSpecGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsSpec(generators)
	AddRelatedPropertyGeneratorsForBgpSettingsSpec(generators)
	bgpSettingsSpecGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Spec{}), generators)

	return bgpSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForBgpSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBgpSettingsSpec(gens map[string]gopter.Gen) {
	gens["Asn"] = gen.PtrOf(gen.UInt32())
	gens["BgpPeeringAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PeerWeight"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForBgpSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBgpSettingsSpec(gens map[string]gopter.Gen) {
	gens["BgpPeeringAddresses"] = gen.SliceOf(IPConfigurationBgpPeeringAddressSpecGenerator())
}

func Test_BgpSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BgpSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBgpSettingsStatus, BgpSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBgpSettingsStatus runs a test to see if a specific instance of BgpSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBgpSettingsStatus(subject BgpSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BgpSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BgpSettings_Status instances for property testing - lazily instantiated by BgpSettingsStatusGenerator()
var bgpSettingsStatusGenerator gopter.Gen

// BgpSettingsStatusGenerator returns a generator of BgpSettings_Status instances for property testing.
// We first initialize bgpSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BgpSettingsStatusGenerator() gopter.Gen {
	if bgpSettingsStatusGenerator != nil {
		return bgpSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsStatus(generators)
	bgpSettingsStatusGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBgpSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForBgpSettingsStatus(generators)
	bgpSettingsStatusGenerator = gen.Struct(reflect.TypeOf(BgpSettings_Status{}), generators)

	return bgpSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForBgpSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBgpSettingsStatus(gens map[string]gopter.Gen) {
	gens["Asn"] = gen.PtrOf(gen.UInt32())
	gens["BgpPeeringAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PeerWeight"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForBgpSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBgpSettingsStatus(gens map[string]gopter.Gen) {
	gens["BgpPeeringAddresses"] = gen.SliceOf(IPConfigurationBgpPeeringAddressStatusGenerator())
}

func Test_VirtualNetworkGatewayIPConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewayIPConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec, VirtualNetworkGatewayIPConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec runs a test to see if a specific instance of VirtualNetworkGatewayIPConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationSpec(subject VirtualNetworkGatewayIPConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewayIPConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewayIPConfiguration_Spec instances for property testing - lazily instantiated by
//VirtualNetworkGatewayIPConfigurationSpecGenerator()
var virtualNetworkGatewayIPConfigurationSpecGenerator gopter.Gen

// VirtualNetworkGatewayIPConfigurationSpecGenerator returns a generator of VirtualNetworkGatewayIPConfiguration_Spec instances for property testing.
// We first initialize virtualNetworkGatewayIPConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayIPConfigurationSpecGenerator() gopter.Gen {
	if virtualNetworkGatewayIPConfigurationSpecGenerator != nil {
		return virtualNetworkGatewayIPConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	virtualNetworkGatewayIPConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(generators)
	virtualNetworkGatewayIPConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Spec{}), generators)

	return virtualNetworkGatewayIPConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_VirtualNetworkGatewayIPConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewayIPConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus, VirtualNetworkGatewayIPConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus runs a test to see if a specific instance of VirtualNetworkGatewayIPConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewayIPConfigurationStatus(subject VirtualNetworkGatewayIPConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewayIPConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewayIPConfiguration_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewayIPConfigurationStatusGenerator()
var virtualNetworkGatewayIPConfigurationStatusGenerator gopter.Gen

// VirtualNetworkGatewayIPConfigurationStatusGenerator returns a generator of VirtualNetworkGatewayIPConfiguration_Status instances for property testing.
// We first initialize virtualNetworkGatewayIPConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkGatewayIPConfigurationStatusGenerator() gopter.Gen {
	if virtualNetworkGatewayIPConfigurationStatusGenerator != nil {
		return virtualNetworkGatewayIPConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	virtualNetworkGatewayIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(generators)
	virtualNetworkGatewayIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewayIPConfiguration_Status{}), generators)

	return virtualNetworkGatewayIPConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkGatewayIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualNetworkGatewaySku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewaySku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec, VirtualNetworkGatewaySkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec runs a test to see if a specific instance of VirtualNetworkGatewaySku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaySkuSpec(subject VirtualNetworkGatewaySku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewaySku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewaySku_Spec instances for property testing - lazily instantiated by
//VirtualNetworkGatewaySkuSpecGenerator()
var virtualNetworkGatewaySkuSpecGenerator gopter.Gen

// VirtualNetworkGatewaySkuSpecGenerator returns a generator of VirtualNetworkGatewaySku_Spec instances for property testing.
func VirtualNetworkGatewaySkuSpecGenerator() gopter.Gen {
	if virtualNetworkGatewaySkuSpecGenerator != nil {
		return virtualNetworkGatewaySkuSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec(generators)
	virtualNetworkGatewaySkuSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewaySku_Spec{}), generators)

	return virtualNetworkGatewaySkuSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkGatewaySku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkGatewaySku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus, VirtualNetworkGatewaySkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus runs a test to see if a specific instance of VirtualNetworkGatewaySku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkGatewaySkuStatus(subject VirtualNetworkGatewaySku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkGatewaySku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkGatewaySku_Status instances for property testing - lazily instantiated by
//VirtualNetworkGatewaySkuStatusGenerator()
var virtualNetworkGatewaySkuStatusGenerator gopter.Gen

// VirtualNetworkGatewaySkuStatusGenerator returns a generator of VirtualNetworkGatewaySku_Status instances for property testing.
func VirtualNetworkGatewaySkuStatusGenerator() gopter.Gen {
	if virtualNetworkGatewaySkuStatusGenerator != nil {
		return virtualNetworkGatewaySkuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus(generators)
	virtualNetworkGatewaySkuStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkGatewaySku_Status{}), generators)

	return virtualNetworkGatewaySkuStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkGatewaySkuStatus(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientConfigurationSpec, VpnClientConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientConfigurationSpec runs a test to see if a specific instance of VpnClientConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientConfigurationSpec(subject VpnClientConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientConfiguration_Spec instances for property testing - lazily instantiated by
//VpnClientConfigurationSpecGenerator()
var vpnClientConfigurationSpecGenerator gopter.Gen

// VpnClientConfigurationSpecGenerator returns a generator of VpnClientConfiguration_Spec instances for property testing.
// We first initialize vpnClientConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VpnClientConfigurationSpecGenerator() gopter.Gen {
	if vpnClientConfigurationSpecGenerator != nil {
		return vpnClientConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	vpnClientConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec(generators)
	vpnClientConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Spec{}), generators)

	return vpnClientConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientConfigurationSpec(gens map[string]gopter.Gen) {
	gens["AadAudience"] = gen.PtrOf(gen.AlphaString())
	gens["AadIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenant"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
	gens["VpnAuthenticationTypes"] = gen.SliceOf(gen.AlphaString())
	gens["VpnClientProtocols"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVpnClientConfigurationSpec(gens map[string]gopter.Gen) {
	gens["RadiusServers"] = gen.SliceOf(RadiusServerSpecGenerator())
	gens["VpnClientAddressPool"] = gen.PtrOf(AddressSpaceSpecGenerator())
	gens["VpnClientIpsecPolicies"] = gen.SliceOf(IpsecPolicySpecGenerator())
	gens["VpnClientRevokedCertificates"] = gen.SliceOf(VpnClientRevokedCertificateSpecGenerator())
	gens["VpnClientRootCertificates"] = gen.SliceOf(VpnClientRootCertificateSpecGenerator())
}

func Test_VpnClientConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientConfigurationStatus, VpnClientConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientConfigurationStatus runs a test to see if a specific instance of VpnClientConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientConfigurationStatus(subject VpnClientConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientConfiguration_Status instances for property testing - lazily instantiated by
//VpnClientConfigurationStatusGenerator()
var vpnClientConfigurationStatusGenerator gopter.Gen

// VpnClientConfigurationStatusGenerator returns a generator of VpnClientConfiguration_Status instances for property testing.
// We first initialize vpnClientConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VpnClientConfigurationStatusGenerator() gopter.Gen {
	if vpnClientConfigurationStatusGenerator != nil {
		return vpnClientConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	vpnClientConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus(generators)
	vpnClientConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientConfiguration_Status{}), generators)

	return vpnClientConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientConfigurationStatus(gens map[string]gopter.Gen) {
	gens["AadAudience"] = gen.PtrOf(gen.AlphaString())
	gens["AadIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["AadTenant"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
	gens["VpnAuthenticationTypes"] = gen.SliceOf(gen.AlphaString())
	gens["VpnClientProtocols"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVpnClientConfigurationStatus(gens map[string]gopter.Gen) {
	gens["RadiusServers"] = gen.SliceOf(RadiusServerStatusGenerator())
	gens["VpnClientAddressPool"] = gen.PtrOf(AddressSpaceStatusGenerator())
	gens["VpnClientIpsecPolicies"] = gen.SliceOf(IpsecPolicyStatusGenerator())
	gens["VpnClientRevokedCertificates"] = gen.SliceOf(VpnClientRevokedCertificateStatusGenerator())
	gens["VpnClientRootCertificates"] = gen.SliceOf(VpnClientRootCertificateStatusGenerator())
}

func Test_IPConfigurationBgpPeeringAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationBgpPeeringAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec, IPConfigurationBgpPeeringAddressSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec runs a test to see if a specific instance of IPConfigurationBgpPeeringAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationBgpPeeringAddressSpec(subject IPConfigurationBgpPeeringAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationBgpPeeringAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationBgpPeeringAddress_Spec instances for property testing - lazily instantiated by
//IPConfigurationBgpPeeringAddressSpecGenerator()
var ipConfigurationBgpPeeringAddressSpecGenerator gopter.Gen

// IPConfigurationBgpPeeringAddressSpecGenerator returns a generator of IPConfigurationBgpPeeringAddress_Spec instances for property testing.
func IPConfigurationBgpPeeringAddressSpecGenerator() gopter.Gen {
	if ipConfigurationBgpPeeringAddressSpecGenerator != nil {
		return ipConfigurationBgpPeeringAddressSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec(generators)
	ipConfigurationBgpPeeringAddressSpecGenerator = gen.Struct(reflect.TypeOf(IPConfigurationBgpPeeringAddress_Spec{}), generators)

	return ipConfigurationBgpPeeringAddressSpecGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressSpec(gens map[string]gopter.Gen) {
	gens["CustomBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["IpconfigurationId"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPConfigurationBgpPeeringAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPConfigurationBgpPeeringAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus, IPConfigurationBgpPeeringAddressStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus runs a test to see if a specific instance of IPConfigurationBgpPeeringAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIPConfigurationBgpPeeringAddressStatus(subject IPConfigurationBgpPeeringAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPConfigurationBgpPeeringAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPConfigurationBgpPeeringAddress_Status instances for property testing - lazily instantiated by
//IPConfigurationBgpPeeringAddressStatusGenerator()
var ipConfigurationBgpPeeringAddressStatusGenerator gopter.Gen

// IPConfigurationBgpPeeringAddressStatusGenerator returns a generator of IPConfigurationBgpPeeringAddress_Status instances for property testing.
func IPConfigurationBgpPeeringAddressStatusGenerator() gopter.Gen {
	if ipConfigurationBgpPeeringAddressStatusGenerator != nil {
		return ipConfigurationBgpPeeringAddressStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus(generators)
	ipConfigurationBgpPeeringAddressStatusGenerator = gen.Struct(reflect.TypeOf(IPConfigurationBgpPeeringAddress_Status{}), generators)

	return ipConfigurationBgpPeeringAddressStatusGenerator
}

// AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPConfigurationBgpPeeringAddressStatus(gens map[string]gopter.Gen) {
	gens["CustomBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DefaultBgpIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["IpconfigurationId"] = gen.PtrOf(gen.AlphaString())
	gens["TunnelIpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_IpsecPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpsecPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpsecPolicySpec, IpsecPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpsecPolicySpec runs a test to see if a specific instance of IpsecPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpsecPolicySpec(subject IpsecPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpsecPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpsecPolicy_Spec instances for property testing - lazily instantiated by IpsecPolicySpecGenerator()
var ipsecPolicySpecGenerator gopter.Gen

// IpsecPolicySpecGenerator returns a generator of IpsecPolicy_Spec instances for property testing.
func IpsecPolicySpecGenerator() gopter.Gen {
	if ipsecPolicySpecGenerator != nil {
		return ipsecPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpsecPolicySpec(generators)
	ipsecPolicySpecGenerator = gen.Struct(reflect.TypeOf(IpsecPolicy_Spec{}), generators)

	return ipsecPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForIpsecPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpsecPolicySpec(gens map[string]gopter.Gen) {
	gens["DhGroup"] = gen.PtrOf(gen.AlphaString())
	gens["IkeEncryption"] = gen.PtrOf(gen.AlphaString())
	gens["IkeIntegrity"] = gen.PtrOf(gen.AlphaString())
	gens["IpsecEncryption"] = gen.PtrOf(gen.AlphaString())
	gens["IpsecIntegrity"] = gen.PtrOf(gen.AlphaString())
	gens["PfsGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SaDataSizeKilobytes"] = gen.PtrOf(gen.Int())
	gens["SaLifeTimeSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpsecPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpsecPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpsecPolicyStatus, IpsecPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpsecPolicyStatus runs a test to see if a specific instance of IpsecPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpsecPolicyStatus(subject IpsecPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpsecPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpsecPolicy_Status instances for property testing - lazily instantiated by IpsecPolicyStatusGenerator()
var ipsecPolicyStatusGenerator gopter.Gen

// IpsecPolicyStatusGenerator returns a generator of IpsecPolicy_Status instances for property testing.
func IpsecPolicyStatusGenerator() gopter.Gen {
	if ipsecPolicyStatusGenerator != nil {
		return ipsecPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpsecPolicyStatus(generators)
	ipsecPolicyStatusGenerator = gen.Struct(reflect.TypeOf(IpsecPolicy_Status{}), generators)

	return ipsecPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpsecPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpsecPolicyStatus(gens map[string]gopter.Gen) {
	gens["DhGroup"] = gen.PtrOf(gen.AlphaString())
	gens["IkeEncryption"] = gen.PtrOf(gen.AlphaString())
	gens["IkeIntegrity"] = gen.PtrOf(gen.AlphaString())
	gens["IpsecEncryption"] = gen.PtrOf(gen.AlphaString())
	gens["IpsecIntegrity"] = gen.PtrOf(gen.AlphaString())
	gens["PfsGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SaDataSizeKilobytes"] = gen.PtrOf(gen.Int())
	gens["SaLifeTimeSeconds"] = gen.PtrOf(gen.Int())
}

func Test_RadiusServer_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RadiusServer_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRadiusServerSpec, RadiusServerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRadiusServerSpec runs a test to see if a specific instance of RadiusServer_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRadiusServerSpec(subject RadiusServer_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RadiusServer_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RadiusServer_Spec instances for property testing - lazily instantiated by RadiusServerSpecGenerator()
var radiusServerSpecGenerator gopter.Gen

// RadiusServerSpecGenerator returns a generator of RadiusServer_Spec instances for property testing.
func RadiusServerSpecGenerator() gopter.Gen {
	if radiusServerSpecGenerator != nil {
		return radiusServerSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRadiusServerSpec(generators)
	radiusServerSpecGenerator = gen.Struct(reflect.TypeOf(RadiusServer_Spec{}), generators)

	return radiusServerSpecGenerator
}

// AddIndependentPropertyGeneratorsForRadiusServerSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRadiusServerSpec(gens map[string]gopter.Gen) {
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerScore"] = gen.PtrOf(gen.Int())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_RadiusServer_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RadiusServer_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRadiusServerStatus, RadiusServerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRadiusServerStatus runs a test to see if a specific instance of RadiusServer_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRadiusServerStatus(subject RadiusServer_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RadiusServer_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RadiusServer_Status instances for property testing - lazily instantiated by RadiusServerStatusGenerator()
var radiusServerStatusGenerator gopter.Gen

// RadiusServerStatusGenerator returns a generator of RadiusServer_Status instances for property testing.
func RadiusServerStatusGenerator() gopter.Gen {
	if radiusServerStatusGenerator != nil {
		return radiusServerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRadiusServerStatus(generators)
	radiusServerStatusGenerator = gen.Struct(reflect.TypeOf(RadiusServer_Status{}), generators)

	return radiusServerStatusGenerator
}

// AddIndependentPropertyGeneratorsForRadiusServerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRadiusServerStatus(gens map[string]gopter.Gen) {
	gens["RadiusServerAddress"] = gen.PtrOf(gen.AlphaString())
	gens["RadiusServerScore"] = gen.PtrOf(gen.Int())
	gens["RadiusServerSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRevokedCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRevokedCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRevokedCertificateSpec, VpnClientRevokedCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRevokedCertificateSpec runs a test to see if a specific instance of VpnClientRevokedCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRevokedCertificateSpec(subject VpnClientRevokedCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRevokedCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRevokedCertificate_Spec instances for property testing - lazily instantiated by
//VpnClientRevokedCertificateSpecGenerator()
var vpnClientRevokedCertificateSpecGenerator gopter.Gen

// VpnClientRevokedCertificateSpecGenerator returns a generator of VpnClientRevokedCertificate_Spec instances for property testing.
func VpnClientRevokedCertificateSpecGenerator() gopter.Gen {
	if vpnClientRevokedCertificateSpecGenerator != nil {
		return vpnClientRevokedCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec(generators)
	vpnClientRevokedCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientRevokedCertificate_Spec{}), generators)

	return vpnClientRevokedCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRevokedCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRevokedCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRevokedCertificateStatus, VpnClientRevokedCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRevokedCertificateStatus runs a test to see if a specific instance of VpnClientRevokedCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRevokedCertificateStatus(subject VpnClientRevokedCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRevokedCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRevokedCertificate_Status instances for property testing - lazily instantiated by
//VpnClientRevokedCertificateStatusGenerator()
var vpnClientRevokedCertificateStatusGenerator gopter.Gen

// VpnClientRevokedCertificateStatusGenerator returns a generator of VpnClientRevokedCertificate_Status instances for property testing.
func VpnClientRevokedCertificateStatusGenerator() gopter.Gen {
	if vpnClientRevokedCertificateStatusGenerator != nil {
		return vpnClientRevokedCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus(generators)
	vpnClientRevokedCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientRevokedCertificate_Status{}), generators)

	return vpnClientRevokedCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRevokedCertificateStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRootCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRootCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRootCertificateSpec, VpnClientRootCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRootCertificateSpec runs a test to see if a specific instance of VpnClientRootCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRootCertificateSpec(subject VpnClientRootCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRootCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRootCertificate_Spec instances for property testing - lazily instantiated by
//VpnClientRootCertificateSpecGenerator()
var vpnClientRootCertificateSpecGenerator gopter.Gen

// VpnClientRootCertificateSpecGenerator returns a generator of VpnClientRootCertificate_Spec instances for property testing.
func VpnClientRootCertificateSpecGenerator() gopter.Gen {
	if vpnClientRootCertificateSpecGenerator != nil {
		return vpnClientRootCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec(generators)
	vpnClientRootCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VpnClientRootCertificate_Spec{}), generators)

	return vpnClientRootCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRootCertificateSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PublicCertData"] = gen.PtrOf(gen.AlphaString())
}

func Test_VpnClientRootCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VpnClientRootCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVpnClientRootCertificateStatus, VpnClientRootCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVpnClientRootCertificateStatus runs a test to see if a specific instance of VpnClientRootCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVpnClientRootCertificateStatus(subject VpnClientRootCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VpnClientRootCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VpnClientRootCertificate_Status instances for property testing - lazily instantiated by
//VpnClientRootCertificateStatusGenerator()
var vpnClientRootCertificateStatusGenerator gopter.Gen

// VpnClientRootCertificateStatusGenerator returns a generator of VpnClientRootCertificate_Status instances for property testing.
func VpnClientRootCertificateStatusGenerator() gopter.Gen {
	if vpnClientRootCertificateStatusGenerator != nil {
		return vpnClientRootCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus(generators)
	vpnClientRootCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VpnClientRootCertificate_Status{}), generators)

	return vpnClientRootCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVpnClientRootCertificateStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicCertData"] = gen.PtrOf(gen.AlphaString())
}
