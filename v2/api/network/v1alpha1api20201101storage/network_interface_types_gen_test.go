// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface, NetworkInterfaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface runs a test to see if a specific instance of NetworkInterface round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface(subject NetworkInterface) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface instances for property testing - lazily instantiated by NetworkInterfaceGenerator()
var networkInterfaceGenerator gopter.Gen

// NetworkInterfaceGenerator returns a generator of NetworkInterface instances for property testing.
func NetworkInterfaceGenerator() gopter.Gen {
	if networkInterfaceGenerator != nil {
		return networkInterfaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkInterface(generators)
	networkInterfaceGenerator = gen.Struct(reflect.TypeOf(NetworkInterface{}), generators)

	return networkInterfaceGenerator
}

// AddRelatedPropertyGeneratorsForNetworkInterface is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface(gens map[string]gopter.Gen) {
	gens["Spec"] = NetworkInterfaces_SPECGenerator()
	gens["Status"] = NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()
}

func Test_NetworkInterface_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded, NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterface_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterface_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterface_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterface_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterface_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterface_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterface_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["HostedWorkloads"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MacAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NicType"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettings_StatusGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["TapConfigurations"] = gen.SliceOf(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["VirtualMachine"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_NetworkInterfaces_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaces_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaces_SPEC, NetworkInterfaces_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaces_SPEC runs a test to see if a specific instance of NetworkInterfaces_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaces_SPEC(subject NetworkInterfaces_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaces_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaces_SPEC instances for property testing - lazily instantiated by
//NetworkInterfaces_SPECGenerator()
var networkInterfaces_specGenerator gopter.Gen

// NetworkInterfaces_SPECGenerator returns a generator of NetworkInterfaces_SPEC instances for property testing.
// We first initialize networkInterfaces_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaces_SPECGenerator() gopter.Gen {
	if networkInterfaces_specGenerator != nil {
		return networkInterfaces_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaces_SPEC(generators)
	networkInterfaces_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaces_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaces_SPEC(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaces_SPEC(generators)
	networkInterfaces_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaces_SPEC{}), generators)

	return networkInterfaces_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaces_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaces_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.AlphaString())
	gens["NicType"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaces_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaces_SPEC(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettings_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkService_SpecGenerator())
}

func Test_NetworkInterfaceDnsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettings_Spec, NetworkInterfaceDnsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettings_Spec runs a test to see if a specific instance of NetworkInterfaceDnsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettings_Spec(subject NetworkInterfaceDnsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettings_SpecGenerator()
var networkInterfaceDnsSettings_specGenerator gopter.Gen

// NetworkInterfaceDnsSettings_SpecGenerator returns a generator of NetworkInterfaceDnsSettings_Spec instances for property testing.
func NetworkInterfaceDnsSettings_SpecGenerator() gopter.Gen {
	if networkInterfaceDnsSettings_specGenerator != nil {
		return networkInterfaceDnsSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Spec(generators)
	networkInterfaceDnsSettings_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_Spec{}), generators)

	return networkInterfaceDnsSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Spec(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status, NetworkInterfaceDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status runs a test to see if a specific instance of NetworkInterfaceDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status(subject NetworkInterfaceDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_Status instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettings_StatusGenerator()
var networkInterfaceDnsSettings_statusGenerator gopter.Gen

// NetworkInterfaceDnsSettings_StatusGenerator returns a generator of NetworkInterfaceDnsSettings_Status instances for property testing.
func NetworkInterfaceDnsSettings_StatusGenerator() gopter.Gen {
	if networkInterfaceDnsSettings_statusGenerator != nil {
		return networkInterfaceDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status(generators)
	networkInterfaceDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_Status{}), generators)

	return networkInterfaceDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["AppliedDnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["InternalDomainNameSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["InternalFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing
//- lazily instantiated by NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPool_SpecGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroup_SpecGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded, NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateLinkConnectionProperties"] = gen.PtrOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded, NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded, NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(subject NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(generators)
	networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(generators)
	networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkSecurityGroup_spec_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkSecurityGroup_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SecurityRules"] = gen.SliceOf(SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(subject NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded, PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(subject PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
}

func Test_PrivateLinkService_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkService_Spec, PrivateLinkService_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkService_Spec runs a test to see if a specific instance of PrivateLinkService_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkService_Spec(subject PrivateLinkService_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Spec instances for property testing - lazily instantiated by
//PrivateLinkService_SpecGenerator()
var privateLinkService_specGenerator gopter.Gen

// PrivateLinkService_SpecGenerator returns a generator of PrivateLinkService_Spec instances for property testing.
// We first initialize privateLinkService_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkService_SpecGenerator() gopter.Gen {
	if privateLinkService_specGenerator != nil {
		return privateLinkService_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(generators)
	privateLinkService_specGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkService_Spec(generators)
	privateLinkService_specGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Spec{}), generators)

	return privateLinkService_specGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkService_Spec(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkService_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkService_Spec(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSet_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSet_SpecGenerator())
}

func Test_PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded, PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(subject PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var privateLinkService_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateLinkService_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateLinkService_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return privateLinkService_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkService_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkService_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateLinkService_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Status, SubResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Status runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Status(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResource_StatusGenerator()
var subResource_statusGenerator gopter.Gen

// SubResource_StatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResource_StatusGenerator() gopter.Gen {
	if subResource_statusGenerator != nil {
		return subResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_Status(generators)
	subResource_statusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddressPool_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Spec, ApplicationGatewayBackendAddressPool_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Spec runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Spec(subject ApplicationGatewayBackendAddressPool_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_Spec instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddressPool_SpecGenerator()
var applicationGatewayBackendAddressPool_specGenerator gopter.Gen

// ApplicationGatewayBackendAddressPool_SpecGenerator returns a generator of ApplicationGatewayBackendAddressPool_Spec instances for property testing.
// We first initialize applicationGatewayBackendAddressPool_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPool_SpecGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPool_specGenerator != nil {
		return applicationGatewayBackendAddressPool_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec(generators)
	applicationGatewayBackendAddressPool_specGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec(generators)
	applicationGatewayBackendAddressPool_specGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Spec{}), generators)

	return applicationGatewayBackendAddressPool_specGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Spec(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddress_SpecGenerator())
}

func Test_ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(subject ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by
//ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddress_StatusGenerator())
}

func Test_ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(subject ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing -
//lazily instantiated by ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded, BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded(subject BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var backendAddressPool_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func BackendAddressPool_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPool_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return backendAddressPool_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	backendAddressPool_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return backendAddressPool_spec_networkInterface_subResourceEmbeddedGenerator
}

func Test_BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(subject BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded, FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(subject FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing -
//lazily instantiated by FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return frontendIPConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_SpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded, InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Spec_NetworkInterface_SubResourceEmbedded(subject InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var inboundNatRule_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func InboundNatRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRule_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return inboundNatRule_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	inboundNatRule_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return inboundNatRule_spec_networkInterface_subResourceEmbeddedGenerator
}

func Test_InboundNatRule_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded, InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(subject InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(generators)
	inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status, NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status runs a test to see if a specific instance of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(subject NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing -
//lazily instantiated by NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator()
var networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator gopter.Gen

// NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator returns a generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing.
func NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator != nil {
		return networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(generators)
	networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status{}), generators)

	return networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMemberName"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded, PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(subject PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateLinkServiceIpConfiguration_spec_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceIpConfiguration_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Subnet"] = gen.PtrOf(Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded, PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(subject PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_StatusGenerator())
}

func Test_ResourceSet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSet_Spec, ResourceSet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSet_Spec runs a test to see if a specific instance of ResourceSet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSet_Spec(subject ResourceSet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSet_Spec instances for property testing - lazily instantiated by ResourceSet_SpecGenerator()
var resourceSet_specGenerator gopter.Gen

// ResourceSet_SpecGenerator returns a generator of ResourceSet_Spec instances for property testing.
func ResourceSet_SpecGenerator() gopter.Gen {
	if resourceSet_specGenerator != nil {
		return resourceSet_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSet_Spec(generators)
	resourceSet_specGenerator = gen.Struct(reflect.TypeOf(ResourceSet_Spec{}), generators)

	return resourceSet_specGenerator
}

// AddIndependentPropertyGeneratorsForResourceSet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSet_Spec(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_SecurityRule_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityRule_Spec_NetworkInterface_SubResourceEmbedded, SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityRule_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityRule_Spec_NetworkInterface_SubResourceEmbedded(subject SecurityRule_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityRule_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var securityRule_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of SecurityRule_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func SecurityRule_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if securityRule_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return securityRule_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	securityRule_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SecurityRule_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return securityRule_spec_networkInterface_subResourceEmbeddedGenerator
}

func Test_Subnet_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Spec_NetworkInterface_SubResourceEmbedded, Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of Subnet_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Spec_NetworkInterface_SubResourceEmbedded(subject Subnet_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily instantiated by
//Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var subnet_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of Subnet_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
func Subnet_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return subnet_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	subnet_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return subnet_spec_networkInterface_subResourceEmbeddedGenerator
}

func Test_Subnet_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded, Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of Subnet_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded(subject Subnet_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily instantiated
//by Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var subnet_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return subnet_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded(generators)
	subnet_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return subnet_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded, VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(subject VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedGenerator()
var virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator != nil {
		return virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(generators)
	virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(generators)
	virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded{}), generators)

	return virtualNetworkTap_spec_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DestinationPort"] = gen.PtrOf(gen.Int())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualNetworkTap_Spec_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DestinationLoadBalancerFrontEndIPConfiguration"] = gen.PtrOf(FrontendIPConfiguration_Spec_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded, VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(subject VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(generators)
	virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddress_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddress_Spec, ApplicationGatewayBackendAddress_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddress_Spec runs a test to see if a specific instance of ApplicationGatewayBackendAddress_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddress_Spec(subject ApplicationGatewayBackendAddress_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_Spec instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddress_SpecGenerator()
var applicationGatewayBackendAddress_specGenerator gopter.Gen

// ApplicationGatewayBackendAddress_SpecGenerator returns a generator of ApplicationGatewayBackendAddress_Spec instances for property testing.
func ApplicationGatewayBackendAddress_SpecGenerator() gopter.Gen {
	if applicationGatewayBackendAddress_specGenerator != nil {
		return applicationGatewayBackendAddress_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Spec(generators)
	applicationGatewayBackendAddress_specGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_Spec{}), generators)

	return applicationGatewayBackendAddress_specGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Spec(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddress_Status, ApplicationGatewayBackendAddress_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddress_Status runs a test to see if a specific instance of ApplicationGatewayBackendAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddress_Status(subject ApplicationGatewayBackendAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_Status instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddress_StatusGenerator()
var applicationGatewayBackendAddress_statusGenerator gopter.Gen

// ApplicationGatewayBackendAddress_StatusGenerator returns a generator of ApplicationGatewayBackendAddress_Status instances for property testing.
func ApplicationGatewayBackendAddress_StatusGenerator() gopter.Gen {
	if applicationGatewayBackendAddress_statusGenerator != nil {
		return applicationGatewayBackendAddress_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status(generators)
	applicationGatewayBackendAddress_statusGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_Status{}), generators)

	return applicationGatewayBackendAddress_statusGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}
