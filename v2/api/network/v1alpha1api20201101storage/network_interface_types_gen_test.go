// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_NetworkInterface_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface, NetworkInterfaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface runs a test to see if a specific instance of NetworkInterface round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface(subject NetworkInterface) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface instances for property testing - lazily instantiated by NetworkInterfaceGenerator()
var networkInterfaceGenerator gopter.Gen

// NetworkInterfaceGenerator returns a generator of NetworkInterface instances for property testing.
func NetworkInterfaceGenerator() gopter.Gen {
	if networkInterfaceGenerator != nil {
		return networkInterfaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkInterface(generators)
	networkInterfaceGenerator = gen.Struct(reflect.TypeOf(NetworkInterface{}), generators)

	return networkInterfaceGenerator
}

// AddRelatedPropertyGeneratorsForNetworkInterface is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface(gens map[string]gopter.Gen) {
	gens["Spec"] = NetworkInterface_SpecGenerator()
	gens["Status"] = NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()
}

func Test_NetworkInterface_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_Spec, NetworkInterface_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_Spec runs a test to see if a specific instance of NetworkInterface_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_Spec(subject NetworkInterface_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_Spec instances for property testing - lazily instantiated by
//NetworkInterface_SpecGenerator()
var networkInterface_specGenerator gopter.Gen

// NetworkInterface_SpecGenerator returns a generator of NetworkInterface_Spec instances for property testing.
// We first initialize networkInterface_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_SpecGenerator() gopter.Gen {
	if networkInterface_specGenerator != nil {
		return networkInterface_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Spec(generators)
	networkInterface_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Spec(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_Spec(generators)
	networkInterface_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Spec{}), generators)

	return networkInterface_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.AlphaString())
	gens["NicType"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_Spec(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettingsGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroupSpecGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkServiceSpecGenerator())
}

func Test_NetworkInterface_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded, NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterface_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterface_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterface_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterface_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterface_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterface_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterface_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterface_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterface_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterface_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterface_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterface_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["HostedWorkloads"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MacAddress"] = gen.PtrOf(gen.AlphaString())
	gens["MigrationPhase"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NicType"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGuid"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterface_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(NetworkInterfaceDnsSettings_StatusGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateLinkService"] = gen.PtrOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["TapConfigurations"] = gen.SliceOf(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["VirtualMachine"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_NetworkInterfaceDnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettings, NetworkInterfaceDnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettings runs a test to see if a specific instance of NetworkInterfaceDnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettings(subject NetworkInterfaceDnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettingsGenerator()
var networkInterfaceDnsSettingsGenerator gopter.Gen

// NetworkInterfaceDnsSettingsGenerator returns a generator of NetworkInterfaceDnsSettings instances for property testing.
func NetworkInterfaceDnsSettingsGenerator() gopter.Gen {
	if networkInterfaceDnsSettingsGenerator != nil {
		return networkInterfaceDnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings(generators)
	networkInterfaceDnsSettingsGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings{}), generators)

	return networkInterfaceDnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status, NetworkInterfaceDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status runs a test to see if a specific instance of NetworkInterfaceDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceDnsSettings_Status(subject NetworkInterfaceDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceDnsSettings_Status instances for property testing - lazily instantiated by
//NetworkInterfaceDnsSettings_StatusGenerator()
var networkInterfaceDnsSettings_statusGenerator gopter.Gen

// NetworkInterfaceDnsSettings_StatusGenerator returns a generator of NetworkInterfaceDnsSettings_Status instances for property testing.
func NetworkInterfaceDnsSettings_StatusGenerator() gopter.Gen {
	if networkInterfaceDnsSettings_statusGenerator != nil {
		return networkInterfaceDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status(generators)
	networkInterfaceDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceDnsSettings_Status{}), generators)

	return networkInterfaceDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["AppliedDnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
	gens["InternalDnsNameLabel"] = gen.PtrOf(gen.AlphaString())
	gens["InternalDomainNameSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["InternalFqdn"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded, NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceIPConfiguration_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceIPConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["LoadBalancerInboundNatRules"] = gen.SliceOf(InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["PrivateLinkConnectionProperties"] = gen.PtrOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator())
	gens["PublicIPAddress"] = gen.PtrOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["Subnet"] = gen.PtrOf(Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator())
	gens["VirtualNetworkTaps"] = gen.SliceOf(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator())
}

func Test_NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded, NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(subject NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkInterfaceTapConfiguration_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceTapConfiguration_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkSecurityGroupSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroupSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroupSpec, NetworkSecurityGroupSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroupSpec runs a test to see if a specific instance of NetworkSecurityGroupSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroupSpec(subject NetworkSecurityGroupSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroupSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroupSpec instances for property testing - lazily instantiated by
//NetworkSecurityGroupSpecGenerator()
var networkSecurityGroupSpecGenerator gopter.Gen

// NetworkSecurityGroupSpecGenerator returns a generator of NetworkSecurityGroupSpec instances for property testing.
func NetworkSecurityGroupSpecGenerator() gopter.Gen {
	if networkSecurityGroupSpecGenerator != nil {
		return networkSecurityGroupSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec(generators)
	networkSecurityGroupSpecGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroupSpec{}), generators)

	return networkSecurityGroupSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroupSpec(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

func Test_NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(subject NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(generators)
	networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(NetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return networkSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded, PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(subject PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpoint_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateEndpoint_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpoint_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
}

func Test_PrivateLinkServiceSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceSpec, PrivateLinkServiceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceSpec runs a test to see if a specific instance of PrivateLinkServiceSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceSpec(subject PrivateLinkServiceSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceSpec instances for property testing - lazily instantiated by
//PrivateLinkServiceSpecGenerator()
var privateLinkServiceSpecGenerator gopter.Gen

// PrivateLinkServiceSpecGenerator returns a generator of PrivateLinkServiceSpec instances for property testing.
// We first initialize privateLinkServiceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkServiceSpecGenerator() gopter.Gen {
	if privateLinkServiceSpecGenerator != nil {
		return privateLinkServiceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	privateLinkServiceSpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec(generators)
	privateLinkServiceSpecGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceSpec{}), generators)

	return privateLinkServiceSpecGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceSpec(gens map[string]gopter.Gen) {
	gens["EnableProxyProtocol"] = gen.PtrOf(gen.Bool())
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkServiceSpec(gens map[string]gopter.Gen) {
	gens["AutoApproval"] = gen.PtrOf(ResourceSetGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["IpConfigurations"] = gen.SliceOf(PrivateLinkServiceIpConfigurationGenerator())
	gens["LoadBalancerFrontendIpConfigurations"] = gen.SliceOf(FrontendIPConfigurationGenerator())
	gens["Visibility"] = gen.PtrOf(ResourceSetGenerator())
}

func Test_PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded, PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(subject PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var privateLinkService_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize privateLinkService_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateLinkService_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateLinkService_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return privateLinkService_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkService_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(generators)
	privateLinkService_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateLinkService_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return privateLinkService_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateLinkService_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Status, SubResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Status runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Status(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResource_StatusGenerator()
var subResource_statusGenerator gopter.Gen

// SubResource_StatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResource_StatusGenerator() gopter.Gen {
	if subResource_statusGenerator != nil {
		return subResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_Status(generators)
	subResource_statusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(subject ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property
//testing - lazily instantiated by
//ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationGatewayBackendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationGatewayBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["BackendAddresses"] = gen.SliceOf(ApplicationGatewayBackendAddress_StatusGenerator())
}

func Test_ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded, ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(subject ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing -
//lazily instantiated by ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(generators)
	applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return applicationSecurityGroup_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationSecurityGroup_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded, BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(subject BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func BackendAddressPool_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(generators)
	backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(BackendAddressPool_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return backendAddressPool_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendAddressPool_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_InboundNatRule_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded, InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(subject InboundNatRule_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InboundNatRule_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of InboundNatRule_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func InboundNatRule_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(generators)
	inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(InboundNatRule_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return inboundNatRule_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInboundNatRule_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status, NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status runs a test to see if a specific instance of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(subject NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing -
//lazily instantiated by NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator()
var networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator gopter.Gen

// NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator returns a generator of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status instances for property testing.
func NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_StatusGenerator() gopter.Gen {
	if networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator != nil {
		return networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(generators)
	networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status{}), generators)

	return networkInterfaceIPConfigurationPrivateLinkConnectionProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_Status(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMemberName"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceIpConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceIpConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceIpConfiguration, PrivateLinkServiceIpConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceIpConfiguration runs a test to see if a specific instance of PrivateLinkServiceIpConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceIpConfiguration(subject PrivateLinkServiceIpConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceIpConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceIpConfiguration instances for property testing - lazily instantiated by
//PrivateLinkServiceIpConfigurationGenerator()
var privateLinkServiceIpConfigurationGenerator gopter.Gen

// PrivateLinkServiceIpConfigurationGenerator returns a generator of PrivateLinkServiceIpConfiguration instances for property testing.
func PrivateLinkServiceIpConfigurationGenerator() gopter.Gen {
	if privateLinkServiceIpConfigurationGenerator != nil {
		return privateLinkServiceIpConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration(generators)
	privateLinkServiceIpConfigurationGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceIpConfiguration{}), generators)

	return privateLinkServiceIpConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceIpConfiguration(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded, PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(subject PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
// We first initialize publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PublicIPAddress_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(generators)
	publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PublicIPAddress_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return publicIPAddress_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPublicIPAddress_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSku_StatusGenerator())
}

func Test_ResourceSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSet, ResourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSet runs a test to see if a specific instance of ResourceSet round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSet(subject ResourceSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSet instances for property testing - lazily instantiated by ResourceSetGenerator()
var resourceSetGenerator gopter.Gen

// ResourceSetGenerator returns a generator of ResourceSet instances for property testing.
func ResourceSetGenerator() gopter.Gen {
	if resourceSetGenerator != nil {
		return resourceSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSet(generators)
	resourceSetGenerator = gen.Struct(reflect.TypeOf(ResourceSet{}), generators)

	return resourceSetGenerator
}

// AddIndependentPropertyGeneratorsForResourceSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSet(gens map[string]gopter.Gen) {
	gens["Subscriptions"] = gen.SliceOf(gen.AlphaString())
}

func Test_Subnet_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Subnet_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded, Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of Subnet_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSubnet_Status_NetworkInterface_SubResourceEmbedded(subject Subnet_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Subnet_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily instantiated
//by Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var subnet_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of Subnet_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func Subnet_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if subnet_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return subnet_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded(generators)
	subnet_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(Subnet_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return subnet_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubnet_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded, VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded runs a test to see if a specific instance of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(subject VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator()
var virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator gopter.Gen

// VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator returns a generator of VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded instances for property testing.
func VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbeddedGenerator() gopter.Gen {
	if virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator != nil {
		return virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(generators)
	virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded{}), generators)

	return virtualNetworkTap_status_networkInterface_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkTap_Status_NetworkInterface_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApplicationGatewayBackendAddress_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGatewayBackendAddress_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGatewayBackendAddress_Status, ApplicationGatewayBackendAddress_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGatewayBackendAddress_Status runs a test to see if a specific instance of ApplicationGatewayBackendAddress_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGatewayBackendAddress_Status(subject ApplicationGatewayBackendAddress_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGatewayBackendAddress_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGatewayBackendAddress_Status instances for property testing - lazily instantiated by
//ApplicationGatewayBackendAddress_StatusGenerator()
var applicationGatewayBackendAddress_statusGenerator gopter.Gen

// ApplicationGatewayBackendAddress_StatusGenerator returns a generator of ApplicationGatewayBackendAddress_Status instances for property testing.
func ApplicationGatewayBackendAddress_StatusGenerator() gopter.Gen {
	if applicationGatewayBackendAddress_statusGenerator != nil {
		return applicationGatewayBackendAddress_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status(generators)
	applicationGatewayBackendAddress_statusGenerator = gen.Struct(reflect.TypeOf(ApplicationGatewayBackendAddress_Status{}), generators)

	return applicationGatewayBackendAddress_statusGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGatewayBackendAddress_Status(gens map[string]gopter.Gen) {
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
}
